(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.rltm = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (Buffer){
/**
 * @license Copyright 2017, Ably
 *
 * Ably JavaScript Library v1.0.3
 * https://github.com/ably/ably-js
 *
 * Ably Realtime Messaging
 * https://www.ably.io
 *
 * Released under the Apache Licence v2.0
 */

var Ably = {};

/**
 * CryptoJS core components.
 */
var CryptoJS = CryptoJS || (function (Math, undefined) {
    /**
     * CryptoJS namespace.
     */
    var C = {};

    /**
     * Library namespace.
     */
    var C_lib = C.lib = {};

    /**
     * Base object for prototypal inheritance.
     */
    var Base = C_lib.Base = (function () {
        function F() {}

        return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function (overrides) {
                // Spawn
                F.prototype = this;
                var subtype = new F();

                // Augment
                if (overrides) {
                    subtype.mixIn(overrides);
                }

                // Create default initializer
                if (!subtype.hasOwnProperty('init')) {
                    subtype.init = function () {
                        subtype.$super.init.apply(this, arguments);
                    };
                }

                // Initializer's prototype is the subtype object
                subtype.init.prototype = subtype;

                // Reference supertype
                subtype.$super = this;

                return subtype;
            },

            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function () {
                var instance = this.extend();
                instance.init.apply(instance, arguments);

                return instance;
            },

            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function () {
            },

            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function (properties) {
                for (var propertyName in properties) {
                    if (properties.hasOwnProperty(propertyName)) {
                        this[propertyName] = properties[propertyName];
                    }
                }

                // IE won't copy toString using the loop above
                if (properties.hasOwnProperty('toString')) {
                    this.toString = properties.toString;
                }
            },

            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function () {
                return this.init.prototype.extend(this);
            }
        };
    }());

    /**
     * An array of 32-bit words.
     *
     * @property {Array} words The array of 32-bit words.
     * @property {number} sigBytes The number of significant bytes in this word array.
     */
    var WordArray = C_lib.WordArray = Base.extend({
        /**
         * Initializes a newly created word array.
         *
         * @param {Array} words (Optional) An array of 32-bit words.
         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
         *
         * @example
         *
         *     var wordArray = CryptoJS.lib.WordArray.create();
         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
         */
        init: function (words, sigBytes) {
            words = this.words = words || [];

            if (sigBytes != undefined) {
                this.sigBytes = sigBytes;
            } else {
                this.sigBytes = words.length * 4;
            }
        },

        /**
         * Converts this word array to a string.
         *
         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
         *
         * @return {string} The stringified word array.
         *
         * @example
         *
         *     var string = wordArray + '';
         *     var string = wordArray.toString();
         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
         */
        toString: function (encoder) {
            return (encoder || Hex).stringify(this);
        },

        /**
         * Concatenates a word array to this word array.
         *
         * @param {WordArray} wordArray The word array to append.
         *
         * @return {WordArray} This word array.
         *
         * @example
         *
         *     wordArray1.concat(wordArray2);
         */
        concat: function (wordArray) {
            // Shortcuts
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;

            // Clamp excess bits
            this.clamp();

            // Concat
            if (thisSigBytes % 4) {
                // Copy one byte at a time
                for (var i = 0; i < thatSigBytes; i++) {
                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
                }
            } else if (thatWords.length > 0xffff) {
                // Copy one word at a time
                for (var i = 0; i < thatSigBytes; i += 4) {
                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
                }
            } else {
                // Copy all words at once
                thisWords.push.apply(thisWords, thatWords);
            }
            this.sigBytes += thatSigBytes;

            // Chainable
            return this;
        },

        /**
         * Removes insignificant bits.
         *
         * @example
         *
         *     wordArray.clamp();
         */
        clamp: function () {
            // Shortcuts
            var words = this.words;
            var sigBytes = this.sigBytes;

            // Clamp
            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
            words.length = Math.ceil(sigBytes / 4);
        },

        /**
         * Creates a copy of this word array.
         *
         * @return {WordArray} The clone.
         *
         * @example
         *
         *     var clone = wordArray.clone();
         */
        clone: function () {
            var clone = Base.clone.call(this);
            clone.words = this.words.slice(0);

            return clone;
        },

        /**
         * Creates a word array filled with random bytes.
         *
         * @param {number} nBytes The number of random bytes to generate.
         *
         * @return {WordArray} The random word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.lib.WordArray.random(16);
         */
        random: function (nBytes) {
            var words = [];

            var r = (function (m_w) {
                var m_w = m_w;
                var m_z = 0x3ade68b1;
                var mask = 0xffffffff;

                return function () {
                    m_z = (0x9069 * (m_z & 0xFFFF) + (m_z >> 0x10)) & mask;
                    m_w = (0x4650 * (m_w & 0xFFFF) + (m_w >> 0x10)) & mask;
                    var result = ((m_z << 0x10) + m_w) & mask;
                    result /= 0x100000000;
                    result += 0.5;
                    return result * (Math.random() > .5 ? 1 : -1);
                }
            });

            for (var i = 0, rcache; i < nBytes; i += 4) {
                var _r = r((rcache || Math.random()) * 0x100000000);

                rcache = _r() * 0x3ade67b7;
                words.push((_r() * 0x100000000) | 0);
            }

            return new WordArray.init(words, nBytes);
        }
    });

    /**
     * Encoder namespace.
     */
    var C_enc = C.enc = {};

    /**
     * Hex encoding strategy.
     */
    var Hex = C_enc.Hex = {
        /**
         * Converts a word array to a hex string.
         *
         * @param {WordArray} wordArray The word array.
         *
         * @return {string} The hex string.
         *
         * @static
         *
         * @example
         *
         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
         */
        stringify: function (wordArray) {
            // Shortcuts
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;

            // Convert
            var hexChars = [];
            for (var i = 0; i < sigBytes; i++) {
                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                hexChars.push((bite >>> 4).toString(16));
                hexChars.push((bite & 0x0f).toString(16));
            }

            return hexChars.join('');
        },

        /**
         * Converts a hex string to a word array.
         *
         * @param {string} hexStr The hex string.
         *
         * @return {WordArray} The word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
         */
        parse: function (hexStr) {
            // Shortcut
            var hexStrLength = hexStr.length;

            // Convert
            var words = [];
            for (var i = 0; i < hexStrLength; i += 2) {
                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
            }

            return new WordArray.init(words, hexStrLength / 2);
        }
    };

    /**
     * Latin1 encoding strategy.
     */
    var Latin1 = C_enc.Latin1 = {
        /**
         * Converts a word array to a Latin1 string.
         *
         * @param {WordArray} wordArray The word array.
         *
         * @return {string} The Latin1 string.
         *
         * @static
         *
         * @example
         *
         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
         */
        stringify: function (wordArray) {
            // Shortcuts
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;

            // Convert
            var latin1Chars = [];
            for (var i = 0; i < sigBytes; i++) {
                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                latin1Chars.push(String.fromCharCode(bite));
            }

            return latin1Chars.join('');
        },

        /**
         * Converts a Latin1 string to a word array.
         *
         * @param {string} latin1Str The Latin1 string.
         *
         * @return {WordArray} The word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
         */
        parse: function (latin1Str) {
            // Shortcut
            var latin1StrLength = latin1Str.length;

            // Convert
            var words = [];
            for (var i = 0; i < latin1StrLength; i++) {
                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
            }

            return new WordArray.init(words, latin1StrLength);
        }
    };

    /**
     * UTF-8 encoding strategy.
     */
    var Utf8 = C_enc.Utf8 = {
        /**
         * Converts a word array to a UTF-8 string.
         *
         * @param {WordArray} wordArray The word array.
         *
         * @return {string} The UTF-8 string.
         *
         * @static
         *
         * @example
         *
         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
         */
        stringify: function (wordArray) {
            try {
                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e) {
                throw new Error('Malformed UTF-8 data');
            }
        },

        /**
         * Converts a UTF-8 string to a word array.
         *
         * @param {string} utf8Str The UTF-8 string.
         *
         * @return {WordArray} The word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
         */
        parse: function (utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
        }
    };

    /**
     * Abstract buffered block algorithm template.
     *
     * The property blockSize must be implemented in a concrete subtype.
     *
     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
     */
    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
        /**
         * Resets this block algorithm's data buffer to its initial state.
         *
         * @example
         *
         *     bufferedBlockAlgorithm.reset();
         */
        reset: function () {
            // Initial values
            this._data = new WordArray.init();
            this._nDataBytes = 0;
        },

        /**
         * Adds new data to this block algorithm's buffer.
         *
         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
         *
         * @example
         *
         *     bufferedBlockAlgorithm._append('data');
         *     bufferedBlockAlgorithm._append(wordArray);
         */
        _append: function (data) {
            // Convert string to WordArray, else assume WordArray already
            if (typeof data == 'string') {
                data = Utf8.parse(data);
            }

            // Append
            this._data.concat(data);
            this._nDataBytes += data.sigBytes;
        },

        /**
         * Processes available data blocks.
         *
         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
         *
         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
         *
         * @return {WordArray} The processed data.
         *
         * @example
         *
         *     var processedData = bufferedBlockAlgorithm._process();
         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
         */
        _process: function (doFlush) {
            // Shortcuts
            var data = this._data;
            var dataWords = data.words;
            var dataSigBytes = data.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;

            // Count blocks ready
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
                // Round up to include partial blocks
                nBlocksReady = Math.ceil(nBlocksReady);
            } else {
                // Round down to include only full blocks,
                // less the number of blocks that must remain in the buffer
                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }

            // Count words ready
            var nWordsReady = nBlocksReady * blockSize;

            // Count bytes ready
            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

            // Process blocks
            if (nWordsReady) {
                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                    // Perform concrete-algorithm logic
                    this._doProcessBlock(dataWords, offset);
                }

                // Remove processed words
                var processedWords = dataWords.splice(0, nWordsReady);
                data.sigBytes -= nBytesReady;
            }

            // Return processed words
            return new WordArray.init(processedWords, nBytesReady);
        },

        /**
         * Creates a copy of this object.
         *
         * @return {Object} The clone.
         *
         * @example
         *
         *     var clone = bufferedBlockAlgorithm.clone();
         */
        clone: function () {
            var clone = Base.clone.call(this);
            clone._data = this._data.clone();

            return clone;
        },

        _minBufferSize: 0
    });

    /**
     * Abstract hasher template.
     *
     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
     */
    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
        /**
         * Configuration options.
         */
        cfg: Base.extend(),

        /**
         * Initializes a newly created hasher.
         *
         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
         *
         * @example
         *
         *     var hasher = CryptoJS.algo.SHA256.create();
         */
        init: function (cfg) {
            // Apply config defaults
            this.cfg = this.cfg.extend(cfg);

            // Set initial values
            this.reset();
        },

        /**
         * Resets this hasher to its initial state.
         *
         * @example
         *
         *     hasher.reset();
         */
        reset: function () {
            // Reset data buffer
            BufferedBlockAlgorithm.reset.call(this);

            // Perform concrete-hasher logic
            this._doReset();
        },

        /**
         * Updates this hasher with a message.
         *
         * @param {WordArray|string} messageUpdate The message to append.
         *
         * @return {Hasher} This hasher.
         *
         * @example
         *
         *     hasher.update('message');
         *     hasher.update(wordArray);
         */
        update: function (messageUpdate) {
            // Append
            this._append(messageUpdate);

            // Update the hash
            this._process();

            // Chainable
            return this;
        },

        /**
         * Finalizes the hash computation.
         * Note that the finalize operation is effectively a destructive, read-once operation.
         *
         * @param {WordArray|string} messageUpdate (Optional) A final message update.
         *
         * @return {WordArray} The hash.
         *
         * @example
         *
         *     var hash = hasher.finalize();
         *     var hash = hasher.finalize('message');
         *     var hash = hasher.finalize(wordArray);
         */
        finalize: function (messageUpdate) {
            // Final message update
            if (messageUpdate) {
                this._append(messageUpdate);
            }

            // Perform concrete-hasher logic
            var hash = this._doFinalize();

            return hash;
        },

        blockSize: 512/32,

        /**
         * Creates a shortcut function to a hasher's object interface.
         *
         * @param {Hasher} hasher The hasher to create a helper for.
         *
         * @return {Function} The shortcut function.
         *
         * @static
         *
         * @example
         *
         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
         */
        _createHelper: function (hasher) {
            return function (message, cfg) {
                return new hasher.init(cfg).finalize(message);
            };
        },

        /**
         * Creates a shortcut function to the HMAC's object interface.
         *
         * @param {Hasher} hasher The hasher to use in this HMAC helper.
         *
         * @return {Function} The shortcut function.
         *
         * @static
         *
         * @example
         *
         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
         */
        _createHmacHelper: function (hasher) {
            return function (message, key) {
                return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
        }
    });

    /**
     * Algorithm namespace.
     */
    var C_algo = C.algo = {};

    return C;
}(Math));

(function (Math) {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var WordArray = C_lib.WordArray;
    var Hasher = C_lib.Hasher;
    var C_algo = C.algo;

    // Initialization and round constants tables
    var H = [];
    var K = [];

    // Compute constants
    (function () {
        function isPrime(n) {
            var sqrtN = Math.sqrt(n);
            for (var factor = 2; factor <= sqrtN; factor++) {
                if (!(n % factor)) {
                    return false;
                }
            }

            return true;
        }

        function getFractionalBits(n) {
            return ((n - (n | 0)) * 0x100000000) | 0;
        }

        var n = 2;
        var nPrime = 0;
        while (nPrime < 64) {
            if (isPrime(n)) {
                if (nPrime < 8) {
                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
                }
                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));

                nPrime++;
            }

            n++;
        }
    }());

    // Reusable object
    var W = [];

    /**
     * SHA-256 hash algorithm.
     */
    var SHA256 = C_algo.SHA256 = Hasher.extend({
        _doReset: function () {
            this._hash = new WordArray.init(H.slice(0));
        },

        _doProcessBlock: function (M, offset) {
            // Shortcut
            var H = this._hash.words;

            // Working variables
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];
            var e = H[4];
            var f = H[5];
            var g = H[6];
            var h = H[7];

            // Computation
            for (var i = 0; i < 64; i++) {
                if (i < 16) {
                    W[i] = M[offset + i] | 0;
                } else {
                    var gamma0x = W[i - 15];
                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^
                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^
                                   (gamma0x >>> 3);

                    var gamma1x = W[i - 2];
                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^
                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^
                                   (gamma1x >>> 10);

                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
                }

                var ch  = (e & f) ^ (~e & g);
                var maj = (a & b) ^ (a & c) ^ (b & c);

                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));
                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));

                var t1 = h + sigma1 + ch + K[i] + W[i];
                var t2 = sigma0 + maj;

                h = g;
                g = f;
                f = e;
                e = (d + t1) | 0;
                d = c;
                c = b;
                b = a;
                a = (t1 + t2) | 0;
            }

            // Intermediate hash value
            H[0] = (H[0] + a) | 0;
            H[1] = (H[1] + b) | 0;
            H[2] = (H[2] + c) | 0;
            H[3] = (H[3] + d) | 0;
            H[4] = (H[4] + e) | 0;
            H[5] = (H[5] + f) | 0;
            H[6] = (H[6] + g) | 0;
            H[7] = (H[7] + h) | 0;
        },

        _doFinalize: function () {
            // Shortcuts
            var data = this._data;
            var dataWords = data.words;

            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;

            // Add padding
            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;

            // Hash final blocks
            this._process();

            // Return final computed hash
            return this._hash;
        },

        clone: function () {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();

            return clone;
        }
    });

    /**
     * Shortcut function to the hasher's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     *
     * @return {WordArray} The hash.
     *
     * @static
     *
     * @example
     *
     *     var hash = CryptoJS.SHA256('message');
     *     var hash = CryptoJS.SHA256(wordArray);
     */
    C.SHA256 = Hasher._createHelper(SHA256);

    /**
     * Shortcut function to the HMAC's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     * @param {WordArray|string} key The secret key.
     *
     * @return {WordArray} The HMAC.
     *
     * @static
     *
     * @example
     *
     *     var hmac = CryptoJS.HmacSHA256(message, key);
     */
    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
}(Math));

(function () {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var Base = C_lib.Base;
    var C_enc = C.enc;
    var Utf8 = C_enc.Utf8;
    var C_algo = C.algo;

    /**
     * HMAC algorithm.
     */
    var HMAC = C_algo.HMAC = Base.extend({
        /**
         * Initializes a newly created HMAC.
         *
         * @param {Hasher} hasher The hash algorithm to use.
         * @param {WordArray|string} key The secret key.
         *
         * @example
         *
         *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
         */
        init: function (hasher, key) {
            // Init hasher
            hasher = this._hasher = new hasher.init();

            // Convert string to WordArray, else assume WordArray already
            if (typeof key == 'string') {
                key = Utf8.parse(key);
            }

            // Shortcuts
            var hasherBlockSize = hasher.blockSize;
            var hasherBlockSizeBytes = hasherBlockSize * 4;

            // Allow arbitrary length keys
            if (key.sigBytes > hasherBlockSizeBytes) {
                key = hasher.finalize(key);
            }

            // Clamp excess bits
            key.clamp();

            // Clone key for inner and outer pads
            var oKey = this._oKey = key.clone();
            var iKey = this._iKey = key.clone();

            // Shortcuts
            var oKeyWords = oKey.words;
            var iKeyWords = iKey.words;

            // XOR keys with pad constants
            for (var i = 0; i < hasherBlockSize; i++) {
                oKeyWords[i] ^= 0x5c5c5c5c;
                iKeyWords[i] ^= 0x36363636;
            }
            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;

            // Set initial values
            this.reset();
        },

        /**
         * Resets this HMAC to its initial state.
         *
         * @example
         *
         *     hmacHasher.reset();
         */
        reset: function () {
            // Shortcut
            var hasher = this._hasher;

            // Reset
            hasher.reset();
            hasher.update(this._iKey);
        },

        /**
         * Updates this HMAC with a message.
         *
         * @param {WordArray|string} messageUpdate The message to append.
         *
         * @return {HMAC} This HMAC instance.
         *
         * @example
         *
         *     hmacHasher.update('message');
         *     hmacHasher.update(wordArray);
         */
        update: function (messageUpdate) {
            this._hasher.update(messageUpdate);

            // Chainable
            return this;
        },

        /**
         * Finalizes the HMAC computation.
         * Note that the finalize operation is effectively a destructive, read-once operation.
         *
         * @param {WordArray|string} messageUpdate (Optional) A final message update.
         *
         * @return {WordArray} The HMAC.
         *
         * @example
         *
         *     var hmac = hmacHasher.finalize();
         *     var hmac = hmacHasher.finalize('message');
         *     var hmac = hmacHasher.finalize(wordArray);
         */
        finalize: function (messageUpdate) {
            // Shortcut
            var hasher = this._hasher;

            // Compute HMAC
            var innerHash = hasher.finalize(messageUpdate);
            hasher.reset();
            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));

            return hmac;
        }
    });
}());

(function () {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var WordArray = C_lib.WordArray;
    var C_enc = C.enc;

    /**
     * Base64 encoding strategy.
     */
    var Base64 = C_enc.Base64 = {
        /**
         * Converts a word array to a Base64 string.
         *
         * @param {WordArray} wordArray The word array.
         *
         * @return {string} The Base64 string.
         *
         * @static
         *
         * @example
         *
         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
         */
        stringify: function (wordArray) {
            // Shortcuts
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map = this._map;

            // Clamp excess bits
            wordArray.clamp();

            // Convert
            var base64Chars = [];
            for (var i = 0; i < sigBytes; i += 3) {
                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;
                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;

                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;

                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
                }
            }

            // Add padding
            var paddingChar = map.charAt(64);
            if (paddingChar) {
                while (base64Chars.length % 4) {
                    base64Chars.push(paddingChar);
                }
            }

            return base64Chars.join('');
        },

        /**
         * Converts a Base64 string to a word array.
         *
         * @param {string} base64Str The Base64 string.
         *
         * @return {WordArray} The word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
         */
        parse: function (base64Str) {
            // Shortcuts
            var base64StrLength = base64Str.length;
            var map = this._map;

            // Ignore padding
            var paddingChar = map.charAt(64);
            if (paddingChar) {
                var paddingIndex = base64Str.indexOf(paddingChar);
                if (paddingIndex != -1) {
                    base64StrLength = paddingIndex;
                }
            }

            // Convert
            var words = [];
            var nBytes = 0;
            for (var i = 0; i < base64StrLength; i++) {
                if (i % 4) {
                    var bits1 = map.indexOf(base64Str.charAt(i - 1)) << ((i % 4) * 2);
                    var bits2 = map.indexOf(base64Str.charAt(i)) >>> (6 - (i % 4) * 2);
                    words[nBytes >>> 2] |= (bits1 | bits2) << (24 - (nBytes % 4) * 8);
                    nBytes++;
                }
            }

            return WordArray.create(words, nBytes);
        },

        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
    };
}());

/**
 * Cipher core components.
 */
CryptoJS.lib.Cipher || (function (undefined) {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var Base = C_lib.Base;
    var WordArray = C_lib.WordArray;
    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
    var C_enc = C.enc;
    var Utf8 = C_enc.Utf8;
    var Base64 = C_enc.Base64;
    var C_algo = C.algo;
    var EvpKDF = C_algo.EvpKDF;

    /**
     * Abstract base cipher template.
     *
     * @property {number} keySize This cipher's key size. Default: 4 (128 bits)
     * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)
     * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.
     * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.
     */
    var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
        /**
         * Configuration options.
         *
         * @property {WordArray} iv The IV to use for this operation.
         */
        cfg: Base.extend(),

        /**
         * Creates this cipher in encryption mode.
         *
         * @param {WordArray} key The key.
         * @param {Object} cfg (Optional) The configuration options to use for this operation.
         *
         * @return {Cipher} A cipher instance.
         *
         * @static
         *
         * @example
         *
         *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
         */
        createEncryptor: function (key, cfg) {
            return this.create(this._ENC_XFORM_MODE, key, cfg);
        },

        /**
         * Creates this cipher in decryption mode.
         *
         * @param {WordArray} key The key.
         * @param {Object} cfg (Optional) The configuration options to use for this operation.
         *
         * @return {Cipher} A cipher instance.
         *
         * @static
         *
         * @example
         *
         *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
         */
        createDecryptor: function (key, cfg) {
            return this.create(this._DEC_XFORM_MODE, key, cfg);
        },

        /**
         * Initializes a newly created cipher.
         *
         * @param {number} xformMode Either the encryption or decryption transormation mode constant.
         * @param {WordArray} key The key.
         * @param {Object} cfg (Optional) The configuration options to use for this operation.
         *
         * @example
         *
         *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
         */
        init: function (xformMode, key, cfg) {
            // Apply config defaults
            this.cfg = this.cfg.extend(cfg);

            // Store transform mode and key
            this._xformMode = xformMode;
            this._key = key;

            // Set initial values
            this.reset();
        },

        /**
         * Resets this cipher to its initial state.
         *
         * @example
         *
         *     cipher.reset();
         */
        reset: function () {
            // Reset data buffer
            BufferedBlockAlgorithm.reset.call(this);

            // Perform concrete-cipher logic
            this._doReset();
        },

        /**
         * Adds data to be encrypted or decrypted.
         *
         * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
         *
         * @return {WordArray} The data after processing.
         *
         * @example
         *
         *     var encrypted = cipher.process('data');
         *     var encrypted = cipher.process(wordArray);
         */
        process: function (dataUpdate) {
            // Append
            this._append(dataUpdate);

            // Process available blocks
            return this._process();
        },

        /**
         * Finalizes the encryption or decryption process.
         * Note that the finalize operation is effectively a destructive, read-once operation.
         *
         * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
         *
         * @return {WordArray} The data after final processing.
         *
         * @example
         *
         *     var encrypted = cipher.finalize();
         *     var encrypted = cipher.finalize('data');
         *     var encrypted = cipher.finalize(wordArray);
         */
        finalize: function (dataUpdate) {
            // Final data update
            if (dataUpdate) {
                this._append(dataUpdate);
            }

            // Perform concrete-cipher logic
            var finalProcessedData = this._doFinalize();

            return finalProcessedData;
        },

        keySize: 128/32,

        ivSize: 128/32,

        _ENC_XFORM_MODE: 1,

        _DEC_XFORM_MODE: 2,

        /**
         * Creates shortcut functions to a cipher's object interface.
         *
         * @param {Cipher} cipher The cipher to create a helper for.
         *
         * @return {Object} An object with encrypt and decrypt shortcut functions.
         *
         * @static
         *
         * @example
         *
         *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
         */
        _createHelper: (function () {
            function selectCipherStrategy(key) {
                if (typeof key == 'string') {
                    return PasswordBasedCipher;
                } else {
                    return SerializableCipher;
                }
            }

            return function (cipher) {
                return {
                    encrypt: function (message, key, cfg) {
                        return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
                    },

                    decrypt: function (ciphertext, key, cfg) {
                        return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
                    }
                };
            };
        }())
    });

    /**
     * Abstract base stream cipher template.
     *
     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 1 (32 bits)
     */
    var StreamCipher = C_lib.StreamCipher = Cipher.extend({
        _doFinalize: function () {
            // Process partial blocks
            var finalProcessedBlocks = this._process(!!'flush');

            return finalProcessedBlocks;
        },

        blockSize: 1
    });

    /**
     * Mode namespace.
     */
    var C_mode = C.mode = {};

    /**
     * Abstract base block cipher mode template.
     */
    var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
        /**
         * Creates this mode for encryption.
         *
         * @param {Cipher} cipher A block cipher instance.
         * @param {Array} iv The IV words.
         *
         * @static
         *
         * @example
         *
         *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
         */
        createEncryptor: function (cipher, iv) {
            return this.Encryptor.create(cipher, iv);
        },

        /**
         * Creates this mode for decryption.
         *
         * @param {Cipher} cipher A block cipher instance.
         * @param {Array} iv The IV words.
         *
         * @static
         *
         * @example
         *
         *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
         */
        createDecryptor: function (cipher, iv) {
            return this.Decryptor.create(cipher, iv);
        },

        /**
         * Initializes a newly created mode.
         *
         * @param {Cipher} cipher A block cipher instance.
         * @param {Array} iv The IV words.
         *
         * @example
         *
         *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
         */
        init: function (cipher, iv) {
            this._cipher = cipher;
            this._iv = iv;
        }
    });

    /**
     * Cipher Block Chaining mode.
     */
    var CBC = C_mode.CBC = (function () {
        /**
         * Abstract base CBC mode.
         */
        var CBC = BlockCipherMode.extend();

        /**
         * CBC encryptor.
         */
        CBC.Encryptor = CBC.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function (words, offset) {
                // Shortcuts
                var cipher = this._cipher;
                var blockSize = cipher.blockSize;

                // XOR and encrypt
                xorBlock.call(this, words, offset, blockSize);
                cipher.encryptBlock(words, offset);

                // Remember this block to use with next block
                this._prevBlock = words.slice(offset, offset + blockSize);
            }
        });

        /**
         * CBC decryptor.
         */
        CBC.Decryptor = CBC.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function (words, offset) {
                // Shortcuts
                var cipher = this._cipher;
                var blockSize = cipher.blockSize;

                // Remember this block to use with next block
                var thisBlock = words.slice(offset, offset + blockSize);

                // Decrypt and XOR
                cipher.decryptBlock(words, offset);
                xorBlock.call(this, words, offset, blockSize);

                // This block becomes the previous block
                this._prevBlock = thisBlock;
            }
        });

        function xorBlock(words, offset, blockSize) {
            // Shortcut
            var iv = this._iv;

            // Choose mixing block
            if (iv) {
                var block = iv;

                // Remove IV for subsequent blocks
                this._iv = undefined;
            } else {
                var block = this._prevBlock;
            }

            // XOR blocks
            for (var i = 0; i < blockSize; i++) {
                words[offset + i] ^= block[i];
            }
        }

        return CBC;
    }());

    /**
     * Padding namespace.
     */
    var C_pad = C.pad = {};

    /**
     * PKCS #5/7 padding strategy.
     */
    var Pkcs7 = C_pad.Pkcs7 = {
        /**
         * Pads data using the algorithm defined in PKCS #5/7.
         *
         * @param {WordArray} data The data to pad.
         * @param {number} blockSize The multiple that the data should be padded to.
         *
         * @static
         *
         * @example
         *
         *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
         */
        pad: function (data, blockSize) {
            // Shortcut
            var blockSizeBytes = blockSize * 4;

            // Count padding bytes
            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

            // Create padding word
            var paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;

            // Create padding
            var paddingWords = [];
            for (var i = 0; i < nPaddingBytes; i += 4) {
                paddingWords.push(paddingWord);
            }
            var padding = WordArray.create(paddingWords, nPaddingBytes);

            // Add padding
            data.concat(padding);
        },

        /**
         * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
         *
         * @param {WordArray} data The data to unpad.
         *
         * @static
         *
         * @example
         *
         *     CryptoJS.pad.Pkcs7.unpad(wordArray);
         */
        unpad: function (data) {
            // Get number of padding bytes from last byte
            var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

            // Remove padding
            data.sigBytes -= nPaddingBytes;
        }
    };

    /**
     * Abstract base block cipher template.
     *
     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 4 (128 bits)
     */
    var BlockCipher = C_lib.BlockCipher = Cipher.extend({
        /**
         * Configuration options.
         *
         * @property {Mode} mode The block mode to use. Default: CBC
         * @property {Padding} padding The padding strategy to use. Default: Pkcs7
         */
        cfg: Cipher.cfg.extend({
            mode: CBC,
            padding: Pkcs7
        }),

        reset: function () {
            // Reset cipher
            Cipher.reset.call(this);

            // Shortcuts
            var cfg = this.cfg;
            var iv = cfg.iv;
            var mode = cfg.mode;

            // Reset block mode
            if (this._xformMode == this._ENC_XFORM_MODE) {
                var modeCreator = mode.createEncryptor;
            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
                var modeCreator = mode.createDecryptor;

                // Keep at least one block in the buffer for unpadding
                this._minBufferSize = 1;
            }
            this._mode = modeCreator.call(mode, this, iv && iv.words);
        },

        _doProcessBlock: function (words, offset) {
            this._mode.processBlock(words, offset);
        },

        _doFinalize: function () {
            // Shortcut
            var padding = this.cfg.padding;

            // Finalize
            if (this._xformMode == this._ENC_XFORM_MODE) {
                // Pad data
                padding.pad(this._data, this.blockSize);

                // Process final blocks
                var finalProcessedBlocks = this._process(!!'flush');
            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
                // Process final blocks
                var finalProcessedBlocks = this._process(!!'flush');

                // Unpad data
                padding.unpad(finalProcessedBlocks);
            }

            return finalProcessedBlocks;
        },

        blockSize: 128/32
    });

    /**
     * A collection of cipher parameters.
     *
     * @property {WordArray} ciphertext The raw ciphertext.
     * @property {WordArray} key The key to this ciphertext.
     * @property {WordArray} iv The IV used in the ciphering operation.
     * @property {WordArray} salt The salt used with a key derivation function.
     * @property {Cipher} algorithm The cipher algorithm.
     * @property {Mode} mode The block mode used in the ciphering operation.
     * @property {Padding} padding The padding scheme used in the ciphering operation.
     * @property {number} blockSize The block size of the cipher.
     * @property {Format} formatter The default formatting strategy to convert this cipher params object to a string.
     */
    var CipherParams = C_lib.CipherParams = Base.extend({
        /**
         * Initializes a newly created cipher params object.
         *
         * @param {Object} cipherParams An object with any of the possible cipher parameters.
         *
         * @example
         *
         *     var cipherParams = CryptoJS.lib.CipherParams.create({
         *         ciphertext: ciphertextWordArray,
         *         key: keyWordArray,
         *         iv: ivWordArray,
         *         salt: saltWordArray,
         *         algorithm: CryptoJS.algo.AES,
         *         mode: CryptoJS.mode.CBC,
         *         padding: CryptoJS.pad.PKCS7,
         *         blockSize: 4,
         *         formatter: CryptoJS.format.OpenSSL
         *     });
         */
        init: function (cipherParams) {
            this.mixIn(cipherParams);
        },

        /**
         * Converts this cipher params object to a string.
         *
         * @param {Format} formatter (Optional) The formatting strategy to use.
         *
         * @return {string} The stringified cipher params.
         *
         * @throws Error If neither the formatter nor the default formatter is set.
         *
         * @example
         *
         *     var string = cipherParams + '';
         *     var string = cipherParams.toString();
         *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
         */
        toString: function (formatter) {
            return (formatter || this.formatter).stringify(this);
        }
    });

    /**
     * Format namespace.
     */
    var C_format = C.format = {};

    /**
     * OpenSSL formatting strategy.
     */
    var OpenSSLFormatter = C_format.OpenSSL = {
        /**
         * Converts a cipher params object to an OpenSSL-compatible string.
         *
         * @param {CipherParams} cipherParams The cipher params object.
         *
         * @return {string} The OpenSSL-compatible string.
         *
         * @static
         *
         * @example
         *
         *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
         */
        stringify: function (cipherParams) {
            // Shortcuts
            var ciphertext = cipherParams.ciphertext;
            var salt = cipherParams.salt;

            // Format
            if (salt) {
                var wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);
            } else {
                var wordArray = ciphertext;
            }

            return wordArray.toString(Base64);
        },

        /**
         * Converts an OpenSSL-compatible string to a cipher params object.
         *
         * @param {string} openSSLStr The OpenSSL-compatible string.
         *
         * @return {CipherParams} The cipher params object.
         *
         * @static
         *
         * @example
         *
         *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
         */
        parse: function (openSSLStr) {
            // Parse base64
            var ciphertext = Base64.parse(openSSLStr);

            // Shortcut
            var ciphertextWords = ciphertext.words;

            // Test for salt
            if (ciphertextWords[0] == 0x53616c74 && ciphertextWords[1] == 0x65645f5f) {
                // Extract salt
                var salt = WordArray.create(ciphertextWords.slice(2, 4));

                // Remove salt from ciphertext
                ciphertextWords.splice(0, 4);
                ciphertext.sigBytes -= 16;
            }

            return CipherParams.create({ ciphertext: ciphertext, salt: salt });
        }
    };

    /**
     * A cipher wrapper that returns ciphertext as a serializable cipher params object.
     */
    var SerializableCipher = C_lib.SerializableCipher = Base.extend({
        /**
         * Configuration options.
         *
         * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
         */
        cfg: Base.extend({
            format: OpenSSLFormatter
        }),

        /**
         * Encrypts a message.
         *
         * @param {Cipher} cipher The cipher algorithm to use.
         * @param {WordArray|string} message The message to encrypt.
         * @param {WordArray} key The key.
         * @param {Object} cfg (Optional) The configuration options to use for this operation.
         *
         * @return {CipherParams} A cipher params object.
         *
         * @static
         *
         * @example
         *
         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
         */
        encrypt: function (cipher, message, key, cfg) {
            // Apply config defaults
            cfg = this.cfg.extend(cfg);

            // Encrypt
            var encryptor = cipher.createEncryptor(key, cfg);
            var ciphertext = encryptor.finalize(message);

            // Shortcut
            var cipherCfg = encryptor.cfg;

            // Create and return serializable cipher params
            return CipherParams.create({
                ciphertext: ciphertext,
                key: key,
                iv: cipherCfg.iv,
                algorithm: cipher,
                mode: cipherCfg.mode,
                padding: cipherCfg.padding,
                blockSize: cipher.blockSize,
                formatter: cfg.format
            });
        },

        /**
         * Decrypts serialized ciphertext.
         *
         * @param {Cipher} cipher The cipher algorithm to use.
         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
         * @param {WordArray} key The key.
         * @param {Object} cfg (Optional) The configuration options to use for this operation.
         *
         * @return {WordArray} The plaintext.
         *
         * @static
         *
         * @example
         *
         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
         */
        decrypt: function (cipher, ciphertext, key, cfg) {
            // Apply config defaults
            cfg = this.cfg.extend(cfg);

            // Convert string to CipherParams
            ciphertext = this._parse(ciphertext, cfg.format);

            // Decrypt
            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);

            return plaintext;
        },

        /**
         * Converts serialized ciphertext to CipherParams,
         * else assumed CipherParams already and returns ciphertext unchanged.
         *
         * @param {CipherParams|string} ciphertext The ciphertext.
         * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
         *
         * @return {CipherParams} The unserialized ciphertext.
         *
         * @static
         *
         * @example
         *
         *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
         */
        _parse: function (ciphertext, format) {
            if (typeof ciphertext == 'string') {
                return format.parse(ciphertext, this);
            } else {
                return ciphertext;
            }
        }
    });

    /**
     * Key derivation function namespace.
     */
    var C_kdf = C.kdf = {};

    /**
     * OpenSSL key derivation function.
     */
    var OpenSSLKdf = C_kdf.OpenSSL = {
        /**
         * Derives a key and IV from a password.
         *
         * @param {string} password The password to derive from.
         * @param {number} keySize The size in words of the key to generate.
         * @param {number} ivSize The size in words of the IV to generate.
         * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
         *
         * @return {CipherParams} A cipher params object with the key, IV, and salt.
         *
         * @static
         *
         * @example
         *
         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
         */
        execute: function (password, keySize, ivSize, salt) {
            // Generate random salt
            if (!salt) {
                salt = WordArray.random(64/8);
            }

            // Derive key and IV
            var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);

            // Separate key and IV
            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
            key.sigBytes = keySize * 4;

            // Return params
            return CipherParams.create({ key: key, iv: iv, salt: salt });
        }
    };

    /**
     * A serializable cipher wrapper that derives the key from a password,
     * and returns ciphertext as a serializable cipher params object.
     */
    var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
        /**
         * Configuration options.
         *
         * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
         */
        cfg: SerializableCipher.cfg.extend({
            kdf: OpenSSLKdf
        }),

        /**
         * Encrypts a message using a password.
         *
         * @param {Cipher} cipher The cipher algorithm to use.
         * @param {WordArray|string} message The message to encrypt.
         * @param {string} password The password.
         * @param {Object} cfg (Optional) The configuration options to use for this operation.
         *
         * @return {CipherParams} A cipher params object.
         *
         * @static
         *
         * @example
         *
         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
         */
        encrypt: function (cipher, message, password, cfg) {
            // Apply config defaults
            cfg = this.cfg.extend(cfg);

            // Derive key and other params
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);

            // Add IV to config
            cfg.iv = derivedParams.iv;

            // Encrypt
            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);

            // Mix in derived params
            ciphertext.mixIn(derivedParams);

            return ciphertext;
        },

        /**
         * Decrypts serialized ciphertext using a password.
         *
         * @param {Cipher} cipher The cipher algorithm to use.
         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
         * @param {string} password The password.
         * @param {Object} cfg (Optional) The configuration options to use for this operation.
         *
         * @return {WordArray} The plaintext.
         *
         * @static
         *
         * @example
         *
         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
         */
        decrypt: function (cipher, ciphertext, password, cfg) {
            // Apply config defaults
            cfg = this.cfg.extend(cfg);

            // Convert string to CipherParams
            ciphertext = this._parse(ciphertext, cfg.format);

            // Derive key and other params
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);

            // Add IV to config
            cfg.iv = derivedParams.iv;

            // Decrypt
            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);

            return plaintext;
        }
    });
}());

(function () {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var BlockCipher = C_lib.BlockCipher;
    var C_algo = C.algo;

    // Lookup tables
    var SBOX = [];
    var INV_SBOX = [];
    var SUB_MIX_0 = [];
    var SUB_MIX_1 = [];
    var SUB_MIX_2 = [];
    var SUB_MIX_3 = [];
    var INV_SUB_MIX_0 = [];
    var INV_SUB_MIX_1 = [];
    var INV_SUB_MIX_2 = [];
    var INV_SUB_MIX_3 = [];

    // Compute lookup tables
    (function () {
        // Compute double table
        var d = [];
        for (var i = 0; i < 256; i++) {
            if (i < 128) {
                d[i] = i << 1;
            } else {
                d[i] = (i << 1) ^ 0x11b;
            }
        }

        // Walk GF(2^8)
        var x = 0;
        var xi = 0;
        for (var i = 0; i < 256; i++) {
            // Compute sbox
            var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
            sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
            SBOX[x] = sx;
            INV_SBOX[sx] = x;

            // Compute multiplication
            var x2 = d[x];
            var x4 = d[x2];
            var x8 = d[x4];

            // Compute sub bytes, mix columns tables
            var t = (d[sx] * 0x101) ^ (sx * 0x1010100);
            SUB_MIX_0[x] = (t << 24) | (t >>> 8);
            SUB_MIX_1[x] = (t << 16) | (t >>> 16);
            SUB_MIX_2[x] = (t << 8)  | (t >>> 24);
            SUB_MIX_3[x] = t;

            // Compute inv sub bytes, inv mix columns tables
            var t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
            INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);
            INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);
            INV_SUB_MIX_2[sx] = (t << 8)  | (t >>> 24);
            INV_SUB_MIX_3[sx] = t;

            // Compute next counter
            if (!x) {
                x = xi = 1;
            } else {
                x = x2 ^ d[d[d[x8 ^ x2]]];
                xi ^= d[d[xi]];
            }
        }
    }());

    // Precomputed Rcon lookup
    var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];

    /**
     * AES block cipher algorithm.
     */
    var AES = C_algo.AES = BlockCipher.extend({
        _doReset: function () {
            // Shortcuts
            var key = this._key;
            var keyWords = key.words;
            var keySize = key.sigBytes / 4;

            // Compute number of rounds
            var nRounds = this._nRounds = keySize + 6

            // Compute number of key schedule rows
            var ksRows = (nRounds + 1) * 4;

            // Compute key schedule
            var keySchedule = this._keySchedule = [];
            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
                if (ksRow < keySize) {
                    keySchedule[ksRow] = keyWords[ksRow];
                } else {
                    var t = keySchedule[ksRow - 1];

                    if (!(ksRow % keySize)) {
                        // Rot word
                        t = (t << 8) | (t >>> 24);

                        // Sub word
                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];

                        // Mix Rcon
                        t ^= RCON[(ksRow / keySize) | 0] << 24;
                    } else if (keySize > 6 && ksRow % keySize == 4) {
                        // Sub word
                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];
                    }

                    keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
                }
            }

            // Compute inv key schedule
            var invKeySchedule = this._invKeySchedule = [];
            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
                var ksRow = ksRows - invKsRow;

                if (invKsRow % 4) {
                    var t = keySchedule[ksRow];
                } else {
                    var t = keySchedule[ksRow - 4];
                }

                if (invKsRow < 4 || ksRow <= 4) {
                    invKeySchedule[invKsRow] = t;
                } else {
                    invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]] ^
                                               INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];
                }
            }
        },

        encryptBlock: function (M, offset) {
            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
        },

        decryptBlock: function (M, offset) {
            // Swap 2nd and 4th rows
            var t = M[offset + 1];
            M[offset + 1] = M[offset + 3];
            M[offset + 3] = t;

            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);

            // Inv swap 2nd and 4th rows
            var t = M[offset + 1];
            M[offset + 1] = M[offset + 3];
            M[offset + 3] = t;
        },

        _doCryptBlock: function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
            // Shortcut
            var nRounds = this._nRounds;

            // Get input, add round key
            var s0 = M[offset]     ^ keySchedule[0];
            var s1 = M[offset + 1] ^ keySchedule[1];
            var s2 = M[offset + 2] ^ keySchedule[2];
            var s3 = M[offset + 3] ^ keySchedule[3];

            // Key schedule row counter
            var ksRow = 4;

            // Rounds
            for (var round = 1; round < nRounds; round++) {
                // Shift rows, sub bytes, mix columns, add round key
                var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[(s1 >>> 16) & 0xff] ^ SUB_MIX_2[(s2 >>> 8) & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow++];
                var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[(s2 >>> 16) & 0xff] ^ SUB_MIX_2[(s3 >>> 8) & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow++];
                var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[(s3 >>> 16) & 0xff] ^ SUB_MIX_2[(s0 >>> 8) & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow++];
                var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[(s0 >>> 16) & 0xff] ^ SUB_MIX_2[(s1 >>> 8) & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow++];

                // Update state
                s0 = t0;
                s1 = t1;
                s2 = t2;
                s3 = t3;
            }

            // Shift rows, sub bytes, add round key
            var t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
            var t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
            var t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
            var t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];

            // Set output
            M[offset]     = t0;
            M[offset + 1] = t1;
            M[offset + 2] = t2;
            M[offset + 3] = t3;
        },

        keySize: 256/32
    });

    /**
     * Shortcut functions to the cipher's object interface.
     *
     * @example
     *
     *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);
     *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);
     */
    C.AES = BlockCipher._createHelper(AES);
}());

(function () {
    // Check if typed arrays are supported
    if (typeof ArrayBuffer === 'undefined') {
        return;
    }

    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var WordArray = C_lib.WordArray;

    // Reference original init
    var superInit = WordArray.init;

    // Augment WordArray.init to handle typed arrays
    var subInit = WordArray.init = function (typedArray) {
        // Convert buffers to uint8
        if (typedArray instanceof ArrayBuffer) {
            typedArray = new Uint8Array(typedArray);
        }

        // Convert other array views to uint8
        else if (
            typedArray instanceof Int8Array ||
            (typeof Uint8ClampedArray !== 'undefined' && typedArray instanceof Uint8ClampedArray) ||
            typedArray instanceof Int16Array ||
            typedArray instanceof Uint16Array ||
            typedArray instanceof Int32Array ||
            typedArray instanceof Uint32Array ||
            (typeof Float32Array !== 'undefined' && typedArray instanceof Float32Array) ||
            (typeof Float64Array !== 'undefined' && typedArray instanceof Float64Array)
        ) {
            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
        }

        // Handle Uint8Array
        if (typedArray instanceof Uint8Array) {
            // Shortcut
            var typedArrayByteLength = typedArray.byteLength;

            // Extract bytes
            var words = [];
            for (var i = 0; i < typedArrayByteLength; i++) {
                words[i >>> 2] |= typedArray[i] << (24 - (i % 4) * 8);
            }

            // Initialize this word array
            superInit.call(this, words, typedArrayByteLength);
        } else {
            // Else call normal init
            superInit.apply(this, arguments);
        }
    };

    subInit.prototype = WordArray;
}());

var DomEvent = (function() {
	function DomEvent() {}

	DomEvent.addListener = function(target, event, listener) {
		if(target.addEventListener) {
			target.addEventListener(event, listener, false);
		} else {
			target.attachEvent('on'+event, function() { listener.apply(target, arguments); });
		}
	};

	DomEvent.removeListener = function(target, event, listener) {
		if(target.removeEventListener) {
			target.removeEventListener(event, listener, false);
		} else {
			target.detachEvent('on'+event, function() { listener.apply(target, arguments); });
		}
	};

	DomEvent.addMessageListener = function(target, listener) {
		DomEvent.addListener(target, 'message', listener);
	};

	DomEvent.removeMessageListener = function(target, listener) {
		DomEvent.removeListener(target, 'message', listener);
	};

	DomEvent.addUnloadListener = function(listener) {
		DomEvent.addListener(window, 'unload', listener);
	};

	return DomEvent;
})();

var msgpack = (function() {
	"use strict";

	var exports = {};

	exports.inspect = inspect;
	function inspect(buffer) {
		if (buffer === undefined)
			return "undefined";
		var view;
		var type;
		if ( buffer instanceof ArrayBuffer) {
			type = "ArrayBuffer";
			view = new DataView(buffer);
		} else if ( buffer instanceof DataView) {
			type = "DataView";
			view = buffer;
		}
		if (!view)
			return JSON.stringify(buffer);
		var bytes = [];
		for (var i = 0; i < buffer.byteLength; i++) {
			if (i > 20) {
				bytes.push("...");
				break;
			}
			var byte_ = view.getUint8(i).toString(16);
			if (byte_.length === 1)
				byte_ = "0" + byte_;
			bytes.push(byte_);
		}
		return "<" + type + " " + bytes.join(" ") + ">";
	}

	// Encode string as utf8 into dataview at offset
	exports.utf8Write = utf8Write;
	function utf8Write(view, offset, string) {
		var byteLength = view.byteLength;
		for (var i = 0, l = string.length; i < l; i++) {
			var codePoint = string.charCodeAt(i);

			// One byte of UTF-8
			if (codePoint < 0x80) {
				view.setUint8(offset++, codePoint >>> 0 & 0x7f | 0x00);
				continue;
			}

			// Two bytes of UTF-8
			if (codePoint < 0x800) {
				view.setUint8(offset++, codePoint >>> 6 & 0x1f | 0xc0);
				view.setUint8(offset++, codePoint >>> 0 & 0x3f | 0x80);
				continue;
			}

			// Three bytes of UTF-8.
			if (codePoint < 0x10000) {
				view.setUint8(offset++, codePoint >>> 12 & 0x0f | 0xe0);
				view.setUint8(offset++, codePoint >>> 6 & 0x3f | 0x80);
				view.setUint8(offset++, codePoint >>> 0 & 0x3f | 0x80);
				continue;
			}

			// Four bytes of UTF-8
			if (codePoint < 0x110000) {
				view.setUint8(offset++, codePoint >>> 18 & 0x07 | 0xf0);
				view.setUint8(offset++, codePoint >>> 12 & 0x3f | 0x80);
				view.setUint8(offset++, codePoint >>> 6 & 0x3f | 0x80);
				view.setUint8(offset++, codePoint >>> 0 & 0x3f | 0x80);
				continue;
			}
			throw new Error("bad codepoint " + codePoint);
		}
	}


	exports.utf8Read = utf8Read;
	function utf8Read(view, offset, length) {
		var string = "";
		for (var i = offset, end = offset + length; i < end; i++) {
			var byte_ = view.getUint8(i);
			// One byte character
			if ((byte_ & 0x80) === 0x00) {
				string += String.fromCharCode(byte_);
				continue;
			}
			// Two byte character
			if ((byte_ & 0xe0) === 0xc0) {
				string += String.fromCharCode(((byte_ & 0x0f) << 6) | (view.getUint8(++i) & 0x3f));
				continue;
			}
			// Three byte character
			if ((byte_ & 0xf0) === 0xe0) {
				string += String.fromCharCode(((byte_ & 0x0f) << 12) | ((view.getUint8(++i) & 0x3f) << 6) | ((view.getUint8(++i) & 0x3f) << 0));
				continue;
			}
			// Four byte character
			if ((byte_ & 0xf8) === 0xf0) {
				string += String.fromCharCode(((byte_ & 0x07) << 18) | ((view.getUint8(++i) & 0x3f) << 12) | ((view.getUint8(++i) & 0x3f) << 6) | ((view.getUint8(++i) & 0x3f) << 0));
				continue;
			}
			throw new Error("Invalid byte " + byte_.toString(16));
		}
		return string;
	}


	exports.utf8ByteCount = utf8ByteCount;
	function utf8ByteCount(string) {
		var count = 0;
		for (var i = 0, l = string.length; i < l; i++) {
			var codePoint = string.charCodeAt(i);
			if (codePoint < 0x80) {
				count += 1;
				continue;
			}
			if (codePoint < 0x800) {
				count += 2;
				continue;
			}
			if (codePoint < 0x10000) {
				count += 3;
				continue;
			}
			if (codePoint < 0x110000) {
				count += 4;
				continue;
			}
			throw new Error("bad codepoint " + codePoint);
		}
		return count;
	}


	exports.encode = function(value, sparse) {
		var size = sizeof(value, sparse);
		if(size == 0)
			return undefined;
		var buffer = new ArrayBuffer(size);
		var view = new DataView(buffer);
		encode(value, view, 0, sparse);
		return buffer;
	};

	exports.decode = decode;

	var SH_L_32 = (1 << 16) * (1 << 16), SH_R_32 = 1 / SH_L_32;
	function getInt64(view, offset) {
		offset = offset || 0;
		return view.getInt32(offset) * SH_L_32 + view.getUint32(offset + 4);
	}

	function getUint64(view, offset) {
		offset = offset || 0;
		return view.getUint32(offset) * SH_L_32 + view.getUint32(offset + 4);
	}

	function setInt64(view, offset, val) {
		if (val < 0x8000000000000000) {
			view.setInt32(offset, Math.floor(val * SH_R_32));
			view.setInt32(offset + 4, val & -1);
		} else {
			view.setUint32(offset, 0x7fffffff);
			view.setUint32(offset + 4, 0x7fffffff);
		}
	}

	function setUint64(view, offset, val) {
		if (val < 0x10000000000000000) {
			view.setUint32(offset, Math.floor(val * SH_R_32));
			view.setInt32(offset + 4, val & -1);
		} else {
			view.setUint32(offset, 0xffffffff);
			view.setUint32(offset + 4, 0xffffffff);
		}
	}

// https://gist.github.com/frsyuki/5432559 - v5 spec
//
// I've used one extension point from `fixext 1` to store `undefined`. On the wire this
// should translate to exactly 0xd40000
//
// +--------+--------+--------+
// |  0xd4  |  0x00  |  0x00  |
// +--------+--------+--------+
//    ^ fixext |        ^ value part unused (fixed to be 0)
//             ^ indicates undefined value
//

	function Decoder(view, offset) {
		this.offset = offset || 0;
		this.view = view;
	}


	Decoder.prototype.map = function(length) {
		var value = {};
		for (var i = 0; i < length; i++) {
			var key = this.parse();
			value[key] = this.parse();
		}
		return value;
	};

	Decoder.prototype.bin = Decoder.prototype.buf = function(length) {
		var value = new ArrayBuffer(length);
		(new Uint8Array(value)).set(new Uint8Array(this.view.buffer, this.offset, length), 0);
		this.offset += length;
		return value;
	};

	Decoder.prototype.str = function(length) {
		var value = utf8Read(this.view, this.offset, length);
		this.offset += length;
		return value;
	};

	Decoder.prototype.array = function(length) {
		var value = new Array(length);
		for (var i = 0; i < length; i++) {
			value[i] = this.parse();
		}
		return value;
	};

	Decoder.prototype.ext = function(length) {
		var value = {};
		// Get the type byte
		value['type'] = this.view.getInt8(this.offset);
		this.offset++;
		// Get the data array (length)
		value['data'] = this.buf(length);
		this.offset += length;
		return value;
	};

	Decoder.prototype.parse = function() {
		var type = this.view.getUint8(this.offset);
		var value, length;

		// Positive FixInt - 0xxxxxxx
		if ((type & 0x80) === 0x00) {
			this.offset++;
			return type;
		}

		// FixMap - 1000xxxx
		if ((type & 0xf0) === 0x80) {
			length = type & 0x0f;
			this.offset++;
			return this.map(length);
		}

		// FixArray - 1001xxxx
		if ((type & 0xf0) === 0x90) {
			length = type & 0x0f;
			this.offset++;
			return this.array(length);
		}

		// FixStr - 101xxxxx
		if ((type & 0xe0) === 0xa0) {
			length = type & 0x1f;
			this.offset++;
			return this.str(length);
		}

		// Negative FixInt - 111xxxxx
		if ((type & 0xe0) === 0xe0) {
			value = this.view.getInt8(this.offset);
			this.offset++;
			return value;
		}

		switch (type) {

			// nil
			case 0xc0:
				this.offset++;
				return null;

			// 0xc1 never used - use for undefined (NON-STANDARD)
			case 0xc1:
				this.offset++;
				return undefined;

			// false
			case 0xc2:
				this.offset++;
				return false;

			// true
			case 0xc3:
				this.offset++;
				return true;

			// bin 8
			case 0xc4:
				length = this.view.getUint8(this.offset + 1);
				this.offset += 2;
				return this.bin(length);

			// bin 16
			case 0xc5:
				length = this.view.getUint16(this.offset + 1);
				this.offset += 3;
				return this.bin(length);

			// bin 32
			case 0xc6:
				length = this.view.getUint32(this.offset + 1);
				this.offset += 5;
				return this.bin(length);

			// ext 8
			case 0xc7:
				length = this.view.getUint8(this.offset + 1);
				this.offset += 2;
				return this.ext(length);

			// ext 16
			case 0xc8:
				length = this.view.getUint16(this.offset + 1);
				this.offset += 3;
				return this.ext(length);

			// ext 32
			case 0xc9:
				length = this.view.getUint32(this.offset + 1);
				this.offset += 5;
				return this.ext(length);

			// float 32
			case 0xca:
				value = this.view.getFloat32(this.offset + 1);
				this.offset += 5;
				return value;

			// float 64
			case 0xcb:
				value = this.view.getFloat64(this.offset + 1);
				this.offset += 9;
				return value;

			// uint8
			case 0xcc:
				value = this.view.getUint8(this.offset + 1);
				this.offset += 2;
				return value;

			// uint 16
			case 0xcd:
				value = this.view.getUint16(this.offset + 1);
				this.offset += 3;
				return value;

			// uint 32
			case 0xce:
				value = this.view.getUint32(this.offset + 1);
				this.offset += 5;
				return value;

			// uint 64
			case 0xcf:
				value = getUint64(this.view, this.offset + 1);
				this.offset += 9;
				return value;

			// int 8
			case 0xd0:
				value = this.view.getInt8(this.offset + 1);
				this.offset += 2;
				return value;

			// int 16
			case 0xd1:
				value = this.view.getInt16(this.offset + 1);
				this.offset += 3;
				return value;

			// int 32
			case 0xd2:
				value = this.view.getInt32(this.offset + 1);
				this.offset += 5;
				return value;

			// int 64
			case 0xd3:
				value = getInt64(this.view, this.offset + 1);
				this.offset += 9;
				return value;

			// fixext 1
			case 0xd4:
				length = 1;
				this.offset++;
				return this.ext(length);

			// fixext 2
			case 0xd5:
				length = 2;
				this.offset++;
				return this.ext(length);

			// fixext 4
			case 0xd6:
				length = 4;
				this.offset++;
				return this.ext(length);

			// fixext 8
			case 0xd7:
				length = 8;
				this.offset++;
				return this.ext(length);

			// fixext 16
			case 0xd8:
				length = 16;
				this.offset++;
				return this.ext(length);

			// str8
			case 0xd9:
				length = this.view.getUint8(this.offset + 1);
				this.offset += 2;
				return this.str(length);

			// str 16
			case 0xda:
				length = this.view.getUint16(this.offset + 1);
				this.offset += 3;
				return this.str(length);

			// str 32
			case 0xdb:
				length = this.view.getUint32(this.offset + 1);
				this.offset += 5;
				return this.str(length);

			// array 16
			case 0xdc:
				length = this.view.getUint16(this.offset + 1);
				this.offset += 3;
				return this.array(length);

			// array 32
			case 0xdd:
				length = this.view.getUint32(this.offset + 1);
				this.offset += 5;
				return this.array(length);

			// map 16
			case 0xde:
				length = this.view.getUint16(this.offset + 1);
				this.offset += 3;
				return this.map(length);

			// map 32
			case 0xdf:
				length = this.view.getUint32(this.offset + 1);
				this.offset += 5;
				return this.map(length);
		}
		throw new Error("Unknown type 0x" + type.toString(16));
	};

	function decode(buffer) {
		var view = new DataView(buffer);
		var decoder = new Decoder(view);
		var value = decoder.parse();
		if (decoder.offset !== buffer.byteLength)
			throw new Error((buffer.byteLength - decoder.offset) + " trailing bytes");
		return value;
	}

	function encodeableKeys(value, sparse) {
		return Utils.keysArray(value, true).filter(function (e) {
			var val = value[e], type = typeof(val);
			return (!sparse || (val !== undefined && val !== null)) && ('function' !== type || !!val.toJSON);
		})
	}

	function encode(value, view, offset, sparse) {
		var type = typeof value;

		// Strings Bytes
		// There are four string types: fixstr/str8/str16/str32
		if (type === "string") {
			var length = utf8ByteCount(value);

			// fixstr
			if (length < 0x20) {
				view.setUint8(offset, length | 0xa0);
				utf8Write(view, offset + 1, value);
				return 1 + length;
			}

			// str8
			if (length < 0x100) {
				view.setUint8(offset, 0xd9);
				view.setUint8(offset + 1, length);
				utf8Write(view, offset + 2, value);
				return 2 + length;
			}

			// str16
			if (length < 0x10000) {
				view.setUint8(offset, 0xda);
				view.setUint16(offset + 1, length);
				utf8Write(view, offset + 3, value);
				return 3 + length;
			}
			// str32
			if (length < 0x100000000) {
				view.setUint8(offset, 0xdb);
				view.setUint32(offset + 1, length);
				utf8Write(view, offset + 5, value);
				return 5 + length;
			}
		}

		// There are three bin types: bin8/bin16/bin32
		if (value instanceof ArrayBuffer) {
			var length = value.byteLength;

			// bin8
			if (length < 0x100) {
				view.setUint8(offset, 0xc4);
				view.setUint8(offset + 1, length);
				(new Uint8Array(view.buffer)).set(new Uint8Array(value), offset + 2);
				return 2 + length;
			}

			// bin16
			if (length < 0x10000) {
				view.setUint8(offset, 0xc5);
				view.setUint16(offset + 1, length);
				(new Uint8Array(view.buffer)).set(new Uint8Array(value), offset + 3);
				return 3 + length;
			}

			// bin 32
			if (length < 0x100000000) {
				view.setUint8(offset, 0xc6);
				view.setUint32(offset + 1, length);
				(new Uint8Array(view.buffer)).set(new Uint8Array(value), offset + 5);
				return 5 + length;
			}
		}

		if (type === "number") {

			// Floating Point
			// NOTE: We're always using float64
			if (Math.floor(value) !== value) {
				view.setUint8(offset, 0xcb);
				view.setFloat64(offset + 1, value);
				return 9;
			}

			// Integers
			if (value >= 0) {
				// positive fixnum
				if (value < 0x80) {
					view.setUint8(offset, value);
					return 1;
				}
				// uint 8
				if (value < 0x100) {
					view.setUint8(offset, 0xcc);
					view.setUint8(offset + 1, value);
					return 2;
				}
				// uint 16
				if (value < 0x10000) {
					view.setUint8(offset, 0xcd);
					view.setUint16(offset + 1, value);
					return 3;
				}
				// uint 32
				if (value < 0x100000000) {
					view.setUint8(offset, 0xce);
					view.setUint32(offset + 1, value);
					return 5;
				}
				// uint 64
				if (value < 0x10000000000000000) {
					view.setUint8(offset, 0xcf);
					setUint64(view, offset + 1, value);
					return 9;
				}
				throw new Error("Number too big 0x" + value.toString(16));
			}

			// negative fixnum
			if (value >= -0x20) {
				view.setInt8(offset, value);
				return 1;
			}
			// int 8
			if (value >= -0x80) {
				view.setUint8(offset, 0xd0);
				view.setInt8(offset + 1, value);
				return 2;
			}
			// int 16
			if (value >= -0x8000) {
				view.setUint8(offset, 0xd1);
				view.setInt16(offset + 1, value);
				return 3;
			}
			// int 32
			if (value >= -0x80000000) {
				view.setUint8(offset, 0xd2);
				view.setInt32(offset + 1, value);
				return 5;
			}
			// int 64
			if (value >= -0x8000000000000000) {
				view.setUint8(offset, 0xd3);
				setInt64(view, offset + 1, value);
				return 9;
			}
			throw new Error("Number too small -0x" + (-value).toString(16).substr(1));
		}

		// undefined - use d4 (NON-STANDARD)
		if (type === "undefined") {
			if(sparse) return 0;
			view.setUint8(offset, 0xd4);
			view.setUint8(offset + 1, 0x00);
			view.setUint8(offset + 2, 0x00);
			return 3;
		}

		// null
		if (value === null) {
			if(sparse) return 0;
			view.setUint8(offset, 0xc0);
			return 1;
		}

		// Boolean
		if (type === "boolean") {
			view.setUint8(offset, value ? 0xc3 : 0xc2);
			return 1;
		}

		if('function' === typeof value.toJSON)
			return encode(value.toJSON(), view, offset, sparse);

		// Container Types
		if (type === "object") {
			var length, size = 0;
			var isArray = Array.isArray(value);

			if (isArray) {
				length = value.length;
			} else {
				var keys = encodeableKeys(value, sparse);
				length = keys.length;
			}

			var size;
			if (length < 0x10) {
				view.setUint8(offset, length | ( isArray ? 0x90 : 0x80));
				size = 1;
			} else if (length < 0x10000) {
				view.setUint8(offset, isArray ? 0xdc : 0xde);
				view.setUint16(offset + 1, length);
				size = 3;
			} else if (length < 0x100000000) {
				view.setUint8(offset, isArray ? 0xdd : 0xdf);
				view.setUint32(offset + 1, length);
				size = 5;
			}

			if (isArray) {
				for (var i = 0; i < length; i++) {
					size += encode(value[i], view, offset + size, sparse);
				}
			} else {
				for (var i = 0; i < length; i++) {
					var key = keys[i];
					size += encode(key, view, offset + size);
					size += encode(value[key], view, offset + size, sparse);
				}
			}

			return size;
		}
		if(type === "function")
			return 0;

		throw new Error("Unknown type " + type);
	}

	function sizeof(value, sparse) {
		var type = typeof value;

		// fixstr or str8 or str16 or str32
		if (type === "string") {
			var length = utf8ByteCount(value);
			if (length < 0x20) {
				return 1 + length;
			}
			if (length < 0x100) {
				return 2 + length;
			}
			if (length < 0x10000) {
				return 3 + length;
			}
			if (length < 0x100000000) {
				return 5 + length;
			}
		}

		// bin8 or bin16 or bin32
		if (value instanceof ArrayBuffer) {
			var length = value.byteLength;
			if (length < 0x100) {
				return 2 + length;
			}
			if (length < 0x10000) {
				return 3 + length;
			}
			if (length < 0x100000000) {
				return 5 + length;
			}
		}

		if (type === "number") {
			// Floating Point (32 bits)
			// double
			if (Math.floor(value) !== value)
				return 9;

			// Integers
			if (value >= 0) {
				// positive fixint
				if (value < 0x80)
					return 1;
				// uint 8
				if (value < 0x100)
					return 2;
				// uint 16
				if (value < 0x10000)
					return 3;
				// uint 32
				if (value < 0x100000000)
					return 5;
				// uint 64
				if (value < 0x10000000000000000)
					return 9;
				// Too big
				throw new Error("Number too big 0x" + value.toString(16));
			}
			// negative fixint
			if (value >= -0x20)
				return 1;
			// int 8
			if (value >= -0x80)
				return 2;
			// int 16
			if (value >= -0x8000)
				return 3;
			// int 32
			if (value >= -0x80000000)
				return 5;
			// int 64
			if (value >= -0x8000000000000000)
				return 9;
			// Too small
			throw new Error("Number too small -0x" + value.toString(16).substr(1));
		}

		// Boolean
		if (type === "boolean") return 1;

		// undefined, null
		if (value === null) return sparse ? 0 : 1;
		if (value === undefined) return sparse ? 0 : 3;

		if('function' === typeof value.toJSON)
			return sizeof(value.toJSON(), sparse);

		// Container Types
		if (type === "object") {
			var length, size = 0;
			if (Array.isArray(value)) {
				length = value.length;
				for (var i = 0; i < length; i++) {
					size += sizeof(value[i], sparse);
				}
			} else {
				var keys = encodeableKeys(value, sparse)
				length = keys.length;
				for (var i = 0; i < length; i++) {
					var key = keys[i];
					size += sizeof(key) + sizeof(value[key], sparse);
				}
			}
			if (length < 0x10) {
				return 1 + size;
			}
			if (length < 0x10000) {
				return 3 + size;
			}
			if (length < 0x100000000) {
				return 5 + size;
			}
			throw new Error("Array or object too long 0x" + length.toString(16));
		}
		if(type === "function")
			return 0;

		throw new Error("Unknown type " + type);
	}

	return exports;
})();

if(typeof window !== 'object') {
	console.log("Warning: this distribution of Ably is intended for browsers. On nodejs, please use the 'ably' package on npm");
}

var Platform = {
	libver: 'js-web-',
	noUpgrade: navigator && navigator.userAgent.toString().match(/MSIE\s8\.0/),
	binaryType: 'arraybuffer',
	WebSocket: window.WebSocket || window.MozWebSocket,
	xhrSupported: (window.XMLHttpRequest && 'withCredentials' in new XMLHttpRequest()),
	streamingSupported: true,
	useProtocolHeartbeats: true,
	createHmac: null,
	msgpack: msgpack,
	supportsBinary: !!window.TextDecoder,
	preferBinary: false,
	ArrayBuffer: window.ArrayBuffer,
	atob: window.atob,
	nextTick: function(f) { setTimeout(f, 0); },
	addEventListener: window.addEventListener,
	inspect: JSON.stringify,
	getRandomValues: (function(crypto) {
		return function(arr, callback) {
			crypto.getRandomValues(arr);
			callback(null);
		};
	})(window.crypto || window.msCrypto) // mscrypto for IE11
};


var Crypto = (function() {
	var DEFAULT_ALGORITHM = 'aes';
	var DEFAULT_KEYLENGTH = 256; // bits
	var DEFAULT_MODE = 'cbc';
	var DEFAULT_BLOCKLENGTH = 16; // bytes
	var DEFAULT_BLOCKLENGTH_WORDS = 4; // 32-bit words
	var UINT32_SUP = 0x100000000;
	var INT32_SUP = 0x80000000;
	var WordArray = CryptoJS.lib.WordArray;

	/**
	 * Internal: generate an array of secure random words corresponding to the given length of bytes
	 * @param bytes
	 * @param callback
	 */
	var generateRandom;
	if(typeof Uint32Array !== 'undefined' && Platform.getRandomValues) {
		var blockRandomArray = new Uint32Array(DEFAULT_BLOCKLENGTH_WORDS);
		generateRandom = function(bytes, callback) {
			var words = bytes / 4, nativeArray = (words == DEFAULT_BLOCKLENGTH_WORDS) ? blockRandomArray : new Uint32Array(words);
			Platform.getRandomValues(nativeArray, function(err) {
				callback(err, BufferUtils.toWordArray(nativeArray))
			});
		};
	} else {
		generateRandom = function(bytes, callback) {
			Logger.logAction(Logger.LOG_MAJOR, 'Ably.Crypto.generateRandom()', 'Warning: the browser you are using does not support secure cryptographically secure randomness generation; falling back to insecure Math.random()');
			var words = bytes / 4, array = new Array(words);
			for(var i = 0; i < words; i++) {
				/* cryptojs wordarrays use signed ints. When WordArray.create is fed a
				* Uint32Array unsigned are converted to signed automatically, but when
				* fed a normal array they aren't, so need to do so ourselves by
				* subtracting INT32_SUP */
				array[i] = Math.floor(Math.random() * UINT32_SUP) - INT32_SUP;
			}

			callback(null, WordArray.create(array));
		};
	}

	/**
	 * Internal: calculate the padded length of a given plaintext
	 * using PKCS5.
	 * @param plaintextLength
	 * @return
	 */
	function getPaddedLength(plaintextLength) {
		return (plaintextLength + DEFAULT_BLOCKLENGTH) & -DEFAULT_BLOCKLENGTH;
	}

	/**
	 * Internal: checks that the cipherParams are a valid combination. Currently
	 * just checks that the calculated keyLength is a valid one for aes-cbc
	 */
	function validateCipherParams(params) {
		if(params.algorithm === 'aes' && params.mode === 'cbc') {
			if(params.keyLength === 128 || params.keyLength === 256) {
				return;
			}
			throw new Error('Unsupported key length ' + params.keyLength + ' for aes-cbc encryption. Encryption key must be 128 or 256 bits (16 or 32 ASCII characters)');
		}
	}

	function normaliseBase64(string) {
		/* url-safe base64 strings use _ and - instread of / and + */
		return string.replace('_', '/').replace('-', '+');
	}

	/**
	 * Internal: a block containing zeros
	 */
	var emptyBlock = WordArray.create([0,0,0,0]);

	/**
	 * Internal: obtain the pkcs5 padding string for a given padded length;
	 */
	var pkcs5Padding = [
		WordArray.create([0x10101010,0x10101010,0x10101010,0x10101010], 16),
		WordArray.create([0x01000000], 1),
		WordArray.create([0x02020000], 2),
		WordArray.create([0x03030300], 3),
		WordArray.create([0x04040404], 4),
		WordArray.create([0x05050505,0x05000000], 5),
		WordArray.create([0x06060606,0x06060000], 6),
		WordArray.create([0x07070707,0x07070700], 7),
		WordArray.create([0x08080808,0x08080808], 8),
		WordArray.create([0x09090909,0x09090909,0x09000000], 9),
		WordArray.create([0x0a0a0a0a,0x0a0a0a0a,0x0a0a0000], 10),
		WordArray.create([0x0b0b0b0b,0x0b0b0b0b,0x0b0b0b00], 11),
		WordArray.create([0x0c0c0c0c,0x0c0c0c0c,0x0c0c0c0c], 12),
		WordArray.create([0x0d0d0d0d,0x0d0d0d0d,0x0d0d0d0d,0x0d000000], 13),
		WordArray.create([0x0e0e0e0e,0x0e0e0e0e,0x0e0e0e0e,0x0e0e0000], 14),
		WordArray.create([0x0f0f0f0f,0x0f0f0f0f,0x0f0f0f0f,0x0f0f0f0f], 15),
		WordArray.create([0x10101010,0x10101010,0x10101010,0x10101010], 16)
	];

	/**
	 * Utility classes and interfaces for message payload encryption.
	 *
	 * This class supports AES/CBC/PKCS5 with a default keylength of 128 bits
	 * but supporting other keylengths. Other algorithms and chaining modes are
	 * not supported directly, but supportable by extending/implementing the base
	 * classes and interfaces here.
	 *
	 * Secure random data for creation of Initialization Vectors (IVs) and keys
	 * is obtained from window.crypto.getRandomValues if available, or from
	 * Math.random() if not. Clients who do not want to depend on Math.random()
	 * should polyfill window.crypto.getRandomValues with a library that seeds
	 * a PRNG with real entropy.
	 *
	 * Each message payload is encrypted with an IV in CBC mode, and the IV is
	 * concatenated with the resulting raw ciphertext to construct the "ciphertext"
	 * data passed to the recipient.
	 */
	function Crypto() {}

	/**
	 * A class encapsulating the client-specifiable parameters for
	 * the cipher.
	 *
	 * algorithm is the name of the algorithm in the default system provider,
	 * or the lower-cased version of it; eg "aes" or "AES".
	 *
	 * Clients are recommended to not call this directly, but instead to use the
	 * Crypto.getDefaultParams helper, which will fill in any fields not supplied
	 * with default values and validation the result.
	 */
	function CipherParams() {
		this.algorithm = null;
		this.keyLength = null;
		this.mode = null;
		this.key = null;
	}
	Crypto.CipherParams = CipherParams;

	/**
	 * Obtain a complete CipherParams instance from the provided params, filling
	 * in any not provided with default values, calculating a keyLength from
	 * the supplied key, and validating the result.
	 * @param params an object containing at a minimum a `key` key with value the
	 * key, as either a binary (ArrayBuffer, Array, WordArray) or a
	 * base64-encoded string. May optionally also contain: algorithm (defaults to
	 * AES), mode (defaults to 'cbc')
	 */
	Crypto.getDefaultParams = function(params) {
		var key;
		/* Backward compatibility */
		if((typeof(params) === 'function') || (typeof(params) === 'string')) {
			Logger.deprecated('Crypto.getDefaultParams(key, callback)', 'Crypto.getDefaultParams({key: key})');
			if(typeof(params) === 'function') {
				Crypto.generateRandomKey(function(key) {
					params(null, Crypto.getDefaultParams({key: key}));
				})
			} else if(typeof arguments[1] === 'function') {
				arguments[1](null, Crypto.getDefaultParams({key: params}));
			} else {
				throw new Error('Invalid arguments for Crypto.getDefaultParams');
			}
			return;
		}

		if(!params.key) {
			throw new Error('Crypto.getDefaultParams: a key is required');
		}

		if (typeof(params.key) === 'string') {
			key = CryptoJS.enc.Base64.parse(normaliseBase64(params.key));
		} else {
			key = BufferUtils.toWordArray(params.key); // Expect key to be an Array, ArrayBuffer, or WordArray at this point
		}

		var cipherParams = new CipherParams();
		cipherParams.key = key;
		cipherParams.algorithm = params.algorithm || DEFAULT_ALGORITHM;
		cipherParams.keyLength = key.words.length * (4 * 8);
		cipherParams.mode = params.mode || DEFAULT_MODE;

		if(params.keyLength && params.keyLength !== cipherParams.keyLength) {
			throw new Error('Crypto.getDefaultParams: a keyLength of ' + params.keyLength + ' was specified, but the key actually has length ' + cipherParams.keyLength);
		}

		validateCipherParams(cipherParams);
		return cipherParams;
	};

	/**
	 * Generate a random encryption key from the supplied keylength (or the
	 * default keyLength if none supplied) as a CryptoJS WordArray
	 * @param keyLength (optional) the required keyLength in bits
	 * @param callback (err, key)
	 */
	Crypto.generateRandomKey = function(keyLength, callback) {
		if(arguments.length == 1 && typeof(keyLength) == 'function') {
			callback = keyLength;
			keyLength = undefined;
		}
		generateRandom((keyLength || DEFAULT_KEYLENGTH) / 8, callback);
	};

	/**
	 * Internal; get a ChannelCipher instance based on the given cipherParams
	 * @param params either a CipherParams instance or some subset of its
	 * fields that includes a key
	 */
	Crypto.getCipher = function(params) {
		var cipherParams = (params instanceof CipherParams) ?
		                   params :
		                   Crypto.getDefaultParams(params);

		return {cipherParams: cipherParams, cipher: new CBCCipher(cipherParams, DEFAULT_BLOCKLENGTH_WORDS, params.iv)};
	};

	function CBCCipher(params, blockLengthWords, iv) {
		this.algorithm = params.algorithm + '-' + String(params.keyLength) + '-' + params.mode;
		this.cjsAlgorithm = params.algorithm.toUpperCase().replace(/-\d+$/, '');
		this.key = BufferUtils.toWordArray(params.key);
		if(iv) {
			this.iv = BufferUtils.toWordArray(iv).clone();
		}
		this.blockLengthWords = blockLengthWords;
	}

	CBCCipher.prototype.encrypt = function(plaintext, callback) {
		Logger.logAction(Logger.LOG_MICRO, 'CBCCipher.encrypt()', '');
		plaintext = BufferUtils.toWordArray(plaintext);
		//console.log('encrypt: plaintext:');
		//console.log(CryptoJS.enc.Hex.stringify(plaintext));
		var plaintextLength = plaintext.sigBytes,
			paddedLength = getPaddedLength(plaintextLength),
			self = this;

		var then = function() {
			self.getIv(function(err, iv) {
				if (err) {
					callback(err);
					return;
				}
				var cipherOut = self.encryptCipher.process(plaintext.concat(pkcs5Padding[paddedLength - plaintextLength]));
				var ciphertext = iv.concat(cipherOut);
				//console.log('encrypt: ciphertext:');
				//console.log(CryptoJS.enc.Hex.stringify(ciphertext));
				callback(null, ciphertext);
			});
		};

		if (!this.encryptCipher) {
			if(this.iv) {
				this.encryptCipher = CryptoJS.algo[this.cjsAlgorithm].createEncryptor(this.key, { iv: this.iv });
				then();
			} else {
				generateRandom(DEFAULT_BLOCKLENGTH, function(err, iv) {
					if (err) {
						callback(err);
						return;
					}
					self.encryptCipher = CryptoJS.algo[self.cjsAlgorithm].createEncryptor(self.key, { iv: iv });
					self.iv = iv;
					then();
				});
			}
		} else {
			then();
		}
	};

	CBCCipher.prototype.decrypt = function(ciphertext) {
		Logger.logAction(Logger.LOG_MICRO, 'CBCCipher.decrypt()', '');
		ciphertext = BufferUtils.toWordArray(ciphertext);
		//console.log('decrypt: ciphertext:');
		//console.log(CryptoJS.enc.Hex.stringify(ciphertext));
		var blockLengthWords = this.blockLengthWords,
			ciphertextWords = ciphertext.words,
			iv = WordArray.create(ciphertextWords.slice(0, blockLengthWords)),
			ciphertextBody = WordArray.create(ciphertextWords.slice(blockLengthWords));

		var decryptCipher = CryptoJS.algo[this.cjsAlgorithm].createDecryptor(this.key, { iv: iv });
		var plaintext = decryptCipher.process(ciphertextBody);
		var epilogue = decryptCipher.finalize();
		decryptCipher.reset();
		if(epilogue && epilogue.sigBytes) plaintext.concat(epilogue);
		//console.log('decrypt: plaintext:');
		//console.log(CryptoJS.enc.Hex.stringify(plaintext));
		return plaintext;
	};

	CBCCipher.prototype.getIv = function(callback) {
		if(this.iv) {
			var iv = this.iv;
			this.iv = null;
			callback(null, iv);
			return;
		}

		/* Since the iv for a new block is the ciphertext of the last, this
		* sets a new iv (= aes(randomBlock XOR lastCipherText)) as well as
		* returning it */
		var self = this;
		generateRandom(DEFAULT_BLOCKLENGTH, function(err, randomBlock) {
			if (err) {
				callback(err);
				return;
			} 
			callback(null, self.encryptCipher.process(randomBlock));
		});
	};

	return Crypto;
})();

var WebStorage = (function() {
	var sessionSupported,
		localSupported,
		test = 'ablyjs-storage-test';

	/* Even just accessing the session/localStorage object can throw a
	 * security exception in some circumstances with some browsers. In
	 * others, calling setItem will throw. So have to check in this
	 * somewhat roundabout way. (If unsupported or no window object,
	 * will throw on accessing a property of undefined) */
	try {
		window.sessionStorage.setItem(test, test);
		window.sessionStorage.removeItem(test);
		sessionSupported = true;
	} catch(e) {
		sessionSupported = false;
	}

	try {
		window.localStorage.setItem(test, test);
		window.localStorage.removeItem(test);
		localSupported = true;
	} catch(e) {
		localSupported = false;
	}

	function WebStorage() {}

	function storageInterface(session) {
		return session ? window.sessionStorage : window.localStorage;
	}

	function set(name, value, ttl, session) {
		var wrappedValue = {value: value};
		if(ttl) {
			wrappedValue.expires = Utils.now() + ttl;
		}
		return storageInterface(session).setItem(name, JSON.stringify(wrappedValue));
	}

	function get(name, session) {
		var rawItem = storageInterface(session).getItem(name);
		if(!rawItem) return null;
		var wrappedValue = JSON.parse(rawItem);
		if(wrappedValue.expires && (wrappedValue.expires < Utils.now())) {
			storageInterface(session).removeItem(name);
			return null;
		}
		return wrappedValue.value;
	}

	function remove(name, session) {
		return storageInterface(session).removeItem(name);
	}

	if(localSupported) {
		WebStorage.set    = function(name, value, ttl) { return set(name, value, ttl, false); };
		WebStorage.get    = function(name) { return get(name, false); };
		WebStorage.remove = function(name) { return remove(name, false); };
	}

	if(sessionSupported) {
		WebStorage.setSession    = function(name, value, ttl) { return set(name, value, ttl, true); };
		WebStorage.getSession    = function(name) { return get(name, true); };
		WebStorage.removeSession = function(name) { return remove(name, true); };
	}

	return WebStorage;
})();

var Defaults = {
	internetUpUrl: 'https://internet-up.ably-realtime.com/is-the-internet-up.txt',
	jsonpInternetUpUrl: 'https://internet-up.ably-realtime.com/is-the-internet-up-0-9.js',
	/* Order matters here: the base transport is the leftmost one in the
	 * intersection of baseTransportOrder and the transports clientOption that's
	 * supported.  This is not quite the same as the preference order -- e.g.
	 * xhr_polling is preferred to jsonp, but for browsers that support it we want
	 * the base transport to be xhr_polling, not jsonp */
	defaultTransports: ['xhr_polling', 'xhr_streaming', 'jsonp', 'web_socket'],
	baseTransportOrder: ['xhr_polling', 'xhr_streaming', 'jsonp', 'web_socket'],
	transportPreferenceOrder: ['jsonp', 'xhr_polling', 'xhr_streaming', 'web_socket'],
	upgradeTransports: ['xhr_streaming', 'web_socket'],
	minified: !(function _(){}).name
};

/* If using IE8, don't attempt to upgrade from xhr_polling to xhr_streaming -
* while it can do streaming, the low max http-connections-per-host limit means
* that the polling transport is crippled during the upgrade process. So just
* leave it at the base transport */
if(Platform.noUpgrade) {
	Defaults.upgradeTransports = [];
}


var BufferUtils = (function() {
	var WordArray = CryptoJS.lib.WordArray;
	var ArrayBuffer = Platform.ArrayBuffer;
	var atob = Platform.atob;

	function isWordArray(ob) { return ob !== null && ob !== undefined && ob.sigBytes !== undefined; }
	function isArrayBuffer(ob) { return ob !== null && ob !== undefined && ob.constructor === ArrayBuffer; }

	// https://gist.githubusercontent.com/jonleighton/958841/raw/f200e30dfe95212c0165ccf1ae000ca51e9de803/gistfile1.js
	function arrayBufferToBase64(ArrayBuffer) {
		var base64    = ''
		var encodings = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'

		var bytes         = new Uint8Array(ArrayBuffer)
		var byteLength    = bytes.byteLength
		var byteRemainder = byteLength % 3
		var mainLength    = byteLength - byteRemainder

		var a, b, c, d
		var chunk

		// Main loop deals with bytes in chunks of 3
		for (var i = 0; i < mainLength; i = i + 3) {
			// Combine the three bytes into a single integer
			chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2]

			// Use bitmasks to extract 6-bit segments from the triplet
			a = (chunk & 16515072) >> 18 // 16515072 = (2^6 - 1) << 18
			b = (chunk & 258048)   >> 12 // 258048   = (2^6 - 1) << 12
			c = (chunk & 4032)     >>  6 // 4032     = (2^6 - 1) << 6
			d = chunk & 63               // 63       = 2^6 - 1

			// Convert the raw binary segments to the appropriate ASCII encoding
			base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d]
		}

		// Deal with the remaining bytes and padding
		if (byteRemainder == 1) {
			chunk = bytes[mainLength]

			a = (chunk & 252) >> 2 // 252 = (2^6 - 1) << 2

			// Set the 4 least significant bits to zero
			b = (chunk & 3)   << 4 // 3   = 2^2 - 1

			base64 += encodings[a] + encodings[b] + '=='
		} else if (byteRemainder == 2) {
			chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1]

			a = (chunk & 64512) >> 10 // 64512 = (2^6 - 1) << 10
			b = (chunk & 1008)  >>  4 // 1008  = (2^6 - 1) << 4

			// Set the 2 least significant bits to zero
			c = (chunk & 15)    <<  2 // 15    = 2^4 - 1

			base64 += encodings[a] + encodings[b] + encodings[c] + '='
		}

		return base64
	}

	function base64ToArrayBuffer(base64) {
		var binary_string =  atob(base64);
		var len = binary_string.length;
		var bytes = new Uint8Array( len );
		for (var i = 0; i < len; i++)        {
			var ascii = binary_string.charCodeAt(i);
			bytes[i] = ascii;
		}
		return bytes.buffer;
	}

	function BufferUtils() {}

	BufferUtils.isBuffer = function(buf) { return isArrayBuffer(buf) || isWordArray(buf); };

	BufferUtils.toArrayBuffer = function(buf) {
		if(!ArrayBuffer)
			throw new Error("Can't convert to ArrayBuffer: ArrayBuffer not supported");

		if(isArrayBuffer(buf))
			return buf;

		if(isWordArray(buf)) {
			/* Backported from unreleased CryptoJS
			* https://code.google.com/p/crypto-js/source/browse/branches/3.x/src/lib-typedarrays.js?r=661 */
			var arrayBuffer = new ArrayBuffer(buf.sigBytes);
			var uint8View = new Uint8Array(arrayBuffer);

			for (var i = 0; i < buf.sigBytes; i++) {
				uint8View[i] = (buf.words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
			}

			return arrayBuffer;
		};

		throw new Error("BufferUtils.toArrayBuffer expected a buffer");
	};

	BufferUtils.toWordArray = function(buf) {
		return isWordArray(buf) ? buf : WordArray.create(buf);
	};

	BufferUtils.base64Encode = function(buf) {
		if(isArrayBuffer(buf))
			return arrayBufferToBase64(buf);
		if(isWordArray(buf))
			return CryptoJS.enc.Base64.stringify(buf);
	};

	BufferUtils.base64Decode = function(str) {
		if(ArrayBuffer && atob)
			return base64ToArrayBuffer(str);
		return CryptoJS.enc.Base64.parse(str);
	};

	BufferUtils.hexEncode = function(buf) {
		if(isArrayBuffer(buf)) buf = WordArray.create(buf);
		return CryptoJS.enc.Hex.stringify(buf);
	};

	BufferUtils.utf8Encode = function(string) {
		return CryptoJS.enc.Utf8.parse(string);
	};

	BufferUtils.utf8Decode = function(buf) {
		if(isArrayBuffer(buf))
			buf = BufferUtils.toWordArray(buf) // CryptoJS only works with WordArrays
		if(isWordArray(buf))
			return CryptoJS.enc.Utf8.stringify(buf);
		throw new Error("Expected input of utf8Decode to be a buffer or CryptoJS WordArray");
	};

	BufferUtils.bufferCompare = function(buf1, buf2) {
		if(!buf1) return -1;
		if(!buf2) return 1;
		buf1 = BufferUtils.toWordArray(buf1);
		buf2 = BufferUtils.toWordArray(buf2);
		buf1.clamp(); buf2.clamp();

		var cmp = buf1.sigBytes - buf2.sigBytes;
		if(cmp != 0) return cmp;
		buf1 = buf1.words; buf2 = buf2.words;
		for(var i = 0; i < buf1.length; i++) {
			cmp = buf1[i] - buf2[i];
			if(cmp != 0) return cmp;
		}
		return 0;
	};

	return BufferUtils;
})();

var Http = (function() {
	var noop = function() {};

	function Http() {}

	function shouldFallback(err) {
		var statusCode = err.statusCode;
		/* 400 + no code = a generic xhr onerror. Browser doesn't give us enough
		 * detail to know whether it's fallback-fixable, but it may be (eg if a
		 * network issue), so try just in case */
		return (statusCode === 408 && !err.code) ||
			(statusCode === 400 && !err.code)      ||
			(statusCode >= 500 && statusCode <= 504);
	}

	/**
	 * Perform an HTTP GET request for a given path against prime and fallback Ably hosts
	 * @param rest
	 * @param path the full path of the POST request
	 * @param headers optional hash of headers
	 * @param params optional hash of params
	 * @param callback (err, response)
	 */
	Http.get = function(rest, path, headers, params, callback) {
		callback = callback || noop;
		var uri = (typeof(path) == 'function') ? path : function(host) { return rest.baseUri(host) + path; };
		var binary = (headers && headers.accept != 'application/json');

		var hosts, connection = rest.connection;
		if(connection && connection.state == 'connected')
			hosts = [connection.connectionManager.host];
		else
			hosts = Defaults.getHosts(rest.options);

		/* if there is only one host do it */
		if(hosts.length == 1) {
			Http.getUri(rest, uri(hosts[0]), headers, params, callback);
			return;
		}

		/* so host is an array with preferred host plus at least one fallback */
		var tryAHost = function(candidateHosts) {
			Http.getUri(rest, uri(candidateHosts.shift()), headers, params, function(err) {
				if(err && shouldFallback(err) && candidateHosts.length) {
					/* use a fallback host if available */
					tryAHost(candidateHosts);
					return;
				}
				callback.apply(null, arguments);
			});
		}
		tryAHost(hosts);
	};

	/**
	 * Perform an HTTP GET request for a given resolved URI
	 * @param rest
	 * @param the full path of the POST request
	 * @param headers optional hash of headers
	 * @param params optional hash of params
	 * @param callback (err, response)
	 */
	Http.getUri = function(rest, uri, headers, params, callback) {
		Http.Request(rest, uri, headers, params, null, callback || noop);
	};

	/**
	 * Perform an HTTP POST request
	 * @param rest
	 * @param the full path of the POST request
	 * @param headers optional hash of headers
	 * @param body object or buffer containing request body
	 * @param params optional hash of params
	 * @param callback (err, response)
	 */
	Http.post = function(rest, path, headers, body, params, callback) {
		callback = callback || noop;
		var uri = (typeof(path) == 'function') ? path : function(host) { return rest.baseUri(host) + path; };
		var binary = (headers && headers.accept != 'application/json');

		var hosts, connection = rest.connection;
		if(connection && connection.state == 'connected')
			hosts = [connection.connectionManager.host];
		else
			hosts = Defaults.getHosts(rest.options);

		/* if there is only one host do it */
		if(hosts.length == 1) {
			Http.postUri(rest, uri(hosts[0]), headers, body, params, callback);
			return;
		}

		/* hosts is an array with preferred host plus at least one fallback */
		var tryAHost = function(candidateHosts) {
			Http.postUri(rest, uri(candidateHosts.shift()), headers, body, params, function(err) {
				if(err && shouldFallback(err) && candidateHosts.length) {
					tryAHost(candidateHosts);
					return;
				}
				callback.apply(null, arguments);
			});
		};
		tryAHost(hosts);
	};

	/**
	 * Perform an HTTP POST request for a given resolved URI
	 * @param rest
	 * @param the full path of the POST request
	 * @param headers optional hash of headers
	 * @param body object or buffer containing request body
	 * @param params optional hash of params
	 * @param callback (err, response)
	 */
	Http.postUri = function(rest, uri, headers, body, params, callback) {
		Http.Request(rest, uri, headers, params, body, callback || noop);
	};

	Http.supportsAuthHeaders = false;
	Http.supportsLinkHeaders = false;
	return Http;
})();

/*
 Copyright (c) 2008 Fred Palmer fred.palmer_at_gmail.com

 Permission is hereby granted, free of charge, to any person
 obtaining a copy of this software and associated documentation
 files (the "Software"), to deal in the Software without
 restriction, including without limitation the rights to use,
 copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the
 Software is furnished to do so, subject to the following
 conditions:

 The above copyright notice and this permission notice shall be
 included in all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 OTHER DEALINGS IN THE SOFTWARE.
 */
var Base64 = (function() {
	function StringBuffer()
	{
		this.buffer = [];
	}

	StringBuffer.prototype.append = function append(string)
	{
		this.buffer.push(string);
		return this;
	};

	StringBuffer.prototype.toString = function toString()
	{
		return this.buffer.join("");
	};

	var Base64 =
	{
		codex : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",

		encode : function (input)
		{
			var output = new StringBuffer();
			var codex = Base64.codex;

			var enumerator = new Utf8EncodeEnumerator(input);
			while (enumerator.moveNext())
			{
				var chr1 = enumerator.current;

				enumerator.moveNext();
				var chr2 = enumerator.current;

				enumerator.moveNext();
				var chr3 = enumerator.current;

				var enc1 = chr1 >> 2;
				var enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
				var enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
				var enc4 = chr3 & 63;

				if (isNaN(chr2))
				{
					enc3 = enc4 = 64;
				}
				else if (isNaN(chr3))
				{
					enc4 = 64;
				}

				output.append(codex.charAt(enc1) + codex.charAt(enc2) + codex.charAt(enc3) + codex.charAt(enc4));
			}

			return output.toString();
		},

		decode : function (input)
		{
			var output = new StringBuffer();

			var enumerator = new Base64DecodeEnumerator(input);
			while (enumerator.moveNext())
			{
				var charCode = enumerator.current;

				if (charCode < 128)
					output.append(String.fromCharCode(charCode));
				else if ((charCode > 191) && (charCode < 224))
				{
					enumerator.moveNext();
					var charCode2 = enumerator.current;

					output.append(String.fromCharCode(((charCode & 31) << 6) | (charCode2 & 63)));
				}
				else
				{
					enumerator.moveNext();
					var charCode2 = enumerator.current;

					enumerator.moveNext();
					var charCode3 = enumerator.current;

					output.append(String.fromCharCode(((charCode & 15) << 12) | ((charCode2 & 63) << 6) | (charCode3 & 63)));
				}
			}

			return output.toString();
		}
	};

	function Utf8EncodeEnumerator(input)
	{
		this._input = input;
		this._index = -1;
		this._buffer = [];
	}

	Utf8EncodeEnumerator.prototype =
	{
		current: Number.NaN,

		moveNext: function()
		{
			if (this._buffer.length > 0)
			{
				this.current = this._buffer.shift();
				return true;
			}
			else if (this._index >= (this._input.length - 1))
			{
				this.current = Number.NaN;
				return false;
			}
			else
			{
				var charCode = this._input.charCodeAt(++this._index);

				// "\r\n" -> "\n"
				//
				if ((charCode == 13) && (this._input.charCodeAt(this._index + 1) == 10))
				{
					charCode = 10;
					this._index += 2;
				}

				if (charCode < 128)
				{
					this.current = charCode;
				}
				else if ((charCode > 127) && (charCode < 2048))
				{
					this.current = (charCode >> 6) | 192;
					this._buffer.push((charCode & 63) | 128);
				}
				else
				{
					this.current = (charCode >> 12) | 224;
					this._buffer.push(((charCode >> 6) & 63) | 128);
					this._buffer.push((charCode & 63) | 128);
				}

				return true;
			}
		}
	};

	function Base64DecodeEnumerator(input)
	{
		this._input = input;
		this._index = -1;
		this._buffer = [];
	}

	Base64DecodeEnumerator.prototype =
	{
		current: 64,

		moveNext: function()
		{
			if (this._buffer.length > 0)
			{
				this.current = this._buffer.shift();
				return true;
			}
			else if (this._index >= (this._input.length - 1))
			{
				this.current = 64;
				return false;
			}
			else
			{
				var enc1 = Base64.codex.indexOf(this._input.charAt(++this._index));
				var enc2 = Base64.codex.indexOf(this._input.charAt(++this._index));
				var enc3 = Base64.codex.indexOf(this._input.charAt(++this._index));
				var enc4 = Base64.codex.indexOf(this._input.charAt(++this._index));

				var chr1 = (enc1 << 2) | (enc2 >> 4);
				var chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
				var chr3 = ((enc3 & 3) << 6) | enc4;

				this.current = chr1;

				if (enc3 != 64)
					this._buffer.push(chr2);

				if (enc4 != 64)
					this._buffer.push(chr3);

				return true;
			}
		}
	};

	return Base64;
})();

Defaults.protocolVersion          = 1;
Defaults.ENVIRONMENT              = '';
Defaults.REST_HOST                = 'rest.ably.io';
Defaults.REALTIME_HOST            = 'realtime.ably.io';
Defaults.FALLBACK_HOSTS           = ['A.ably-realtime.com', 'B.ably-realtime.com', 'C.ably-realtime.com', 'D.ably-realtime.com', 'E.ably-realtime.com'];
Defaults.PORT                     = 80;
Defaults.TLS_PORT                 = 443;
Defaults.TIMEOUTS = {
	/* Documented as options params: */
	disconnectedRetryTimeout   : 15000,
	suspendedRetryTimeout      : 30000,
	httpRequestTimeout         : 15000,
	channelRetryTimeout        : 15000,
	/* Not documented: */
	connectionStateTtl         : 120000,
	realtimeRequestTimeout     : 10000,
	recvTimeout                : 90000,
	preferenceConnectTimeout   : 6000,
	parallelUpgradeDelay       : 4000
};
Defaults.httpMaxRetryCount = 3;

Defaults.version          = '1.0.3';
Defaults.libstring        = Platform.libver + Defaults.version;
Defaults.apiVersion       = '1.0';

Defaults.getHost = function(options, host, ws) {
	if(ws)
		host = ((host == options.restHost) && options.realtimeHost) || host || options.realtimeHost;
	else
		host = host || options.restHost;

	return host;
};

Defaults.getPort = function(options, tls) {
	return (tls || options.tls) ? options.tlsPort : options.port;
};

Defaults.getHttpScheme = function(options) {
	return options.tls ? 'https://' : 'http://';
};

Defaults.getHosts = function(options) {
	var hosts = [options.restHost],
		fallbackHosts = options.fallbackHosts,
		httpMaxRetryCount = typeof(options.httpMaxRetryCount) !== 'undefined' ? options.httpMaxRetryCount : Defaults.httpMaxRetryCount;

	if(fallbackHosts) {
		hosts = hosts.concat(Utils.arrChooseN(fallbackHosts, httpMaxRetryCount));
	}
	return hosts;
};

Defaults.normaliseOptions = function(options) {
	/* Deprecated options */
	if(options.host) {
		Logger.deprecated('host', 'restHost');
		options.restHost = options.host;
	}
	if(options.wsHost) {
		Logger.deprecated('wsHost', 'realtimeHost');
		options.realtimeHost = options.wsHost;
	}
	if(options.queueEvents) {
		Logger.deprecated('queueEvents', 'queueMessages');
		options.queueMessages = options.queueEvents;
	}

	if(options.recover === true) {
		Logger.deprecated('{recover: true}', '{recover: function(lastConnectionDetails, cb) { cb(true); }}');
		options.recover = function(lastConnectionDetails, cb) { cb(true); };
	}

	if(typeof options.recover === 'function' && options.closeOnUnload === true) {
		Logger.logAction(LOG_ERROR, 'Defaults.normaliseOptions', 'closeOnUnload was true and a session recovery function was set - these are mutually exclusive, so unsetting the latter');
		options.recover = null;
	}

	if(options.transports && Utils.arrIn(options.transports, 'xhr')) {
		Logger.deprecated('transports: ["xhr"]', 'transports: ["xhr_streaming"]');
		Utils.arrDeleteValue(options.transports, 'xhr');
		options.transports.push('xhr_streaming');
	}

	if(!('queueMessages' in options))
		options.queueMessages = true;

	var production = false;
	if(options.restHost) {
		options.realtimeHost = options.realtimeHost || options.restHost;
	} else {
		var environment = (options.environment && String(options.environment).toLowerCase()) || Defaults.ENVIRONMENT;
		production = !environment || (environment === 'production');
		options.restHost = production ? Defaults.REST_HOST : environment + '-' + Defaults.REST_HOST;
		options.realtimeHost = production ? Defaults.REALTIME_HOST : environment + '-' + Defaults.REALTIME_HOST;
	}
	options.fallbackHosts = (production || options.fallbackHostsUseDefault) ? Defaults.FALLBACK_HOSTS : options.fallbackHosts;
	options.port = options.port || Defaults.PORT;
	options.tlsPort = options.tlsPort || Defaults.TLS_PORT;
	if(!('tls' in options)) options.tls = true;

	/* Allow values passed in options to override default timeouts */
	options.timeouts = {};
	for(var prop in Defaults.TIMEOUTS) {
		options.timeouts[prop] = options[prop] || Defaults.TIMEOUTS[prop];
	};

	if('useBinaryProtocol' in options) {
		options.useBinaryProtocol = Platform.supportsBinary && options.useBinaryProtocol;
	} else {
		options.useBinaryProtocol = Platform.preferBinary;
	}

	return options;
};

var EventEmitter = (function() {

	/* public constructor */
	function EventEmitter() {
		this.any = [];
		this.events = {};
		this.anyOnce = [];
		this.eventsOnce = {};
	}

	/* Call the listener, catch any exceptions and log, but continue operation*/
	function callListener(eventThis, listener, args) {
		try {
			listener.apply(eventThis, args);
		} catch(e) {
			Logger.logAction(Logger.LOG_ERROR, 'EventEmitter.emit()', 'Unexpected listener exception: ' + e + '; stack = ' + e.stack);
		}
	}

	/**
	 * Remove listeners that match listener
	 * @param targetListeners is an array of listener arrays or event objects with arrays of listeners
	 * @param listener the listener callback to remove
	 * @param eventFilter (optional) event name instructing the function to only remove listeners for the specified event
	 */
	function removeListener(targetListeners, listener, eventFilter) {
		var listeners, idx, eventName, targetListenersIndex;

		for (targetListenersIndex = 0; targetListenersIndex < targetListeners.length; targetListenersIndex++) {
			listeners = targetListeners[targetListenersIndex];
			if (eventFilter) { listeners = listeners[eventFilter]; }

			if (Utils.isArray(listeners)) {
				while ((idx = Utils.arrIndexOf(listeners, listener)) !== -1) {
					listeners.splice(idx, 1);
				}
				/* If events object has an event name key with no listeners then
				   remove the key to stop the list growing indefinitely */
				if (eventFilter && (listeners.length === 0)) {
					delete targetListeners[targetListenersIndex][eventFilter];
				}
			} else if (Utils.isObject(listeners)) {
				/* events */
				for (eventName in listeners) {
					if (listeners.hasOwnProperty(eventName) && Utils.isArray(listeners[eventName])) {
						removeListener([listeners], listener, eventName);
					}
				}
			}
		}
	}

	/**
	 * Add an event listener
	 * @param event (optional) the name of the event to listen to
	 *        if not supplied, all events trigger a call to the listener
	 * @param listener the listener to be called
	 */
	EventEmitter.prototype.on = function(event, listener) {
		if(arguments.length == 1 && typeof(event) == 'function') {
			this.any.push(event);
		} else if(Utils.isEmptyArg(event)) {
			this.any.push(listener);
		} else if(Utils.isArray(event)) {
			var self = this;
			Utils.arrForEach(event, function(ev) {
				self.on(ev, listener);
			});
		} else {
			var listeners = (this.events[event] || (this.events[event] = []));
			listeners.push(listener);
		}
	};

	/**
	 * Remove one or more event listeners
	 * @param event (optional) the name of the event whose listener
	 *        is to be removed. If not supplied, the listener is
	 *        treated as an 'any' listener
	 * @param listener (optional) the listener to remove. If not
	 *        supplied, all listeners are removed.
	 */
	EventEmitter.prototype.off = function(event, listener) {
		if(arguments.length == 0 || (Utils.isEmptyArg(event) && Utils.isEmptyArg(listener))) {
			this.any = [];
			this.events = {};
			this.anyOnce = [];
			this.eventsOnce = {};
			return;
		}
		if(arguments.length == 1) {
			if(typeof(event) == 'function') {
				/* we take this to be the listener and treat the event as "any" .. */
				listener = event;
				event = null;
			}
			/* ... or we take event to be the actual event name and listener to be all */
		}

		if(listener && Utils.isEmptyArg(event)) {
			removeListener([this.any, this.events, this.anyOnce, this.eventsOnce], listener);
			return;
		}

		if(Utils.isArray(event)) {
			var self = this;
			Utils.arrForEach(event, function(ev) {
				self.off(ev, listener);
			});
		}

		/* "normal" case where event is an actual event */
		if(listener) {
			removeListener([this.events, this.eventsOnce], listener, event);
		} else {
			delete this.events[event];
			delete this.eventsOnce[event];
		}
	};

	/**
	 * Get the array of listeners for a given event; excludes once events
	 * @param event (optional) the name of the event, or none for 'any'
	 * @return array of events, or null if none
	 */
	EventEmitter.prototype.listeners = function(event) {
		if(event) {
			var listeners = (this.events[event] || []);
			if(this.eventsOnce[event])
				Array.prototype.push.apply(listeners, this.eventsOnce[event]);
			return listeners.length ? listeners : null;
		}
		return this.any.length ? this.any : null;
	};

	/**
	 * Emit an event
	 * @param event the event name
	 * @param args the arguments to pass to the listener
	 */
	EventEmitter.prototype.emit = function(event  /* , args... */) {
		var args = Array.prototype.slice.call(arguments, 1);
		var eventThis = {event:event};
		var listeners = [];

		if(this.anyOnce.length) {
			Array.prototype.push.apply(listeners, this.anyOnce);
			this.anyOnce = [];
		}
		if(this.any.length) {
			Array.prototype.push.apply(listeners, this.any);
		}
		var eventsOnceListeners = this.eventsOnce[event];
		if(eventsOnceListeners) {
			Array.prototype.push.apply(listeners, eventsOnceListeners);
			delete this.eventsOnce[event];
		}
		var eventsListeners = this.events[event];
		if(eventsListeners) {
			Array.prototype.push.apply(listeners, eventsListeners);
		}

		Utils.arrForEach(listeners, function(listener) {
			callListener(eventThis, listener, args);
		});
	};

	/**
	 * Listen for a single occurrence of an event
	 * @param event the name of the event to listen to
	 * @param listener the listener to be called
	 */
	EventEmitter.prototype.once = function(event, listener) {
		if(arguments.length == 1 && typeof(event) == 'function') {
			this.anyOnce.push(event);
		} else if(Utils.isEmptyArg(event)) {
			this.anyOnce.push(listener);
		} else if(Utils.isArray(event)){
			throw("Arrays of events can only be used with on(), not once()");
		} else {
			var listeners = (this.eventsOnce[event] || (this.eventsOnce[event] = []));
			listeners.push(listener);
		}
	};

	/**
	 * Private API
	 *
	 * Listen for a single occurrence of a state event and fire immediately if currentState matches targetState
	 * @param targetState the name of the state event to listen to
	 * @param currentState the name of the current state of this object
	 * @param listener the listener to be called
	 */
	EventEmitter.prototype.whenState = function(targetState, currentState, listener /* ...listenerArgs */) {
		var eventThis = {event:targetState},
				listenerArgs = Array.prototype.slice.call(arguments, 3);

		if((typeof(targetState) !== 'string') || (typeof(currentState) !== 'string'))
			throw("whenState requires a valid event String argument");
		if (typeof(listener) !== 'function')
			throw("whenState requires a valid listener argument");

		if(targetState === currentState) {
			callListener(eventThis, listener, listenerArgs);
		} else {
			this.once(targetState, listener);
		}
	}

	return EventEmitter;
})();

var Logger = (function() {
	var consoleLogger;

	/* Can't just check for console && console.log; fails in IE <=9 */
	if((typeof window === 'undefined') /* node */ ||
		 (window.console && window.console.log && (typeof window.console.log.apply === 'function')) /* sensible browsers */) {
		consoleLogger = function() { console.log.apply(console, arguments); };
	} else if(window.console && window.console.log) {
		/* IE <= 9 with the console open -- console.log does not
		 * inherit from Function, so has no apply method */
		consoleLogger = function() { Function.prototype.apply.call(console.log, console, arguments); };
	} else {
		/* IE <= 9 when dev tools are closed - window.console not even defined */
		consoleLogger = function() {};
	}

	var LOG_NONE  = 0,
	LOG_ERROR = 1,
	LOG_MAJOR = 2,
	LOG_MINOR = 3,
	LOG_MICRO = 4;

	var LOG_DEFAULT = LOG_ERROR,
	LOG_DEBUG   = LOG_MICRO;

	var logLevel = LOG_DEFAULT;
	var logHandler = consoleLogger;

	/* public constructor */
	function Logger(args) {}

	/* public constants */
	Logger.LOG_NONE    = LOG_NONE,
	Logger.LOG_ERROR   = LOG_ERROR,
	Logger.LOG_MAJOR   = LOG_MAJOR,
	Logger.LOG_MINOR   = LOG_MINOR,
	Logger.LOG_MICRO   = LOG_MICRO;

	Logger.LOG_DEFAULT = LOG_DEFAULT,
	Logger.LOG_DEBUG   = LOG_DEBUG;

	/* public static functions */
	Logger.logAction = function(level, action, message) {
		if (Logger.shouldLog(level)) {
			logHandler('Ably: ' + action + ': ' + message);
		}
	};

	Logger.deprecated = function(original, replacement) {
		if (Logger.shouldLog(LOG_ERROR)) {
			logHandler("Ably: Deprecation warning - '" + original + "' is deprecated and will be removed from a future version. Please use '" + replacement + "' instead.");
		}
	}

	/* Where a logging operation is expensive, such as serialisation of data, use shouldLog will prevent
	   the object being serialised if the log level will not output the message */
	Logger.shouldLog = function(level) {
		return level <= logLevel;
	};

	Logger.setLog = function(level, handler) {
		if(level !== undefined) logLevel = level;
		if(handler !== undefined) logHandler = handler;
	};

	return Logger;
})();

var Utils = (function() {
	function Utils() {}

	/*
	 * Add a set of properties to a target object
	 * target: the target object
	 * props:  an object whose enumerable properties are
	 *         added, by reference only
	 */
	Utils.mixin = function(target, src) {
		if(src) {
			var hasOwnProperty = src.hasOwnProperty;
			for(var key in src) {
				if(!hasOwnProperty || hasOwnProperty.call(src, key)) {
					target[key] = src[key];
				}
			}
		}
		return target;
	};

	/*
	 * Add a set of properties to a target object
	 * target: the target object
	 * props:  an object whose enumerable properties are
	 *         added, by reference only
	 */
	Utils.copy = function(src) {
		return Utils.mixin({}, src);
	};

	/*
	 * Determine whether or not a given object is
	 * an array.
	 */
	Utils.isArray = Array.isArray || function(ob) {
		return Object.prototype.toString.call(ob) == '[object Array]';
	};

	/*
	 * Ensures that an Array object is always returned
	 * returning the original Array of obj is an Array
	 * else wrapping the obj in a single element Array
	 */
	Utils.ensureArray = function(obj) {
		if(Utils.isEmptyArg(obj)) {
			return [];
		}
		if(Utils.isArray(obj)) {
			return obj;
		}
		return [obj];
	}

	/* ...Or an Object (in the narrow sense) */
	Utils.isObject = function(ob) {
		return Object.prototype.toString.call(ob) == '[object Object]';
	};

	/*
	 * Determine whether or not an object contains
	 * any enumerable properties.
	 * ob: the object
	 */
	Utils.isEmpty = function(ob) {
		for(var prop in ob)
			return false;
		return true;
	};

	Utils.isOnlyPropIn = function(ob, property) {
		for(var prop in ob) {
			if(prop !== property) {
				return false;
			}
		}
		return true;
	};

	/*
	 * Determine whether or not an argument to an overloaded function is
	 * undefined (missing) or null.
	 * This method is useful when constructing functions such as (WebIDL terminology):
	 *   off([TreatUndefinedAs=Null] DOMString? event)
	 * as you can then confirm the argument using:
	 *   Utils.isEmptyArg(event)
	 */

	Utils.isEmptyArg = function(arg) {
		return arg === null || arg === undefined;
	}

	/*
	 * Perform a simple shallow clone of an object.
	 * Result is an object irrespective of whether
	 * the input is an object or array. All
	 * enumerable properties are copied.
	 * ob: the object
	 */
	Utils.shallowClone = function(ob) {
		var result = new Object();
		for(var prop in ob)
			result[prop] = ob[prop];
		return result;
	};

	/*
	 * Clone an object by creating a new object with the
	 * given object as its prototype. Optionally
	 * a set of additional own properties can be
	 * supplied to be added to the newly created clone.
	 * ob:            the object to be cloned
	 * ownProperties: optional object with additional
	 *                properties to add
	 */
	Utils.prototypicalClone = function(ob, ownProperties) {
		function F() {}
		F.prototype = ob;
		var result = new F();
		if(ownProperties)
			Utils.mixin(result, ownProperties);
		return result;
	};

	/*
	 * Declare a constructor to represent a subclass
	 * of another constructor
	 * If platform has a built-in version we use that from Platform, else we
	 * define here (so can make use of other Utils fns)
	 * See node.js util.inherits
	 */
	Utils.inherits = Platform.inherits || function(ctor, superCtor) {
		ctor.super_ = superCtor;
		ctor.prototype = Utils.prototypicalClone(superCtor.prototype, { constructor: ctor });
	};

	/*
	 * Determine whether or not an object has an enumerable
	 * property whose value equals a given value.
	 * ob:  the object
	 * val: the value to find
	 */
	Utils.containsValue = function(ob, val) {
		for(var i in ob) {
			if(ob[i] == val)
				return true;
		}
		return false;
	};

	Utils.intersect = function(arr, ob) { return Utils.isArray(ob) ? Utils.arrIntersect(arr, ob) : Utils.arrIntersectOb(arr, ob); };

	Utils.arrIntersect = function(arr1, arr2) {
		var result = [];
		for(var i = 0; i < arr1.length; i++) {
			var member = arr1[i];
			if(Utils.arrIndexOf(arr2, member) != -1)
				result.push(member);
		}
		return result;
	};

	Utils.arrIntersectOb = function(arr, ob) {
		var result = [];
		for(var i = 0; i < arr.length; i++) {
			var member = arr[i];
			if(member in ob)
				result.push(member);
		}
		return result;
	};

	Utils.arrSubtract = function(arr1, arr2) {
		var result = [];
		for(var i = 0; i < arr1.length; i++) {
			var element = arr1[i];
			if(Utils.arrIndexOf(arr2, element) == -1)
				result.push(element);
		}
		return result;
	};

	Utils.arrIndexOf = Array.prototype.indexOf
		? function(arr, elem, fromIndex) {
			return arr.indexOf(elem,  fromIndex);
		}
		: function(arr, elem, fromIndex) {
			fromIndex = fromIndex || 0;
			var len = arr.length;
			for(;fromIndex < len; fromIndex++) {
				if(arr[fromIndex] === elem) {
					return fromIndex;
				}
			}
			return -1;
		};

	Utils.arrIn = function(arr, val) {
		return Utils.arrIndexOf(arr, val) !== -1;
	};

	Utils.arrDeleteValue = function(arr, val) {
		var idx = Utils.arrIndexOf(arr, val);
		var res = (idx != -1);
		if(res)
			arr.splice(idx, 1);
		return res;
	};

	Utils.arrWithoutValue = function(arr, val) {
		var newArr = arr.slice();
		Utils.arrDeleteValue(newArr, val);
		return newArr;
	};

	/*
	 * Construct an array of the keys of the enumerable
	 * properties of a given object, optionally limited
	 * to only the own properties.
	 * ob:      the object
	 * ownOnly: boolean, get own properties only
	 */
	Utils.keysArray = function(ob, ownOnly) {
		var result = [];
		for(var prop in ob) {
			if(ownOnly && !ob.hasOwnProperty(prop)) continue;
			result.push(prop);
		}
		return result;
	};

	/*
	 * Construct an array of the values of the enumerable
	 * properties of a given object, optionally limited
	 * to only the own properties.
	 * ob:      the object
	 * ownOnly: boolean, get own properties only
	 */
	Utils.valuesArray = function(ob, ownOnly) {
		var result = [];
		for(var prop in ob) {
			if(ownOnly && !ob.hasOwnProperty(prop)) continue;
			result.push(ob[prop]);
		}
		return result;
	};

	Utils.arrForEach = Array.prototype.forEach ?
		function(arr, fn) {
			arr.forEach(fn);
		} :
		function(arr, fn) {
			var len = arr.length;
			for(var i = 0; i < len; i++) {
				fn(arr[i], i, arr);
			}
		};

	/* Useful when the function may mutate the array */
	Utils.safeArrForEach = function(arr, fn) {
		return Utils.arrForEach(arr.slice(), fn);
	};

	Utils.arrMap = Array.prototype.map ?
		function(arr, fn) {
			return arr.map(fn);
		} :
		function(arr, fn)	{
			var result = [],
				len = arr.length;
			for(var i = 0; i < len; i++) {
				result.push(fn(arr[i], i, arr));
			}
			return result;
		};

	Utils.arrFilter = Array.prototype.filter ?
		function(arr, fn) {
			return arr.filter(fn);
		} :
		function(arr, fn)	{
			var result = [],
				len = arr.length;
			for(var i = 0; i < len; i++) {
				if(fn(arr[i])) {
					result.push(arr[i]);
				}
			}
			return result;
		};

	Utils.arrEvery = Array.prototype.every ?
		function(arr, fn) {
			return arr.every(fn);
		} : function(arr, fn) {
			var len = arr.length;
			for(var i = 0; i < len; i++) {
				if(!fn(arr[i], i, arr)) {
					return false;
				};
			}
			return true;
		};

	Utils.nextTick = Platform.nextTick;

	var contentTypes = {
		json:   'application/json',
		jsonp:  'application/javascript',
		xml:    'application/xml',
		html:   'text/html',
		msgpack: 'application/x-msgpack'
	};

	Utils.defaultGetHeaders = function(format) {
		format = format || 'json';
		var accept = (format === 'json') ? contentTypes.json : contentTypes[format] + ',' + contentTypes.json;
		return {
			accept: accept,
			'X-Ably-Version': Defaults.apiVersion,
			'X-Ably-Lib': Defaults.libstring
		};
	};

	Utils.defaultPostHeaders = function(format) {
		format = format || 'json';
		var accept = (format === 'json') ? contentTypes.json : contentTypes[format] + ',' + contentTypes.json,
			contentType = (format === 'json') ? contentTypes.json : contentTypes[format];

		return {
			accept: accept,
			'content-type': contentType,
			'X-Ably-Version': Defaults.apiVersion,
			'X-Ably-Lib': Defaults.libstring
		};
	};

	Utils.arrPopRandomElement = function(arr) {
		return arr.splice(Math.floor(Math.random() * arr.length), 1)[0];
	};

	Utils.toQueryString = function(params) {
		var parts = [];
		if(params) {
			for(var key in params)
				parts.push(encodeURIComponent(key) + '=' + encodeURIComponent(params[key]));
		}
		return parts.length ? '?' + parts.join('&') : '';
	};

	Utils.parseQueryString = function(query) {
		var match,
			search = /([^?&=]+)=?([^&]*)/g,
			result = {};

		while (match = search.exec(query))
			result[decodeURIComponent(match[1])] = decodeURIComponent(match[2]);

 		return result;
	};

	Utils.now = Date.now || function() {
		/* IE 8 */
		return new Date().getTime();
	};

	Utils.inspect = Platform.inspect;

	Utils.inspectError = function(x) {
		return (x && (x.constructor.name == 'ErrorInfo' || x.constructor.name == 'Error')) ?
			x.toString() :
			Utils.inspect(x);
	};

	Utils.randStr = function() {
		return String(Math.random()).substr(2);
	};

	/* Pick n elements at random without replacement from an array */
	Utils.arrChooseN = function(arr, n) {
		var numItems = Math.min(n, arr.length),
			mutableArr = arr.slice(),
			result = [];
		for(var i = 0; i < numItems; i++) {
			result.push(Utils.arrPopRandomElement(mutableArr));
		}
		return result;
	};

	Utils.trim = String.prototype.trim ? function(str) {
		return str.trim();
	} : function(str) {
		return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
	};

	return Utils;
})();

var Multicaster = (function() {

	function Multicaster(members) {
		members = members || [];

		var handler = function() {
			for(var i = 0; i < members.length; i++) {
				var member = members[i];
				if(member) {
					try {
						member.apply(null, arguments);
					} catch(e){
						Logger.logAction(Logger.LOG_ERROR, 'Multicaster multiple callback handler', 'Unexpected exception: ' + e + '; stack = ' + e.stack);
					}
				}
			}
		};

		handler.push = function() {
			Array.prototype.push.apply(members, arguments);
		};
		return handler;
	}

	return Multicaster;
})();

var ErrorInfo = (function() {

	function ErrorInfo(message, code, statusCode) {
		this.message = message;
		this.code = code;
		this.statusCode = statusCode;
	}

	ErrorInfo.prototype.toString = function() {
		var result = '[' + this.constructor.name;
		if(this.message) result += ': ' + this.message;
		if(this.statusCode) result += '; statusCode=' + this.statusCode;
		if(this.code) result += '; code=' + this.code;
		result += ']';
		return result;
	};

	ErrorInfo.fromValues = function(values) {
		var result = Utils.mixin(new ErrorInfo(), values);
		if (values instanceof Error) {
			/* Error.message is not enumerable, so mixin loses the message */
			result.message = values.message;
		}
		return result;
	};

	return ErrorInfo;
})();

var Message = (function() {
	var msgpack = Platform.msgpack;

	function Message() {
		this.name = undefined;
		this.id = undefined;
		this.timestamp = undefined;
		this.clientId = undefined;
		this.connectionId = undefined;
		this.connectionKey = undefined;
		this.data = undefined;
		this.encoding = undefined;
		this.extras = undefined;
	}

	/**
	 * Overload toJSON() to intercept JSON.stringify()
	 * @return {*}
	 */
	Message.prototype.toJSON = function() {
		var result = {
			name: this.name,
			clientId: this.clientId,
			connectionId: this.connectionId,
			connectionKey: this.connectionKey,
			encoding: this.encoding,
			extras: this.extras
		};

		/* encode data to base64 if present and we're returning real JSON;
		 * although msgpack calls toJSON(), we know it is a stringify()
		 * call if it has a non-empty arguments list */
		var data = this.data;
		if(data && BufferUtils.isBuffer(data)) {
			if(arguments.length > 0) {
				/* stringify call */
				var encoding = this.encoding;
				result.encoding = encoding ? (encoding + '/base64') : 'base64';
				data = BufferUtils.base64Encode(data);
			} else {
				/* Called by msgpack. Need to feed it an ArrayBuffer, msgpack doesn't
				* understand WordArrays */
				data = BufferUtils.toArrayBuffer(data);
			}
		}
		result.data = data;
		return result;
	};

	Message.prototype.toString = function() {
		var result = '[Message';
		if(this.name)
			result += '; name=' + this.name;
		if(this.id)
			result += '; id=' + this.id;
		if(this.timestamp)
			result += '; timestamp=' + this.timestamp;
		if(this.clientId)
			result += '; clientId=' + this.clientId;
		if(this.connectionId)
			result += '; connectionId=' + this.connectionId;
		if(this.encoding)
			result += '; encoding=' + this.encoding;
		if(this.extras)
			result += '; extras =' + JSON.stringify(this.extras);
		if(this.data) {
			if (typeof(data) == 'string')
				result += '; data=' + this.data;
			else if (BufferUtils.isBuffer(this.data))
				result += '; data (buffer)=' + BufferUtils.base64Encode(this.data);
			else
				result += '; data (json)=' + JSON.stringify(this.data);
		}
		result += ']';
		return result;
	};

	Message.encrypt = function(msg, options, callback) {
		var data = msg.data,
			encoding = msg.encoding,
			cipher = options.channelCipher;

		encoding = encoding ? (encoding + '/') : '';
		if(!BufferUtils.isBuffer(data)) {
			data = BufferUtils.utf8Encode(String(data));
			encoding = encoding + 'utf-8/';
		}
		cipher.encrypt(data, function(err, data) {
			if (err) {
				callback(err);
				return;
			}
			msg.data = data;
			msg.encoding = encoding + 'cipher+' + cipher.algorithm;
			callback(null, msg);
		});
	};

	Message.encode = function(msg, options, callback) {
		var data = msg.data, encoding,
			nativeDataType = typeof(data) == 'string' || BufferUtils.isBuffer(data) || data === null || data === undefined;

		if (!nativeDataType) {
			if (Utils.isObject(data) || Utils.isArray(data)) {
				msg.data = JSON.stringify(data);
				msg.encoding = (encoding = msg.encoding) ? (encoding + '/json') : 'json';
			} else {
				throw new ErrorInfo('Data type is unsupported', 40013, 400);
			}
		}

		if(options != null && options.cipher) {
			Message.encrypt(msg, options, callback);
		} else {
			callback(null, msg);
		}
	};

	Message.encodeArray = function(messages, options, callback) {
		var processed = 0;
		for (var i = 0; i < messages.length; i++) {
			Message.encode(messages[i], options, function(err, msg) {
				if (err) {
					callback(err);
					return;
				}
				processed++;
				if (processed == messages.length) {
					callback(null, messages);
				}
			});
		}
	};

	Message.toRequestBody = function(messages, options, format, callback) {
		Message.encodeArray(messages, options, function(err) {
			if (err) {
				callback(err);
				return;
			}
			callback(null, (format == 'msgpack') ? msgpack.encode(messages, true): JSON.stringify(messages));
		});
	};

	Message.decode = function(message, options) {
		var encoding = message.encoding;
		if(encoding) {
			var xforms = encoding.split('/'),
				i, j = xforms.length,
				data = message.data;

			try {
				while((i = j) > 0) {
					var match = xforms[--j].match(/([\-\w]+)(\+([\w\-]+))?/);
					if(!match) break;
					var xform = match[1];
					switch(xform) {
						case 'base64':
							data = BufferUtils.base64Decode(String(data));
							continue;
						case 'utf-8':
							data = BufferUtils.utf8Decode(data);
							continue;
						case 'json':
							data = JSON.parse(data);
							continue;
						case 'cipher':
							if(options != null && options.cipher) {
								var xformAlgorithm = match[3], cipher = options.channelCipher;
								/* don't attempt to decrypt unless the cipher params are compatible */
								if(xformAlgorithm != cipher.algorithm) {
									throw new Error('Unable to decrypt message with given cipher; incompatible cipher params');
								}
								data = cipher.decrypt(data);
								continue;
							} else {
								throw new Error('Unable to decrypt message; not an encrypted channel');
							}
						default:
							throw new Error("Unknown encoding");
					}
					break;
				}
			} catch(e) {
				throw new ErrorInfo('Error processing the ' + xform + ' encoding, decoder returned ‘' + e.message + '’', 40013, 400);
			} finally {
				message.encoding = (i <= 0) ? null : xforms.slice(0, i).join('/');
				message.data = data;
			}
		}
	};

	Message.fromResponseBody = function(body, options, format) {
		if(format)
			body = (format == 'msgpack') ? msgpack.decode(body) : JSON.parse(String(body));

		for(var i = 0; i < body.length; i++) {
			var msg = body[i] = Message.fromValues(body[i]);
			try {
				Message.decode(msg, options);
			} catch (e) {
				Logger.logAction(Logger.LOG_ERROR, 'Message.fromResponseBody()', e.toString());
			}
		}
		return body;
	};

	Message.fromValues = function(values) {
		return Utils.mixin(new Message(), values);
	};

	Message.fromValuesArray = function(values) {
		var count = values.length, result = new Array(count);
		for(var i = 0; i < count; i++) result[i] = Message.fromValues(values[i]);
		return result;
	};

	Message.fromEncoded = function(encoded, options) {
		var msg = Message.fromValues(encoded);
		/* if decoding fails at any point, catch and return the message decoded to
		 * the fullest extent possible */
		try {
			Message.decode(msg, options);
		} catch(e) {
			Logger.logAction(Logger.LOG_ERROR, 'Message.fromEncoded()', e.toString());
		}
		return msg;
	};

	Message.fromEncodedArray = function(encodedArray, options) {
		return Utils.arrMap(encodedArray, function(encoded) {
			return Message.fromEncoded(encoded, options);
		});
	};

	return Message;
})();

var PresenceMessage = (function() {
	var msgpack = Platform.msgpack;

	function toActionValue(actionString) {
		return Utils.arrIndexOf(PresenceMessage.Actions, actionString)
	}

	function PresenceMessage() {
		this.action = undefined;
		this.id = undefined;
		this.timestamp = undefined;
		this.clientId = undefined;
		this.connectionId = undefined;
		this.data = undefined;
		this.encoding = undefined;
	}

	PresenceMessage.Actions = [
		'absent',
		'present',
		'enter',
		'leave',
		'update'
	];

	/* Returns whether this presenceMessage is synthesized, i.e. was not actually
	 * sent by the connection (usually means a leave event sent 15s after a
	 * disconnection). This is useful because synthesized messages cannot be
	 * compared for newness by id lexicographically - RTP2b1
	 */
	PresenceMessage.prototype.isSynthesized = function() {
		return this.id.substring(this.connectionId.length, 0) !== this.connectionId;
	};

	/* RTP2b2 */
	PresenceMessage.prototype.parseId = function() {
		var parts = this.id.split(':');
		return {
			connectionId: parts[0],
			msgSerial: parseInt(parts[1], 10),
			index: parseInt(parts[2], 10)
		};
	};

	/**
	 * Overload toJSON() to intercept JSON.stringify()
	 * @return {*}
	 */
	PresenceMessage.prototype.toJSON = function() {
		var result = {
			clientId: this.clientId,
			/* Convert presence action back to an int for sending to Ably */
			action: toActionValue(this.action),
			encoding: this.encoding
		};

		/* encode data to base64 if present and we're returning real JSON;
		 * although msgpack calls toJSON(), we know it is a stringify()
		 * call if it has a non-empty arguments list */
		var data = this.data;
		if(data && BufferUtils.isBuffer(data)) {
			if(arguments.length > 0) {
				/* stringify call */
				var encoding = this.encoding;
				result.encoding = encoding ? (encoding + '/base64') : 'base64';
				data = BufferUtils.base64Encode(data);
			} else {
				/* Called by msgpack. Need to feed it an ArrayBuffer, msgpack doesn't
				* understand WordArrays */
				data = BufferUtils.toArrayBuffer(data);
			}
		}
		result.data = data;
		return result;
	};

	PresenceMessage.prototype.toString = function() {
		var result = '[PresenceMessage';
		result += '; action=' + this.action;
		if(this.id)
			result += '; id=' + this.id;
		if(this.timestamp)
			result += '; timestamp=' + this.timestamp;
		if(this.clientId)
			result += '; clientId=' + this.clientId;
		if(this.connectionId)
			result += '; connectionId=' + this.connectionId;
		if(this.encoding)
			result += '; encoding=' + this.encoding;
		if(this.data) {
			if (typeof(this.data) == 'string')
				result += '; data=' + this.data;
			else if (BufferUtils.isBuffer(this.data))
				result += '; data (buffer)=' + BufferUtils.base64Encode(this.data);
			else
				result += '; data (json)=' + JSON.stringify(this.data);
		}
		result += ']';
		return result;
	};
	PresenceMessage.encode = Message.encode;
	PresenceMessage.decode = Message.decode;

	PresenceMessage.fromResponseBody = function(body, options, format) {
		if(format)
			body = (format == 'msgpack') ? msgpack.decode(body) : JSON.parse(String(body));

		for(var i = 0; i < body.length; i++) {
			var msg = body[i] = PresenceMessage.fromValues(body[i], true);
			try {
				PresenceMessage.decode(msg, options);
			} catch (e) {
				Logger.logAction(Logger.LOG_ERROR, 'PresenceMessage.fromResponseBody()', e.toString());
			}
		}
		return body;
	};

	/* Creates a PresenceMessage from specified values, with a string presence action */
	PresenceMessage.fromValues = function(values, stringifyAction) {
		if(stringifyAction) {
			values.action = PresenceMessage.Actions[values.action]
		}
		return Utils.mixin(new PresenceMessage(), values);
	};

	PresenceMessage.fromValuesArray = function(values) {
		var count = values.length, result = new Array(count);
		for(var i = 0; i < count; i++) result[i] = PresenceMessage.fromValues(values[i]);
		return result;
	};

	PresenceMessage.fromEncoded = function(encoded, options) {
		var msg = PresenceMessage.fromValues(encoded, true);
		/* if decoding fails at any point, catch and return the message decoded to
		 * the fullest extent possible */
		try {
			PresenceMessage.decode(msg, options);
		} catch(e) {
			Logger.logAction(Logger.LOG_ERROR, 'PresenceMessage.fromEncoded()', e.toString());
		}
		return msg;
	};

	PresenceMessage.fromEncodedArray = function(encodedArray, options) {
		return Utils.arrMap(encodedArray, function(encoded) {
			return PresenceMessage.fromEncoded(encoded, options);
		});
	};

	return PresenceMessage;
})();

var ProtocolMessage = (function() {
	var msgpack = Platform.msgpack;

	function ProtocolMessage() {
		this.action = undefined;
		this.flags = undefined;
		this.id = undefined;
		this.timestamp = undefined;
		this.count = undefined;
		this.error = undefined;
		this.connectionId = undefined;
		this.connectionKey = undefined;
		this.connectionSerial = undefined;
		this.channel = undefined;
		this.channelSerial = undefined;
		this.msgSerial = undefined;
		this.messages = undefined;
		this.presence = undefined;
		this.auth = undefined;
	}

	ProtocolMessage.Action = {
		'HEARTBEAT' : 0,
		'ACK' : 1,
		'NACK' : 2,
		'CONNECT' : 3,
		'CONNECTED' : 4,
		'DISCONNECT' : 5,
		'DISCONNECTED' : 6,
		'CLOSE' : 7,
		'CLOSED' : 8,
		'ERROR' : 9,
		'ATTACH' : 10,
		'ATTACHED' : 11,
		'DETACH' : 12,
		'DETACHED' : 13,
		'PRESENCE' : 14,
		'MESSAGE' : 15,
		'SYNC' : 16,
		'AUTH' : 17
	};

	ProtocolMessage.ActionName = [];
	Utils.arrForEach(Utils.keysArray(ProtocolMessage.Action, true), function(name) {
		ProtocolMessage.ActionName[ProtocolMessage.Action[name]] = name;
	});

	var flags = {
		/* Channel attach state flags */
		'HAS_PRESENCE':       1 << 0,
		'HAS_BACKLOG':        1 << 1,
		'RESUMED':            1 << 2,
		'HAS_LOCAL_PRESENCE': 1 << 3,
		'TRANSIENT':          1 << 4,
		/* Channel mode flags */
		'PRESENCE':           1 << 16,
		'PUBLISH':            1 << 17,
		'SUBSCRIBE':          1 << 18,
		'PRESENCE_SUBSCRIBE': 1 << 19
	};
	var flagNames = Utils.keysArray(flags);
	flags.MODE_ALL = flags.PRESENCE | flags.PUBLISH | flags.SUBSCRIBE | flags.PRESENCE_SUBSCRIBE;

	ProtocolMessage.prototype.hasFlag = function(flag) {
		return ((this.flags & flags[flag]) > 0);
	};

	ProtocolMessage.prototype.setFlag = function(flag) {
		return this.flags = this.flags | flags[flag];
	};

	ProtocolMessage.prototype.getMode = function() {
		return this.flags && (this.flags & flags.MODE_ALL);
	};

	ProtocolMessage.serialize = function(msg, format) {
		return (format == 'msgpack') ? msgpack.encode(msg, true): JSON.stringify(msg);
	};

	ProtocolMessage.deserialize = function(serialized, format) {
		var deserialized = (format == 'msgpack') ? msgpack.decode(serialized) : JSON.parse(String(serialized));
		return ProtocolMessage.fromDeserialized(deserialized);
	};

	ProtocolMessage.fromDeserialized = function(deserialized) {
		var error = deserialized.error;
		if(error) deserialized.error = ErrorInfo.fromValues(error);
		var messages = deserialized.messages;
		if(messages) for(var i = 0; i < messages.length; i++) messages[i] = Message.fromValues(messages[i]);
		var presence = deserialized.presence;
		if(presence) for(var i = 0; i < presence.length; i++) presence[i] = PresenceMessage.fromValues(presence[i], true);
		return Utils.mixin(new ProtocolMessage(), deserialized);
	};

	ProtocolMessage.fromValues = function(values) {
		return Utils.mixin(new ProtocolMessage(), values);
	};

	function toStringArray(array) {
		var result = [];
		if (array) {
			for (var i = 0; i < array.length; i++) {
				result.push(array[i].toString());
			}
		}
		return '[ ' + result.join(', ') + ' ]';
	}

	var simpleAttributes = 'id channel channelSerial connectionId connectionKey connectionSerial count msgSerial timestamp'.split(' ');

	ProtocolMessage.stringify = function(msg) {
		var result = '[ProtocolMessage';
		if(msg.action !== undefined)
			result += '; action=' + ProtocolMessage.ActionName[msg.action] || msg.action;

		var attribute;
		for (var attribIndex = 0; attribIndex < simpleAttributes.length; attribIndex++) {
			attribute = simpleAttributes[attribIndex];
			if(msg[attribute] !== undefined)
				result += '; ' + attribute + '=' + msg[attribute];
		}

		if(msg.messages)
			result += '; messages=' + toStringArray(Message.fromValuesArray(msg.messages));
		if(msg.presence)
			result += '; presence=' + toStringArray(PresenceMessage.fromValuesArray(msg.presence));
		if(msg.error)
			result += '; error=' + ErrorInfo.fromValues(msg.error).toString();
		if(msg.auth && msg.auth.accessToken)
			result += '; token=' + msg.auth.accessToken;
		if(msg.flags)
			result += '; flags=' + Utils.arrFilter(flagNames, function(flag) {
				return msg.hasFlag(flag);
			}).join(',');

		result += ']';
		return result;
	};

	return ProtocolMessage;
})();

var Stats = (function() {

	function MessageCount(values) {
		this.count = (values && values.count) || 0;
		this.data = (values && values.data) || 0;
		this.failed = (values && values.failed) || 0;
		this.refused = (values && values.refused) || 0;
	}

	function ResourceCount(values) {
		this.peak = (values && values.peak) || 0;
		this.min = (values && values.min) || 0;
		this.mean = (values && values.mean) || 0;
		this.opened = (values && values.opened) || 0;
		this.refused = (values && values.refused) || 0;
	}

	function RequestCount(values) {
		this.succeeded = (values && values.succeeded) || 0;
		this.failed = (values && values.failed) || 0;
		this.refused = (values && values.refused) || 0;
	}

	function ConnectionTypes(values) {
		this.plain = new ResourceCount(values && values.plain);
		this.tls = new ResourceCount(values && values.tls);
		this.all = new ResourceCount(values && values.all);
	}

	function MessageTypes(values) {
		this.messages = new MessageCount(values && values.messages);
		this.presence = new MessageCount(values && values.presence);
		this.all = new MessageCount(values && values.all);
	}

	function MessageTraffic(values) {
		this.realtime = new MessageTypes(values && values.realtime);
		this.rest = new MessageTypes(values && values.rest);
		this.webhook = new MessageTypes(values && values.webhook);
		this.push = new MessageTypes(values && values.push);
		this.sharedQueue = new MessageTypes(values && values.sharedQueue);
		this.externalQueue = new MessageTypes(values && values.externalQueue);
		this.all = new MessageTypes(values && values.all);
	}

	function Stats(values) {
		this.all           = new MessageTypes(values && values.all);
		this.inbound       = new MessageTraffic(values && values.inbound);
		this.outbound      = new MessageTraffic(values && values.outbound);
		this.persisted     = new MessageTypes(values && values.persisted);
		this.connections   = new ConnectionTypes(values && values.connections);
		this.channels      = new ResourceCount(values && values.channels);
		this.apiRequests   = new RequestCount(values && values.apiRequests);
		this.tokenRequests = new RequestCount(values && values.tokenRequests);
		this.inProgress    = (values && values.inProgress) || undefined;
		this.unit          = (values && values.unit) || undefined;
		this.intervalId    = (values && values.intervalId) || undefined;
	}

	Stats.fromValues = function(values) {
		return new Stats(values);
	};

	return Stats;
})();

var ConnectionError = {
	disconnected: ErrorInfo.fromValues({
		statusCode: 400,
		code: 80003,
		message: 'Connection to server temporarily unavailable'
	}),
	suspended: ErrorInfo.fromValues({
		statusCode: 400,
		code: 80002,
		message: 'Connection to server unavailable'
	}),
	failed: ErrorInfo.fromValues({
		statusCode: 400,
		code: 80000,
		message: 'Connection failed or disconnected by server'
	}),
	closing: ErrorInfo.fromValues({
		statusCode: 400,
		code: 80017,
		message: 'Connection closing'
	}),
	closed: ErrorInfo.fromValues({
		statusCode: 400,
		code: 80017,
		message: 'Connection closed'
	}),
	unknownConnectionErr: ErrorInfo.fromValues({
		statusCode: 500,
		code: 50002,
		message: 'Internal connection error'
	}),
	unknownChannelErr: ErrorInfo.fromValues({
		statusCode: 500,
		code: 50001,
		message: 'Internal channel error'
	})
};

var MessageQueue = (function() {
	function MessageQueue() {
		EventEmitter.call(this);
		this.messages = [];
	}
	Utils.inherits(MessageQueue, EventEmitter);

	MessageQueue.prototype.count = function() {
		return this.messages.length;
	};

	MessageQueue.prototype.push = function(message) {
		this.messages.push(message);
	};

	MessageQueue.prototype.shift = function() {
		return this.messages.shift();
	};

	MessageQueue.prototype.last = function() {
		return this.messages[this.messages.length - 1];
	};

	MessageQueue.prototype.copyAll = function() {
		return this.messages.slice();
	};

	MessageQueue.prototype.append = function(messages) {
		this.messages.push.apply(this.messages, messages);
	};

	MessageQueue.prototype.prepend = function(messages) {
		this.messages.unshift.apply(this.messages, messages);
	};

	MessageQueue.prototype.completeMessages = function(serial, count, err) {
		Logger.logAction(Logger.LOG_MICRO, 'MessageQueue.completeMessages()', 'serial = ' + serial + '; count = ' + count);
		err = err || null;
		var messages = this.messages;
		var first = messages[0];
		if(first) {
			var startSerial = first.message.msgSerial;
			var endSerial = serial + count; /* the serial of the first message that is *not* the subject of this call */
			if(endSerial > startSerial) {
				var completeMessages = messages.splice(0, (endSerial - startSerial));
				for(var i = 0; i < completeMessages.length; i++) {
					completeMessages[i].callback(err);
				}
			}
			if(messages.length == 0)
				this.emit('idle');
		}
	};

	MessageQueue.prototype.completeAllMessages = function(err) {
		this.completeMessages(0, Number.MAX_SAFE_INTEGER || Number.MAX_VALUE, err);
	};

	MessageQueue.prototype.clear = function() {
		Logger.logAction(Logger.LOG_MICRO, 'MessageQueue.clear()', 'clearing ' + this.messages.length + ' messages');
		this.messages = [];
		this.emit('idle');
	};

	return MessageQueue;
})();

var Protocol = (function() {
	var actions = ProtocolMessage.Action;

	function Protocol(transport) {
		EventEmitter.call(this);
		this.transport = transport;
		this.messageQueue = new MessageQueue();
		var self = this;
		transport.on('ack', function(serial, count) { self.onAck(serial, count); });
		transport.on('nack', function(serial, count, err) { self.onNack(serial, count, err); });
	}
	Utils.inherits(Protocol, EventEmitter);

	Protocol.prototype.onAck = function(serial, count) {
		Logger.logAction(Logger.LOG_MICRO, 'Protocol.onAck()', 'serial = ' + serial + '; count = ' + count);
		this.messageQueue.completeMessages(serial, count);
	};

	Protocol.prototype.onNack = function(serial, count, err) {
		Logger.logAction(Logger.LOG_ERROR, 'Protocol.onNack()', 'serial = ' + serial + '; count = ' + count + '; err = ' + Utils.inspectError(err));
		if(!err) {
			err = new ErrorInfo('Unable to send message; channel not responding', 50001, 500);
		}
		this.messageQueue.completeMessages(serial, count, err);
	};

	Protocol.prototype.onceIdle = function(listener) {
		var messageQueue = this.messageQueue;
		if(messageQueue.count() === 0) {
			listener();
			return;
		}
		messageQueue.once('idle', listener);
	};

	Protocol.prototype.send = function(pendingMessage) {
		if(pendingMessage.ackRequired) {
			this.messageQueue.push(pendingMessage);
		}
		if (Logger.shouldLog(Logger.LOG_MICRO)) {
			Logger.logAction(Logger.LOG_MICRO, 'Protocol.send()', 'sending msg; ' + ProtocolMessage.stringify(pendingMessage.message));
		}
		pendingMessage.sendAttempted = true;
		this.transport.send(pendingMessage.message);
	};

	Protocol.prototype.getTransport = function() {
		return this.transport;
	};

	Protocol.prototype.getPendingMessages = function() {
		return this.messageQueue.copyAll();
	};

	Protocol.prototype.clearPendingMessages = function() {
		return this.messageQueue.clear();
	};

	Protocol.prototype.finish = function() {
		var transport = this.transport;
		this.onceIdle(function() {
			transport.disconnect();
		});
	};

	function PendingMessage(message, callback) {
		this.message = message;
		this.callback = callback;
		this.merged = false;
		var action = message.action;
		this.sendAttempted = false;
		this.ackRequired = (action == actions.MESSAGE || action == actions.PRESENCE);
	}
	Protocol.PendingMessage = PendingMessage;

	return Protocol;
})();

var ConnectionManager = (function() {
	var haveWebStorage = !!(typeof(WebStorage) !== 'undefined' && WebStorage.get);
	var haveSessionStorage = !!(typeof(WebStorage) !== 'undefined' && WebStorage.getSession);
	var actions = ProtocolMessage.Action;
	var PendingMessage = Protocol.PendingMessage;
	var noop = function() {};
	var transportPreferenceOrder = Defaults.transportPreferenceOrder;
	var optimalTransport = transportPreferenceOrder[transportPreferenceOrder.length - 1];
	var transportPreferenceName = 'ably-transport-preference';

	var sessionRecoveryName = 'ably-connection-recovery';
	function getSessionRecoverData() {
		return haveSessionStorage && WebStorage.getSession(sessionRecoveryName);
	}
	function setSessionRecoverData(value) {
		return haveSessionStorage && WebStorage.setSession(sessionRecoveryName, value);
	}
	function clearSessionRecoverData() {
		return haveSessionStorage && WebStorage.removeSession(sessionRecoveryName);
	}

	function betterTransportThan(a, b) {
		return Utils.arrIndexOf(transportPreferenceOrder, a.shortName) >
		   Utils.arrIndexOf(transportPreferenceOrder, b.shortName);
	}

	function TransportParams(options, host, mode, connectionKey, connectionSerial) {
		this.options = options;
		this.host = host;
		this.mode = mode;
		this.connectionKey = connectionKey;
		this.connectionSerial = connectionSerial;
		this.format = options.useBinaryProtocol ? 'msgpack' : 'json';
	}

	TransportParams.prototype.getConnectParams = function(authParams) {
		var params = authParams ? Utils.copy(authParams) : {};
		var options = this.options;
		switch(this.mode) {
			case 'upgrade':
				params.upgrade = this.connectionKey;
				break;
			case 'resume':
				params.resume = this.connectionKey;
				if(this.connectionSerial !== undefined)
					params.connection_serial = this.connectionSerial;
				break;
			case 'recover':
				var match = options.recover.split(':');
				if(match) {
					params.recover = match[0];
					params.connection_serial = match[1];
				}
				break;
			default:
		}
		if(options.clientId !== undefined)
			params.clientId = options.clientId;
		if(options.echoMessages === false)
			params.echo = 'false';
		if(this.format !== undefined)
			params.format = this.format;
		if(this.stream !== undefined)
			params.stream = this.stream;
		if(this.heartbeats !== undefined)
			params.heartbeats = this.heartbeats;
		if(options.transportParams !== undefined) {
			Utils.mixin(params, options.transportParams);
		}
		params.v = Defaults.apiVersion;
		params.lib = Defaults.libstring;
		return params;
	};

	/* public constructor */
	function ConnectionManager(realtime, options) {
		EventEmitter.call(this);
		this.realtime = realtime;
		this.options = options;
		var timeouts = options.timeouts;
		var self = this;
		/* connectingTimeout: leave preferenceConnectTimeout (~6s) to try the
		 * preference transport, then realtimeRequestTimeout (~10s) to establish
		 * the base transport in case that fails */
		var connectingTimeout = timeouts.preferenceConnectTimeout + timeouts.realtimeRequestTimeout;
		this.states = {
			initialized:   {state: 'initialized',   terminal: false, queueEvents: true,  sendEvents: false, failState: 'disconnected'},
			connecting:    {state: 'connecting',    terminal: false, queueEvents: true,  sendEvents: false, retryDelay: connectingTimeout, failState: 'disconnected'},
			connected:     {state: 'connected',     terminal: false, queueEvents: false, sendEvents: true,  failState: 'disconnected'},
			synchronizing: {state: 'connected',     terminal: false, queueEvents: true,  sendEvents: false, forceQueueEvents: true, failState: 'disconnected'},
			disconnected:  {state: 'disconnected',  terminal: false, queueEvents: true,  sendEvents: false, retryDelay: timeouts.disconnectedRetryTimeout, failState: 'disconnected'},
			suspended:     {state: 'suspended',     terminal: false, queueEvents: false, sendEvents: false, retryDelay: timeouts.suspendedRetryTimeout, failState: 'suspended'},
			closing:       {state: 'closing',       terminal: false, queueEvents: false, sendEvents: false, retryDelay: timeouts.realtimeRequestTimeout, failState: 'closed'},
			closed:        {state: 'closed',        terminal: true,  queueEvents: false, sendEvents: false, failState: 'closed'},
			failed:        {state: 'failed',        terminal: true,  queueEvents: false, sendEvents: false, failState: 'failed'}
		};
		this.state = this.states.initialized;
		this.errorReason = null;

		this.queuedMessages = new MessageQueue();
		this.msgSerial = 0;
		this.connectionId = undefined;
		this.connectionKey = undefined;
		this.connectionSerial = undefined;
		this.connectionStateTtl = timeouts.connectionStateTtl;
		this.maxIdleInterval = null;

		this.transports = Utils.intersect((options.transports || Defaults.defaultTransports), ConnectionManager.supportedTransports);
		/* baseTransports selects the leftmost transport in the Defaults.baseTransportOrder list
		* that's both requested and supported. Normally this will be xhr_polling;
		* if xhr isn't supported it will be jsonp. If the user has forced a
		* transport, it'll just be that one. */
		this.baseTransport = Utils.intersect(Defaults.baseTransportOrder, this.transports)[0];
		this.upgradeTransports = Utils.intersect(this.transports, Defaults.upgradeTransports);
		/* Map of hosts to an array of transports to not be tried for that host */
		this.transportHostBlacklist = {};
		this.transportPreference = null;

		this.httpHosts = Defaults.getHosts(options);
		this.activeProtocol = null;
		this.proposedTransports = [];
		this.pendingTransports = [];
		this.host = null;
		this.lastAutoReconnectAttempt = null;
		this.lastActivity = null;

		Logger.logAction(Logger.LOG_MINOR, 'Realtime.ConnectionManager()', 'started');
		Logger.logAction(Logger.LOG_MICRO, 'Realtime.ConnectionManager()', 'requested transports = [' + (options.transports || Defaults.defaultTransports) + ']');
		Logger.logAction(Logger.LOG_MICRO, 'Realtime.ConnectionManager()', 'available transports = [' + this.transports + ']');
		Logger.logAction(Logger.LOG_MICRO, 'Realtime.ConnectionManager()', 'http hosts = [' + this.httpHosts + ']');

		if(!this.transports.length) {
			var msg = 'no requested transports available';
			Logger.logAction(Logger.LOG_ERROR, 'realtime.ConnectionManager()', msg);
			throw new Error(msg);
		}

		var addEventListener = Platform.addEventListener;
		if(addEventListener) {
			/* intercept close event in browser to persist connection id if requested */
			if(haveSessionStorage && typeof options.recover === 'function') {
				/* Usually can't use bind as not supported in IE8, but IE doesn't support sessionStorage, so... */
				addEventListener('beforeunload', this.persistConnection.bind(this));
			}

			if(options.closeOnUnload === true) {
				addEventListener('beforeunload', function() { self.requestState({state: 'closing'}); });
			}

			/* Listen for online and offline events */
			addEventListener('online', function() {
				if(self.state == self.states.disconnected || self.state == self.states.suspended) {
					Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager caught browser ‘online’ event', 'reattempting connection');
					self.requestState({state: 'connecting'});
				}
			});
			addEventListener('offline', function() {
				if(self.state == self.states.connected) {
					Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager caught browser ‘offline’ event', 'disconnecting active transport');
					// Not sufficient to just go to the 'disconnected' state, want to
					// force all transports to reattempt the connection. Will immediately
					// retry.
					self.disconnectAllTransports();
				}
			});
		}
	}
	Utils.inherits(ConnectionManager, EventEmitter);

	/*********************
	 * transport management
	 *********************/

	ConnectionManager.supportedTransports = {};

	ConnectionManager.prototype.getTransportParams = function(callback) {
		var self = this;

		function decideMode(modeCb) {
			if(self.connectionKey) {
				modeCb('resume');
				return;
			}

			if(typeof self.options.recover === 'string') {
				modeCb('recover');
				return;
			}

			var recoverFn = self.options.recover,
				lastSessionData = getSessionRecoverData();
			if(lastSessionData && typeof(recoverFn) === 'function') {
				Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager.getTransportParams()', 'Calling clientOptions-provided recover function with last session data');
				recoverFn(lastSessionData, function(shouldRecover) {
					if(shouldRecover) {
						self.options.recover = lastSessionData.recoveryKey;
						modeCb('recover');
					} else {
						modeCb('clean');
					}
				});
				return;
			}
			modeCb('clean');
		}

		decideMode(function(mode) {
			Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager.getTransportParams()', 'Transport recovery mode = ' + mode + (mode == 'clean' ? '' : '; connectionKey = ' + self.connectionKey + '; connectionSerial = ' + self.connectionSerial));
			callback(new TransportParams(self.options, null, mode, self.connectionKey, self.connectionSerial));
		});
	};

	/**
	 * Attempt to connect using a given transport
	 * @param transportParams
	 * @param candidate, the transport to try
	 * @param callback
	 */
	ConnectionManager.prototype.tryATransport = function(transportParams, candidate, callback) {
		var self = this, host = transportParams.host;
		Logger.logAction(Logger.LOG_MICRO, 'ConnectionManager.tryATransport()', 'trying ' + candidate);
		if((host in this.transportHostBlacklist) && Utils.arrIn(this.transportHostBlacklist[host], candidate)) {
			Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager.tryATransport()', candidate + ' transport is blacklisted for host ' + transportParams.host);
			return;
		}
		(ConnectionManager.supportedTransports[candidate]).tryConnect(this, this.realtime.auth, transportParams, function(wrappedErr, transport) {
			var state = self.state;
			if(state == self.states.closing || state == self.states.closed || state == self.states.failed) {
				if(transport) {
					Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager.tryATransport()', 'connection ' + state.state + ' while we were attempting the transport; closing ' + transport);
					transport.close();
				}
				callback(true);
				return;
			}

			if(wrappedErr) {
				Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager.tryATransport()', 'transport ' + candidate + ' ' + wrappedErr.event + ', err: ' + wrappedErr.error.toString());

				/* Comet transport onconnect token errors can be dealt with here.
				* Websocket ones only happen after the transport claims to be viable,
				* so are dealt with as non-onconnect token errors */
				if(Auth.isTokenErr(wrappedErr.error)) {
					/* re-get a token and try again */
					self.realtime.auth._forceNewToken(null, null, function(err) {
						if(err) {
							self.actOnErrorFromAuthorize(err);
							return;
						}
						self.tryATransport(transportParams, candidate, callback);
					});
				} else if(wrappedErr.event === 'failed') {
					/* Error that's fatal to the connection */
					self.notifyState({state: 'failed', error: wrappedErr.error});
					callback(true);
				} else if(wrappedErr.event === 'disconnected') {
					/* Error with that transport only */
					callback(false);
				}
				return;
			}

			Logger.logAction(Logger.LOG_MICRO, 'ConnectionManager.chooseTransportForHost()', 'viable transport ' + candidate + '; setting pending');
			self.setTransportPending(transport, transportParams);
			callback(null, transport);
		});
	};


	/**
	 * Called when a transport is indicated to be viable, and the connectionmanager
	 * expects to activate this transport as soon as it is connected.
	 * @param host
	 * @param transportParams
	 */
	ConnectionManager.prototype.setTransportPending = function(transport, transportParams) {
		var mode = transportParams.mode;
		Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager.setTransportPending()', 'transport = ' + transport + '; mode = ' + mode);

		Utils.arrDeleteValue(this.proposedTransports, transport);
		this.pendingTransports.push(transport);

		var self = this;
		transport.once('connected', function(error, connectionKey, connectionSerial, connectionId, connectionDetails) {
			if(mode == 'upgrade' && self.activeProtocol) {
				/*  if ws and xhrs are connecting in parallel, delay xhrs activation to let ws go ahead */
				if(transport.shortName !== optimalTransport && Utils.arrIn(self.getUpgradePossibilities(), optimalTransport)) {
					setTimeout(function() {
						self.scheduleTransportActivation(error, transport, connectionKey, connectionSerial, connectionId, connectionDetails);
					}, self.options.timeouts.parallelUpgradeDelay);
				} else {
					self.scheduleTransportActivation(error, transport, connectionKey, connectionSerial, connectionId, connectionDetails);
				}
			} else {
				self.activateTransport(error, transport, connectionKey, connectionSerial, connectionId, connectionDetails);

				/* allow connectImpl to start the upgrade process if needed, but allow
				 * other event handlers, including activating the transport, to run first */
				Utils.nextTick(function() {
					self.connectImpl(transportParams);
				});
			}

			if(mode === 'recover' && self.options.recover) {
				/* After a successful recovery, we unpersist, as a recovery key cannot
				* be used more than once */
				self.options.recover = null;
				self.unpersistConnection();
			}
		});

		transport.on(['disconnected', 'closed', 'failed'], function(error) {
			self.deactivateTransport(transport, this.event, error);
		});

		this.emit('transport.pending', transport);
	};

	/**
	 * Called when an upgrade transport is connected,
	 * to schedule the activation of that transport.
	 * @param transport, the transport instance
	 * @param connectionKey
	 */
	ConnectionManager.prototype.scheduleTransportActivation = function(error, transport, connectionKey, connectionSerial, connectionId, connectionDetails) {
		var self = this,
			currentTransport = this.activeProtocol && this.activeProtocol.getTransport(),
			abandon = function() {
				transport.disconnect();
				Utils.arrDeleteValue(self.pendingTransports, transport);
			};

		if(this.state !== this.states.connected && this.state !== this.states.connecting) {
			/* This is most likely to happen for the delayed xhrs, when xhrs and ws are scheduled in parallel*/
			Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Current connection state (' + this.state.state + (this.state === this.states.synchronizing ? ', but with an upgrade already in progress' : '') + ') is not valid to upgrade in; abandoning upgrade to ' + transport.shortName);
			abandon();
			return;
		}

		if(currentTransport && !betterTransportThan(transport, currentTransport)) {
			Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Proposed transport ' + transport.shortName + ' is no better than current active transport ' + currentTransport.shortName + ' - abandoning upgrade');
			abandon();
			return;
		}

		Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Scheduling transport upgrade; transport = ' + transport);

		this.realtime.channels.onceNopending(function(err) {
			var oldProtocol;
			if(err) {
				Logger.logAction(Logger.LOG_ERROR, 'ConnectionManager.scheduleTransportActivation()', 'Unable to activate transport; transport = ' + transport + '; err = ' + err);
				return;
			}

			if(!transport.isConnected) {
				/* This is only possible if the xhr streaming transport was disconnected during the parallelUpgradeDelay */
				Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Proposed transport ' + transport.shortName + 'is no longer connected; abandoning upgrade');
				abandon();
				return;
			}

			if(self.state === self.states.connected) {
				Logger.logAction(Logger.LOG_MICRO, 'ConnectionManager.scheduleTransportActivation()', 'Currently connected, so temporarily pausing events until the upgrade is complete');
				self.state = self.states.synchronizing;
				oldProtocol = self.activeProtocol;
			} else if(self.state !== self.states.connecting) {
				/* Note: upgrading from the connecting state is valid if the old active
				* transport was deactivated after the upgrade transport first connected;
				* see logic in deactivateTransport */
				Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Current connection state (' + self.state.state + (self.state === self.states.synchronizing ? ', but with an upgrade already in progress' : '') + ') is not valid to upgrade in; abandoning upgrade to ' + transport.shortName);
				abandon();
				return;
			}

			/* If the connectionId has changed, the upgrade hasn't worked. But as
			* it's still an upgrade, realtime still expects a sync - it just needs to
			* be a sync with the new connectionSerial (which will be -1). (And it
			* needs to be set in the library, which is done by activateTransport). */
			var connectionReset = connectionId !== self.connectionId,
				newConnectionSerial = connectionReset ? connectionSerial : self.connectionSerial;

			if(connectionReset) {
				Logger.logAction(Logger.LOG_ERROR, 'ConnectionManager.scheduleTransportActivation()', 'Upgrade resulted in new connectionId; resetting library connectionSerial from ' + self.connectionSerial + ' to ' + newConnectionSerial + '; upgrade error was ' + error);
			}

			Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Syncing transport; transport = ' + transport);
			self.sync(transport, function(syncErr, newConnectionSerial, connectionId) {
				/* If there's been some problem with syncing (and the connection hasn't
				 * closed or something in the meantime), we have a problem -- we can't
				 * just fall back on the old transport, as we don't know whether
				 * realtime got the sync -- if it did, the old transport is no longer
				 * valid. To be safe, we disconnect both and start again from scratch. */
				if(syncErr) {
					if(self.state === self.states.synchronizing) {
						Logger.logAction(Logger.LOG_ERROR, 'ConnectionManager.scheduleTransportActivation()', 'Unexpected error attempting to sync transport; transport = ' + transport + '; err = ' + syncErr);
						self.disconnectAllTransports();
					}
					return;
				}
				var finishUpgrade = function() {
					Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Activating transport; transport = ' + transport);
					self.activateTransport(error, transport, connectionKey, newConnectionSerial, connectionId, connectionDetails);
					/* Restore pre-sync state. If state has changed in the meantime,
					 * don't touch it -- since the websocket transport waits a tick before
					 * disposing itself, it's possible for it to have happily synced
					 * without err while, unknown to it, the connection has closed in the
					 * meantime and the ws transport is scheduled for death */
					if(self.state === self.states.synchronizing) {
						Logger.logAction(Logger.LOG_MICRO, 'ConnectionManager.scheduleTransportActivation()', 'Pre-upgrade protocol idle, sending queued messages on upgraded transport; transport = ' + transport);
						self.state = self.states.connected;
					} else {
						Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Pre-upgrade protocol idle, but state is now ' + self.state.state + ', so leaving unchanged');
					}
					if(self.state.sendEvents) {
						self.sendQueuedMessages();
					}
				};

				/* Wait until sync is done and old transport is idle before activating new transport. This
				 * guarantees that messages arrive at realtime in the same order they are sent.
				 *
				 * If a message times out on the old transport, since it's still the active transport the
				 * message will be requeued. deactivateTransport will see the pending transport and notify
				 * the `connecting` state without starting a new connection, so the new transport can take
				 * over once deactivateTransport clears the old protocol's queue.
				 *
				 * If there is no old protocol, that meant that we weren't in the connected state at the
				 * beginning of the sync - likely the base transport died just before the sync. So can just
				 * finish the upgrade. If we're actually in closing/failed rather than connecting, that's
				 * fine, activatetransport will deal with that. */
				if(oldProtocol) {
				 /* Most of the time this will be already true: the new-transport sync will have given
				 * enough time for in-flight messages on the old transport to complete. */
					oldProtocol.onceIdle(finishUpgrade);
				} else {
					finishUpgrade();
				}
			});
		});
	};

	/**
	 * Called when a transport is connected, and the connectionmanager decides that
	 * it will now be the active transport. Returns whether or not it activated
	 * the transport (if the connection is closing/closed it will choose not to).
	 * @param transport the transport instance
	 * @param connectionKey the key of the new active connection
	 * @param connectionSerial the current connectionSerial
	 * @param connectionId the id of the new active connection
	 */
	ConnectionManager.prototype.activateTransport = function(error, transport, connectionKey, connectionSerial, connectionId, connectionDetails) {
		Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager.activateTransport()', 'transport = ' + transport);
		if(error) {
			Logger.logAction(Logger.LOG_ERROR, 'ConnectionManager.activateTransport()', 'error = ' + error);
		}
		if(connectionKey)
			Logger.logAction(Logger.LOG_MICRO, 'ConnectionManager.activateTransport()', 'connectionKey =  ' + connectionKey);
		if(connectionSerial !== undefined)
			Logger.logAction(Logger.LOG_MICRO, 'ConnectionManager.activateTransport()', 'connectionSerial =  ' + connectionSerial);
		if(connectionId)
			Logger.logAction(Logger.LOG_MICRO, 'ConnectionManager.activateTransport()', 'connectionId =  ' + connectionId);
		if(connectionDetails)
			Logger.logAction(Logger.LOG_MICRO, 'ConnectionManager.activateTransport()', 'connectionDetails =  ' + JSON.stringify(connectionDetails));

		this.persistTransportPreference(transport);

		/* if the connectionmanager moved to the closing/closed state before this
		 * connection event, then we won't activate this transport */
		var existingState = this.state,
			connectedState = this.states.connected.state;
		Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager.activateTransport()', 'current state = ' + existingState.state);
		if(existingState.state == this.states.closing.state || existingState.state == this.states.closed.state || existingState.state == this.states.failed.state) {
			Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager.activateTransport()', 'Disconnecting transport and abandoning');
			transport.disconnect();
			return false;
		}

		/* remove this transport from pending transports */
		Utils.arrDeleteValue(this.pendingTransports, transport);

		/* if the transport is not connected (eg because it failed during a
		 * scheduleTransportActivation#onceNoPending wait) then don't activate it */
		if(!transport.isConnected) {
			Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager.activateTransport()', 'Declining to activate transport ' + transport + ' since it appears to no longer be connected');
			return false;
		}

		/* the given transport is connected; this will immediately
		 * take over as the active transport */
		var existingActiveProtocol = this.activeProtocol;
		this.activeProtocol = new Protocol(transport);
		this.host = transport.params.host;
		if(connectionKey && this.connectionKey != connectionKey)  {
			this.setConnection(connectionId, connectionKey, connectionSerial);
		}

		/* Rebroadcast any new connectionDetails from the active transport, which
		 * can come at any time (eg following a reauth), and emit an RTN24 UPDATE
		 * event. (Listener added on nextTick because we're in a transport.on('connected')
		 * callback at the moment; if we add it now we'll be adding it to the end
		 * of the listeners array and it'll be called immediately) */
		this.onConnectionDetailsUpdate(connectionDetails, transport);
		var self = this;
		Utils.nextTick(function() {
			transport.on('connected', function(connectedErr, _connectionKey, _connectionSerial, _connectionId, connectionDetails) {
				self.onConnectionDetailsUpdate(connectionDetails, transport);
				self.emit('update', new ConnectionStateChange(connectedState, connectedState, null, connectedErr));
			});
		})

		/* If previously not connected, notify the state change (including any
		 * error). */
		if(existingState.state === this.states.connected.state) {
			if(error) {
				/* if upgrading without error, leave any existing errorReason alone */
				this.errorReason = this.realtime.connection.errorReason = error;
				/* Only bother emitting an upgrade if there's an error; otherwise it's
				 * just a transport upgrade, so auth details won't have changed */
				this.emit('update', new ConnectionStateChange(connectedState, connectedState, null, error));
			}
		} else {
			this.notifyState({state: 'connected', error: error});
			this.errorReason = this.realtime.connection.errorReason = error || null;
		}

		/* Send after the connection state update, as Channels hooks into this to
		 * resend attaches on a new transport if necessary */
		this.emit('transport.active', transport, connectionKey, transport.params);

		/* Gracefully terminate existing protocol */
		if(existingActiveProtocol) {
			if(existingActiveProtocol.messageQueue.count() > 0) {
				/* We could just requeue pending messages on the new transport, but
				 * actually this should never happen: transports should only take over
				 * from other active transports when upgrading, and upgrading waits for
				 * the old transport to be idle. So log an error. */
				Logger.logAction(Logger.LOG_ERROR, 'ConnectionManager.activateTransport()', 'Previous active protocol (for transport ' + existingActiveProtocol.transport.shortName + ', new one is ' + transport.shortName + ') finishing with ' + existingActiveProtocol.messageQueue.count() + ' messages still pending');
			}
			existingActiveProtocol.finish();
		}

		/* Terminate any other pending transport(s), and
		 * abort any not-yet-pending transport attempts */
		Utils.safeArrForEach(this.pendingTransports, function(transport) {
			transport.disconnect();
		});
		Utils.safeArrForEach(this.proposedTransports, function(transport) {
			transport.dispose();
		});

		return true;
	};

	/**
	 * Called when a transport is no longer the active transport. This can occur
	 * in any transport connection state.
	 * @param transport
	 */
	ConnectionManager.prototype.deactivateTransport = function(transport, state, error) {
		var currentProtocol = this.activeProtocol,
			wasActive = currentProtocol && currentProtocol.getTransport() === transport,
			wasPending = Utils.arrDeleteValue(this.pendingTransports, transport),
			wasProposed = Utils.arrDeleteValue(this.proposedTransports, transport),
			noTransportsScheduledForActivation = this.noTransportsScheduledForActivation();

		Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager.deactivateTransport()', 'transport = ' + transport);
		Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager.deactivateTransport()', 'state = ' + state + (wasActive ? '; was active' : wasPending ? '; was pending' : wasProposed ? '; was proposed' : '') + (noTransportsScheduledForActivation ? '' : '; another transport is scheduled for activation'));
		if(error && error.message)
			Logger.logAction(Logger.LOG_MICRO, 'ConnectionManager.deactivateTransport()', 'reason =  ' + error.message);

		if(wasActive) {
			Logger.logAction(Logger.LOG_MICRO, 'ConnectionManager.deactivateTransport()', 'Getting, clearing, and requeuing ' + this.activeProtocol.messageQueue.count() + ' pending messages');
			this.queuePendingMessages(currentProtocol.getPendingMessages());
			/* Clear any messages we requeue to allow the protocol to become idle.
			 * In case of an upgrade, this will trigger an immediate activation of
			 * the upgrade transport, so delay a tick so this transport can finish
			 * deactivating */
			Utils.nextTick(function() {
				currentProtocol.clearPendingMessages();
			});
			this.activeProtocol = this.host = null;
		}

		this.emit('transport.inactive', transport);

		/* this transport state change is a state change for the connectionmanager if
		 * - the transport was the active transport and there are no transports
		 *   which are connected and scheduled for activation, just waiting for the
		 *   active transport to finish what its doing; or
		 * - the transport was the active transport and the error was fatal (so
		 *   unhealable by another transport); or
		 * - there is no active transport, and this is the last remaining
		 *   pending transport (so we were in the connecting state)
		 */
		if((wasActive && noTransportsScheduledForActivation) ||
			(wasActive && (state === 'failed') || (state === 'closed')) ||
			(currentProtocol === null && wasPending && this.pendingTransports.length === 0)) {
			/* TODO remove below line once realtime sends token errors as DISCONNECTEDs */
			if(state === 'failed' && Auth.isTokenErr(error)) { state = 'disconnected' }
			this.notifyState({state: state, error: error});
		} else if(wasActive && (state === 'disconnected')) {
			/* If we were active but there is another transport scheduled for
			* activation, go into to the connecting state until that transport
			* activates and sets us back to connected. (manually starting the
			* transition timers in case that never happens) */
			Logger.logAction(Logger.LOG_MICRO, 'ConnectionManager.deactivateTransport()', 'wasActive but another transport is connected and scheduled for activation, so going into the connecting state until it activates');
			this.startSuspendTimer();
			this.startTransitionTimer(this.states.connecting);
			this.notifyState({state: 'connecting', error: error});
		}
	};

	/* Helper that returns true if there are no transports which are pending,
	* have been connected, and are just waiting for onceNoPending to fire before
	* being activated */
	ConnectionManager.prototype.noTransportsScheduledForActivation = function() {
		return Utils.isEmpty(this.pendingTransports) ||
			this.pendingTransports.every(function(transport) {
				return !transport.isConnected;
			});
	};

	/**
	 * Called when activating a new transport, to ensure message delivery
	 * on the new transport synchronises with the messages already received
	 */
	ConnectionManager.prototype.sync = function(transport, callback) {
		var timeout = setTimeout(function () {
			transport.off('sync');
			callback(new ErrorInfo('Timeout waiting for sync response', 50000, 500));
		}, this.options.timeouts.realtimeRequestTimeout);

		/* send sync request */
		var syncMessage = ProtocolMessage.fromValues({
			action: actions.SYNC,
			connectionKey: this.connectionKey,
			connectionSerial: this.connectionSerial
		});

		transport.send(syncMessage);

		transport.once('sync', function(connectionSerial, connectionId) {
			clearTimeout(timeout);
			callback(null, connectionSerial, connectionId);
		});
	};

	ConnectionManager.prototype.setConnection = function(connectionId, connectionKey, connectionSerial) {
		/* if connectionKey changes but connectionId stays the same, then just a
		 * transport change on the same connection. If connectionId changes, we're
		 * on a new connection, with implications for msgSerial and channel state */
		var self = this;
		connectionSerial = (connectionSerial === undefined) ? -1 : connectionSerial;
		/* Note that this is also run on clean connections; the msgSerial is a
		 * noop, but the channel reattach is needed for channels that were
		 * previously in the attached state even though the connection mode was
		 * 'clean' due to a freshness check - see https://github.com/ably/ably-js/issues/394 */
		if(this.connectionId !== connectionId)  {
			Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager.setConnection()', 'New connectionId; resetting msgSerial and reattaching any attached channels');
			this.msgSerial = 0;
			/* Wait till next tick before reattaching channels, so that connection
			 * state will be updated and so that it will be applied after
			 * Channels#onTransportUpdate, else channels will not have an ATTACHED
			 * sent twice (once from this and once from that). */
			Utils.nextTick(function() {
				self.realtime.channels.reattach();
			});
		} else {
			/* don't allow the connectionSerial in the CONNECTED to lower the stored
			 * connectionSerial, because messages can arrive on the upgrade transport
			 * (validly incrementing the stored connectionSerial) after it's been
			 * synced but before it gets activated */
			connectionSerial = (this.connectionSerial === undefined) ? connectionSerial : Math.max(connectionSerial, this.connectionSerial);
		}
		this.realtime.connection.id = this.connectionId = connectionId;
		this.realtime.connection.key = this.connectionKey = connectionKey;
		this.realtime.connection.serial = this.connectionSerial = connectionSerial;
		this.realtime.connection.recoveryKey = connectionKey + ':' + this.connectionSerial;
	};

	ConnectionManager.prototype.clearConnection = function() {
		this.realtime.connection.id = this.connectionId = undefined;
		this.realtime.connection.key = this.connectionKey = undefined;
		this.realtime.connection.serial = this.connectionSerial = undefined;
		this.realtime.connection.recoveryKey = null;
		this.msgSerial = 0;
		this.unpersistConnection();
	};

	ConnectionManager.prototype.checkConnectionStateFreshness = function() {
		if(!this.lastActivity || !this.connectionId) { return; }

		var sinceLast = Utils.now() - this.lastActivity;
		if(sinceLast > this.connectionStateTtl + this.maxIdleInterval) {
			Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager.checkConnectionStateFreshness()', 'Last known activity from realtime was ' + sinceLast + 'ms ago; discarding connection state');
			this.clearConnection();
			this.states.connecting.failState = 'suspended';
			this.states.connecting.queueEvents = false;
		}
	};

	/**
	 * Called when the connectionmanager wants to persist transport
	 * state for later recovery. Only applicable in the browser context.
	 */
	ConnectionManager.prototype.persistConnection = function() {
		if(haveSessionStorage && this.connectionKey && this.connectionSerial !== undefined) {
			setSessionRecoverData({
				recoveryKey: this.connectionKey + ':' + this.connectionSerial,
				disconnectedAt: Utils.now(),
				location: window.location,
				clientId: this.realtime.auth.clientId
			}, this.connectionStateTtl);
		}
	};

	/**
	 * Called when the connectionmanager wants to persist transport
	 * state for later recovery. Only applicable in the browser context.
	 */
	ConnectionManager.prototype.unpersistConnection = function() {
		clearSessionRecoverData();
	};

	/*********************
	 * state management
	 *********************/

	ConnectionManager.prototype.getStateError = function() {
		return ConnectionError[this.state.state];
	};

	ConnectionManager.prototype.activeState = function() {
		return this.state.queueEvents || this.state.sendEvents;
	};

	ConnectionManager.prototype.enactStateChange = function(stateChange) {
		var logLevel = stateChange.current === 'failed' ? Logger.LOG_ERROR : Logger.LOG_MAJOR;
		Logger.logAction(logLevel, 'Connection state', stateChange.current + (stateChange.reason ? ('; reason: ' + stateChange.reason.message + ', code: ' + stateChange.reason.code) : ''));
		Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager.enactStateChange', 'setting new state: ' + stateChange.current + '; reason = ' + (stateChange.reason && stateChange.reason.message));
		var newState = this.state = this.states[stateChange.current];
		if(stateChange.reason) {
			this.errorReason = stateChange.reason;
			this.realtime.connection.errorReason = stateChange.reason;
		}
		if(newState.terminal || newState.state === 'suspended') {
			/* suspended is nonterminal, but once in the suspended state, realtime
			 * will have discarded our connection state, so futher connection
			 * attempts should start from scratch */
			this.clearConnection();
		}
		this.emit('connectionstate', stateChange);
	};

	/****************************************
	 * ConnectionManager connection lifecycle
	 ****************************************/

	ConnectionManager.prototype.startTransitionTimer = function(transitionState) {
		Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager.startTransitionTimer()', 'transitionState: ' + transitionState.state);

		if(this.transitionTimer) {
			Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager.startTransitionTimer()', 'clearing already-running timer');
			clearTimeout(this.transitionTimer);
		}

		var self = this;
		this.transitionTimer = setTimeout(function() {
			if(self.transitionTimer) {
				self.transitionTimer = null;
				Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager ' + transitionState.state + ' timer expired', 'requesting new state: ' + transitionState.failState);
				self.notifyState({state: transitionState.failState});
			}
		}, transitionState.retryDelay);
	};

	ConnectionManager.prototype.cancelTransitionTimer = function() {
		Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager.cancelTransitionTimer()', '');
		if(this.transitionTimer) {
			clearTimeout(this.transitionTimer);
			this.transitionTimer = null;
		}
	};

	ConnectionManager.prototype.startSuspendTimer = function() {
		var self = this;
		if(this.suspendTimer)
			return;
		this.suspendTimer = setTimeout(function() {
			if(self.suspendTimer) {
				self.suspendTimer = null;
				Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager suspend timer expired', 'requesting new state: suspended');
				self.states.connecting.failState = 'suspended';
				self.states.connecting.queueEvents = false;
				self.notifyState({state: 'suspended'});
			}
		}, this.connectionStateTtl);
	};

	ConnectionManager.prototype.checkSuspendTimer = function(state) {
		if(state !== 'disconnected' && state !== 'suspended' && state !== 'connecting')
			this.cancelSuspendTimer();
	};

	ConnectionManager.prototype.cancelSuspendTimer = function() {
		this.states.connecting.failState = 'disconnected';
		this.states.connecting.queueEvents = true;
		if(this.suspendTimer) {
			clearTimeout(this.suspendTimer);
			this.suspendTimer = null;
		}
	};

	ConnectionManager.prototype.startRetryTimer = function(interval) {
		var self = this;
		this.retryTimer = setTimeout(function() {
			Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager retry timer expired', 'retrying');
			self.retryTimer = null;
			self.requestState({state: 'connecting'});
		}, interval);
	};

	ConnectionManager.prototype.cancelRetryTimer = function() {
		if(this.retryTimer) {
			clearTimeout(this.retryTimer);
			this.retryTimer = null;
		}
	};

	ConnectionManager.prototype.notifyState = function(indicated) {
		var state = indicated.state,
			self = this;

		/* We retry immediately if:
		 * - something disconnects us while we're connected, or
		 * - a viable (but not yet active) transport fails due to a token error (so
		 *   this.errorReason will be set, and startConnect will do a forced authorize) */
		var retryImmediately = (state === 'disconnected' &&
			(this.state === this.states.connected     ||
			 this.state === this.states.synchronizing ||
				(this.state === this.states.connecting  &&
					indicated.error && Auth.isTokenErr(indicated.error))));

		Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager.notifyState()', 'new state: ' + state + (retryImmediately ? '; will retry connection immediately' : ''));
		/* do nothing if we're already in the indicated state */
		if(state == this.state.state)
			return;

		/* kill timers (possibly excepting suspend timer depending on the notified
		* state), as these are superseded by this notification */
		this.cancelTransitionTimer();
		this.cancelRetryTimer();
		this.checkSuspendTimer(indicated.state);

		/* do nothing if we're unable to move from the current state */
		if(this.state.terminal)
			return;

		/* process new state */
		var newState = this.states[indicated.state],
			change = new ConnectionStateChange(this.state.state, newState.state, newState.retryDelay, (indicated.error || ConnectionError[newState.state]));

		if(retryImmediately) {
			var autoReconnect = function() {
				if(self.state === self.states.disconnected) {
					self.lastAutoReconnectAttempt = Utils.now();
					self.requestState({state: 'connecting'});
				}
			};
			var sinceLast = this.lastAutoReconnectAttempt && (Utils.now() - this.lastAutoReconnectAttempt + 1);
			if(sinceLast && (sinceLast < 1000)) {
				Logger.logAction(Logger.LOG_MICRO, 'ConnectionManager.notifyState()', 'Last reconnect attempt was only ' + sinceLast + 'ms ago, waiting another ' + (1000 - sinceLast) + 'ms before trying again');
				setTimeout(autoReconnect, 1000 - sinceLast);
			} else {
				Utils.nextTick(autoReconnect);
			}
		} else if(state === 'disconnected' || state === 'suspended') {
			this.startRetryTimer(newState.retryDelay);
		}

		 /* If going into disconnect/suspended (and not retrying immediately), or a
			* terminal state, ensure there are no orphaned transports hanging around. */
		if((state === 'disconnected' && !retryImmediately) ||
			 (state === 'suspended') ||
			 newState.terminal) {
				 /* Wait till the next tick so the connection state change is enacted,
				 * so aborting transports doesn't trigger redundant state changes */
				 Utils.nextTick(function() {
					 self.disconnectAllTransports();
				 });
		 }

		if(state == 'connected' && !this.activeProtocol) {
			Logger.logAction(Logger.LOG_ERROR, 'ConnectionManager.notifyState()', 'Broken invariant: attempted to go into connected state, but there is no active protocol');
		}

		/* implement the change and notify */
		this.enactStateChange(change);
		if(this.state.sendEvents) {
			this.sendQueuedMessages();
		} else if(!this.state.queueEvents) {
			this.realtime.channels.propogateConnectionInterruption(state, change.reason);
			this.failQueuedMessages(change.reason); // RTN7c
		}
	};

	ConnectionManager.prototype.requestState = function(request) {
		var state = request.state, self = this;
		Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager.requestState()', 'requested state: ' + state + '; current state: ' + this.state.state);
		if(state == this.state.state)
			return; /* silently do nothing */

		/* kill running timers, as this request supersedes them */
		this.cancelTransitionTimer();
		this.cancelRetryTimer();
		/* for suspend timer check rather than cancel -- eg requesting a connecting
		* state should not reset the suspend timer */
		this.checkSuspendTimer(state);

		if(state == 'connecting' && this.state.state == 'connected') return;
		if(state == 'closing' && this.state.state == 'closed') return;

		var newState = this.states[state],
			change = new ConnectionStateChange(this.state.state, newState.state, null, (request.error || ConnectionError[newState.state]));

		this.enactStateChange(change);

		if(state == 'connecting') {
			Utils.nextTick(function() { self.startConnect(); });
		}
		if(state == 'closing') {
			this.closeImpl();
		}
	};


	ConnectionManager.prototype.startConnect = function() {
		if(this.state !== this.states.connecting) {
			Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager.startConnect()', 'Must be in connecting state to connect, but was ' + this.state.state);
			return;
		}

		var auth = this.realtime.auth,
			self = this;

		var connect = function() {
			self.checkConnectionStateFreshness();
			self.getTransportParams(function(transportParams) {
				self.connectImpl(transportParams);
			});
		};

		Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager.startConnect()', 'starting connection');
		this.startSuspendTimer();
		this.startTransitionTimer(this.states.connecting);

		if(auth.method === 'basic') {
			connect();
		} else {
			var authCb = function(err) {
				if(err) {
					self.actOnErrorFromAuthorize(err);
				} else {
					connect();
				}
			};
			if(this.errorReason && Auth.isTokenErr(this.errorReason)) {
				/* Force a refetch of a new token */
				auth._forceNewToken(null, null, authCb);
			} else {
				auth._ensureValidAuthCredentials(authCb);
			}
		}
	};


	/**
	 * There are three stages in connecting:
	 * - preference: if there is a cached transport preference, we try to connect
	 *   on that. If that fails or times out we abort the attempt, remove the
	 *   preference and fall back to base. If it succeeds, we try upgrading it if
	 *   needed (will only be in the case where the preference is xhrs and the
	 *   browser supports ws).
	 * - base: we try to connect with the best transport that we think will
	 *   never fail for this browser (usually this is xhr_polling; for very old
	 *   browsers will be jsonp, for node will be comet). If it doesn't work, we
	 *   try fallback hosts.
	 * - upgrade: given a connected transport, we see if there are any better
	 *   ones, and if so, try to upgrade to them.
	 *
	 * connectImpl works out what stage you're at (which is purely a function of
	 * the current connection state and whether there are any stored preferences),
	 * and dispatches accordingly. After a transport has been set pending,
	 * tryATransport calls connectImpl to see if there's another stage to be done.
	 * */
	ConnectionManager.prototype.connectImpl = function(transportParams) {
		var state = this.state.state;

		if(state !== this.states.connecting.state && state !== this.states.connected.state) {
			/* Only keep trying as long as in the 'connecting' state (or 'connected'
			 * for upgrading). Any operation can put us into 'disconnected' to cancel
			 * connection attempts and wait before retrying, or 'failed' to fail. */
			Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager.connectImpl()', 'Must be in connecting state to connect (or connected to upgrade), but was ' + state);
		} else if(this.pendingTransports.length) {
			Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager.connectImpl()', 'Transports ' + this.pendingTransports[0].toString() + ' currently pending; taking no action');
		} else if(state == this.states.connected.state) {
			this.upgradeIfNeeded(transportParams);
		} else if(this.transports.length > 1 && this.getTransportPreference()) {
			this.connectPreference(transportParams);
		} else {
			this.connectBase(transportParams);
		}
	};


	ConnectionManager.prototype.connectPreference = function(transportParams) {
		var preference = this.getTransportPreference(),
			self = this,
			preferenceTimeoutExpired = false;

		if(!Utils.arrIn(this.transports, preference)) {
			this.unpersistTransportPreference();
			this.connectImpl(transportParams);
		}

		Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager.connectPreference()', 'Trying to connect with stored transport preference ' + preference);

		var preferenceTimeout = setTimeout(function() {
			preferenceTimeoutExpired = true;
			if(!(self.state.state === self.states.connected.state)) {
				Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager.connectPreference()', 'Shortcircuit connection attempt with ' + preference + ' failed; clearing preference and trying from scratch');
				/* Abort all connection attempts. (This also disconnects the active
				 * protocol, but none exists if we're not in the connected state) */
				self.disconnectAllTransports();
				/* Be quite agressive about clearing the stored preference if ever it doesn't work */
				self.unpersistTransportPreference();
			}
			self.connectImpl(transportParams);
		}, this.options.timeouts.preferenceConnectTimeout);

		/* For connectPreference, just use the main host. If host fallback is needed, do it in connectBase.
		 * The wstransport it will substitute the httphost for an appropriate wshost */
		transportParams.host = self.httpHosts[0];
		self.tryATransport(transportParams, preference, function(fatal, transport) {
			clearTimeout(preferenceTimeout);
			if(preferenceTimeoutExpired && transport) {
				/* Viable, but too late - connectImpl() will already be trying
				* connectBase, and we weren't in upgrade mode. Just remove the
				* onconnected listener and get rid of it */
				transport.off();
				transport.disconnect();
				Utils.arrDeleteValue(this.pendingTransports, transport);
			} else if(!transport && !fatal) {
				/* Preference failed in a transport-specific way. Try more */
				self.unpersistTransportPreference();
				self.connectImpl(transportParams);
			}
			/* If suceeded, or failed fatally, nothing to do */
		});
	};


	/**
	 * Try to establish a transport on the base transport (the best transport
	 * such that if it doesn't work, nothing will work) as determined through
	 * static feature detection, checking for network connectivity and trying
	 * fallback hosts if applicable.
	 * @param transportParams
	 */
	ConnectionManager.prototype.connectBase = function(transportParams) {
		var self = this,
			giveUp = function(err) {
				self.notifyState({state: self.states.connecting.failState, error: err});
			},
			candidateHosts = this.httpHosts.slice(),
			hostAttemptCb = function(fatal, transport) {
				if(!transport && !fatal) {
					tryFallbackHosts();
				}
			};

		Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager.connectBase()', 'Trying to connect with base transport ' + this.baseTransport);

		/* first try to establish a connection with the priority host with http transport */
		var host = candidateHosts.shift();
		if(!host) {
			giveUp(new ErrorInfo('Unable to connect (no available host)', 80000, 404));
			return;
		}
		transportParams.host = host;

		/* this is what we'll be doing if the attempt for the main host fails */
		function tryFallbackHosts() {
			/* if there aren't any fallback hosts, fail */
			if(!candidateHosts.length) {
				giveUp(new ErrorInfo('Unable to connect (and no more fallback hosts to try)', 80000, 404));
				return;
			}
			/* before trying any fallback (or any remaining fallback) we decide if
			 * there is a problem with the ably host, or there is a general connectivity
			 * problem */
			Http.checkConnectivity(function(err, connectivity) {
				/* we know err won't happen but handle it here anyway */
				if(err) {
					giveUp(err);
					return;
				}
				if(!connectivity) {
					/* the internet isn't reachable, so don't try the fallback hosts */
					giveUp(new ErrorInfo('Unable to connect (network unreachable)', 80000, 404));
					return;
				}
				/* the network is there, so there's a problem with the main host, or
				 * its dns. Try the fallback hosts. We could try them simultaneously but
				 * that would potentially cause a huge spike in load on the load balancer */
				transportParams.host = Utils.arrPopRandomElement(candidateHosts);
				self.tryATransport(transportParams, self.baseTransport, hostAttemptCb);
			});
		}

		this.tryATransport(transportParams, this.baseTransport, hostAttemptCb);
	};


	ConnectionManager.prototype.getUpgradePossibilities = function() {
		/* returns the subset of upgradeTransports to the right of the current
		 * transport in upgradeTransports (if it's in there - if not, currentPosition
		 * will be -1, so return upgradeTransports.slice(0) == upgradeTransports */
		var current = this.activeProtocol.getTransport().shortName;
		var currentPosition = Utils.arrIndexOf(this.upgradeTransports, current);
		return this.upgradeTransports.slice(currentPosition + 1);
	};


	ConnectionManager.prototype.upgradeIfNeeded = function(transportParams) {
		var upgradePossibilities = this.getUpgradePossibilities(),
			self = this;
		Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager.upgradeIfNeeded()', 'upgrade possibilities: ' + Utils.inspect(upgradePossibilities));

		if(!upgradePossibilities.length) {
			return;
		}

		Utils.arrForEach(upgradePossibilities, function(upgradeTransport) {
			/* Note: the transport may mutate the params, so give each transport a fresh one */
			var upgradeTransportParams = new TransportParams(self.options, transportParams.host, 'upgrade', self.connectionKey);
			self.tryATransport(upgradeTransportParams, upgradeTransport, noop);
		});
	};


	ConnectionManager.prototype.closeImpl = function() {
		Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager.closeImpl()', 'closing connection');
		this.cancelSuspendTimer();
		this.startTransitionTimer(this.states.closing);

		Utils.safeArrForEach(this.pendingTransports, function(transport) {
			Logger.logAction(Logger.LOG_MICRO, 'ConnectionManager.closeImpl()', 'Closing pending transport: ' + transport);
			if(transport) transport.close();
		});

		Utils.safeArrForEach(this.proposedTransports, function(transport) {
			Logger.logAction(Logger.LOG_MICRO, 'ConnectionManager.closeImpl()', 'Disposing of proposed transport: ' + transport);
			if(transport) transport.dispose();
		});

		if(this.activeProtocol) {
			Logger.logAction(Logger.LOG_MICRO, 'ConnectionManager.closeImpl()', 'Closing active transport: ' + this.activeProtocol.getTransport());
			this.activeProtocol.getTransport().close();
		}

		/* If there was an active transport, this will probably be
		 * preempted by the notifyState call in deactivateTransport */
		this.notifyState({state: 'closed'});
	};

	ConnectionManager.prototype.onAuthUpdated = function(tokenDetails, callback) {
		var self = this;
		switch(this.state.state) {
			case 'connected':
				Logger.logAction(Logger.LOG_MICRO, 'ConnectionManager.onAuthUpdated()', 'Sending AUTH message on active transport');
				/* If there are any proposed/pending transports (eg an upgrade that
				 * isn't yet scheduled for activation) that hasn't yet started syncing,
				 * just to get rid of them & restart the upgrade with the new token, to
				 * avoid a race condition. (If it has started syncing, the AUTH will be
				 * queued until the upgrade is complete, so everything's fine) */
				if((this.pendingTransports.length || this.proposedTransports.length) &&
					self.state !== self.states.synchronizing) {
					this.disconnectAllTransports(/* exceptActive: */true);
					var transportParams = this.activeProtocol.getTransport().params;
					Utils.nextTick(function() {
						if(self.state.state === 'connected') {
							self.upgradeIfNeeded(transportParams);
						}
					});
				}

				/* Do any transport-specific new-token action */
				this.activeProtocol.getTransport().onAuthUpdated(tokenDetails);

				var authMsg = ProtocolMessage.fromValues({
					action: actions.AUTH,
					auth: {
						accessToken: tokenDetails.token
					}
				});
				this.send(authMsg);

				/* The answer will come back as either a connectiondetails event
				 * (realtime sends a CONNECTED to asknowledge the reauth) or a
				 * statechange to failed */
				var successListener = function() {
					self.off(failureListener);
					callback(null, tokenDetails);
				};
				var failureListener = function(stateChange) {
					if(stateChange.current === 'failed') {
						self.off(successListener);
						self.off(failureListener);
						callback(stateChange.reason || self.getStateError());
					}
				};
				this.once('connectiondetails', successListener);
				this.on('connectionstate', failureListener);
				break;

			case 'connecting':
				Logger.logAction(Logger.LOG_MICRO, 'ConnectionManager.onAuthUpdated()',
					'Aborting current connection attempts in order to start again with the new auth details');
				this.disconnectAllTransports();
				/* fallthrough to add statechange listener */

			default:
				Logger.logAction(Logger.LOG_MICRO, 'ConnectionManager.onAuthUpdated()',
					'Connection state is ' + this.state.state + '; waiting until either connected or failed');
				var listener = function(stateChange) {
					switch(stateChange.current) {
						case 'connected':
							self.off(listener);
							callback(null, tokenDetails);
							break;
						case 'failed':
						case 'closed':
						case 'suspended':
							self.off(listener);
							callback(stateChange.reason || self.getStateError());
							break;
						default:
							/* ignore till we get either connected or failed */
							break;
					}
				};
				self.on('connectionstate', listener);
				if(this.state.state === 'connecting') {
					/* can happen if in the connecting state but no transport was pending
					 * yet, so disconnectAllTransports did not trigger a disconnected state */
					self.startConnect();
				} else {
					self.requestState({state: 'connecting'});
				}
		}
	};

	ConnectionManager.prototype.disconnectAllTransports = function(exceptActive) {
		Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager.disconnectAllTransports()', 'Disconnecting all transports' + (exceptActive ? ' except the active transport' : ''));

		Utils.safeArrForEach(this.pendingTransports, function(transport) {
			Logger.logAction(Logger.LOG_MICRO, 'ConnectionManager.disconnectAllTransports()', 'Disconnecting pending transport: ' + transport);
			if(transport) transport.disconnect();
		});
		this.pendingTransports = [];

		Utils.safeArrForEach(this.proposedTransports, function(transport) {
			Logger.logAction(Logger.LOG_MICRO, 'ConnectionManager.disconnectAllTransports()', 'Disposing of proposed transport: ' + transport);
			if(transport) transport.dispose();
		});
		this.proposedTransports = [];

		if(this.activeProtocol && !exceptActive) {
			Logger.logAction(Logger.LOG_MICRO, 'ConnectionManager.disconnectAllTransports()', 'Disconnecting active transport: ' + this.activeProtocol.getTransport());
			this.activeProtocol.getTransport().disconnect();
		}
		/* No need to notify state disconnected; disconnecting the active transport
		 * will have that effect */
	};

	/******************
	 * event queueing
	 ******************/

	ConnectionManager.prototype.send = function(msg, queueEvent, callback) {
		callback = callback || noop;
		var state = this.state;

		if(state.sendEvents) {
			Logger.logAction(Logger.LOG_MICRO, 'ConnectionManager.send()', 'sending event');
			this.sendImpl(new PendingMessage(msg, callback));
			return;
		}
		var shouldQueue = (queueEvent && state.queueEvents) || state.forceQueueEvents;
		if(!shouldQueue) {
			var err = 'rejecting event, queueEvent was ' + queueEvent + ', state was ' + state.state;
			Logger.logAction(Logger.LOG_MICRO, 'ConnectionManager.send()', err);
			callback(this.errorReason || new ErrorInfo(err, 90000, 400));
			return;
		}
		if(Logger.shouldLog(Logger.LOG_MICRO)) {
			Logger.logAction(Logger.LOG_MICRO, 'ConnectionManager.send()', 'queueing msg; ' + ProtocolMessage.stringify(msg));
		}
		this.queue(msg, callback);
	};

	ConnectionManager.prototype.sendImpl = function(pendingMessage) {
		var msg = pendingMessage.message;
		/* If have already attempted to send this, resend with the same msgSerial,
		 * so Ably can dedup if the previous send succeeded */
		if(pendingMessage.ackRequired && !pendingMessage.sendAttempted) {
			msg.msgSerial = this.msgSerial++;
		}
		try {
			this.activeProtocol.send(pendingMessage);
		} catch(e) {
			Logger.logAction(Logger.LOG_ERROR, 'ConnectionManager.sendImpl()', 'Unexpected exception in transport.send(): ' + e.stack);
		}
	};

	ConnectionManager.prototype.queue = function(msg, callback) {
		Logger.logAction(Logger.LOG_MICRO, 'ConnectionManager.queue()', 'queueing event');
		var lastQueued = this.queuedMessages.last();
		/* If have already attempted to send a message, don't merge more messages
		 * into it, as if the previous send actually succeeded and realtime ignores
		 * the dup, they'll be lost */
		if(lastQueued && !lastQueued.sendAttempted && RealtimeChannel.mergeTo(lastQueued.message, msg)) {
			if(!lastQueued.merged) {
				lastQueued.callback = Multicaster([lastQueued.callback]);
				lastQueued.merged = true;
			}
			lastQueued.callback.push(callback);
		} else {
			this.queuedMessages.push(new PendingMessage(msg, callback));
		}
	};

	ConnectionManager.prototype.sendQueuedMessages = function() {
		Logger.logAction(Logger.LOG_MICRO, 'ConnectionManager.sendQueuedMessages()', 'sending ' + this.queuedMessages.count() + ' queued messages');
		var pendingMessage;
		while(pendingMessage = this.queuedMessages.shift())
			this.sendImpl(pendingMessage);
	};

	ConnectionManager.prototype.queuePendingMessages = function(pendingMessages) {
		if(pendingMessages && pendingMessages.length) {
			Logger.logAction(Logger.LOG_MICRO, 'ConnectionManager.queuePendingMessages()', 'queueing ' + pendingMessages.length + ' pending messages');
			this.queuedMessages.prepend(pendingMessages);
		}
	};

	ConnectionManager.prototype.failQueuedMessages = function(err) {
		Logger.logAction(Logger.LOG_MICRO, 'ConnectionManager.failQueuedMessages()', 'failing ' + this.queuedMessages.count() + ' queued messages');
		this.queuedMessages.completeAllMessages(err);
	};

	ConnectionManager.prototype.onChannelMessage = function(message, transport) {
		var onActiveTransport = this.activeProtocol && transport === this.activeProtocol.getTransport(),
			onUpgradeTransport = Utils.arrIn(this.pendingTransports, transport) && this.state == this.states.synchronizing;

		/* As the lib now has a period where the upgrade transport is synced but
		 * before it's become active (while waiting for the old one to become
		 * idle), message can validly arrive on it even though it isn't active */
		if(onActiveTransport || onUpgradeTransport) {
			var connectionSerial = message.connectionSerial;
			if(connectionSerial <= this.connectionSerial) {
				Logger.logAction(Logger.LOG_MICRO, 'ConnectionManager.onChannelMessage() received message with connectionSerial ' + connectionSerial + ', but current connectionSerial is ' + this.connectionSerial + '; assuming message is a duplicate and discarding it');
				return;
			}
			if(connectionSerial !== undefined) {
				this.realtime.connection.serial = this.connectionSerial = connectionSerial;
				this.realtime.connection.recoveryKey = this.connectionKey + ':' + connectionSerial;
			}
			this.realtime.channels.onChannelMessage(message);
		} else {
			// Message came in on a defunct transport. Allow only acks, nacks, & errors for outstanding
			// messages,  no new messages (as sync has been sent on new transport so new messages will
			// be resent there, or connection has been closed so don't want new messages)
			if(Utils.arrIndexOf([actions.ACK, actions.NACK, actions.ERROR], message.action) > -1) {
				this.realtime.channels.onChannelMessage(message);
			} else {
				Logger.logAction(Logger.LOG_MICRO, 'ConnectionManager.onChannelMessage()', 'received message ' + JSON.stringify(message) + 'on defunct transport; discarding');
			}
		}
	};

	ConnectionManager.prototype.ping = function(transport, callback) {
		/* if transport is specified, try that */
		if(transport) {
			Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager.ping()', 'transport = ' + transport);

			var onTimeout = function () {
				transport.off('heartbeat', onHeartbeat);
				callback(new ErrorInfo('Timeout waiting for heartbeat response', 50000, 500));
			};

			var pingStart = Utils.now(),
				id = Utils.randStr();

			var onHeartbeat = function (responseId) {
				if(responseId === id) {
					clearTimeout(timer);
					var responseTime = Utils.now() - pingStart;
					callback(null, responseTime);
				}
			};

			var timer = setTimeout(onTimeout, this.options.timeouts.realtimeRequestTimeout);

			transport.once('heartbeat', onHeartbeat);
			transport.ping(id);
			return;
		}

		/* if we're not connected, don't attempt */
		if(this.state.state !== 'connected') {
			callback(new ErrorInfo('Unable to ping service; not connected', 40000, 400));
			return;
		}

		/* no transport was specified, so use the current (connected) one
		 * but ensure that we retry if the transport is superseded before we complete */
		var completed = false, self = this;

		var onPingComplete = function(err, responseTime) {
			self.off('transport.active', onTransportActive);
			if(!completed) {
				completed = true;
				callback(err, responseTime);
			}
		};

		var onTransportActive = function() {
			if(!completed) {
				/* ensure that no callback happens for the currently outstanding operation */
				completed = true;
				/* repeat but picking up the new transport */
				Utils.nextTick(function() {
					self.ping(null, callback);
				});
			}
		};

		this.on('transport.active', onTransportActive);
		this.ping(this.activeProtocol.getTransport(), onPingComplete);
	};

	ConnectionManager.prototype.abort = function(error) {
		this.activeProtocol.getTransport().fail(error);
	};

	ConnectionManager.prototype.registerProposedTransport = function(transport) {
		this.proposedTransports.push(transport);
	};

	ConnectionManager.prototype.getTransportPreference = function() {
		return this.transportPreference || (haveWebStorage && WebStorage.get(transportPreferenceName));
	};

	ConnectionManager.prototype.persistTransportPreference = function(transport) {
		if(Utils.arrIn(Defaults.upgradeTransports, transport.shortName)) {
			this.transportPreference = transport.shortName;
			if(haveWebStorage) {
				WebStorage.set(transportPreferenceName, transport.shortName);
			}
		}
	};

	ConnectionManager.prototype.unpersistTransportPreference = function() {
		this.transportPreference = null;
		if(haveWebStorage) {
			WebStorage.remove(transportPreferenceName);
		}
	};

	ConnectionManager.prototype.actOnErrorFromAuthorize = function(err) {
		if(err.code === 40170) {
			/* Special-case problems with the client auth callback - unlike other
			 * auth errors these may be nonfatal. (RSA4c) */
			err.code = 80019;
			this.notifyState({state: this.state.failState, error: err});
		} else {
			this.notifyState({state: 'failed', error: err});
		}
	};

	ConnectionManager.prototype.onConnectionDetailsUpdate = function(connectionDetails, transport) {
		if(!connectionDetails) {
			return;
		}
		var clientId = connectionDetails.clientId;
		if(clientId) {
			var err = this.realtime.auth._uncheckedSetClientId(clientId);
			if(err) {
				Logger.logAction(Logger.LOG_ERROR, 'ConnectionManager.onConnectionDetailsUpdate()', err.message);
				/* Errors setting the clientId are fatal to the connection */
				transport.fail(err);
				return;
			}
		}
		var connectionStateTtl = connectionDetails.connectionStateTtl;
		if(connectionStateTtl) {
			this.connectionStateTtl = connectionStateTtl;
		}
		this.maxIdleInterval = connectionDetails.maxIdleInterval;
		this.emit('connectiondetails', connectionDetails);
	};

	return ConnectionManager;
})();

var Transport = (function() {
	var actions = ProtocolMessage.Action;
	var closeMessage = ProtocolMessage.fromValues({action: actions.CLOSE});
	var disconnectMessage = ProtocolMessage.fromValues({action: actions.DISCONNECT});
	var noop = function() {};

	/*
	 * EventEmitter, generates the following events:
	 *
	 * event name       data
	 * closed           error
	 * failed           error
	 * disposed
	 * connected        null error, connectionKey
	 * event            channel message object
	 */

	/* public constructor */
	function Transport(connectionManager, auth, params) {
		EventEmitter.call(this);
		this.connectionManager = connectionManager;
		connectionManager.registerProposedTransport(this);
		this.auth = auth;
		this.params = params;
		this.timeouts = params.options.timeouts;
		this.format = params.format;
		this.isConnected = false;
		this.isFinished = false;
		this.maxIdleInterval = null;
		this.idleTimer = null;
		this.lastActivity = null;
	}
	Utils.inherits(Transport, EventEmitter);

	Transport.prototype.connect = function() {};

	Transport.prototype.close = function() {
		if(this.isConnected) {
			this.requestClose();
		}
		this.finish('closed', ConnectionError.closed);
	};

	Transport.prototype.disconnect = function(err) {
		/* Used for network/transport issues that need to result in the transport
		 * being disconnected, but should not affect the connection */
		if(this.isConnected) {
			this.requestDisconnect();
		}
		this.finish('disconnected', err || ConnectionError.disconnected);
	};

	Transport.prototype.fail = function(err) {
		/* Used for client-side-detected fatal connection issues */
		if(this.isConnected) {
			this.requestDisconnect();
		}
		this.finish('failed', err || ConnectionError.failed);
	};

	Transport.prototype.finish = function(event, err) {
		if(this.isFinished) {
			return;
		}

		this.isFinished = true;
		this.isConnected = false;
		this.maxIdleInterval = null;
		clearTimeout(this.idleTimer);
		this.idleTimer = null;
		this.emit(event, err);
		this.dispose();
	};

	Transport.prototype.onProtocolMessage = function(message) {
		if (Logger.shouldLog(Logger.LOG_MICRO)) {
			Logger.logAction(Logger.LOG_MICRO, 'Transport.onProtocolMessage()', 'received on ' + this.shortName + ': ' + ProtocolMessage.stringify(message));
		}
		this.lastActivity = this.connectionManager.lastActivity = Utils.now();
		if(this.maxIdleInterval) {
			this.setIdleTimer();
		}

		switch(message.action) {
		case actions.HEARTBEAT:
			Logger.logAction(Logger.LOG_MICRO, 'Transport.onProtocolMessage()', this.shortName + ' heartbeat; connectionKey = ' + this.connectionManager.connectionKey);
			this.emit('heartbeat', message.id);
			break;
		case actions.CONNECTED:
			this.onConnect(message);
			this.emit('connected', message.error, (message.connectionDetails ? message.connectionDetails.connectionKey : message.connectionKey), message.connectionSerial, message.connectionId, message.connectionDetails);
			break;
		case actions.CLOSED:
			this.onClose(message);
			break;
		case actions.DISCONNECTED:
			this.onDisconnect(message);
			break;
		case actions.ACK:
			this.emit('ack', message.msgSerial, message.count);
			break;
		case actions.NACK:
			this.emit('nack', message.msgSerial, message.count, message.error);
			break;
		case actions.SYNC:
			if(message.connectionId !== undefined) {
				/* a transport SYNC */
				this.emit('sync', message.connectionSerial, message.connectionId);
				break;
			}
			/* otherwise it's a channel SYNC, so handle it in the channel */
			this.connectionManager.onChannelMessage(message, this);
			break;
		case actions.AUTH:
			this.auth.authorize(function(err) {
				if(err) {
					Logger.logAction(Logger.LOG_ERROR, 'Transport.onProtocolMessage()', 'Ably requested re-authentication, but unable to obtain a new token: ' + Utils.inspectError(err));
				}
			});
			break;
		case actions.ERROR:
			Logger.logAction(Logger.LOG_MINOR, 'Transport.onProtocolMessage()', 'received error action; connectionKey = ' + this.connectionManager.connectionKey + '; err = ' + Utils.inspect(message.error) + (message.channel ? (', channel: ' +  message.channel) : ''));
			if(message.channel === undefined) {
				this.onFatalError(message);
				break;
			}
			/* otherwise it's a channel-specific error, so handle it in the channel */
			this.connectionManager.onChannelMessage(message, this);
			break;
		default:
			/* all other actions are channel-specific */
			this.connectionManager.onChannelMessage(message, this);
		}
	};

	Transport.prototype.onConnect = function(message) {
		this.isConnected = true;
		var maxPromisedIdle = message.connectionDetails.maxIdleInterval;
		if(maxPromisedIdle) {
			this.maxIdleInterval = maxPromisedIdle + this.timeouts.realtimeRequestTimeout;
			this.setIdleTimer();
		}
		/* else Realtime declines to guarantee any maximum idle interval - CD2h */
	};

	Transport.prototype.onDisconnect = function(message) {
		/* Used for when the server has disconnected the client (usually with a
		 * DISCONNECTED action) */
		var err = message && message.error;
		Logger.logAction(Logger.LOG_MINOR, 'Transport.onDisconnect()', 'err = ' + Utils.inspectError(err));
		this.finish('disconnected', err);
	};

	Transport.prototype.onFatalError = function(message) {
		/* On receipt of a fatal connection error, we can assume that the server
		 * will close the connection and the transport, and do not need to request
		 * a disconnection - RTN15i */
		var err = message && message.error;
		Logger.logAction(Logger.LOG_MINOR, 'Transport.onFatalError()', 'err = ' + Utils.inspectError(err));
		this.finish('failed', err);
	};

	Transport.prototype.onClose = function(message) {
		var err = message && message.error;
		Logger.logAction(Logger.LOG_MINOR, 'Transport.onClose()', 'err = ' + Utils.inspectError(err));
		this.finish('closed', err);
	};

	Transport.prototype.requestClose = function() {
		Logger.logAction(Logger.LOG_MINOR, 'Transport.requestClose()', '');
		this.send(closeMessage);
	};

	Transport.prototype.requestDisconnect = function() {
		Logger.logAction(Logger.LOG_MINOR, 'Transport.requestDisconnect()', '');
		this.send(disconnectMessage);
	};

	Transport.prototype.ping = function(id) {
		var msg = {action: ProtocolMessage.Action.HEARTBEAT};
		if(id) msg.id = id;
		this.send(ProtocolMessage.fromValues(msg));
	};

	Transport.prototype.dispose = function() {
		Logger.logAction(Logger.LOG_MINOR, 'Transport.dispose()', '');
		this.off();
	};

	Transport.prototype.setIdleTimer = function(timeout) {
		var self = this;
		if(!this.idleTimer) {
			this.idleTimer = setTimeout(function() {
				self.onIdleTimerExpire();
			}, timeout || this.maxIdleInterval);
		}
	};

	Transport.prototype.onIdleTimerExpire = function() {
		this.idleTimer = null;
		var sinceLast = Utils.now() - this.lastActivity,
			timeRemaining = this.maxIdleInterval - sinceLast;
		if(timeRemaining <= 0) {
			var msg = 'No activity seen from realtime in ' + sinceLast + 'ms; assuming connection has dropped';
			Logger.logAction(Logger.LOG_ERROR, 'Transport.onIdleTimerExpire()', msg);
			this.disconnect(new ErrorInfo(msg, 80003, 408));
		} else {
			this.setIdleTimer(timeRemaining + 10);
		}
	};

	Transport.prototype.onAuthUpdated = function() {};

	return Transport;
})();

var WebSocketTransport = (function() {
	var WebSocket = Platform.WebSocket;
	var shortName = 'web_socket';

	/* public constructor */
	function WebSocketTransport(connectionManager, auth, params) {
		this.shortName = shortName;
		/* If is a browser, can't detect pings, so request protocol heartbeats */
		params.heartbeats = Platform.useProtocolHeartbeats;
		Transport.call(this, connectionManager, auth, params);
		this.wsHost = Defaults.getHost(params.options, params.host, true);
	}
	Utils.inherits(WebSocketTransport, Transport);

	WebSocketTransport.isAvailable = function() {
		return !!WebSocket;
	};

	if(WebSocketTransport.isAvailable())
		ConnectionManager.supportedTransports[shortName] = WebSocketTransport;

	WebSocketTransport.tryConnect = function(connectionManager, auth, params, callback) {
		var transport = new WebSocketTransport(connectionManager, auth, params);
		var errorCb = function(err) { callback({event: this.event, error: err}); };
		transport.on(['failed', 'disconnected'], errorCb);
		transport.on('wsopen', function() {
			Logger.logAction(Logger.LOG_MINOR, 'WebSocketTransport.tryConnect()', 'viable transport ' + transport);
			transport.off(['failed', 'disconnected'], errorCb);
			callback(null, transport);
		});
		transport.connect();
	};

	WebSocketTransport.prototype.createWebSocket = function(uri, connectParams) {
		var paramCount = 0;
		if(connectParams) {
			for(var key in connectParams)
				uri += (paramCount++ ? '&' : '?') + key + '=' + connectParams[key];
		}
		this.uri = uri;
		return new WebSocket(uri);
	};

	WebSocketTransport.prototype.toString = function() {
		return 'WebSocketTransport; uri=' + this.uri;
	};

	WebSocketTransport.prototype.connect = function() {
		Logger.logAction(Logger.LOG_MINOR, 'WebSocketTransport.connect()', 'starting');
		Transport.prototype.connect.call(this);
		var self = this, params = this.params, options = params.options;
		var wsScheme = options.tls ? 'wss://' : 'ws://';
		var wsUri = wsScheme + this.wsHost + ':' + Defaults.getPort(options) + '/';
		Logger.logAction(Logger.LOG_MINOR, 'WebSocketTransport.connect()', 'uri: ' + wsUri);
		this.auth.getAuthParams(function(err, authParams) {
			var paramStr = ''; for(var param in authParams) paramStr += ' ' + param + ': ' + authParams[param] + ';';
			Logger.logAction(Logger.LOG_MINOR, 'WebSocketTransport.connect()', 'authParams:' + paramStr + ' err: ' + err);
			if(err) {
				self.disconnect(err);
				return;
			}
			var connectParams = params.getConnectParams(authParams);
			try {
				var wsConnection = self.wsConnection = self.createWebSocket(wsUri, connectParams);
				wsConnection.binaryType = Platform.binaryType;
				wsConnection.onopen = function() { self.onWsOpen(); };
				wsConnection.onclose = function(ev) { self.onWsClose(ev); };
				wsConnection.onmessage = function(ev) { self.onWsData(ev.data); };
				wsConnection.onerror = function(ev) { self.onWsError(ev); };
				if(wsConnection.on) {
					/* node; browsers currently don't have a general eventemitter and can't detect
					 * pings. Also, no need to reply with a pong explicitly, ws lib handles that */
					wsConnection.on('ping', function() { self.setIdleTimer() });
				}
			} catch(e) {
				Logger.logAction(Logger.LOG_ERROR, 'WebSocketTransport.connect()', 'Unexpected exception creating websocket: err = ' + (e.stack || e.message));
				self.disconnect(e);
			}
		});
	};

	WebSocketTransport.prototype.send = function(message) {
		var wsConnection = this.wsConnection;
		if(!wsConnection) {
			Logger.logAction(Logger.LOG_ERROR, 'WebSocketTransport.send()', 'No socket connection');
			return;
		}
		wsConnection.send(ProtocolMessage.serialize(message, this.params.format));
	};

	WebSocketTransport.prototype.onWsData = function(data) {
		Logger.logAction(Logger.LOG_MICRO, 'WebSocketTransport.onWsData()', 'data received; length = ' + data.length + '; type = ' + typeof(data));
		try {
			this.onProtocolMessage(ProtocolMessage.deserialize(data, this.format));
		} catch (e) {
			Logger.logAction(Logger.LOG_ERROR, 'WebSocketTransport.onWsData()', 'Unexpected exception handing channel message: ' + e.stack);
		}
	};

	WebSocketTransport.prototype.onWsOpen = function() {
		Logger.logAction(Logger.LOG_MINOR, 'WebSocketTransport.onWsOpen()', 'opened WebSocket');
		this.emit('wsopen');
	};

	WebSocketTransport.prototype.onWsClose = function(ev) {
		var wasClean, code, reason;
		if(typeof(ev) == 'object') {
			/* W3C spec-compatible */
			wasClean = ev.wasClean;
			code = ev.code;
		} else /*if(typeof(ev) == 'number')*/ {
			/* ws in node */
			code = ev;
			wasClean = (code == 1000);
		}
		delete this.wsConnection;
		if(wasClean) {
			Logger.logAction(Logger.LOG_MINOR, 'WebSocketTransport.onWsClose()', 'Cleanly closed WebSocket');
			var err = new ErrorInfo('Websocket closed', 80003, 400);
			this.finish('disconnected', err);
		} else {
			var msg = 'Unclean disconnection of WebSocket ; code = ' + code,
				err = new ErrorInfo(msg, 80003, 400);
			Logger.logAction(Logger.LOG_ERROR, 'WebSocketTransport.onWsClose()', msg);
			this.finish('disconnected', err);
		}
		this.emit('disposed');
	};

	WebSocketTransport.prototype.onWsError = function(err) {
		Logger.logAction(Logger.LOG_ERROR, 'WebSocketTransport.onError()', 'Unexpected error from WebSocket: ' + err.message);
		/* Wait a tick before aborting: if the websocket was connected, this event
		 * will be immediately followed by an onclose event with a close code. Allow
		 * that to close it (so we see the close code) rather than anticipating it */
		var self = this;
		Utils.nextTick(function() {
			self.disconnect(err);
		});
	};

	WebSocketTransport.prototype.dispose = function() {
		Logger.logAction(Logger.LOG_MINOR, 'WebSocketTransport.dispose()', '');
		var wsConnection = this.wsConnection;
		if(wsConnection) {
			/* Ignore any messages that come through after dispose() is called but before
			 * websocket is actually closed. (mostly would be harmless, but if it's a
			 * CONNECTED, it'll re-tick isConnected and cause all sorts of havoc) */
			wsConnection.onmessage = function() {};
			delete this.wsConnection;
			/* defer until the next event loop cycle before closing the socket,
			 * giving some implementations the opportunity to send any outstanding close message */
			Utils.nextTick(function() {
				Logger.logAction(Logger.LOG_MICRO, 'WebSocketTransport.dispose()', 'closing websocket');
				wsConnection.close();
			});
		}
	};

	return WebSocketTransport;
})();

var CometTransport = (function() {

	var REQ_SEND = 0,
		REQ_RECV = 1,
		REQ_RECV_POLL = 2,
		REQ_RECV_STREAM = 3;

	function actOnConnectHeaders(headers, host, connectionManager) {
		if(headers && headers.server && (headers.server.indexOf('cloudflare') > -1)) {
			/* Cloudflare doesn't support xhr streaming */
			var blacklist = connectionManager.transportHostBlacklist[host];
			if(!blacklist) {
				connectionManager.transportHostBlacklist[host] = ['xhr_streaming'];
				return;
			}
			if(!Utils.arrIn(blacklist, 'xhr_streaming')) {
				blacklist.push('xhr_streaming');
			}
		}
	}

	/* TODO: can remove once realtime sends protocol message responses for comet errors */
	function shouldBeErrorAction(err) {
		var UNRESOLVABLE_ERROR_CODES = [80015, 80017, 80030];
		if(err.code) {
			if(Auth.isTokenErr(err)) return false;
			if(Utils.arrIn(UNRESOLVABLE_ERROR_CODES, err.code)) return true;
			return (err.code >= 40000 && err.code < 50000);
		} else {
			/* Likely a network or transport error of some kind. Certainly not fatal to the connection */
			return false;
		}
	}

	function protocolMessageFromRawError(err) {
		/* err will be either a legacy (non-protocolmessage) comet error response
		 * (which will have an err.code), or a xhr/network error (which won't). */
		if(shouldBeErrorAction(err)) {
			return [ProtocolMessage.fromValues({action: ProtocolMessage.Action.ERROR, error: err})];
		} else {
			return [ProtocolMessage.fromValues({action: ProtocolMessage.Action.DISCONNECTED, error: err})];
		}
	}

	/*
	 * A base comet transport class
	 */
	function CometTransport(connectionManager, auth, params) {
		/* binary not supported for comet, so just fall back to default */
		params.format = undefined;
		params.heartbeats = true;
		Transport.call(this, connectionManager, auth, params);
		/* streaming defaults to true */
		this.stream = ('stream' in params) ? params.stream : true;
		this.sendRequest = null;
		this.recvRequest = null;
		this.pendingCallback = null;
		this.pendingItems = null;
		this.disposed = false;
	}
	Utils.inherits(CometTransport, Transport);

	CometTransport.REQ_SEND = REQ_SEND;
	CometTransport.REQ_RECV = REQ_RECV;
	CometTransport.REQ_RECV_POLL = REQ_RECV_POLL;
	CometTransport.REQ_RECV_STREAM = REQ_RECV_STREAM;

	/* public instance methods */
	CometTransport.prototype.connect = function() {
		Logger.logAction(Logger.LOG_MINOR, 'CometTransport.connect()', 'starting');
		Transport.prototype.connect.call(this);
		var self = this, params = this.params, options = params.options;
		var host = Defaults.getHost(options, params.host);
		var port = Defaults.getPort(options);
		var cometScheme = options.tls ? 'https://' : 'http://';

		this.baseUri = cometScheme + host + ':' + port + '/comet/';
		var connectUri = this.baseUri + 'connect';
		Logger.logAction(Logger.LOG_MINOR, 'CometTransport.connect()', 'uri: ' + connectUri);
		this.auth.getAuthParams(function(err, authParams) {
			if(err) {
				self.disconnect(err);
				return;
			}
			self.authParams = authParams;
			var connectParams = self.params.getConnectParams(authParams);
			if('stream' in connectParams) self.stream = connectParams.stream;
			Logger.logAction(Logger.LOG_MINOR, 'CometTransport.connect()', 'connectParams:' + Utils.toQueryString(connectParams));

			/* this will be the 'recvRequest' so this connection can stream messages */
			var preconnected = false,
				connectRequest = self.recvRequest = self.createRequest(connectUri, null, connectParams, null, (self.stream ? REQ_RECV_STREAM : REQ_RECV));

			connectRequest.on('data', function(data) {
				if(!self.recvRequest) {
					/* the transport was disposed before we connected */
					return;
				}
				if(!preconnected) {
					preconnected = true;
					self.emit('preconnect');
				}
				self.onData(data);
			});
			connectRequest.on('complete', function(err, _body, headers) {
				actOnConnectHeaders(headers, host, self.connectionManager);
				if(!self.recvRequest) {
					/* the transport was disposed before we connected */
					err = err || new ErrorInfo('Request cancelled', 80000, 400);
				}
				self.recvRequest = null;
				if(this.maxIdleInterval) {
					this.setIdleTimer();
				}
				if(err) {
					if(err.code) {
						/* A protocol error received from realtime. TODO: once realtime
						 * consistendly sends errors wrapped in protocol messages, should be
						 * able to remove this */
						self.onData(protocolMessageFromRawError(err));
					} else {
						/* A network/xhr error. Don't bother wrapping in a protocol message,
						 * just disconnect the transport */
						self.disconnect(err);
					}
					return;
				}
				Utils.nextTick(function() {
					self.recv();
				});
			});
			connectRequest.exec();
		});
	};

	CometTransport.prototype.requestClose = function() {
		Logger.logAction(Logger.LOG_MINOR, 'CometTransport.requestClose()');
		this._requestCloseOrDisconnect(true);
	};

	CometTransport.prototype.requestDisconnect = function() {
		Logger.logAction(Logger.LOG_MINOR, 'CometTransport.requestDisconnect()');
		this._requestCloseOrDisconnect(false);
	};

	CometTransport.prototype._requestCloseOrDisconnect = function(closing) {
		var closeOrDisconnectUri = closing ? this.closeUri : this.disconnectUri;
		if(closeOrDisconnectUri) {
			var self = this,
				request = this.createRequest(closeOrDisconnectUri, null, this.authParams, null, REQ_SEND);

			request.on('complete', function (err) {
				if(err) {
					Logger.logAction(Logger.LOG_ERROR, 'CometTransport.request' + (closing ? 'Close()' : 'Disconnect()'), 'request returned err = ' + err);
					self.finish('disconnected', err);
				}
			});
			request.exec();
		}
	};

	CometTransport.prototype.dispose = function() {
		Logger.logAction(Logger.LOG_MINOR, 'CometTransport.dispose()', '');
		if(!this.disposed) {
			this.disposed = true;
			if(this.recvRequest) {
				Logger.logAction(Logger.LOG_MINOR, 'CometTransport.dispose()', 'aborting recv request');
				this.recvRequest.abort();
				this.recvRequest = null;
			}
			/* In almost all cases the transport will be finished before it's
			 * disposed. Finish here just to make sure. */
			this.finish('disconnected', ConnectionError.disconnected);
			var self = this;
			Utils.nextTick(function() {
				self.emit('disposed');
			});
		}
	};

	CometTransport.prototype.onConnect = function(message) {
		/* if this transport has been disposed whilst awaiting connection, do nothing */
		if(this.disposed) return;

		/* the connectionKey in a comet connected response is really
		 * <instId>-<connectionKey> */
		var connectionStr = message.connectionKey;
		Transport.prototype.onConnect.call(this, message);

		var baseConnectionUri =  this.baseUri + connectionStr;
		Logger.logAction(Logger.LOG_MICRO, 'CometTransport.onConnect()', 'baseUri = ' + baseConnectionUri + '; connectionKey = ' + message.connectionKey);
		this.sendUri = baseConnectionUri + '/send';
		this.recvUri = baseConnectionUri + '/recv';
		this.closeUri = baseConnectionUri + '/close';
		this.disconnectUri = baseConnectionUri + '/disconnect';
	};

	CometTransport.prototype.send = function(message) {
		if(this.sendRequest) {
			/* there is a pending send, so queue this message */
			this.pendingItems = this.pendingItems || [];
			this.pendingItems.push(message);
			return;
		}
		/* send this, plus any pending, now */
		var pendingItems = this.pendingItems || [];
		pendingItems.push(message);
		this.pendingItems = null;

		this.sendItems(pendingItems);
	};

	CometTransport.prototype.sendAnyPending = function() {
		var pendingItems = this.pendingItems;

		if(!pendingItems) {
			return;
		}

		this.pendingItems = null;
		this.sendItems(pendingItems);
	}

	CometTransport.prototype.sendItems = function(items) {
		var self = this,
			sendRequest = this.sendRequest = self.createRequest(self.sendUri, null, self.authParams, this.encodeRequest(items), REQ_SEND);

		sendRequest.on('complete', function(err, data) {
			if(err) Logger.logAction(Logger.LOG_ERROR, 'CometTransport.sendItems()', 'on complete: err = ' + JSON.stringify(err));
			self.sendRequest = null;

			/* the results of the request usually get handled as protocol responses instead of send errors */
			if(data) {
				self.onData(data);
			} else if(err && err.code) {
				/* A protocol error received from realtime. TODO: once realtime
				 * consistendly sends errors wrapped in protocol messages, should be
				 * able to remove this */
				self.onData(protocolMessageFromRawError(err));
			} else {
				/* A network/xhr error. Don't bother wrapping in a protocol message,
				 * just disconnect the transport */
				self.disconnect(err);
			}

			if(self.pendingItems) {
				Utils.nextTick(function() {
					/* If there's a new send request by now, any pending items will have
					 * been picked up by that; any new ones added since then will be
					 * picked up after that one completes */
					if(!self.sendRequest) {
						self.sendAnyPending();
					}
				});
			}
		});
		sendRequest.exec();
	};

	CometTransport.prototype.recv = function() {
		/* do nothing if there is an active request, which might be streaming */
		if(this.recvRequest)
			return;

		/* If we're no longer connected, do nothing */
		if(!this.isConnected)
			return;

		var self = this,
			recvRequest = this.recvRequest = this.createRequest(this.recvUri, null, this.authParams, null, (self.stream ? REQ_RECV_STREAM : REQ_RECV_POLL));

		recvRequest.on('data', function(data) {
			self.onData(data);
		});
		recvRequest.on('complete', function(err) {
			self.recvRequest = null;
			if(this.maxIdleInterval) {
				/* A request completing must be considered activity, as realtime sends
				 * heartbeats every 15s since a request began, not every 15s absolutely */
				this.setIdleTimer();
			}
			if(err) {
				if(err.code) {
					/* A protocol error received from realtime. TODO: once realtime
					 * consistendly sends errors wrapped in protocol messages, should be
					 * able to remove this */
					self.onData(protocolMessageFromRawError(err));
				} else {
					/* A network/xhr error. Don't bother wrapping in a protocol message,
					 * just disconnect the transport */
					self.disconnect(err);
				}
				return;
			}
			Utils.nextTick(function() {
				self.recv();
			});
		});
		recvRequest.exec();
	};

	CometTransport.prototype.onData = function(responseData) {
		try {
			var items = this.decodeResponse(responseData);
			if(items && items.length)
				for(var i = 0; i < items.length; i++)
					this.onProtocolMessage(ProtocolMessage.fromDeserialized(items[i]));
		} catch (e) {
			Logger.logAction(Logger.LOG_ERROR, 'CometTransport.onData()', 'Unexpected exception handing channel event: ' + e.stack);
		}
	};

	CometTransport.prototype.encodeRequest = function(requestItems) {
		return JSON.stringify(requestItems);
	};

	CometTransport.prototype.decodeResponse = function(responseData) {
		if(typeof(responseData) == 'string')
			responseData = JSON.parse(responseData);
		return responseData;
	};

	/* For comet, we could do the auth update by aborting the current recv and
	 * starting a new one with the new token, that'd be sufficient for realtime.
	 * Problem is JSONP - you can't cancel truly abort a recv once started. So
	 * we need to send an AUTH for jsonp. In which case it's simpler to keep all
	 * comet transports the same and do it for all of them. So we send the AUTH
	 * instead, and don't need to abort the recv */
	CometTransport.prototype.onAuthUpdated = function(tokenDetails) {
		this.authParams = {access_token: tokenDetails.token};
	};

	return CometTransport;
})();

var Presence = (function() {
	function noop() {}
	function Presence(channel) {
		this.channel = channel;
		this.basePath = channel.basePath + '/presence';
	}
	Utils.inherits(Presence, EventEmitter);

	Presence.prototype.get = function(params, callback) {
		Logger.logAction(Logger.LOG_MICRO, 'Presence.get()', 'channel = ' + this.channel.name);
		/* params and callback are optional; see if params contains the callback */
		if(callback === undefined) {
			if(typeof(params) == 'function') {
				callback = params;
				params = null;
			} else {
				callback = noop;
			}
		}
		var rest = this.channel.rest,
			format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			envelope = Http.supportsLinkHeaders ? undefined : format,
			headers = Utils.copy(Utils.defaultGetHeaders(format));

		if(rest.options.headers)
			Utils.mixin(headers, rest.options.headers);

		var options = this.channel.channelOptions;
		(new PaginatedResource(rest, this.basePath, headers, envelope, function(body, headers, unpacked) {
			return PresenceMessage.fromResponseBody(body, options, !unpacked && format);
		})).get(params, callback);
	};

	Presence.prototype.history = function(params, callback) {
		Logger.logAction(Logger.LOG_MICRO, 'Presence.history()', 'channel = ' + this.channel.name);
		this._history(params, callback);
	};

	Presence.prototype._history = function(params, callback) {
		/* params and callback are optional; see if params contains the callback */
		if(callback === undefined) {
			if(typeof(params) == 'function') {
				callback = params;
				params = null;
			} else {
				callback = noop;
			}
		}
		var rest = this.channel.rest,
			format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			envelope = Http.supportsLinkHeaders ? undefined : format,
			headers = Utils.copy(Utils.defaultGetHeaders(format)),
			channel = this.channel;

		if(rest.options.headers)
			Utils.mixin(headers, rest.options.headers);

		var options = this.channel.channelOptions;
		(new PaginatedResource(rest, this.basePath + '/history', headers, envelope, function(body, headers, unpacked) {
			return PresenceMessage.fromResponseBody(body, options, !unpacked && format);
		})).get(params, callback);
	};

	return Presence;
})();

var Resource = (function() {
	var msgpack = Platform.msgpack;

	function Resource() {}

	function withAuthDetails(rest, headers, params, errCallback, opCallback) {
		if (Http.supportsAuthHeaders) {
			rest.auth.getAuthHeaders(function(err, authHeaders) {
				if(err)
					errCallback(err);
				else
					opCallback(Utils.mixin(authHeaders, headers), params);
			});
		} else {
			rest.auth.getAuthParams(function(err, authParams) {
				if(err)
					errCallback(err);
				else
					opCallback(headers, Utils.mixin(authParams, params));
			});
		}
	}

	function unenvelope(callback, format) {
		return function(err, body, headers, unpacked, statusCode) {
			if(err) {
				callback(err);
				return;
			}

			if(!unpacked) {
				try {
					body = (format == 'msgpack') ? msgpack.decode(body) : JSON.parse(body);
				} catch(e) {
					callback(e);
					return;
				}
			}

			if(body.statusCode === undefined) {
				/* Envelope already unwrapped by the transport */
				callback(err, body, headers, true, statusCode);
				return;
			}

			var statusCode = body.statusCode,
				response = body.response,
				headers = body.headers;

			if(statusCode < 200 || statusCode >= 300) {
				/* handle wrapped errors */
				var err = response && response.error;
				if(!err) {
					err = new Error(String(res));
					err.statusCode = statusCode;
				}
				callback(err);
				return;
			}

			callback(null, response, headers, true, statusCode);
		};
	}

	function paramString(params) {
		var paramPairs = [];
		if (params) {
			for (var needle in params) {
				paramPairs.push(needle + '=' + params[needle]);
			}
		}
		return paramPairs.join('&');
	}

	function urlFromPathAndParams(path, params) {
		return path + (params ? '?' : '') + paramString(params);
	}

	function logResponseHandler(callback, verb, path, params) {
		return function(err, body, headers, unpacked, statusCode) {
			if (err) {
				Logger.logAction(Logger.LOG_MICRO, 'Resource.' + verb + '()', 'Received Error; ' + urlFromPathAndParams(path, params) + '; Error: ' + JSON.stringify(err));
			} else {
				Logger.logAction(Logger.LOG_MICRO, 'Resource.' + verb + '()',
					'Received; ' + urlFromPathAndParams(path, params) + '; Headers: ' + paramString(headers) + '; StatusCode: ' + statusCode + '; Body: ' + (BufferUtils.isBuffer(body) ? body.toString() : body));
			}
			if (callback) { callback(err, body, headers, unpacked, statusCode); }
		}
	}

	Resource.get = function(rest, path, origheaders, origparams, envelope, callback) {
		if (Logger.shouldLog(Logger.LOG_MICRO)) {
			callback = logResponseHandler(callback, 'get', path, origparams);
		}

		if(envelope) {
			callback = (callback && unenvelope(callback, envelope));
			(origparams = (origparams || {}))['envelope'] = envelope;
		}

		function doGet(headers, params) {
			if (Logger.shouldLog(Logger.LOG_MICRO)) {
				Logger.logAction(Logger.LOG_MICRO, 'Resource.get()', 'Sending; ' + urlFromPathAndParams(path, params));
			}

			Http.get(rest, path, headers, params, function(err, res, headers, unpacked, statusCode) {
				if(err && Auth.isTokenErr(err)) {
					/* token has expired, so get a new one */
					rest.auth.authorize(null, null, function(err) {
						if(err) {
							callback(err);
							return;
						}
						/* retry ... */
						withAuthDetails(rest, origheaders, origparams, callback, doGet);
					});
					return;
				}
				callback(err, res, headers, unpacked, statusCode);
			});
		}
		withAuthDetails(rest, origheaders, origparams, callback, doGet);
	};

	Resource.post = function(rest, path, body, origheaders, origparams, envelope, callback) {
		if (Logger.shouldLog(Logger.LOG_MICRO)) {
			callback = logResponseHandler(callback, 'post', path, origparams);
		}

		if(envelope) {
			callback = unenvelope(callback, envelope);
			origparams['envelope'] = envelope;
		}

		function doPost(headers, params) {
			if (Logger.shouldLog(Logger.LOG_MICRO)) {
				var decodedBody = body;
				if ((headers['content-type'] || '').indexOf('msgpack') > 0) {
					try {
						body = msgpack.decode(body);
					} catch (decodeErr) {
						Logger.logAction(Logger.LOG_MICRO, 'Resource.post()', 'Sending MsgPack Decoding Error: ' + JSON.stringify(decodeErr));
					}
				}
				Logger.logAction(Logger.LOG_MICRO, 'Resource.post()', 'Sending; ' + urlFromPathAndParams(path, params) + '; Body: ' + decodedBody);
			}

			Http.post(rest, path, headers, body, params, function(err, res, headers, unpacked, statusCode) {
				if(err && Auth.isTokenErr(err)) {
					/* token has expired, so get a new one */
					rest.auth.authorize(null, null, function(err) {
						if(err) {
							callback(err);
							return;
						}
						/* retry ... */
						withAuthDetails(rest, origheaders, origparams, callback, doPost);
					});
					return;
				}
				callback(err, res, headers, unpacked, statusCode);
			});
		}
		withAuthDetails(rest, origheaders, origparams, callback, doPost);
	};

	return Resource;
})();

var PaginatedResource = (function() {

	function getRelParams(linkUrl) {
		var urlMatch = linkUrl.match(/^\.\/(\w+)\?(.*)$/);
		return urlMatch && Utils.parseQueryString(urlMatch[2]);
	}

	function parseRelLinks(linkHeader) {
		if(typeof(linkHeader) == 'string')
			linkHeader = linkHeader.split(',');

		var relParams = {};
		for(var i = 0; i < linkHeader.length; i++) {
			var linkMatch = linkHeader[i].match(/^\s*<(.+)>;\s*rel="(\w+)"$/);
			if(linkMatch) {
				var params = getRelParams(linkMatch[1]);
				if(params)
					relParams[linkMatch[2]] = params;
			}
		}
		return relParams;
	}

	function PaginatedResource(rest, path, headers, envelope, bodyHandler, useHttpPaginatedResponse) {
		this.rest = rest;
		this.path = path;
		this.headers = headers;
		this.envelope = envelope;
		this.bodyHandler = bodyHandler;
		this.useHttpPaginatedResponse = useHttpPaginatedResponse || false;
	}

	PaginatedResource.prototype.get = function(params, callback) {
		var self = this;
		Resource.get(self.rest, self.path, self.headers, params, self.envelope, function(err, body, headers, unpacked, statusCode) {
			self.handlePage(err, body, headers, unpacked, statusCode, callback);
		});
	};

	PaginatedResource.prototype.post = function(params, body, callback) {
		var self = this;
		Resource.post(self.rest, self.path, body, self.headers, params, self.envelope, function(err, resbody, headers, unpacked, statusCode) {
			if(callback) self.handlePage(err, resbody, headers, unpacked, statusCode, callback);
		});
	};

	PaginatedResource.prototype.handlePage = function(err, body, headers, unpacked, statusCode, callback) {
		if(err) {
			Logger.logAction(Logger.LOG_ERROR, 'PaginatedResource.handlePage()', 'Unexpected error getting resource: err = ' + JSON.stringify(err));
			callback(err);
			return;
		}
		var items, linkHeader, relParams;
		try {
			items = this.bodyHandler(body, headers, unpacked);
		} catch(e) {
			callback(e);
			return;
		}

		if(headers && (linkHeader = (headers['Link'] || headers['link']))) {
			relParams = parseRelLinks(linkHeader);
		}

		if(this.useHttpPaginatedResponse) {
			callback(null, new HttpPaginatedResponse(this, items, headers, statusCode, relParams));
		} else {
			callback(null, new PaginatedResult(this, items, relParams));
		}
	};

	function PaginatedResult(resource, items, relParams) {
		this.resource = resource;
		this.items = items;

		if(relParams) {
			var self = this;
			if('first' in relParams)
				this.first = function(cb) { self.get(relParams.first, cb); };
			if('current' in relParams)
				this.current = function(cb) { self.get(relParams.current, cb); };
			this.next = function(cb) {
				if('next' in relParams)
					self.get(relParams.next, cb);
				else
					cb(null, null);
			};

			this.hasNext = function() { return ('next' in relParams) };
			this.isLast = function() { return !this.hasNext(); }
		}
	}

	/* We assume that only the initial request can be a POST, and that accessing
	 * the rest of a multipage set of results can always be done with GET */
	PaginatedResult.prototype.get = function(params, callback) {
		var res = this.resource;
		Resource.get(res.rest, res.path, res.headers, params, res.envelope, function(err, body, headers, unpacked, statusCode) {
			res.handlePage(err, body, headers, unpacked, statusCode, callback);
		});
	};

	function HttpPaginatedResponse(resource, items, headers, statusCode, relParams) {
		PaginatedResult.call(this, resource, items, relParams);
		this.statusCode = statusCode;
		this.success = statusCode < 300 && statusCode >= 200;
		this.headers = headers;
		/* Note: we don't populate errorCode or errorMessage: for consistency with
		 * the way the rest of the js library works, error data is passed as
		 * ErrorInfos to the err argument of the callback; an  HttpPaginatedResponse
		 * is only ever passed to the callback if there was no error */
	}
	Utils.inherits(HttpPaginatedResponse, PaginatedResult);

	return PaginatedResource;
})();

var Auth = (function() {
	var msgpack = Platform.msgpack;
	var MAX_TOKENOBJECT_LENGTH = Math.pow(2, 17);
	var MAX_TOKENSTRING_LENGTH = 384;
	function noop() {}
	function random() { return ('000000' + Math.floor(Math.random() * 1E16)).slice(-16); }

	var hmac, toBase64;
	if(Platform.createHmac) {
		toBase64 = function(str) { return (new Buffer(str, 'ascii')).toString('base64'); };
		hmac = function(text, key) {
			var inst = Platform.createHmac('SHA256', key);
			inst.update(text);
			return inst.digest('base64');
		};
	} else {
		toBase64 = Base64.encode;
		hmac = function(text, key) {
			return CryptoJS.HmacSHA256(text, key).toString(CryptoJS.enc.Base64);
		};
	}

	function c14n(capability) {
		if(!capability)
			return '';

		if(typeof(capability) == 'string')
			capability = JSON.parse(capability);

		var c14nCapability = {};
		var keys = Utils.keysArray(capability, true);
		if(!keys)
			return '';
		keys.sort();
		for(var i = 0; i < keys.length; i++) {
			c14nCapability[keys[i]] = capability[keys[i]].sort();
		}
		return JSON.stringify(c14nCapability);
	}

	function logAndValidateTokenAuthMethod(authOptions) {
		if(authOptions.authCallback) {
			Logger.logAction(Logger.LOG_MINOR, 'Auth()', 'using token auth with authCallback');
		} else if(authOptions.authUrl) {
			Logger.logAction(Logger.LOG_MINOR, 'Auth()', 'using token auth with authUrl');
		} else if(authOptions.key) {
			Logger.logAction(Logger.LOG_MINOR, 'Auth()', 'using token auth with client-side signing');
		} else if(authOptions.tokenDetails) {
			Logger.logAction(Logger.LOG_MINOR, 'Auth()', 'using token auth with supplied token only');
		} else {
			var msg = 'authOptions must include valid authentication parameters';
			Logger.logAction(Logger.LOG_ERROR, 'Auth()', msg);
			throw new Error(msg);
		}
	}

	function basicAuthForced(options) {
		return 'useTokenAuth' in options && !options.useTokenAuth;
	}

	/* RSA4 */
	function useTokenAuth(options) {
		return options.useTokenAuth ||
			(!basicAuthForced(options) &&
			 (options.clientId     ||
			  options.authCallback ||
			  options.authUrl      ||
			  options.token        ||
			  options.tokenDetails))
	}

	function Auth(client, options) {
		this.client = client;
		this.tokenParams = options.defaultTokenParams || {};

		if(useTokenAuth(options)) {
			/* Token auth */
			if(options.key && !hmac) {
				var msg = 'client-side token request signing not supported';
				Logger.logAction(Logger.LOG_ERROR, 'Auth()', msg);
				throw new Error(msg);
			}
			this._saveTokenOptions(options.defaultTokenParams, options);
			logAndValidateTokenAuthMethod(this.authOptions);
		} else {
			/* Basic auth */
			if(options.clientId || !options.key) {
				var msg = 'Cannot authenticate with basic auth' +
					(options.clientId ? ' as a clientId implies token auth' :
					 (!options.key ? ' as no key was given' : ''));
					 Logger.logAction(Logger.LOG_ERROR, 'Auth()', msg);
					 throw new Error(msg);
			}
			Logger.logAction(Logger.LOG_MINOR, 'Auth()', 'anonymous, using basic auth');
			this._saveBasicOptions(options);
		}
	}

	/**
	 * Instructs the library to get a token immediately and ensures Token Auth
	 * is used for all future requests, storing the tokenParams and authOptions
	 * given as the new defaults for subsequent use.
	 *
	 * @param tokenParams
	 * an object containing the parameters for the requested token:
	 *
	 * - ttl:        (optional) the requested life of any new token in ms. If none
	 *               is specified a default of 1 hour is provided. The maximum lifetime
	 *               is 24hours; any request exceeeding that lifetime will be rejected
	 *               with an error.
	 *
	 * - capability: (optional) the capability to associate with the access token.
	 *               If none is specified, a token will be requested with all of the
	 *               capabilities of the specified key.
	 *
	 * - clientId:   (optional) a client Id to associate with the token
	 *
	 * - timestamp:  (optional) the time in ms since the epoch. If none is specified,
	 *               the system will be queried for a time value to use.
	 *
	 * @param authOptions
	 * an object containing auth options relevant to token auth:
	 *
	 * - queryTime   (optional) boolean indicating that the Ably system should be
	 *               queried for the current time when none is specified explicitly.
	 *
	 * - tokenDetails: (optional) object: An authenticated TokenDetails object.
	 *
	 * - token:        (optional) string: the `token` property of a tokenDetails object
	 *
	 * - authCallback:  (optional) a javascript callback to be called to get auth information.
	 *                  authCallback should be a function of (tokenParams, callback) that calls
	 *                  the callback with (err, result), where result is any of:
	 *                  - a tokenRequest object (ie the result of a rest.auth.createTokenRequest call),
	 *                  - a tokenDetails object (ie the result of a rest.auth.requestToken call),
	 *                  - a token string
	 *
	 * - authUrl:       (optional) a URL to be used to GET or POST a set of token request
	 *                  params, to obtain a signed token request.
	 *
	 * - authHeaders:   (optional) a set of application-specific headers to be added to any request
	 *                  made to the authUrl.
	 *
	 * - authParams:    (optional) a set of application-specific query params to be added to any
	 *                  request made to the authUrl.
	 *
	 *
	 * - requestHeaders (optional, unsupported, for testing only) extra headers to add to the
	 *                  requestToken request
	 *
	 * @param callback (err, tokenDetails)
	 */
	Auth.prototype.authorize = function(tokenParams, authOptions, callback) {
		/* shuffle and normalise arguments as necessary */
		if(typeof(tokenParams) == 'function' && !callback) {
			callback = tokenParams;
			authOptions = tokenParams = null;
		} else if(typeof(authOptions) == 'function' && !callback) {
			callback = authOptions;
			authOptions = null;
		}
		callback = callback || noop;
		var self = this;

		/* RSA10a: authorize() call implies token auth. If a key is passed it, we
		 * just check if it doesn't clash and assume we're generating a token from it */
		if(authOptions && authOptions.key && (this.key !== authOptions.key)) {
			throw new ErrorInfo('Unable to update auth options with incompatible key', 40102, 401);
		}

		if(authOptions && ('force' in authOptions)) {
			Logger.logAction(Logger.LOG_ERROR, 'Auth.authorize', 'Deprecation warning: specifying {force: true} in authOptions is no longer necessary, authorize() now always gets a new token. Please remove this, as in version 1.0 and later, having a non-null authOptions will overwrite stored library authOptions, which may not be what you want');
			/* Emulate the old behaviour: if 'force' was the only member of authOptions,
			 * set it to null so it doesn't overwrite stored. TODO: remove in version 1.0 */
			if(Utils.isOnlyPropIn(authOptions, 'force')) {
				authOptions = null;
			}
		}

		this._forceNewToken(tokenParams, authOptions, function(err, tokenDetails) {
			if(err) {
				callback(err);
				return;
			}
			/* RTC8
			 * - When authorize called by an end user and have a realtime connection,
			 * don't call back till new token has taken effect.
			 * - Use self.client.connection as a proxy for (self.client instanceof Realtime),
			 * which doesn't work in node as Realtime isn't part of the vm context for Rest clients */
			if(self.client.connection) {
				self.client.connection.connectionManager.onAuthUpdated(tokenDetails, callback);
			} else {
				callback(null, tokenDetails);
			}
		})
	};

	Auth.prototype.authorise = function() {
		Logger.deprecated('Auth.authorise', 'Auth.authorize');
		this.authorize.apply(this, arguments);
	};

	/* For internal use, eg by connectionManager - useful when want to call back
	 * as soon as we have the new token, rather than waiting for it to take
	 * effect on the connection as #authorize does */
	Auth.prototype._forceNewToken = function(tokenParams, authOptions, callback) {
		var self = this;

		/* get rid of current token even if still valid */
		this.tokenDetails = null;

		/* _save normalises the tokenParams and authOptions and updates the auth
		 * object. All subsequent operations should use the values on `this`,
		 * not the passed in ones. */
		this._saveTokenOptions(tokenParams, authOptions);

		logAndValidateTokenAuthMethod(this.authOptions);

		this._ensureValidAuthCredentials(function(err, tokenDetails) {
			/* RSA10g */
			delete self.tokenParams.timestamp;
			delete self.authOptions.queryTime;
			callback(err, tokenDetails);
		});
	}

	/**
	 * Request an access token
	 * @param authOptions
	 * an object containing the request options:
	 * - key:           the key to use.
	 *
	 * - authCallback:  (optional) a javascript callback to be called to get auth information.
	 *                  authCallback should be a function of (tokenParams, callback) that calls
	 *                  the callback with (err, result), where result is any of:
	 *                  - a tokenRequest object (ie the result of a rest.auth.createTokenRequest call),
	 *                  - a tokenDetails object (ie the result of a rest.auth.requestToken call),
	 *                  - a token string
	 *
	 * - authUrl:       (optional) a URL to be used to GET or POST a set of token request
	 *                  params, to obtain a signed token request.
	 *
	 * - authHeaders:   (optional) a set of application-specific headers to be added to any request
	 *                  made to the authUrl.
	 *
	 * - authParams:    (optional) a set of application-specific query params to be added to any
	 *                  request made to the authUrl.
	 *
	 * - queryTime      (optional) boolean indicating that the ably system should be
	 *                  queried for the current time when none is specified explicitly
	 *
	 * - requestHeaders (optional, unsupported, for testing only) extra headers to add to the
	 *                  requestToken request
	 *
	 * @param tokenParams
	 * an object containing the parameters for the requested token:
	 * - ttl:          (optional) the requested life of the token in milliseconds. If none is specified
	 *                  a default of 1 hour is provided. The maximum lifetime is 24hours; any request
	 *                  exceeeding that lifetime will be rejected with an error.
	 *
	 * - capability:    (optional) the capability to associate with the access token.
	 *                  If none is specified, a token will be requested with all of the
	 *                  capabilities of the specified key.
	 *
	 * - clientId:      (optional) a client Id to associate with the token; if not
	 *                  specified, a clientId passed in constructing the Rest interface will be used
	 *
	 * - timestamp:     (optional) the time in ms since the epoch. If none is specified,
	 *                  the system will be queried for a time value to use.
	 *
	 * @param callback (err, tokenDetails)
	 */
	Auth.prototype.requestToken = function(tokenParams, authOptions, callback) {
		/* shuffle and normalise arguments as necessary */
		if(typeof(tokenParams) == 'function' && !callback) {
			callback = tokenParams;
			authOptions = tokenParams = null;
		}
		else if(typeof(authOptions) == 'function' && !callback) {
			callback = authOptions;
			authOptions = null;
		}

		/* RSA8e: if authOptions passed in, they're used instead of stored, don't merge them */
		authOptions = authOptions || this.authOptions;
		tokenParams = tokenParams || Utils.copy(this.tokenParams);
		callback = callback || noop;
		var format = authOptions.format || 'json';

		/* first set up whatever callback will be used to get signed
		 * token requests */
		var tokenRequestCallback, client = this.client;

		if(authOptions.authCallback) {
			Logger.logAction(Logger.LOG_MINOR, 'Auth.requestToken()', 'using token auth with authCallback');
			tokenRequestCallback = authOptions.authCallback;
		} else if(authOptions.authUrl) {
			Logger.logAction(Logger.LOG_MINOR, 'Auth.requestToken()', 'using token auth with authUrl');
			/* if no authParams given, check if they were given in the URL */
			if(!authOptions.authParams) {
				var queryIdx = authOptions.authUrl.indexOf('?');
				if(queryIdx > -1) {
					authOptions.authParams = Utils.parseQueryString(authOptions.authUrl.slice(queryIdx));
					authOptions.authUrl = authOptions.authUrl.slice(0, queryIdx);
				}
			}
			tokenRequestCallback = function(params, cb) {
				var authHeaders = Utils.mixin({accept: 'application/json, text/plain'}, authOptions.authHeaders),
						authParams = Utils.mixin(params, authOptions.authParams);
				var authUrlRequestCallback = function(err, body, headers, unpacked) {
					if (err) {
						Logger.logAction(Logger.LOG_MICRO, 'Auth.requestToken().tokenRequestCallback', 'Received Error; ' + JSON.stringify(err));
					} else {
						Logger.logAction(Logger.LOG_MICRO, 'Auth.requestToken().tokenRequestCallback', 'Received; body: ' + (BufferUtils.isBuffer(body) ? body.toString() : body));
					}
					if(err || unpacked) return cb(err, body);
					if(BufferUtils.isBuffer(body)) body = body.toString();
					var contentType = headers['content-type'];
					if(!contentType) {
						cb(new ErrorInfo('authUrl response is missing a content-type header', 40170, 401));
						return;
					}
					var json = contentType.indexOf('application/json') > -1,
						text = contentType.indexOf('text/plain') > -1;
					if(!json && !text) {
						cb(new ErrorInfo('authUrl responded with unacceptable content-type ' + contentType + ', should be either text/plain or application/json', 40170, 401));
						return;
					}
					if(json) {
						if(body.length > MAX_TOKENOBJECT_LENGTH) {
							cb(new ErrorInfo('authUrl response exceeded max permitted length', 40170, 401));
							return;
						}
						try {
							body = JSON.parse(body);
						} catch(e) {
							cb(new ErrorInfo('Unexpected error processing authURL response; err = ' + e.message, 40170, 401));
							return;
						}
					}
					cb(null, body);
				};
				Logger.logAction(Logger.LOG_MICRO, 'Auth.requestToken().tokenRequestCallback', 'Sending; ' + authOptions.authUrl + '; Params: ' + JSON.stringify(authParams));
				if(authOptions.authMethod && authOptions.authMethod.toLowerCase() === 'post') {
					/* send body form-encoded */
					var headers = authHeaders || {};
					headers['content-type'] = 'application/x-www-form-urlencoded';
					var body = Utils.toQueryString(authParams).slice(1); /* slice is to remove the initial '?' */
					Http.postUri(client, authOptions.authUrl, headers, body, {}, authUrlRequestCallback);
				} else {
					Http.getUri(client, authOptions.authUrl, authHeaders || {}, authParams, authUrlRequestCallback);
				}
			};
		} else if(authOptions.key) {
			var self = this;
			Logger.logAction(Logger.LOG_MINOR, 'Auth.requestToken()', 'using token auth with client-side signing');
			tokenRequestCallback = function(params, cb) { self.createTokenRequest(params, authOptions, cb); };
		} else {
			var msg = "Need a new token, but authOptions does not include any way to request one";
			Logger.logAction(Logger.LOG_ERROR, 'Auth.requestToken()', msg);
			callback(new ErrorInfo(msg, 40101, 401));
			return;
		}

		/* normalise token params */
		if('capability' in tokenParams)
			tokenParams.capability = c14n(tokenParams.capability);

		var client = this.client;
		var tokenRequest = function(signedTokenParams, tokenCb) {
			var keyName = signedTokenParams.keyName,
				tokenUri = function(host) { return client.baseUri(host) + '/keys/' + keyName + '/requestToken'; };

			var requestHeaders = Utils.defaultPostHeaders(format);
			if(authOptions.requestHeaders) Utils.mixin(requestHeaders, authOptions.requestHeaders);
			Logger.logAction(Logger.LOG_MICRO, 'Auth.requestToken().requestToken', 'Sending POST; ' + tokenUri + '; Token params: ' + JSON.stringify(signedTokenParams));
			signedTokenParams = (format == 'msgpack') ? msgpack.encode(signedTokenParams, true) : JSON.stringify(signedTokenParams);
			Http.post(client, tokenUri, requestHeaders, signedTokenParams, null, tokenCb);
		};

		var tokenRequestCallbackTimeoutExpired = false,
			timeoutLength = this.client.options.timeouts.realtimeRequestTimeout,
			tokenRequestCallbackTimeout = setTimeout(function() {
				tokenRequestCallbackTimeoutExpired = true;
				var msg = 'Token request callback timed out after ' + (timeoutLength / 1000) + ' seconds';
				Logger.logAction(Logger.LOG_ERROR, 'Auth.requestToken()', msg);
				callback(new ErrorInfo(msg, 40170, 401));
			}, timeoutLength);

		tokenRequestCallback(tokenParams, function(err, tokenRequestOrDetails) {
			if(tokenRequestCallbackTimeoutExpired) return;
			clearTimeout(tokenRequestCallbackTimeout);

			if(err) {
				Logger.logAction(Logger.LOG_ERROR, 'Auth.requestToken()', 'token request signing call returned error; err = ' + Utils.inspectError(err));
				if(!(err && err.code)) {
					/* network errors don't have an error code, so assign them
					 * 40170 so they'll by connectionManager as nonfatal */
					err = new ErrorInfo(Utils.inspectError(err), 40170, 401);
				}
				callback(err);
				return;
			}
			/* the response from the callback might be a token string, a signed request or a token details */
			if(typeof(tokenRequestOrDetails) === 'string') {
				if(tokenRequestOrDetails.length > MAX_TOKENSTRING_LENGTH) {
					callback(new ErrorInfo('Token string exceeded max permitted length (was ' + tokenRequestOrDetails.length + ' bytes)', 40170, 401));
				} else {
					callback(null, {token: tokenRequestOrDetails});
				}
				return;
			}
			if(typeof(tokenRequestOrDetails) !== 'object') {
				var msg = 'Expected token request callback to call back with a token string or token request/details object, but got a ' + typeof(tokenRequestOrDetails);
				Logger.logAction(Logger.LOG_ERROR, 'Auth.requestToken()', msg);
				callback(new ErrorInfo(msg, 40170, 401));
				return;
			}
			var objectSize = JSON.stringify(tokenRequestOrDetails).length;
			if(objectSize > MAX_TOKENOBJECT_LENGTH) {
				callback(new ErrorInfo('Token request/details object exceeded max permitted stringified size (was ' + objectSize + ' bytes)', 40170, 401));
				return;
			}
			if('issued' in tokenRequestOrDetails) {
				/* a tokenDetails object */
				callback(null, tokenRequestOrDetails);
				return;
			}
			if(!('keyName' in tokenRequestOrDetails)) {
				var msg = 'Expected token request callback to call back with a token string, token request object, or token details object';
				Logger.logAction(Logger.LOG_ERROR, 'Auth.requestToken()', msg);
				callback(new ErrorInfo(msg, 40170, 401));
				return;
			}
			/* it's a token request, so make the request */
			tokenRequest(tokenRequestOrDetails, function(err, tokenResponse, headers, unpacked) {
				if(err) {
					Logger.logAction(Logger.LOG_ERROR, 'Auth.requestToken()', 'token request API call returned error; err = ' + Utils.inspectError(err));
					callback(err);
					return;
				}
				if(!unpacked) tokenResponse = (format == 'msgpack') ? msgpack.decode(tokenResponse) : JSON.parse(tokenResponse);
				Logger.logAction(Logger.LOG_MINOR, 'Auth.getToken()', 'token received');
				callback(null, tokenResponse);
			});
		});
	};

	/**
	 * Create and sign a token request based on the given options.
	 * NOTE this can only be used when the key value is available locally.
	 * Otherwise, signed token requests must be obtained from the key
	 * owner (either using the token request callback or url).
	 *
	 * @param authOptions
	 * an object containing the request options:
	 * - key:           the key to use. If not specified, a key passed in constructing
	 *                  the Rest interface will be used
	 *
	 * - queryTime      (optional) boolean indicating that the ably system should be
	 *                  queried for the current time when none is specified explicitly
	 *
	 * - requestHeaders (optional, unsupported, for testing only) extra headers to add to the
	 *                  requestToken request
	 *
	 * @param tokenParams
	 * an object containing the parameters for the requested token:
	 * - ttl:       (optional) the requested life of the token in ms. If none is specified
	 *                  a default of 1 hour is provided. The maximum lifetime is 24hours; any request
	 *                  exceeeding that lifetime will be rejected with an error.
	 *
	 * - capability:    (optional) the capability to associate with the access token.
	 *                  If none is specified, a token will be requested with all of the
	 *                  capabilities of the specified key.
	 *
	 * - clientId:      (optional) a client Id to associate with the token; if not
	 *                  specified, a clientId passed in constructing the Rest interface will be used
	 *
	 * - timestamp:     (optional) the time in ms since the epoch. If none is specified,
	 *                  the system will be queried for a time value to use.
	 *
	 */
	Auth.prototype.createTokenRequest = function(tokenParams, authOptions, callback) {
		/* shuffle and normalise arguments as necessary */
		if(typeof(tokenParams) == 'function' && !callback) {
			callback = tokenParams;
			authOptions = tokenParams = null;
		} else if(typeof(authOptions) == 'function' && !callback) {
			callback = authOptions;
			authOptions = null;
		}

		/* RSA9h: if authOptions passed in, they're used instead of stored, don't merge them */
		authOptions = authOptions || this.authOptions;
		tokenParams = tokenParams || Utils.copy(this.tokenParams);

		var key = authOptions.key;
		if(!key) {
			callback(new Error('No key specified'));
			return;
		}
		var keyParts = key.split(':'),
			keyName = keyParts[0],
			keySecret = keyParts[1];

		if(!keySecret) {
			callback(new Error('Invalid key specified'));
			return;
		}

		if(tokenParams.clientId === '') {
			callback(new ErrorInfo('clientId can’t be an empty string', 40012, 400));
			return;
		}

		tokenParams.capability = c14n(tokenParams.capability);

		var request = Utils.mixin({ keyName: keyName }, tokenParams),
			clientId = tokenParams.clientId || '',
			ttl = tokenParams.ttl || '',
			capability = tokenParams.capability,
			self = this;

		(function(authoriseCb) {
			if(request.timestamp) {
				authoriseCb();
				return;
			};
			self.getTimestamp(authOptions && authOptions.queryTime, function(err, time) {
				if(err) {callback(err); return;}
				request.timestamp = time;
				authoriseCb();
			});
		})(function() {
			/* nonce */
			/* NOTE: there is no expectation that the client
			 * specifies the nonce; this is done by the library
			 * However, this can be overridden by the client
			 * simply for testing purposes. */
			var nonce = request.nonce || (request.nonce = random()),
				timestamp = request.timestamp;

			var signText
			=	request.keyName + '\n'
			+	ttl + '\n'
			+	capability + '\n'
			+	clientId + '\n'
			+	timestamp + '\n'
			+	nonce + '\n';

			/* mac */
			/* NOTE: there is no expectation that the client
			 * specifies the mac; this is done by the library
			 * However, this can be overridden by the client
			 * simply for testing purposes. */
			request.mac = request.mac || hmac(signText, keySecret);

			Logger.logAction(Logger.LOG_MINOR, 'Auth.getTokenRequest()', 'generated signed request');
			callback(null, request);
		});
	};

	/**
	 * Get the auth query params to use for a websocket connection,
	 * based on the current auth parameters
	 */
	Auth.prototype.getAuthParams = function(callback) {
		if(this.method == 'basic')
			callback(null, {key: this.key});
		else
			this._ensureValidAuthCredentials(function(err, tokenDetails) {
				if(err) {
					callback(err);
					return;
				}
				callback(null, {access_token: tokenDetails.token});
			});
	};

	/**
	 * Get the authorization header to use for a REST or comet request,
	 * based on the current auth parameters
	 */
	Auth.prototype.getAuthHeaders = function(callback) {
		if(this.method == 'basic') {
			callback(null, {authorization: 'Basic ' + this.basicKey});
		} else {
			this._ensureValidAuthCredentials(function(err, tokenDetails) {
				if(err) {
					callback(err);
					return;
				}
				callback(null, {authorization: 'Bearer ' + toBase64(tokenDetails.token)});
			});
		}
	};

	/**
	 * Get the current time based on the local clock,
	 * or if the option queryTime is true, return the server time.
	 * The server time offset from the local time is stored so that
	 * only one request to the server to get the time is ever needed
	 */
	Auth.prototype.getTimestamp = function(queryTime, callback) {
		var offsetSet = !isNaN(parseInt(this.client.serverTimeOffset));
		if (!offsetSet && (queryTime || this.authOptions.queryTime)) {
			this.client.time(function(err, time) {
				if(err) {
					callback(err);
					return;
				}
				callback(null, time);
			});
		} else {
			callback(null, Utils.now() + (this.client.serverTimeOffset || 0));
		}
	};

	Auth.prototype._saveBasicOptions = function(authOptions) {
		this.method = 'basic';
		this.key = authOptions.key;
		this.basicKey = toBase64(authOptions.key);
		this.authOptions = authOptions || {};
		if('clientId' in authOptions) {
			this._userSetClientId(authOptions.clientId);
		}
	}

	Auth.prototype._saveTokenOptions = function(tokenParams, authOptions) {
		this.method = 'token';

		if(tokenParams) {
			/* We temporarily persist tokenParams.timestamp in case a new token needs
			 * to be requested, then null it out in the callback of
			 * _ensureValidAuthCredentials for RSA10g compliance */
			this.tokenParams = tokenParams;
		}

		if(authOptions) {
			/* normalise */
			if(authOptions.token) {
				/* options.token may contain a token string or, for convenience, a TokenDetails */
				authOptions.tokenDetails = (typeof(authOptions.token) === 'string') ? {token: authOptions.token} : authOptions.token;
			}

			if(authOptions.tokenDetails) {
				this.tokenDetails = authOptions.tokenDetails;
			}

			if('clientId' in authOptions) {
				this._userSetClientId(authOptions.clientId);
			}

			this.authOptions = authOptions;
		}
	};

	Auth.prototype._ensureValidAuthCredentials = function(callback) {
		var self = this,
			token = this.tokenDetails;

		var requestToken = function() {
			self.requestToken(self.tokenParams, self.authOptions, function(err, tokenResponse) {
				if(err) {
					callback(err);
					return;
				}
				callback(null, (self.tokenDetails = tokenResponse));
			});
		};

		if(token) {
			if(this._tokenClientIdMismatch(token.clientId)) {
				callback(new ErrorInfo('Mismatch between clientId in token (' + token.clientId + ') and current clientId (' + this.clientId + ')', 40102, 401));
				return;
			}
			this.getTimestamp(self.authOptions && self.authOptions.queryTime, function(err, time) {
				if(err)
					callback(err);

				if(token.expires === undefined || (token.expires >= time)) {
					Logger.logAction(Logger.LOG_MINOR, 'Auth.getToken()', 'using cached token; expires = ' + token.expires);
					callback(null, token);
					return;
				} else {
					/* expired, so remove */
					Logger.logAction(Logger.LOG_MINOR, 'Auth.getToken()', 'deleting expired token');
					self.tokenDetails = null;
				}
				requestToken();
			});
		} else {
			requestToken();
		}
	};


	/* User-set: check types, '*' is disallowed, throw any errors */
	Auth.prototype._userSetClientId = function(clientId) {
		if(!(typeof(clientId) === 'string' || clientId === null)) {
			throw new ErrorInfo('clientId must be either a string or null', 40012, 400);
		} else if(clientId === '*') {
			throw new ErrorInfo('Can’t use "*" as a clientId as that string is reserved. (To change the default token request behaviour to use a wildcard clientId, instantiate the library with {defaultTokenParams: {clientId: "*"}}), or if calling authorize(), pass it in as a tokenParam: authorize({clientId: "*"}, authOptions)', 40012, 400);
		} else {
			var err = this._uncheckedSetClientId(clientId);
			if(err) throw err;
		}
	};

	/* Ably-set: no typechecking, '*' is allowed but not set on this.clientId), return errors to the caller */
	Auth.prototype._uncheckedSetClientId = function(clientId) {
		if(this._tokenClientIdMismatch(clientId)) {
			/* Should never happen in normal circumstances as realtime should
			 * recognise mismatch and return an error */
			var msg = 'Unexpected clientId mismatch: client has ' + this.clientId + ', requested ' + clientId;
			var err = new ErrorInfo(msg, 40102, 401);
			Logger.logAction(Logger.LOG_ERROR, 'Auth._uncheckedSetClientId()', msg);
			return err;
		} else if(clientId === '*') {
			this.tokenParams.clientId = clientId;
		} else {
			/* RSA7a4: if options.clientId is provided and is not
			 * null, it overrides defaultTokenParams.clientId */
			this.clientId = this.tokenParams.clientId = clientId;
			return null;
		}
	};

	Auth.prototype._tokenClientIdMismatch = function(tokenClientId) {
		return this.clientId &&
			tokenClientId &&
			(tokenClientId !== '*') &&
			(this.clientId !== tokenClientId);
	};

	Auth.isTokenErr = function(error) {
		return error.code && (error.code >= 40140) && (error.code < 40150);
	};

	return Auth;
})();

var Rest = (function() {
	var noop = function() {};

	function Rest(options) {
		if(!(this instanceof Rest)){
			return new Rest(options);
		}

		/* normalise options */
		if(!options) {
			var msg = 'no options provided';
			Logger.logAction(Logger.LOG_ERROR, 'Rest()', msg);
			throw new Error(msg);
		}
		if(typeof(options) == 'string') {
			options = (options.indexOf(':') == -1) ? {token: options} : {key: options};
		}
		this.options = Defaults.normaliseOptions(options);

		/* process options */
		if(options.key) {
			var keyMatch = options.key.match(/^([^:\s]+):([^:.\s]+)$/);
			if(!keyMatch) {
				var msg = 'invalid key parameter';
				Logger.logAction(Logger.LOG_ERROR, 'Rest()', msg);
				throw new Error(msg);
			}
			options.keyName = keyMatch[1];
			options.keySecret = keyMatch[2];
		}

		if('clientId' in options) {
			if(!(typeof(options.clientId) === 'string' || options.clientId === null))
				throw new ErrorInfo('clientId must be either a string or null', 40012, 400);
			else if(options.clientId === '*')
				throw new ErrorInfo('Can’t use "*" as a clientId as that string is reserved. (To change the default token request behaviour to use a wildcard clientId, use {defaultTokenParams: {clientId: "*"}})', 40012, 400);
		}

		if(options.log)
			Logger.setLog(options.log.level, options.log.handler);
		Logger.logAction(Logger.LOG_MINOR, 'Rest()', 'started');

		this.baseUri = this.authority = function(host) { return Defaults.getHttpScheme(options) + host + ':' + Defaults.getPort(options, false); };

		this.serverTimeOffset = null;
		this.auth = new Auth(this, options);
		this.channels = new Channels(this);
	}

	Rest.prototype.stats = function(params, callback) {
		/* params and callback are optional; see if params contains the callback */
		if(callback === undefined) {
			if(typeof(params) == 'function') {
				callback = params;
				params = null;
			} else {
				callback = noop;
			}
		}
		var headers = Utils.copy(Utils.defaultGetHeaders()),
			envelope = Http.supportsLinkHeaders ? undefined : 'json';

		if(this.options.headers)
			Utils.mixin(headers, this.options.headers);

		(new PaginatedResource(this, '/stats', headers, envelope, function(body, headers, unpacked) {
			var statsValues = (unpacked ? body : JSON.parse(body));
			for(var i = 0; i < statsValues.length; i++) statsValues[i] = Stats.fromValues(statsValues[i]);
			return statsValues;
		})).get(params, callback);
	};

	Rest.prototype.time = function(params, callback) {
		/* params and callback are optional; see if params contains the callback */
		if(callback === undefined) {
			if(typeof(params) == 'function') {
				callback = params;
				params = null;
			} else {
				callback = noop;
			}
		}
		var headers = Utils.copy(Utils.defaultGetHeaders());
		if(this.options.headers)
			Utils.mixin(headers, this.options.headers);
		var self = this;
		var timeUri = function(host) { return self.authority(host) + '/time' };
		Http.get(this, timeUri, headers, params, function(err, res, headers, unpacked) {
			if(err) {
				callback(err);
				return;
			}
			if(!unpacked) res = JSON.parse(res);
			var time = res[0];
			if(!time) {
				err = new Error('Internal error (unexpected result type from GET /time)');
				err.statusCode = 500;
				callback(err);
				return;
			}
			/* calculate time offset only once for this device by adding to the prototype */
			self.serverTimeOffset = (time - Utils.now());
			callback(null, time);
		});
	};

	Rest.prototype.request = function(method, path, params, body, customHeaders, callback) {
		var format = this.options.useBinaryProtocol ? 'msgpack' : 'json',
			method = method.toLowerCase(),
			envelope = Http.supportsLinkHeaders ? undefined : 'json',
			params = params || {},
			headers = Utils.copy(method == 'get' ? Utils.defaultGetHeaders() : Utils.defaultPostHeaders(format));

		if(typeof body !== 'string') {
			body = JSON.stringify(body);
		}
		if(this.options.headers) {
			Utils.mixin(headers, this.options.headers);
		}
		if(customHeaders) {
			Utils.mixin(headers, customHeaders);
		}
		var paginatedResource = new PaginatedResource(this, path, headers, envelope, function(resbody, headers, unpacked) {
			return Utils.ensureArray(unpacked ? resbody : JSON.parse(resbody));
		}, /* useHttpPaginatedResponse: */ true);

		switch(method) {
			case 'get':
				paginatedResource.get(params, callback);
				break;
			case 'post':
				paginatedResource.post(params, body, callback);
				break;
			default:
				throw new ErrorInfo('Currently only GET and POST methods are supported', 40500, 405);
		}
	};

	function Channels(rest) {
		this.rest = rest;
		this.attached = {};
	}

	Channels.prototype.get = function(name, channelOptions) {
		name = String(name);
		var channel = this.attached[name];
		if(!channel) {
			this.attached[name] = channel = new Channel(this.rest, name, channelOptions);
		} else if(channelOptions) {
			channel.setOptions(channelOptions);
		}

		return channel;
	};

	return Rest;
})();

var Realtime = (function() {

	function Realtime(options) {
		if(!(this instanceof Realtime)){
			return new Realtime(options);
		}

		Logger.logAction(Logger.LOG_MINOR, 'Realtime()', '');
		Rest.call(this, options);
		this.connection = new Connection(this, this.options);
		this.channels = new Channels(this);
		if(options.autoConnect !== false)
			this.connect();
	}
	Utils.inherits(Realtime, Rest);

	Realtime.prototype.connect = function() {
		Logger.logAction(Logger.LOG_MINOR, 'Realtime.connect()', '');
		this.connection.connect();
	};

	Realtime.prototype.close = function() {
		Logger.logAction(Logger.LOG_MINOR, 'Realtime.close()', '');
		this.connection.close();
	};

	function Channels(realtime) {
		EventEmitter.call(this);
		this.realtime = realtime;
		this.all = {};
		this.inProgress = {};
		realtime.connection.connectionManager.on('transport.active', this.onTransportActive.bind(this));
	}
	Utils.inherits(Channels, EventEmitter);

	Channels.prototype.onChannelMessage = function(msg) {
		var channelName = msg.channel;
		if(channelName === undefined) {
			Logger.logAction(Logger.LOG_ERROR, 'Channels.onChannelMessage()', 'received event unspecified channel, action = ' + msg.action);
			return;
		}
		var channel = this.all[channelName];
		if(!channel) {
			Logger.logAction(Logger.LOG_ERROR, 'Channels.onChannelMessage()', 'received event for non-existent channel: ' + channelName);
			return;
		}
		channel.onMessage(msg);
	};

	/* called when a transport becomes connected; reattempt attach/detach
	 * for channels that are attaching or detaching.
	 * Note that this does not use inProgress as inProgress is only channels which have already made
	* at least one attempt to attach/detach */
	Channels.prototype.onTransportActive = function() {
		for(var channelName in this.all) {
			var channel = this.all[channelName];
			if(channel.state === 'attaching' || channel.state === 'detaching') {
				channel.checkPendingState();
			} else if(channel.state === 'suspended') {
				channel.autonomousAttach();
			}
		}
	};

	Channels.prototype.reattach = function(reason) {
		for(var channelId in this.all) {
			var channel = this.all[channelId];
			/* NB this should not trigger for merely attaching channels, as they will
			 * be reattached anyway through the onTransportActive checkPendingState */
			if(channel.state === 'attached') {
				channel.requestState('attaching', reason);
			}
		}
	};

	/* Connection interruptions (ie when the connection will no longer queue
	 * events) imply connection state changes for any channel which is either
	 * attached, pending, or will attempt to become attached in the future */
	Channels.prototype.propogateConnectionInterruption = function(connectionState, reason) {
		var connectionStateToChannelState = {
			'closing'  : 'detached',
			'closed'   : 'detached',
			'failed'   : 'failed',
			'suspended': 'suspended'
		};
		var fromChannelStates = ['attaching', 'attached', 'detaching', 'suspended'];
		var toChannelState = connectionStateToChannelState[connectionState];

		for(var channelId in this.all) {
			var channel = this.all[channelId];
			if(Utils.arrIn(fromChannelStates, channel.state)) {
				 channel.notifyState(toChannelState, reason);
			}
		}
	};

	Channels.prototype.get = function(name, channelOptions) {
		name = String(name);
		var channel = this.all[name];
		if(!channel) {
			channel = this.all[name] = new RealtimeChannel(this.realtime, name, channelOptions);
		} else if(channelOptions) {
			channel.setOptions(channelOptions);
		}
		return channel;
	};

	Channels.prototype.release = function(name) {
		var channel = this.all[name];
		if(channel) {
			delete this.all[name];
		}
	};

	/* Records operations currently pending on a transport; used by connectionManager to decide when
	 * it's safe to upgrade. Note that a channel might be in the attaching state without any pending
	 * operations (eg if attached while the connection state is connecting) - such a channel must not
	 * hold up an upgrade, so is not considered inProgress.
	 * Operation is currently one of either 'statechange' or 'sync' */
	Channels.prototype.setInProgress = function(channel, operation, inProgress) {
		this.inProgress[channel.name] = this.inProgress[channel.name] || {};
		this.inProgress[channel.name][operation] = inProgress;
		if(!inProgress && this.hasNopending()) {
			this.emit('nopending');
		}
	};

	Channels.prototype.onceNopending = function(listener) {
		if(this.hasNopending()) {
			listener();
			return;
		}
		this.once('nopending', listener);
	};

	Channels.prototype.hasNopending = function() {
		return Utils.arrEvery(Utils.valuesArray(this.inProgress, true), function(operations) {
			return !Utils.containsValue(operations, true);
		});
	};

	return Realtime;
})();

var ConnectionStateChange = (function() {

	/* public constructor */
	function ConnectionStateChange(previous, current, retryIn, reason) {
		this.previous = previous;
		this.current = current;
		if(retryIn) this.retryIn = retryIn;
		if(reason) this.reason = reason;
	}

	return ConnectionStateChange;
})();

var ChannelStateChange = (function() {

	/* public constructor */
	function ChannelStateChange(previous, current, resumed, reason) {
		this.previous = previous;
		this.current = current;
		if(current === 'attached') this.resumed = resumed;
		if(reason) this.reason = reason;
	}

	return ChannelStateChange;
})();

var Connection = (function() {

	/* public constructor */
	function Connection(ably, options) {
		EventEmitter.call(this);
		this.ably = ably;
		this.connectionManager = new ConnectionManager(ably, options);
		this.state = this.connectionManager.state.state;
		this.key = undefined;
		this.id = undefined;
		this.serial = undefined;
		this.recoveryKey = undefined;
		this.errorReason = null;

		var self = this;
		this.connectionManager.on('connectionstate', function(stateChange) {
			var state = self.state = stateChange.current;
			Utils.nextTick(function() {
				self.emit(state, stateChange);
			});
		});
		this.connectionManager.on('update', function(stateChange) {
			Utils.nextTick(function() {
				self.emit('update', stateChange);
			});
		});
	}
	Utils.inherits(Connection, EventEmitter);

	Connection.prototype.whenState = function(state, listener) {
		EventEmitter.prototype.whenState.call(this, state, this.state, listener, new ConnectionStateChange(undefined, state));
	}

	Connection.prototype.connect = function() {
		Logger.logAction(Logger.LOG_MINOR, 'Connection.connect()', '');
		this.connectionManager.requestState({state: 'connecting'});
	};

	Connection.prototype.ping = function(callback) {
		Logger.logAction(Logger.LOG_MINOR, 'Connection.ping()', '');
		callback = callback || function() {};
		this.connectionManager.ping(null, callback);
	};

	Connection.prototype.close = function() {
		Logger.logAction(Logger.LOG_MINOR, 'Connection.close()', 'connectionKey = ' + this.key);
		this.connectionManager.requestState({state: 'closing'});
	};

	return Connection;
})();

var Channel = (function() {
	function noop() {}

	/* public constructor */
	function Channel(rest, name, channelOptions) {
		Logger.logAction(Logger.LOG_MINOR, 'Channel()', 'started; name = ' + name);
		EventEmitter.call(this);
		this.rest = rest;
		this.name = name;
		this.basePath = '/channels/' + encodeURIComponent(name);
		this.presence = new Presence(this);
		this.setOptions(channelOptions);
	}
	Utils.inherits(Channel, EventEmitter);

	Channel.prototype.setOptions = function(options) {
		this.channelOptions = options = options || {};
		if(options.cipher) {
			if(!Crypto) throw new Error('Encryption not enabled; use ably.encryption.js instead');
			var cipher = Crypto.getCipher(options.cipher);
			options.cipher = cipher.cipherParams;
			options.channelCipher = cipher.cipher;
		} else if('cipher' in options) {
			/* Don't deactivate an existing cipher unless options
			 * has a 'cipher' key that's falsey */
			options.cipher = null;
			options.channelCipher = null;
		}
	};

	Channel.prototype.history = function(params, callback) {
		Logger.logAction(Logger.LOG_MICRO, 'Channel.history()', 'channel = ' + this.name);
		/* params and callback are optional; see if params contains the callback */
		if(callback === undefined) {
			if(typeof(params) == 'function') {
				callback = params;
				params = null;
			} else {
				callback = noop;
			}
		}

		this._history(params, callback);
	};

	Channel.prototype._history = function(params, callback) {
		var rest = this.rest,
			format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			envelope = Http.supportsLinkHeaders ? undefined : format,
			headers = Utils.copy(Utils.defaultGetHeaders(format)),
			channel = this;

		if(rest.options.headers)
			Utils.mixin(headers, rest.options.headers);

		var options = this.channelOptions;
		(new PaginatedResource(rest, this.basePath + '/messages', headers, envelope, function(body, headers, unpacked) {
			return Message.fromResponseBody(body, options, !unpacked && format);
		})).get(params, callback);
	};

	Channel.prototype.publish = function() {
		var argCount = arguments.length,
			messages = arguments[0],
			callback = arguments[argCount - 1],
			self = this;

		if(typeof(callback) !== 'function') {
			callback = noop;
			++argCount;
		}
		if(argCount == 2) {
			if(Utils.isObject(messages))
				messages = [Message.fromValues(messages)];
			else if(Utils.isArray(messages))
				messages = Message.fromValuesArray(messages);
			else
				throw new ErrorInfo('The single-argument form of publish() expects a message object or an array of message objects', 40013, 400);
		} else {
			messages = [Message.fromValues({name: arguments[0], data: arguments[1]})];
		}

		var rest = this.rest,
			format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			headers = Utils.copy(Utils.defaultPostHeaders(format));

		if(rest.options.headers)
			Utils.mixin(headers, rest.options.headers);

		Message.toRequestBody(messages, this.channelOptions, format, function(err, requestBody) {
			if (err) {
				callback(err);
				return;
			}
			self._publish(requestBody, headers, callback);
		});
	};

	Channel.prototype._publish = function(requestBody, headers, callback) {
		Resource.post(this.rest, this.basePath + '/messages', requestBody, headers, null, false, callback);
	};

	return Channel;
})();

var RealtimeChannel = (function() {
	var actions = ProtocolMessage.Action;
	var noop = function() {};
	var statechangeOp = 'statechange';
	var syncOp = 'sync';

	/* public constructor */
	function RealtimeChannel(realtime, name, options) {
		Logger.logAction(Logger.LOG_MINOR, 'RealtimeChannel()', 'started; name = ' + name);
		Channel.call(this, realtime, name, options);
		this.realtime = realtime;
		this.presence = new RealtimePresence(this, realtime.options);
		this.connectionManager = realtime.connection.connectionManager;
		this.state = 'initialized';
		this.subscriptions = new EventEmitter();
		this.pendingEvents = [];
		this.syncChannelSerial = undefined;
		this.attachSerial = undefined;
		this.setOptions(options);
		this.errorReason = null;
		this._requestedFlags = null;
		this._mode = null;
	}
	Utils.inherits(RealtimeChannel, Channel);

	RealtimeChannel.invalidStateError = function(state) {
		return {
			statusCode: 400,
			code: 90001,
			message: 'Channel operation failed as channel state is ' + state
		};
	};

	RealtimeChannel.progressOps = {
		statechange: statechangeOp,
		sync: syncOp
	};

	RealtimeChannel.processListenerArgs = function(args) {
		/* [event], listener, [callback] */
		if(typeof(args[0]) == 'function')
			return [null, args[0], args[1] || noop];
		else
			return [args[0], args[1], (args[2] || noop)];
	}

	RealtimeChannel.prototype.publish = function() {
		var argCount = arguments.length,
			messages = arguments[0],
			callback = arguments[argCount - 1];

		if(typeof(callback) !== 'function') {
			callback = noop;
			++argCount;
		}
		if(!this.connectionManager.activeState()) {
			callback(this.connectionManager.getStateError());
			return;
		}
		if(argCount == 2) {
			if(Utils.isObject(messages))
				messages = [Message.fromValues(messages)];
			else if(Utils.isArray(messages))
				messages = Message.fromValuesArray(messages);
			else
				throw new ErrorInfo('The single-argument form of publish() expects a message object or an array of message objects', 40013, 400);
		} else {
			messages = [Message.fromValues({name: arguments[0], data: arguments[1]})];
		}
		var options = this.channelOptions;
		var self = this;
		Message.encodeArray(messages, options, function(err) {
			if (err) {
				callback(err);
				return;
			}
			self._publish(messages, callback);
		});
	};

	RealtimeChannel.prototype._publish = function(messages, callback) {
		Logger.logAction(Logger.LOG_MICRO, 'RealtimeChannel.publish()', 'message count = ' + messages.length);
		switch(this.state) {
			case 'failed':
				callback(ErrorInfo.fromValues(RealtimeChannel.invalidStateError('failed')));
				break;
			case 'attached':
				Logger.logAction(Logger.LOG_MICRO, 'RealtimeChannel.publish()', 'sending message');
				var msg = new ProtocolMessage();
				msg.action = actions.MESSAGE;
				msg.channel = this.name;
				msg.messages = messages;
				this.sendMessage(msg, callback);
				break;
			default:
				this.autonomousAttach();
			case 'attaching':
				if(this.realtime.options.queueMessages) {
					Logger.logAction(Logger.LOG_MICRO, 'RealtimeChannel.publish()', 'queueing message');
					this.pendingEvents.push({messages: messages, callback: callback});
				} else {
					var msg = 'Cannot publish messages while channel is attaching as queueMessages was disabled';
					Logger.logAction(Logger.LOG_MICRO, 'RealtimeChannel.publish()', msg);
					callback(new ErrorInfo(msg, 90001, 409));
				}
				break;
		}
	};

	RealtimeChannel.prototype.onEvent = function(messages) {
		Logger.logAction(Logger.LOG_MICRO, 'RealtimeChannel.onEvent()', 'received message');
		var subscriptions = this.subscriptions;
		for(var i = 0; i < messages.length; i++) {
			var message = messages[i];
			subscriptions.emit(message.name, message);
		}
	};

	RealtimeChannel.prototype.attach = function(flags, callback) {
		if(typeof(flags) === 'function') {
			callback = flags;
			flags = null;
		}
		callback = callback || noop;
		if(flags) {
			this._requestedFlags = flags;
		}
		var connectionManager = this.connectionManager;
		if(!connectionManager.activeState()) {
			callback(connectionManager.getStateError());
			return;
		}
		switch(this.state) {
			case 'attached':
				/* If flags requested, always do a re-attach. TODO only do this if if
				* current mode differs from requested mode */
				if(!flags) {
					callback();
					break;
				} /* else fallthrough */
			default:
				this.requestState('attaching');
			case 'attaching':
				this.once(function(stateChange) {
					switch(this.event) {
						case 'attached':
							callback();
							break;
						case 'detached':
						case 'suspended':
						case 'failed':
							callback(stateChange.reason || connectionManager.getStateError());
					}
				});
			}
    };

	RealtimeChannel.prototype.attachImpl = function() {
		Logger.logAction(Logger.LOG_MICRO, 'RealtimeChannel.attachImpl()', 'sending ATTACH message');
		this.setInProgress(statechangeOp, true);
		var attachMsg = ProtocolMessage.fromValues({action: actions.ATTACH, channel: this.name});
		if(this._requestedFlags) {
			Utils.arrForEach(this._requestedFlags, function(flag) {
				attachMsg.setFlag(flag);
			})
		}
		this.sendMessage(attachMsg, noop);
	};

	RealtimeChannel.prototype.detach = function(callback) {
		callback = callback || noop;
		var connectionManager = this.connectionManager;
		if(!connectionManager.activeState()) {
			callback(connectionManager.getStateError());
			return;
		}
		switch(this.state) {
			case 'detached':
			case 'failed':
				callback();
				break;
			default:
				this.requestState('detaching');
			case 'detaching':
				this.once(function(stateChange) {
					switch(this.event) {
						case 'detached':
							callback();
							break;
						case 'failed':
						case 'attached':
							callback(stateChange.reason || connectionManager.getStateError());
							break;
						default:
							/* this shouldn't happen ... */
							callback(ConnectionError.unknownChannelErr);
							break;
					}
				});
		}
	};

	RealtimeChannel.prototype.autonomousAttach = function() {
		var self = this;
		this.attach(function(err) {
			if(err) {
				var msg = 'Channel auto-attach failed: ' + err.toString();
				Logger.logAction(Logger.LOG_MINOR, 'RealtimeChannel.autonomousAttach()', msg);
			}
		});
	};

	RealtimeChannel.prototype.detachImpl = function(callback) {
		Logger.logAction(Logger.LOG_MICRO, 'RealtimeChannel.detach()', 'sending DETACH message');
		this.setInProgress(statechangeOp, true);
		var msg = ProtocolMessage.fromValues({action: actions.DETACH, channel: this.name});
		this.sendMessage(msg, (callback || noop));
	};

	RealtimeChannel.prototype.subscribe = function(/* [event], listener, [callback] */) {
		var args = RealtimeChannel.processListenerArgs(arguments);
		var event = args[0];
		var listener = args[1];
		var callback = args[2];
		var subscriptions = this.subscriptions;
		var events;

		if(this.state === 'failed') {
			callback(ErrorInfo.fromValues(RealtimeChannel.invalidStateError('failed')));
			return;
		}

		subscriptions.on(event, listener);

		if(callback) {
			this.attach(callback);
		} else {
			this.autonomousAttach();
		}
	};

	RealtimeChannel.prototype.unsubscribe = function(/* [event], listener, [callback] */) {
		var args = RealtimeChannel.processListenerArgs(arguments);
		var event = args[0];
		var listener = args[1];
		var callback = args[2];
		var subscriptions = this.subscriptions;
		var events;

		if(this.state === 'failed') {
			callback(ErrorInfo.fromValues(RealtimeChannel.invalidStateError('failed')));
			return;
		}

		subscriptions.off(event, listener);
	};

	RealtimeChannel.prototype.sync = function() {
		/* check preconditions */
		switch(this.state) {
			case 'initialized':
			case 'detaching':
			case 'detached':
				throw new ErrorInfo("Unable to sync to channel; not attached", 40000);
			default:
		}
		var connectionManager = this.connectionManager;
		if(!connectionManager.activeState()) {
			throw connectionManager.getStateError();
		}

		/* send sync request */
		var syncMessage = ProtocolMessage.fromValues({action: actions.SYNC, channel: this.name});
		if(this.syncChannelSerial) {
			syncMessage.channelSerial = this.syncChannelSerial;
		}
		connectionManager.send(syncMessage);
	};

	RealtimeChannel.prototype.sendMessage = function(msg, callback) {
		this.connectionManager.send(msg, this.realtime.options.queueMessages, callback);
	};

	RealtimeChannel.prototype.sendPresence = function(presence, callback) {
		var msg = ProtocolMessage.fromValues({
			action: actions.PRESENCE,
			channel: this.name,
			presence: (Utils.isArray(presence) ?
				PresenceMessage.fromValuesArray(presence) :
				[PresenceMessage.fromValues(presence)])
		});
		this.sendMessage(msg, callback);
	};

	RealtimeChannel.prototype.onMessage = function(message) {
		var syncChannelSerial, isSync = false;
		switch(message.action) {
		case actions.ATTACHED:
			this.attachSerial = message.channelSerial;
			this._mode = message.getMode();
			if(this.state === 'attached') {
				if(!message.hasFlag('RESUMED')) {
					/* On a loss of continuity, the presence set needs to be re-synced */
					this.presence.onAttached(message.hasFlag('HAS_PRESENCE'))
					var change = new ChannelStateChange(this.state, this.state, false, message.error);
					this.emit('update', change);
				}
			} else {
				this.notifyState('attached', message.error, message.hasFlag('RESUMED'), message.hasFlag('HAS_PRESENCE'));
			}
			break;

		case actions.DETACHED:
			var err = message.error ? ErrorInfo.fromValues(message.error) : new ErrorInfo('Channel detached', 90001, 404);
			if(this.state === 'detaching') {
				this.notifyState('detached', err);
			} else if(this.state === 'attaching') {
				/* Only retry immediately if we were previously attached. If we were
				 * attaching, go into suspended, fail messages, and wait a few seconds
				 * before retrying */
				this.notifyState('suspended', err);
			} else {
				this.requestState('attaching', err);
			}
			break;

		case actions.SYNC:
			/* syncs can have channelSerials, but might not if the sync is one page long */
			isSync = true;
			syncChannelSerial = this.syncChannelSerial = message.channelSerial;
			/* syncs can happen on channels with no presence data as part of connection
			 * resuming, in which case protocol message has no presence property */
			if(!message.presence) break;
		case actions.PRESENCE:
			var presence = message.presence,
				id = message.id,
				connectionId = message.connectionId,
				timestamp = message.timestamp;

			var options = this.channelOptions;
			for(var i = 0; i < presence.length; i++) {
				try {
					var presenceMsg = presence[i];
					PresenceMessage.decode(presenceMsg, options);
				} catch (e) {
					Logger.logAction(Logger.LOG_ERROR, 'RealtimeChannel.onMessage()', e.toString());
				}
				if(!presenceMsg.connectionId) presenceMsg.connectionId = connectionId;
				if(!presenceMsg.timestamp) presenceMsg.timestamp = timestamp;
				if(!presenceMsg.id) presenceMsg.id = id + ':' + i;
			}
			this.presence.setPresence(presence, isSync, syncChannelSerial);
			break;

		case actions.MESSAGE:
			var messages = message.messages,
				id = message.id,
				connectionId = message.connectionId,
				timestamp = message.timestamp;

			var options = this.channelOptions;
			for(var i = 0; i < messages.length; i++) {
				try {
					var msg = messages[i];
					Message.decode(msg, options);
				} catch (e) {
					/* decrypt failed .. the most likely cause is that we have the wrong key */
					Logger.logAction(Logger.LOG_ERROR, 'RealtimeChannel.onMessage()', e.toString());
				}
				if(!msg.connectionId) msg.connectionId = connectionId;
				if(!msg.timestamp) msg.timestamp = timestamp;
				if(!msg.id) msg.id = id + ':' + i;
			}
			this.onEvent(messages);
			break;

		case actions.ERROR:
			/* there was a channel-specific error */
			var err = message.error;
			if(err && err.code == 80016) {
				/* attach/detach operation attempted on superseded transport handle */
				this.checkPendingState();
			} else {
				this.notifyState('failed', ErrorInfo.fromValues(err));
			}
			break;

		default:
			Logger.logAction(Logger.LOG_ERROR, 'RealtimeChannel.onMessage()', 'Fatal protocol error: unrecognised action (' + message.action + ')');
			this.connectionManager.abort(ConnectionError.unknownChannelErr);
		}
	};

	RealtimeChannel.mergeTo = function(dest, src) {
		var result = false;
		var action;
		if(dest.channel == src.channel) {
			if((action = dest.action) == src.action) {
				switch(action) {
				case actions.MESSAGE:
					for(var i = 0; i < src.messages.length; i++)
						dest.messages.push(src.messages[i]);
					result = true;
					break;
				case actions.PRESENCE:
					for(var i = 0; i < src.presence.length; i++)
						dest.presence.push(src.presence[i]);
					result = true;
					break;
				default:
				}
			}
		}
		return result;
	};

	RealtimeChannel.prototype.onAttached = function() {
		Logger.logAction(Logger.LOG_MINOR, 'RealtimeChannel.onAttached', 'activating channel; name = ' + this.name);

		var pendingEvents = this.pendingEvents, pendingCount = pendingEvents.length;
		if(pendingCount) {
			this.pendingEvents = [];
			var msg = ProtocolMessage.fromValues({action: actions.MESSAGE, channel: this.name, messages: []});
			var multicaster = Multicaster();
			Logger.logAction(Logger.LOG_MICRO, 'RealtimeChannel.setAttached', 'sending ' + pendingCount + ' queued messages');
			for(var i = 0; i < pendingCount; i++) {
				var event = pendingEvents[i];
				Array.prototype.push.apply(msg.messages, event.messages);
				multicaster.push(event.callback);
			}
			this.sendMessage(msg, multicaster);
		}
	};

	RealtimeChannel.prototype.notifyState = function(state, reason, resumed, hasPresence) {
		Logger.logAction(Logger.LOG_MICRO, 'RealtimeChannel.notifyState', 'name = ' + this.name + ', current state = ' + this.state + ', notifying state ' + state);
		this.clearStateTimer();

		if(state === this.state) {
			return;
		}
		this.presence.actOnChannelState(state, hasPresence, reason);
		if(state !== 'attached' && state !== 'attaching') {
			this.failPendingMessages(reason || RealtimeChannel.invalidStateError(state));
		}
		if(state === 'suspended' && this.connectionManager.state.sendEvents) {
			this.startRetryTimer();
		} else {
			this.cancelRetryTimer();
		}
		if(reason) {
			this.errorReason = reason;
		}
		var change = new ChannelStateChange(this.state, state, resumed, reason);
		var logLevel = state === 'failed' ? Logger.LOG_ERROR : Logger.LOG_MAJOR;
		Logger.logAction(logLevel, 'Channel state for channel "' + this.name + '"', state + (reason ? ('; reason: ' + reason.toString()) : ''));

		/* Note: we don't set inProgress for pending states until the request is actually in progress */
		if(state === 'attached') {
			this.onAttached();
			this.setInProgress(syncOp, hasPresence);
			this.setInProgress(statechangeOp, false);
		} else if(state === 'detached' || state === 'failed' || state === 'suspended') {
			this.setInProgress(statechangeOp, false);
			this.setInProgress(syncOp, false);
		}

		this.state = state;
		this.emit(state, change);
	};

	RealtimeChannel.prototype.requestState = function(state, reason) {
		Logger.logAction(Logger.LOG_MINOR, 'RealtimeChannel.requestState', 'name = ' + this.name + ', state = ' + state);
		this.notifyState(state, reason);
		/* send the event and await response */
		this.checkPendingState();
	};

	RealtimeChannel.prototype.checkPendingState = function() {
		/* if can't send events, do nothing */
		var cmState = this.connectionManager.state;
		/* Allow attach messages to queue up when synchronizing, since this will be
		 * the state we'll be in when upgrade transport.active triggers a checkpendingstate */
		if(!(cmState.sendEvents || cmState.forceQueueEvents)) {
			Logger.logAction(Logger.LOG_MINOR, 'RealtimeChannel.checkPendingState', 'sendEvents is false; state is ' + this.connectionManager.state.state);
			return;
		}

		Logger.logAction(Logger.LOG_MINOR, 'RealtimeChannel.checkPendingState', 'name = ' + this.name + ', state = ' + this.state);
		/* Only start the state timer running when actually sending the event */
		switch(this.state) {
			case 'attaching':
				this.startStateTimerIfNotRunning();
				this.attachImpl();
				break;
			case 'detaching':
				this.startStateTimerIfNotRunning();
				this.detachImpl();
				break;
			case 'attached':
				/* resume any sync operation that was in progress */
				this.sync();
			default:
				break;
		}
	};

	RealtimeChannel.prototype.timeoutPendingState = function() {
		switch(this.state) {
			case 'attaching':
				var err = new ErrorInfo('Channel attach timed out', 90007, 408);
				this.notifyState('suspended', err);
				break;
			case 'detaching':
				var err = new ErrorInfo('Channel detach timed out', 90007, 408);
				this.notifyState('attached', err);
				break;
			default:
				this.checkPendingState();
				break;
		}
	};

	RealtimeChannel.prototype.startStateTimerIfNotRunning = function() {
		var self = this;
		if(!this.stateTimer) {
			this.stateTimer = setTimeout(function() {
				Logger.logAction(Logger.LOG_MINOR, 'RealtimeChannel.startStateTimerIfNotRunning', 'timer expired');
				self.stateTimer = null;
				self.timeoutPendingState();
			}, this.realtime.options.timeouts.realtimeRequestTimeout);
		}
	};

	RealtimeChannel.prototype.clearStateTimer = function() {
		var stateTimer = this.stateTimer;
		if(stateTimer) {
			clearTimeout(stateTimer);
			this.stateTimer = null;
		}
	};

	RealtimeChannel.prototype.startRetryTimer = function() {
		var self = this;
		if(this.retryTimer) return;

		this.retryTimer = setTimeout(function() {
			/* If connection is not connected, just leave in suspended, a reattach
			 * will be triggered once it connects again */
			if(self.state === 'suspended' && self.connectionManager.state.sendEvents) {
				self.retryTimer = null;
				Logger.logAction(Logger.LOG_MINOR, 'RealtimeChannel retry timer expired', 'attempting a new attach');
				self.requestState('attaching');
			}
		}, this.realtime.options.timeouts.channelRetryTimeout);
	};

	RealtimeChannel.prototype.cancelRetryTimer = function() {
		if(this.retryTimer) {
			clearTimeout(this.retryTimer);
			this.suspendTimer = null;
		}
	};

	RealtimeChannel.prototype.setInProgress = function(operation, value) {
		this.rest.channels.setInProgress(this, operation, value);
	};

	RealtimeChannel.prototype.failPendingMessages = function(err) {
		Logger.logAction(Logger.LOG_MINOR, 'RealtimeChannel.failPendingMessages', 'channel; name = ' + this.name + ', err = ' + Utils.inspectError(err));
		for(var i = 0; i < this.pendingEvents.length; i++)
			try {
				this.pendingEvents[i].callback(err);
			} catch(e) {}
		this.pendingEvents = [];
	};

	RealtimeChannel.prototype.history = function(params, callback) {
		Logger.logAction(Logger.LOG_MICRO, 'RealtimeChannel.history()', 'channel = ' + this.name);
		/* params and callback are optional; see if params contains the callback */
		if(callback === undefined) {
			if(typeof(params) == 'function') {
				callback = params;
				params = null;
			} else {
				callback = noop;
			}
		}

		if(params && params.untilAttach) {
			if(this.state !== 'attached') {
				callback(new ErrorInfo("option untilAttach requires the channel to be attached", 40000, 400));
				return;
			}
			if(!this.attachSerial) {
				callback(new ErrorInfo("untilAttach was specified and channel is attached, but attachSerial is not defined", 40000, 400));
				return;
			}
			delete params.untilAttach;
			params.from_serial = this.attachSerial;
		}

		Channel.prototype._history.call(this, params, callback);
	};

	RealtimeChannel.prototype.whenState = function(state, listener) {
		EventEmitter.prototype.whenState.call(this, state, this.state, listener);
	}

	return RealtimeChannel;
})();

var RealtimePresence = (function() {
	var noop = function() {};

	function memberKey(item) {
		return item.clientId + ':' + item.connectionId;
	}

	function getClientId(realtimePresence) {
		return realtimePresence.channel.realtime.auth.clientId;
	}

	function isAnonymous(realtimePresence) {
		var realtime = realtimePresence.channel.realtime;
		/* If not currently connected, we can't assume that we're an anonymous
		 * client, as realtime may inform us of our clientId in the CONNECTED
		 * message. So assume we're not anonymous and leave it to realtime to
		 * return an error if we are */
		return !realtime.auth.clientId && realtime.connection.state === 'connected';
	}

	function waitAttached(channel, callback, action) {
		switch(channel.state) {
			case 'attached':
			case 'suspended':
				action();
				break;
			case 'initialized':
			case 'detached':
			case 'detaching':
			case 'attaching':
				channel.attach(function(err) {
					if(err) callback(err);
					else action();
				});
				break;
			default:
				callback(ErrorInfo.fromValues(RealtimeChannel.invalidStateError(channel.state)));
		}
	}

	function RealtimePresence(channel, options) {
		Presence.call(this, channel);
		this.members = new PresenceMap(this);
		this._myMembers = new PresenceMap(this);
		this.subscriptions = new EventEmitter();
		this.pendingPresence = [];
	}
	Utils.inherits(RealtimePresence, Presence);

	RealtimePresence.prototype.enter = function(data, callback) {
		if(isAnonymous(this))
			throw new ErrorInfo('clientId must be specified to enter a presence channel', 40012, 400);
		this._enterOrUpdateClient(undefined, data, callback, 'enter');
	};

	RealtimePresence.prototype.update = function(data, callback) {
		if(isAnonymous(this))
			throw new ErrorInfo('clientId must be specified to update presence data', 40012, 400);
		this._enterOrUpdateClient(undefined, data, callback, 'update');
	};

	RealtimePresence.prototype.enterClient = function(clientId, data, callback) {
		this._enterOrUpdateClient(clientId, data, callback, 'enter');
	};

	RealtimePresence.prototype.updateClient = function(clientId, data, callback) {
		this._enterOrUpdateClient(clientId, data, callback, 'update');
	};

	RealtimePresence.prototype._enterOrUpdateClient = function(clientId, data, callback, action) {
		if (!callback) {
			if (typeof(data)==='function') {
				callback = data;
				data = null;
			} else {
				callback = noop;
			}
		}

		var channel = this.channel;
		if(!channel.connectionManager.activeState()) {
			callback(channel.connectionManager.getStateError());
			return;
		}

		Logger.logAction(Logger.LOG_MICRO, 'RealtimePresence.' + action + 'Client()',
		  action + 'ing; channel = ' + channel.name + ', client = ' + clientId || '(implicit) ' + getClientId(this));

		var presence = PresenceMessage.fromValues({
			action : action,
			data   : data
		});
		if (clientId) { presence.clientId = clientId; }

		var self = this;
		PresenceMessage.encode(presence, channel.channelOptions, function(err) {
			if (err) {
				callback(err);
				return;
			}
			switch(channel.state) {
				case 'attached':
					channel.sendPresence(presence, callback);
					break;
				case 'initialized':
				case 'detached':
					channel.autonomousAttach();
				case 'attaching':
					self.pendingPresence.push({
						presence : presence,
						callback : callback
					});
					break;
				default:
					var err = new ErrorInfo('Unable to ' + action + ' presence channel (incompatible state)', 90001);
					err.code = 90001;
					callback(err);
			}
		});
	};

	RealtimePresence.prototype.leave = function(data, callback) {
		if(isAnonymous(this))
			throw new ErrorInfo('clientId must have been specified to enter or leave a presence channel', 40012, 400);
		this.leaveClient(undefined, data, callback);
	};

	RealtimePresence.prototype.leaveClient = function(clientId, data, callback) {
		if (!callback) {
			if (typeof(data)==='function') {
				callback = data;
				data = null;
			} else {
				callback = noop;
			}
		}

		var channel = this.channel;
		if(!channel.connectionManager.activeState()) {
			callback(channel.connectionManager.getStateError());
			return;
		}

		Logger.logAction(Logger.LOG_MICRO, 'RealtimePresence.leaveClient()', 'leaving; channel = ' + this.channel.name + ', client = ' + clientId);
		var presence = PresenceMessage.fromValues({
			action : 'leave',
			data   : data
		});
		if (clientId) { presence.clientId = clientId; }

		switch(channel.state) {
			case 'attached':
				channel.sendPresence(presence, callback);
				break;
			case 'attaching':
				this.pendingPresence.push({
					presence : presence,
					callback : callback
				});
				break;
			case 'initialized':
			case 'failed':
				/* we're not attached; therefore we let any entered status
				 * timeout by itself instead of attaching just in order to leave */
				var err = new ErrorInfo('Unable to leave presence channel (incompatible state)', 90001);
				callback(err);
				break;
			default:
				/* there is no connection; therefore we let
				 * any entered status timeout by itself */
				callback(ConnectionError.failed);
		}
	};

	RealtimePresence.prototype.get = function(/* params, callback */) {
		var args = Array.prototype.slice.call(arguments);
		if(args.length == 1 && typeof(args[0]) == 'function')
			args.unshift(null);

		var params = args[0],
			callback = args[1] || noop,
			waitForSync = !params || ('waitForSync' in params ? params.waitForSync : true)

		function returnMembers(members) {
			callback(null, params ? members.list(params) : members.values());
		}

		/* Special-case the suspended state: can still get (stale) presence set if waitForSync is false */
		if(this.channel.state === 'suspended') {
			if(waitForSync) {
				callback(ErrorInfo.fromValues({
					statusCode: 400,
					code: 91005,
					message: 'Presence state is out of sync due to channel being in the SUSPENDED state'
				}));
			} else {
				returnMembers(this.members);
			}
			return;
		}

		var self = this;
		waitAttached(this.channel, callback, function() {
			var members = self.members;
			if(waitForSync) {
				members.waitSync(function() {
					returnMembers(members);
				});
			} else {
				returnMembers(members);
			}
		});
	};

	RealtimePresence.prototype.history = function(params, callback) {
		Logger.logAction(Logger.LOG_MICRO, 'RealtimePresence.history()', 'channel = ' + this.name);
		/* params and callback are optional; see if params contains the callback */
		if(callback === undefined) {
			if(typeof(params) == 'function') {
				callback = params;
				params = null;
			} else {
				callback = noop;
			}
		}

		if(params && params.untilAttach) {
			if(this.channel.state === 'attached') {
				delete params.untilAttach;
				params.from_serial = this.channel.attachSerial;
			} else {
				callback(new ErrorInfo("option untilAttach requires the channel to be attached, was: " + this.channel.state, 40000, 400));
			}
		}

		Presence.prototype._history.call(this, params, callback);
	};

	RealtimePresence.prototype.setPresence = function(presenceSet, isSync, syncChannelSerial) {
		Logger.logAction(Logger.LOG_MICRO, 'RealtimePresence.setPresence()', 'received presence for ' + presenceSet.length + ' participants; syncChannelSerial = ' + syncChannelSerial);
		var syncCursor, match, members = this.members, myMembers = this._myMembers,
			broadcastMessages = [], connId = this.channel.connectionManager.connectionId;

		if(isSync) {
			this.members.startSync();
			if(syncChannelSerial && (match = syncChannelSerial.match(/^[\w\-]+:(.*)$/))) {
				syncCursor = match[1];
			}
		}

		for(var i = 0; i < presenceSet.length; i++) {
			var presence = PresenceMessage.fromValues(presenceSet[i]);
			switch(presence.action) {
				case 'leave':
					if(members.remove(presence)) {
						broadcastMessages.push(presence);
					}
					if(presence.connectionId === connId && !presence.isSynthesized) {
						myMembers.remove(presence);
					}
					break;
				case 'enter':
				case 'present':
				case 'update':
					if(members.put(presence)) {
						broadcastMessages.push(presence);
					}
					if(presence.connectionId === connId) {
						myMembers.put(presence);
					}
					break;
			}
		}
		/* if this is the last (or only) message in a sequence of sync updates, end the sync */
		if(isSync && !syncCursor) {
			members.endSync();
			/* RTP5c2: re-enter our own members if they haven't shown up in the sync */
			this._ensureMyMembersPresent();
			this.channel.setInProgress(RealtimeChannel.progressOps.sync, false);
			this.channel.syncChannelSerial = null;
		}

		/* broadcast to listeners */
		for(var i = 0; i < broadcastMessages.length; i++) {
			var presence = broadcastMessages[i];
			this.subscriptions.emit(presence.action, presence);
		}
	};

	RealtimePresence.prototype.onAttached = function(hasPresence) {
		Logger.logAction(Logger.LOG_MINOR, 'RealtimePresence.onAttached()', 'channel = ' + this.channel.name + ', hasPresence = ' + hasPresence);

		if(hasPresence) {
			this.members.startSync();
		} else {
			this._synthesizeLeaves(this.members.values());
			this.members.clear();
			this._ensureMyMembersPresent();
		}

		/* NB this must be after the _ensureMyMembersPresent call, which may add items to pendingPresence */
		var pendingPresence = this.pendingPresence,
			pendingPresCount = pendingPresence.length;

		if(pendingPresCount) {
			this.pendingPresence = [];
			var presenceArray = [];
			var multicaster = Multicaster();
			Logger.logAction(Logger.LOG_MICRO, 'RealtimePresence.onAttached', 'sending ' + pendingPresCount + ' queued presence messages');
			for(var i = 0; i < pendingPresCount; i++) {
				var event = pendingPresence[i];
				presenceArray.push(event.presence);
				multicaster.push(event.callback);
			}
			this.channel.sendPresence(presenceArray, multicaster);
		}
	};

	RealtimePresence.prototype.actOnChannelState = function(state, hasPresence, err) {
		switch(state) {
			case 'attached':
				this.onAttached(hasPresence);
				break;
			case 'detached':
			case 'failed':
				this._clearMyMembers();
				this.members.clear();
				/* falls through */
			case 'suspended':
				this.failPendingPresence(err);
				break;
		}
	};

	RealtimePresence.prototype.failPendingPresence = function(err) {
		if(this.pendingPresence.length) {
			Logger.logAction(Logger.LOG_MINOR, 'RealtimeChannel.failPendingPresence', 'channel; name = ' + this.channel.name + ', err = ' + Utils.inspectError(err));
			for(var i = 0; i < this.pendingPresence.length; i++)
				try {
					this.pendingPresence[i].callback(err);
				} catch(e) {}
			this.pendingPresence = [];
		}
	};

	RealtimePresence.prototype._clearMyMembers = function() {
		this._myMembers.clear();
	};

	RealtimePresence.prototype._ensureMyMembersPresent = function() {
		var self = this, members = this.members, myMembers = this._myMembers,
			reenterCb = function(err) {
				if(err) {
					var msg = 'Presence auto-re-enter failed: ' + err.toString();
					var wrappedErr = new ErrorInfo(msg, 91004, 400);
					Logger.logAction(Logger.LOG_ERROR, 'RealtimePresence._ensureMyMembersPresent()', msg);
					var change = new ChannelStateChange(self.channel.state, self.channel.state, true, wrappedErr);
					self.channel.emit('update', change);
				}
			};

		for(var memberKey in myMembers.map) {
			if(!(memberKey in members.map)) {
				var entry = myMembers.map[memberKey];
				Logger.logAction(Logger.LOG_MICRO, 'RealtimePresence._ensureMyMembersPresent()', 'Auto-reentering clientId "' + entry.clientId + '" into the presence set');
				this._enterOrUpdateClient(entry.clientId, entry.data, reenterCb, 'enter');
				delete myMembers.map[memberKey];
			}
		}
	};

	RealtimePresence.prototype._synthesizeLeaves = function(items) {
		var subscriptions = this.subscriptions;
		Utils.arrForEach(items, function(item) {
			var presence = PresenceMessage.fromValues({
				action: 'leave',
				connectionId: item.connectionId,
				clientId: item.clientId,
				data: item.data,
				encoding: item.encoding,
				timestamp: Utils.now()
			});
			subscriptions.emit('leave', presence);
		});
	};

	/* Deprecated */
	RealtimePresence.prototype.on = function() {
		Logger.deprecated('presence.on', 'presence.subscribe');
		this.subscribe.apply(this, arguments);
	};

	/* Deprecated */
	RealtimePresence.prototype.off = function() {
		Logger.deprecated('presence.off', 'presence.unsubscribe');
		this.unsubscribe.apply(this, arguments);
	};

	RealtimePresence.prototype.subscribe = function(/* [event], listener, [callback] */) {
		var args = RealtimeChannel.processListenerArgs(arguments);
		var event = args[0];
		var listener = args[1];
		var callback = args[2];
		var self = this;

		waitAttached(this.channel, callback, function() {
			self.subscriptions.on(event, listener);
		});
	};

	RealtimePresence.prototype.unsubscribe = function(/* [event], listener, [callback] */) {
		var args = RealtimeChannel.processListenerArgs(arguments);
		var event = args[0];
		var listener = args[1];
		var callback = args[2];

		if(this.channel.state === 'failed')
			callback(ErrorInfo.fromValues(RealtimeChannel.invalidStateError('failed')));

		this.subscriptions.off(event, listener);
	};

	RealtimePresence.prototype.syncComplete = function() {
		return !this.members.syncInProgress;
	};

	function PresenceMap(presence) {
		EventEmitter.call(this);
		this.presence = presence;
		this.map = {};
		this.syncInProgress = false;
		this.residualMembers = null;
	}
	Utils.inherits(PresenceMap, EventEmitter);

	PresenceMap.prototype.get = function(key) {
		return this.map[key];
	};

	PresenceMap.prototype.getClient = function(clientId) {
		var map = this.map, result = [];
		for(var key in map) {
			var item = map[key];
			if(item.clientId == clientId && item.action != 'absent')
				result.push(item);
		}
		return result;
	};

	PresenceMap.prototype.list = function(params) {
		var map = this.map,
			clientId = params && params.clientId,
			connectionId = params && params.connectionId,
			result = [];

		for(var key in map) {
			var item = map[key];
			if(item.action === 'absent') continue;
			if(clientId && clientId != item.clientId) continue;
			if(connectionId && connectionId != item.connectionId) continue;
			result.push(item);
		}
		return result;
	};

	function newerThan(item, existing) {
		/* RTP2b1: if either is synthesised, compare by timestamp */
		if(item.isSynthesized() || existing.isSynthesized()) {
			return item.timestamp > existing.timestamp;
		}

		/* RTP2b2 */
		var itemOrderings = item.parseId(),
			existingOrderings = existing.parseId();
		if(itemOrderings.msgSerial === existingOrderings.msgSerial) {
			return itemOrderings.index > existingOrderings.index;
		} else {
			return itemOrderings.msgSerial > existingOrderings.msgSerial;
		}
	}

	PresenceMap.prototype.put = function(item) {
		if(item.action === 'enter' || item.action === 'update') {
			item = PresenceMessage.fromValues(item);
			item.action = 'present';
		}
		var map = this.map, key = memberKey(item);
		/* we've seen this member, so do not remove it at the end of sync */
		if(this.residualMembers)
			delete this.residualMembers[key];

		/* compare the timestamp of the new item with any existing member (or ABSENT witness) */
		var existingItem = map[key];
		if(existingItem && !newerThan(item, existingItem)) {
			return false;
		}
		map[key] = item;
		return true;

	};

	PresenceMap.prototype.values = function() {
		var map = this.map, result = [];
		for(var key in map) {
			var item = map[key];
			if(item.action != 'absent')
				result.push(item);
		}
		return result;
	};

	PresenceMap.prototype.remove = function(item) {
		var map = this.map, key = memberKey(item);
		var existingItem = map[key];

		if(existingItem && !newerThan(item, existingItem)) {
			return false;
		}

		/* RTP2f */
		if(this.syncInProgress) {
			item = PresenceMessage.fromValues(item);
			item.action = 'absent';
			map[key] = item;
		} else {
			delete map[key];
		}

		return true;
	};

	PresenceMap.prototype.startSync = function() {
		var map = this.map, syncInProgress = this.syncInProgress;
		Logger.logAction(Logger.LOG_MINOR, 'PresenceMap.startSync()', 'channel = ' + this.presence.channel.name + '; syncInProgress = ' + syncInProgress);
		/* we might be called multiple times while a sync is in progress */
		if(!this.syncInProgress) {
			this.residualMembers = Utils.copy(map);
			this.syncInProgress = true;
		}
	};

	PresenceMap.prototype.endSync = function() {
		var map = this.map, syncInProgress = this.syncInProgress;
		Logger.logAction(Logger.LOG_MINOR, 'PresenceMap.endSync()', 'channel = ' + this.presence.channel.name + '; syncInProgress = ' + syncInProgress);
		if(syncInProgress) {
			/* we can now strip out the ABSENT members, as we have
			 * received all of the out-of-order sync messages */
			for(var memberKey in map) {
				var entry = map[memberKey];
				if(entry.action === 'absent') {
					delete map[memberKey];
				}
			}
			/* any members that were present at the start of the sync,
			 * and have not been seen in sync, can be removed, and leave events emitted */
			this.presence._synthesizeLeaves(Utils.valuesArray(this.residualMembers));
			for(var memberKey in this.residualMembers) {
				delete map[memberKey];
			}
			this.residualMembers = null;

			/* finish, notifying any waiters */
			this.syncInProgress = false;
		}
		this.emit('sync');
	};

	PresenceMap.prototype.waitSync = function(callback) {
		var syncInProgress = this.syncInProgress;
		Logger.logAction(Logger.LOG_MINOR, 'PresenceMap.waitSync()', 'channel = ' + this.presence.channel.name + '; syncInProgress = ' + syncInProgress);
		if(!syncInProgress) {
			callback();
			return;
		}
		this.once('sync', callback);
	};

	PresenceMap.prototype.clear = function(callback) {
		this.map = {};
		this.syncInProgress = false;
		this.residualMembers = null;
	};

	return RealtimePresence;
})();

var XHRRequest = (function() {
	var noop = function() {};
	var idCounter = 0;
	var pendingRequests = {};

	var REQ_SEND = 0,
		REQ_RECV = 1,
		REQ_RECV_POLL = 2,
		REQ_RECV_STREAM = 3;

	function clearPendingRequests() {
		for(var id in pendingRequests)
			pendingRequests[id].dispose();
	}

	var isIE = typeof window !== 'undefined' && window.XDomainRequest;

	function ieVersion() {
		var match = navigator.userAgent.toString().match(/MSIE\s([\d.]+)/);
		return match && Number(match[1]);
	}

	function needJsonEnvelope() {
		/* IE 10 xhr bug: http://stackoverflow.com/a/16320339 */
		var version;
		return isIE && (version = ieVersion()) && version === 10;
	}

	function getHeader(xhr, header) {
		return xhr.getResponseHeader && xhr.getResponseHeader(header);
	}

	/* Safari mysteriously returns 'Identity' for transfer-encoding
	 * when in fact it is 'chunked'. So instead, decide that it is
	 * chunked when transfer-encoding is present, content-length is absent */
	function isEncodingChunked(xhr) {
		return xhr.getResponseHeader
			&& xhr.getResponseHeader('transfer-encoding')
			&& !xhr.getResponseHeader('content-length');
	}

	function getHeadersAsObject(xhr) {
		var headerPairs = Utils.trim(xhr.getAllResponseHeaders()).split('\r\n'),
			headers = {};
		for (var i = 0; i < headerPairs.length; i++) {
			var parts = Utils.arrMap(headerPairs[i].split(':'), Utils.trim);
			headers[parts[0].toLowerCase()] = parts[1];
		}
		return headers;
	}

	function XHRRequest(uri, headers, params, body, requestMode, timeouts) {
		EventEmitter.call(this);
		params = params || {};
		params.rnd = Utils.randStr();
		if(needJsonEnvelope() && !params.envelope)
			params.envelope = 'json';
		this.uri = uri + Utils.toQueryString(params);
		this.headers = headers || {};
		this.body = body;
		this.requestMode = requestMode;
		this.timeouts = timeouts;
		this.timedOut = false;
		this.requestComplete = false;
		pendingRequests[this.id = String(++idCounter)] = this;
	}
	Utils.inherits(XHRRequest, EventEmitter);

	var createRequest = XHRRequest.createRequest = function(uri, headers, params, body, requestMode, timeouts) {
		/* XHR requests are used either with the context being a realtime
		 * transport, or with timeouts passed in (for when used by a rest client),
		 * or completely standalone.  Use the appropriate timeouts in each case */
		timeouts = (this && this.timeouts) || timeouts || Defaults.TIMEOUTS;
		return new XHRRequest(uri, headers, Utils.copy(params), body, requestMode, timeouts);
	};

	XHRRequest.prototype.complete = function(err, body, headers, unpacked, statusCode) {
		if(!this.requestComplete) {
			this.requestComplete = true;
			if(body)
				this.emit('data', body);
			this.emit('complete', err, body, headers, unpacked, statusCode);
			this.dispose();
		}
	};

	XHRRequest.prototype.abort = function() {
		this.dispose();
	};

	XHRRequest.prototype.exec = function() {
		var timeout = (this.requestMode == REQ_SEND) ? this.timeouts.httpRequestTimeout : this.timeouts.recvTimeout,
			self = this,
			timer = this.timer = setTimeout(function() {
				self.timedOut = true;
				xhr.abort();
			}, timeout),
			body = this.body,
			method = body ? 'POST' : 'GET',
			headers = this.headers,
			xhr = this.xhr = new XMLHttpRequest(),
			accept = headers['accept'],
			responseType = 'text';

		if(!accept) {
			headers['accept'] = 'application/json';
		} else if(accept.indexOf('application/json') === -1) {
			responseType = 'arraybuffer';
		}

		if(body) {
			var contentType = headers['content-type'] || (headers['content-type'] = 'application/json');
			if(contentType.indexOf('application/json') > -1 && typeof(body) != 'string')
				body = JSON.stringify(body);
		}


		xhr.open(method, this.uri, true);
		xhr.responseType = responseType;

		if ('authorization' in headers) {
			xhr.withCredentials = 'true';
		}

		for(var h in headers)
			xhr.setRequestHeader(h, headers[h]);

		var errorHandler = function(errorEvent, message, code, statusCode) {
			var errorMessage = message + ' (event type: ' + errorEvent.type + ')' + (self.xhr.statusText ? ', current statusText is ' + self.xhr.statusText : '');
			Logger.logAction(Logger.LOG_ERROR, 'Request.on' + errorEvent.type + '()', errorMessage);
			self.complete(new ErrorInfo(errorMessage, code, statusCode));
		};
		xhr.onerror = function(errorEvent) {
			errorHandler(errorEvent, 'XHR error occurred', null, 400);
		}
		xhr.onabort = function(errorEvent) {
			if(self.timedOut) {
				errorHandler(errorEvent, 'Request aborted due to request timeout expiring', null, 408);
			} else {
				errorHandler(errorEvent, 'Request cancelled', null, 400);
			}
		};
		xhr.ontimeout = function(errorEvent) {
			errorHandler(errorEvent, 'Request timed out', null, 408);
		};

		var streaming,
			statusCode,
			responseBody,
			contentType,
			successResponse,
			streamPos = 0,
			unpacked = false;

		function onResponse() {
			clearTimeout(timer);
			successResponse = (statusCode < 400);
			if(statusCode == 204) {
				self.complete(null, null, null, null, statusCode);
				return;
			}
			streaming = (self.requestMode == REQ_RECV_STREAM && successResponse && isEncodingChunked(xhr));
		}

		function onEnd() {
			try {
				var contentType = getHeader(xhr, 'content-type'),
					headers,
					server,
					json = contentType ? (contentType.indexOf('application/json') >= 0) : (xhr.responseType == 'text');

				responseBody = json ? xhr.responseText : xhr.response;

				if(json) {
					responseBody = String(responseBody);
					if(responseBody.length) {
						responseBody = JSON.parse(responseBody);
					}
					unpacked = true;
				}

				if(responseBody.response !== undefined) {
					/* unwrap JSON envelope */
					statusCode = responseBody.statusCode;
					successResponse = (statusCode < 400);
					headers = responseBody.headers;
					responseBody = responseBody.response;
				} else {
					headers = getHeadersAsObject(xhr);
				}
			} catch(e) {
				self.complete(new ErrorInfo('Malformed response body from server: ' + e.message, null, 400));
				return;
			}

			/* If response is an array, it's an array of protocol messages -- even if
			 * is contains an error action (hence the nonsuccess statuscode), we can
			 * consider the request to have succeeded, just pass it on to
			 * onProtocolMessage to decide what to do */
			if(successResponse || Utils.isArray(responseBody)) {
				self.complete(null, responseBody, headers, unpacked, statusCode);
				return;
			}

			var err = responseBody.error;
			if(!err) {
				err = new ErrorInfo('Error response received from server: ' + statusCode + ' body was: ' + Utils.inspect(responseBody), null, statusCode);
			}
			self.complete(err);
		}

		function onProgress() {
			responseBody = xhr.responseText;
			var bodyEnd = responseBody.length - 1, idx, chunk;
			while((streamPos < bodyEnd) && (idx = responseBody.indexOf('\n', streamPos)) > -1) {
				chunk = responseBody.slice(streamPos, idx);
				streamPos = idx + 1;
				onChunk(chunk);
			}
		}

		function onChunk(chunk) {
			try {
				chunk = JSON.parse(chunk);
			} catch(e) {
				self.complete(new ErrorInfo('Malformed response body from server: ' + e.message, null, 400));
				return;
			}
			self.emit('data', chunk);
		}

		function onStreamEnd() {
			onProgress();
			self.streamComplete = true;
			Utils.nextTick(function() {
				self.complete();
			});
		}

		xhr.onreadystatechange = function() {
			var readyState = xhr.readyState;
			if(readyState < 3) return;
			if(xhr.status !== 0) {
				if(statusCode === undefined) {
					statusCode = xhr.status;
					/* IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450 */
					if(statusCode === 1223) statusCode = 204;
					onResponse();
				}
				if(readyState == 3 && streaming) {
					onProgress();
				} else if(readyState == 4) {
					if(streaming)
						onStreamEnd();
					else
						onEnd();
				}
			}
		};
		xhr.send(body);
	};

	XHRRequest.prototype.dispose = function() {
		var xhr = this.xhr;
		if(xhr) {
			xhr.onreadystatechange = xhr.onerror = xhr.onabort = xhr.ontimeout = noop;
			this.xhr = null;
			var timer = this.timer;
			if(timer) {
				clearTimeout(timer);
				this.timer = null;
			}
			if(!this.requestComplete)
				xhr.abort();
		}
		delete pendingRequests[this.id];
	};

	if(Platform.xhrSupported) {
		if(typeof DomEvent === 'object') {
			DomEvent.addUnloadListener(clearPendingRequests);
		}
		if(typeof(Http) !== 'undefined') {
			Http.supportsAuthHeaders = true;
			Http.Request = function(rest, uri, headers, params, body, callback) {
				var req = createRequest(uri, headers, params, body, REQ_SEND, rest && rest.options.timeouts);
				req.once('complete', callback);
				req.exec();
				return req;
			};

			Http.checkConnectivity = function(callback) {
				var upUrl = Defaults.internetUpUrl;
				Logger.logAction(Logger.LOG_MICRO, '(XHRRequest)Http.checkConnectivity()', 'Sending; ' + upUrl);
				Http.Request(null, upUrl, null, null, null, function(err, responseText) {
					var result = (!err && responseText.replace(/\n/, '') == 'yes');
					Logger.logAction(Logger.LOG_MICRO, '(XHRRequest)Http.checkConnectivity()', 'Result: ' + result);
					callback(null, result);
				});
			};
		}
	}

	return XHRRequest;
})();

var XHRStreamingTransport = (function() {
	var shortName = 'xhr_streaming';

	/* public constructor */
	function XHRStreamingTransport(connectionManager, auth, params) {
		CometTransport.call(this, connectionManager, auth, params);
		this.shortName = shortName;
	}
	Utils.inherits(XHRStreamingTransport, CometTransport);

	XHRStreamingTransport.isAvailable = function() {
		return Platform.xhrSupported && Platform.streamingSupported;
	};

	XHRStreamingTransport.tryConnect = function(connectionManager, auth, params, callback) {
		var transport = new XHRStreamingTransport(connectionManager, auth, params);
		var errorCb = function(err) { callback({event: this.event, error: err}); };
		transport.on(['failed', 'disconnected'], errorCb);
		transport.on('preconnect', function() {
			Logger.logAction(Logger.LOG_MINOR, 'XHRStreamingTransport.tryConnect()', 'viable transport ' + transport);
			transport.off(['failed', 'disconnected'], errorCb);
			callback(null, transport);
		});
		transport.connect();
	};

	XHRStreamingTransport.prototype.toString = function() {
		return 'XHRStreamingTransport; uri=' + this.baseUri + '; isConnected=' + this.isConnected;
	};

	XHRStreamingTransport.prototype.createRequest = XHRRequest.createRequest;

	if(typeof(ConnectionManager) !== 'undefined' && XHRStreamingTransport.isAvailable()) {
		ConnectionManager.supportedTransports[shortName] = XHRStreamingTransport;
	}

	return XHRStreamingTransport;
})();

var XHRPollingTransport = (function() {
	var shortName = 'xhr_polling';

	function XHRPollingTransport(connectionManager, auth, params) {
		params.stream = false;
		CometTransport.call(this, connectionManager, auth, params);
		this.shortName = shortName;
	}
	Utils.inherits(XHRPollingTransport, CometTransport);

	XHRPollingTransport.isAvailable = function() {
		return Platform.xhrSupported;
	};

	XHRPollingTransport.tryConnect = function(connectionManager, auth, params, callback) {
		var transport = new XHRPollingTransport(connectionManager, auth, params);
		var errorCb = function(err) { callback({event: this.event, error: err}); };
		transport.on(['failed', 'disconnected'], errorCb);
		transport.on('preconnect', function() {
			Logger.logAction(Logger.LOG_MINOR, 'XHRPollingTransport.tryConnect()', 'viable transport ' + transport);
			transport.off(['failed', 'disconnected'], errorCb);
			callback(null, transport);
		});
		transport.connect();
	};

	XHRPollingTransport.prototype.toString = function() {
		return 'XHRPollingTransport; uri=' + this.baseUri + '; isConnected=' + this.isConnected;
	};

	XHRPollingTransport.prototype.createRequest = XHRRequest.createRequest;

	if(typeof(ConnectionManager) !== 'undefined' && XHRPollingTransport.isAvailable()) {
		ConnectionManager.supportedTransports[shortName] = XHRPollingTransport;
	}

	return XHRPollingTransport;
})();

var JSONPTransport = (function() {
	var noop = function() {};
	/* Can't just use windows.Ably, as that won't exist if using the commonjs version. */
	var _ = window._ablyjs_jsonp = {};

	/* express strips out parantheses from the callback!
	 * Kludge to still alow its responses to work, while not keeping the
	 * function form for normal use and not cluttering window.Ably
	 * https://github.com/strongloop/express/blob/master/lib/response.js#L305
	 */
	_._ = function(id) { return _['_' + id] || noop; };
	var idCounter = 1;
	var isSupported = (typeof(document) !== 'undefined');
	var head = isSupported ? document.getElementsByTagName('head')[0] : null;
	var shortName = 'jsonp';

	/* public constructor */
	function JSONPTransport(connectionManager, auth, params) {
		params.stream = false;
		CometTransport.call(this, connectionManager, auth, params);
		this.shortName = shortName;
	}
	Utils.inherits(JSONPTransport, CometTransport);

	JSONPTransport.isAvailable = function() { return isSupported; };
	if(isSupported) {
		ConnectionManager.supportedTransports[shortName] = JSONPTransport;
	}

	/* connectivity check; since this has a hard-coded callback id,
	 * we just make sure that we handle concurrent requests (but the
	 * connectionmanager should ensure this doesn't happen anyway */
	var checksInProgress = null;
	window.JSONPTransport = JSONPTransport

	JSONPTransport.tryConnect = function(connectionManager, auth, params, callback) {
		var transport = new JSONPTransport(connectionManager, auth, params);
		var errorCb = function(err) { callback({event: this.event, error: err}); };
		transport.on(['failed', 'disconnected'], errorCb);
		transport.on('preconnect', function() {
			Logger.logAction(Logger.LOG_MINOR, 'JSONPTransport.tryConnect()', 'viable transport ' + transport);
			transport.off(['failed', 'disconnected'], errorCb);
			callback(null, transport);
		});
		transport.connect();
	};

	JSONPTransport.prototype.toString = function() {
		return 'JSONPTransport; uri=' + this.baseUri + '; isConnected=' + this.isConnected;
	};

	var createRequest = JSONPTransport.prototype.createRequest = function(uri, headers, params, body, requestMode, timeouts) {
		/* JSONP requests are used either with the context being a realtime
		 * transport, or with timeouts passed in (for when used by a rest client),
		 * or completely standalone.  Use the appropriate timeouts in each case */
		timeouts = (this && this.timeouts) || timeouts || Defaults.TIMEOUTS;
		return new Request(undefined, uri, headers, Utils.copy(params), body, requestMode, timeouts);
	};

	function Request(id, uri, headers, params, body, requestMode, timeouts) {
		EventEmitter.call(this);
		if(id === undefined) id = idCounter++;
		this.id = id;
		this.uri = uri;
		this.params = params || {};
		this.params.rnd = Utils.randStr();
		if(headers) {
			/* JSONP doesn't allow headers. Cherry-pick a couple to turn into qs params */
			if(headers['X-Ably-Version']) this.params.v = headers['X-Ably-Version'];
			if(headers['X-Ably-Lib']) this.params.lib = headers['X-Ably-Lib'];
		}
		this.body = body;
		this.requestMode = requestMode;
		this.timeouts = timeouts;
		this.requestComplete = false;
	}
	Utils.inherits(Request, EventEmitter);

	Request.prototype.exec = function() {
		var id = this.id,
			body = this.body,
			uri = this.uri,
			params = this.params,
			self = this;

		params.callback = '_ablyjs_jsonp._(' + id + ')';

		params.envelope = 'jsonp';
		if(body)
			params.body = body;

		var script = this.script = document.createElement('script');
		var src = uri + Utils.toQueryString(params);
		script.src = src;
		if(script.src.split('/').slice(-1)[0] !== src.split('/').slice(-1)[0]) {
			/* The src has been truncated. Can't abort, but can at least emit an
			 * error so the user knows what's gone wrong. (Can't compare strings
			 * directly as src may have a port, script.src won't) */
			Logger.logAction(Logger.LOG_ERROR, 'JSONP Request.exec()', 'Warning: the browser appears to have truncated the script URI. This will likely result in the request failing due to an unparseable body param');
		}
		script.async = true;
		script.type = 'text/javascript';
		script.charset = 'UTF-8';
		script.onerror = function(err) {
			self.complete(new ErrorInfo('JSONP script error (event: ' + Utils.inspect(err) + ')', null, 400));
		};

		_['_' + id] = function(message) {
			if(message.statusCode) {
				/* Handle as enveloped jsonp, as all jsonp transport uses should be */
				var response = message.response;
				if(message.statusCode == 204) {
					self.complete(null, null, null, message.statusCode);
				} else if(!response) {
					self.complete(new ErrorInfo('Invalid server response: no envelope detected', null, 500));
				} else if(message.statusCode < 400 || Utils.isArray(response)) {
					/* If response is an array, it's an array of protocol messages -- even if
					 * it contains an error action (hence the nonsuccess statuscode), we can
					 * consider the request to have succeeded, just pass it on to
					 * onProtocolMessage to decide what to do */
					self.complete(null, response, message.headers, message.statusCode);
				} else {
					var err = response.error || new ErrorInfo('Error response received from server', null, message.statusCode);
					self.complete(err);
				}
			} else {
				/* Handle as non-enveloped -- as will be eg from a customer's authUrl server */
				self.complete(null, message);
			}
		};

		var timeout = (this.requestMode == CometTransport.REQ_SEND) ? this.timeouts.httpRequestTimeout : this.timeouts.recvTimeout;
		this.timer = setTimeout(function() { self.abort(); }, timeout);
		head.insertBefore(script, head.firstChild);
	};

	Request.prototype.complete = function(err, body, headers, statusCode) {
		headers = headers || {};
		if(!this.requestComplete) {
			this.requestComplete = true;
			var contentType;
			if(body) {
				contentType = (typeof(body) == 'string') ? 'text/plain' : 'application/json';
				headers['content-type'] = contentType;
				this.emit('data', body);
			}

			this.emit('complete', err, body, headers, /* unpacked: */ true, statusCode);
			this.dispose();
		}
	};

	Request.prototype.abort = function() {
		this.dispose();
	};

	Request.prototype.dispose = function() {
		var timer = this.timer;
		if(timer) {
			clearTimeout(timer);
			this.timer = null;
		}
		var script = this.script;
		if(script.parentNode) script.parentNode.removeChild(script);
		delete _[this.id];
		this.emit('disposed');
	};

	if(!Http.Request) {
		Http.Request = function(rest, uri, headers, params, body, callback) {
			var req = createRequest(uri, headers, params, body, CometTransport.REQ_SEND, rest && rest.options.timeouts);
			req.once('complete', callback);
			Utils.nextTick(function() {
				req.exec();
			});
			return req;
		};

		Http.checkConnectivity = function(callback) {
			var upUrl = Defaults.jsonpInternetUpUrl;

			if(checksInProgress) {
				checksInProgress.push(callback);
				return;
			}
			checksInProgress = [callback];
			Logger.logAction(Logger.LOG_MICRO, '(JSONP)Http.checkConnectivity()', 'Sending; ' + upUrl);

			var req = new Request('isTheInternetUp', upUrl, null, null, null, CometTransport.REQ_SEND, Defaults.TIMEOUTS);
			req.once('complete', function(err, response) {
				var result = !err && response;
				Logger.logAction(Logger.LOG_MICRO, '(JSONP)Http.checkConnectivity()', 'Result: ' + result);
				for(var i = 0; i < checksInProgress.length; i++) checksInProgress[i](null, result);
				checksInProgress = null;
			});
			Utils.nextTick(function() {
				req.exec();
			});
		};
	}

	return JSONPTransport;
})();

Ably.msgpack = msgpack;
Ably.Rest = Rest;
Ably.Realtime = Realtime;
Realtime.ConnectionManager = ConnectionManager;
Realtime.BufferUtils = Rest.BufferUtils = BufferUtils;
if(typeof(Crypto) !== 'undefined') Realtime.Crypto = Rest.Crypto = Crypto;
Realtime.Defaults = Rest.Defaults = Defaults;
Realtime.Http = Rest.Http = Http;
Realtime.Utils = Rest.Utils = Utils;
Realtime.Http = Rest.Http = Http;
Realtime.Message = Rest.Message = Message;
Realtime.PresenceMessage = Rest.PresenceMessage = PresenceMessage;
Realtime.ProtocolMessage = Rest.ProtocolMessage = ProtocolMessage;

module.exports = Ably;

/* SystemJS support for default exports to be added to the root of the module
   https://github.com/frankwallis/plugin-typescript/issues/185 */
module.exports.__esModule = true;

}).call(this,require("buffer").Buffer)

},{"buffer":3}],2:[function(require,module,exports){

},{}],3:[function(require,module,exports){
(function (global){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"base64-js":4,"ieee754":5,"isarray":6}],4:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return b64.length * 3 / 4 - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, j, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr(len * 3 / 4 - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}

},{}],5:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],6:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],7:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],8:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],9:[function(require,module,exports){
!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.PubNub=t():e.PubNub=t()}(this,function(){return function(e){function t(r){if(n[r])return n[r].exports;var i=n[r]={exports:{},id:r,loaded:!1};return e[r].call(i.exports,i,i.exports,t),i.loaded=!0,i.exports}var n={};return t.m=e,t.c=n,t.p="",t(0)}([function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function o(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function s(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}function a(e){if(!navigator||!navigator.sendBeacon)return!1;navigator.sendBeacon(e)}Object.defineProperty(t,"__esModule",{value:!0});var u=n(1),c=r(u),l=n(40),h=r(l),f=n(41),d=r(f),p=n(42),g=(n(8),function(e){function t(e){i(this,t);var n=e.listenToBrowserNetworkEvents,r=void 0===n||n;e.db=d.default,e.sdkFamily="Web",e.networking=new h.default({get:p.get,post:p.post,sendBeacon:a});var s=o(this,(t.__proto__||Object.getPrototypeOf(t)).call(this,e));return r&&(window.addEventListener("offline",function(){s.networkDownDetected()}),window.addEventListener("online",function(){s.networkUpDetected()})),s}return s(t,e),t}(c.default));t.default=g,e.exports=t.default},function(e,t,n){"use strict";function r(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n]);return t.default=e,t}function i(e){return e&&e.__esModule?e:{default:e}}function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(t,"__esModule",{value:!0});var s=function(){function e(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(t,n,r){return n&&e(t.prototype,n),r&&e(t,r),t}}(),a=n(2),u=i(a),c=n(7),l=i(c),h=n(9),f=i(h),d=n(11),p=i(d),g=n(12),y=i(g),v=n(18),b=i(v),_=n(19),m=r(_),k=n(20),P=r(k),S=n(21),O=r(S),w=n(22),T=r(w),C=n(23),M=r(C),x=n(24),E=r(x),N=n(25),R=r(N),K=n(26),A=r(K),j=n(27),D=r(j),G=n(28),U=r(G),B=n(29),I=r(B),H=n(30),L=r(H),q=n(31),F=r(q),z=n(32),X=r(z),W=n(33),V=r(W),J=n(34),$=r(J),Q=n(35),Y=r(Q),Z=n(36),ee=r(Z),te=n(37),ne=r(te),re=n(38),ie=r(re),oe=n(15),se=r(oe),ae=n(39),ue=r(ae),ce=n(16),le=i(ce),he=n(13),fe=i(he),de=(n(8),function(){function e(t){var n=this;o(this,e);var r=t.db,i=t.networking,s=this._config=new l.default({setup:t,db:r}),a=new f.default({config:s});i.init(s);var u={config:s,networking:i,crypto:a},c=b.default.bind(this,u,se),h=b.default.bind(this,u,U),d=b.default.bind(this,u,L),g=b.default.bind(this,u,X),v=b.default.bind(this,u,ue),_=this._listenerManager=new y.default,k=new p.default({timeEndpoint:c,leaveEndpoint:h,heartbeatEndpoint:d,setStateEndpoint:g,subscribeEndpoint:v,crypto:u.crypto,config:u.config,listenerManager:_});this.addListener=_.addListener.bind(_),this.removeListener=_.removeListener.bind(_),this.removeAllListeners=_.removeAllListeners.bind(_),this.channelGroups={listGroups:b.default.bind(this,u,T),listChannels:b.default.bind(this,u,M),addChannels:b.default.bind(this,u,m),removeChannels:b.default.bind(this,u,P),deleteGroup:b.default.bind(this,u,O)},this.push={addChannels:b.default.bind(this,u,E),removeChannels:b.default.bind(this,u,R),deleteDevice:b.default.bind(this,u,D),listChannels:b.default.bind(this,u,A)},this.hereNow=b.default.bind(this,u,V),this.whereNow=b.default.bind(this,u,I),this.getState=b.default.bind(this,u,F),this.setState=k.adaptStateChange.bind(k),this.grant=b.default.bind(this,u,Y),this.audit=b.default.bind(this,u,$),this.publish=b.default.bind(this,u,ee),this.fire=function(e,t){e.replicate=!1,e.storeInHistory=!1,n.publish(e,t)},this.history=b.default.bind(this,u,ne),this.fetchMessages=b.default.bind(this,u,ie),this.time=c,this.subscribe=k.adaptSubscribeChange.bind(k),this.unsubscribe=k.adaptUnsubscribeChange.bind(k),this.disconnect=k.disconnect.bind(k),this.reconnect=k.reconnect.bind(k),this.destroy=function(e){k.unsubscribeAll(e),k.disconnect()},this.stop=this.destroy,this.unsubscribeAll=k.unsubscribeAll.bind(k),this.getSubscribedChannels=k.getSubscribedChannels.bind(k),this.getSubscribedChannelGroups=k.getSubscribedChannelGroups.bind(k),this.encrypt=a.encrypt.bind(a),this.decrypt=a.decrypt.bind(a),this.getAuthKey=u.config.getAuthKey.bind(u.config),this.setAuthKey=u.config.setAuthKey.bind(u.config),this.setCipherKey=u.config.setCipherKey.bind(u.config),this.getUUID=u.config.getUUID.bind(u.config),this.setUUID=u.config.setUUID.bind(u.config),this.getFilterExpression=u.config.getFilterExpression.bind(u.config),this.setFilterExpression=u.config.setFilterExpression.bind(u.config)}return s(e,[{key:"getVersion",value:function(){return this._config.getVersion()}},{key:"networkDownDetected",value:function(){this._listenerManager.announceNetworkDown(),this._config.restore?this.disconnect():this.destroy(!0)}},{key:"networkUpDetected",value:function(){this._listenerManager.announceNetworkUp(),this.reconnect()}}],[{key:"generateUUID",value:function(){return u.default.v4()}}]),e}());de.OPERATIONS=le.default,de.CATEGORIES=fe.default,t.default=de,e.exports=t.default},function(e,t,n){var r=n(3),i=n(6),o=i;o.v1=r,o.v4=i,e.exports=o},function(e,t,n){function r(e,t,n){var r=t&&n||0,i=t||[];e=e||{};var s=void 0!==e.clockseq?e.clockseq:u,h=void 0!==e.msecs?e.msecs:(new Date).getTime(),f=void 0!==e.nsecs?e.nsecs:l+1,d=h-c+(f-l)/1e4;if(d<0&&void 0===e.clockseq&&(s=s+1&16383),(d<0||h>c)&&void 0===e.nsecs&&(f=0),f>=1e4)throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");c=h,l=f,u=s,h+=122192928e5;var p=(1e4*(268435455&h)+f)%4294967296;i[r++]=p>>>24&255,i[r++]=p>>>16&255,i[r++]=p>>>8&255,i[r++]=255&p;var g=h/4294967296*1e4&268435455;i[r++]=g>>>8&255,i[r++]=255&g,i[r++]=g>>>24&15|16,i[r++]=g>>>16&255,i[r++]=s>>>8|128,i[r++]=255&s;for(var y=e.node||a,v=0;v<6;++v)i[r+v]=y[v];return t?t:o(i)}var i=n(4),o=n(5),s=i(),a=[1|s[0],s[1],s[2],s[3],s[4],s[5]],u=16383&(s[6]<<8|s[7]),c=0,l=0;e.exports=r},function(e,t){(function(t){var n,r=t.crypto||t.msCrypto;if(r&&r.getRandomValues){var i=new Uint8Array(16);n=function(){return r.getRandomValues(i),i}}if(!n){var o=new Array(16);n=function(){for(var e,t=0;t<16;t++)0==(3&t)&&(e=4294967296*Math.random()),o[t]=e>>>((3&t)<<3)&255;return o}}e.exports=n}).call(t,function(){return this}())},function(e,t){function n(e,t){var n=t||0,i=r;return i[e[n++]]+i[e[n++]]+i[e[n++]]+i[e[n++]]+"-"+i[e[n++]]+i[e[n++]]+"-"+i[e[n++]]+i[e[n++]]+"-"+i[e[n++]]+i[e[n++]]+"-"+i[e[n++]]+i[e[n++]]+i[e[n++]]+i[e[n++]]+i[e[n++]]+i[e[n++]]}for(var r=[],i=0;i<256;++i)r[i]=(i+256).toString(16).substr(1);e.exports=n},function(e,t,n){function r(e,t,n){var r=t&&n||0;"string"==typeof e&&(t="binary"==e?new Array(16):null,e=null),e=e||{};var s=e.random||(e.rng||i)();if(s[6]=15&s[6]|64,s[8]=63&s[8]|128,t)for(var a=0;a<16;++a)t[r+a]=s[a];return t||o(s)}var i=n(4),o=n(5);e.exports=r},function(e,t,n){"use strict";function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(t,"__esModule",{value:!0});var i=function(){function e(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(t,n,r){return n&&e(t.prototype,n),r&&e(t,r),t}}(),o=n(2),s=function(e){return e&&e.__esModule?e:{default:e}}(o),a=(n(8),function(){function e(t){var n=t.setup,i=t.db;r(this,e),this._db=i,this.instanceId="pn-"+s.default.v4(),this.secretKey=n.secretKey||n.secret_key,this.subscribeKey=n.subscribeKey||n.subscribe_key,this.publishKey=n.publishKey||n.publish_key,this.sdkFamily=n.sdkFamily,this.partnerId=n.partnerId,this.setAuthKey(n.authKey),this.setCipherKey(n.cipherKey),this.setFilterExpression(n.filterExpression),this.origin=n.origin||"pubsub.pubnub.com",this.secure=n.ssl||!1,this.restore=n.restore||!1,this.proxy=n.proxy,this.keepAlive=n.keepAlive,this.keepAliveSettings=n.keepAliveSettings,"undefined"!=typeof location&&"https:"===location.protocol&&(this.secure=!0),this.logVerbosity=n.logVerbosity||!1,this.suppressLeaveEvents=n.suppressLeaveEvents||!1,this.announceFailedHeartbeats=n.announceFailedHeartbeats||!0,this.announceSuccessfulHeartbeats=n.announceSuccessfulHeartbeats||!1,this.useInstanceId=n.useInstanceId||!1,this.useRequestId=n.useRequestId||!1,this.requestMessageCountThreshold=n.requestMessageCountThreshold,this.setTransactionTimeout(n.transactionalRequestTimeout||15e3),this.setSubscribeTimeout(n.subscribeRequestTimeout||31e4),this.setSendBeaconConfig(n.useSendBeacon||!0),this.setPresenceTimeout(n.presenceTimeout||300),n.heartbeatInterval&&this.setHeartbeatInterval(n.heartbeatInterval),this.setUUID(this._decideUUID(n.uuid))}return i(e,[{key:"getAuthKey",value:function(){return this.authKey}},{key:"setAuthKey",value:function(e){return this.authKey=e,this}},{key:"setCipherKey",value:function(e){return this.cipherKey=e,this}},{key:"getUUID",value:function(){return this.UUID}},{key:"setUUID",value:function(e){return this._db&&this._db.set&&this._db.set(this.subscribeKey+"uuid",e),this.UUID=e,this}},{key:"getFilterExpression",value:function(){return this.filterExpression}},{key:"setFilterExpression",value:function(e){return this.filterExpression=e,this}},{key:"getPresenceTimeout",value:function(){return this._presenceTimeout}},{key:"setPresenceTimeout",value:function(e){return this._presenceTimeout=e,this.setHeartbeatInterval(this._presenceTimeout/2-1),this}},{key:"getHeartbeatInterval",value:function(){return this._heartbeatInterval}},{key:"setHeartbeatInterval",value:function(e){return this._heartbeatInterval=e,this}},{key:"getSubscribeTimeout",value:function(){return this._subscribeRequestTimeout}},{key:"setSubscribeTimeout",value:function(e){return this._subscribeRequestTimeout=e,this}},{key:"getTransactionTimeout",value:function(){return this._transactionalRequestTimeout}},{key:"setTransactionTimeout",value:function(e){return this._transactionalRequestTimeout=e,this}},{key:"isSendBeaconEnabled",value:function(){return this._useSendBeacon}},{key:"setSendBeaconConfig",value:function(e){return this._useSendBeacon=e,this}},{key:"getVersion",value:function(){return"4.8.0"}},{key:"_decideUUID",value:function(e){return e?e:this._db&&this._db.get&&this._db.get(this.subscribeKey+"uuid")?this._db.get(this.subscribeKey+"uuid"):"pn-"+s.default.v4()}}]),e}());t.default=a,e.exports=t.default},function(e,t){"use strict";e.exports={}},function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(t,"__esModule",{value:!0});var o=function(){function e(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(t,n,r){return n&&e(t.prototype,n),r&&e(t,r),t}}(),s=n(7),a=(r(s),n(10)),u=r(a),c=function(){function e(t){var n=t.config;i(this,e),this._config=n,this._iv="0123456789012345",this._allowedKeyEncodings=["hex","utf8","base64","binary"],this._allowedKeyLengths=[128,256],this._allowedModes=["ecb","cbc"],this._defaultOptions={encryptKey:!0,keyEncoding:"utf8",keyLength:256,mode:"cbc"}}return o(e,[{key:"HMACSHA256",value:function(e){return u.default.HmacSHA256(e,this._config.secretKey).toString(u.default.enc.Base64)}},{key:"SHA256",value:function(e){return u.default.SHA256(e).toString(u.default.enc.Hex)}},{key:"_parseOptions",value:function(e){var t=e||{};return t.hasOwnProperty("encryptKey")||(t.encryptKey=this._defaultOptions.encryptKey),t.hasOwnProperty("keyEncoding")||(t.keyEncoding=this._defaultOptions.keyEncoding),t.hasOwnProperty("keyLength")||(t.keyLength=this._defaultOptions.keyLength),t.hasOwnProperty("mode")||(t.mode=this._defaultOptions.mode),this._allowedKeyEncodings.indexOf(t.keyEncoding.toLowerCase())===-1&&(t.keyEncoding=this._defaultOptions.keyEncoding),this._allowedKeyLengths.indexOf(parseInt(t.keyLength,10))===-1&&(t.keyLength=this._defaultOptions.keyLength),this._allowedModes.indexOf(t.mode.toLowerCase())===-1&&(t.mode=this._defaultOptions.mode),t}},{key:"_decodeKey",value:function(e,t){return"base64"===t.keyEncoding?u.default.enc.Base64.parse(e):"hex"===t.keyEncoding?u.default.enc.Hex.parse(e):e}},{key:"_getPaddedKey",value:function(e,t){return e=this._decodeKey(e,t),t.encryptKey?u.default.enc.Utf8.parse(this.SHA256(e).slice(0,32)):e}},{key:"_getMode",value:function(e){return"ecb"===e.mode?u.default.mode.ECB:u.default.mode.CBC}},{key:"_getIV",value:function(e){return"cbc"===e.mode?u.default.enc.Utf8.parse(this._iv):null}},{key:"encrypt",value:function(e,t,n){if(!t&&!this._config.cipherKey)return e;n=this._parseOptions(n);var r=this._getIV(n),i=this._getMode(n),o=this._getPaddedKey(t||this._config.cipherKey,n);return u.default.AES.encrypt(e,o,{iv:r,mode:i}).ciphertext.toString(u.default.enc.Base64)||e}},{key:"decrypt",value:function(e,t,n){if(!t&&!this._config.cipherKey)return e;n=this._parseOptions(n);var r=this._getIV(n),i=this._getMode(n),o=this._getPaddedKey(t||this._config.cipherKey,n);try{var s=u.default.enc.Base64.parse(e),a=u.default.AES.decrypt({ciphertext:s},o,{iv:r,mode:i}).toString(u.default.enc.Utf8);return JSON.parse(a)}catch(e){return null}}}]),e}();t.default=c,e.exports=t.default},function(e,t){"use strict";var n=n||function(e,t){var n={},r=n.lib={},i=function(){},o=r.Base={extend:function(e){i.prototype=this;var t=new i;return e&&t.mixIn(e),t.hasOwnProperty("init")||(t.init=function(){t.$super.init.apply(this,arguments)}),t.init.prototype=t,t.$super=this,t},create:function(){var e=this.extend();return e.init.apply(e,arguments),e},init:function(){},mixIn:function(e){for(var t in e)e.hasOwnProperty(t)&&(this[t]=e[t]);e.hasOwnProperty("toString")&&(this.toString=e.toString)},clone:function(){return this.init.prototype.extend(this)}},s=r.WordArray=o.extend({init:function(e,t){e=this.words=e||[],this.sigBytes=void 0!=t?t:4*e.length},toString:function(e){return(e||u).stringify(this)},concat:function(e){var t=this.words,n=e.words,r=this.sigBytes;if(e=e.sigBytes,this.clamp(),r%4)for(var i=0;i<e;i++)t[r+i>>>2]|=(n[i>>>2]>>>24-i%4*8&255)<<24-(r+i)%4*8;else if(65535<n.length)for(i=0;i<e;i+=4)t[r+i>>>2]=n[i>>>2];else t.push.apply(t,n);return this.sigBytes+=e,this},clamp:function(){var t=this.words,n=this.sigBytes;t[n>>>2]&=4294967295<<32-n%4*8,t.length=e.ceil(n/4)},clone:function(){var e=o.clone.call(this);return e.words=this.words.slice(0),e},random:function(t){for(var n=[],r=0;r<t;r+=4)n.push(4294967296*e.random()|0);return new s.init(n,t)}}),a=n.enc={},u=a.Hex={stringify:function(e){var t=e.words;e=e.sigBytes;for(var n=[],r=0;r<e;r++){var i=t[r>>>2]>>>24-r%4*8&255;n.push((i>>>4).toString(16)),n.push((15&i).toString(16))}return n.join("")},parse:function(e){for(var t=e.length,n=[],r=0;r<t;r+=2)n[r>>>3]|=parseInt(e.substr(r,2),16)<<24-r%8*4;return new s.init(n,t/2)}},c=a.Latin1={stringify:function(e){var t=e.words;e=e.sigBytes;for(var n=[],r=0;r<e;r++)n.push(String.fromCharCode(t[r>>>2]>>>24-r%4*8&255));return n.join("")},parse:function(e){for(var t=e.length,n=[],r=0;r<t;r++)n[r>>>2]|=(255&e.charCodeAt(r))<<24-r%4*8;return new s.init(n,t)}},l=a.Utf8={stringify:function(e){try{return decodeURIComponent(escape(c.stringify(e)))}catch(e){throw Error("Malformed UTF-8 data")}},parse:function(e){return c.parse(unescape(encodeURIComponent(e)))}},h=r.BufferedBlockAlgorithm=o.extend({reset:function(){this._data=new s.init,this._nDataBytes=0},_append:function(e){"string"==typeof e&&(e=l.parse(e)),this._data.concat(e),this._nDataBytes+=e.sigBytes},_process:function(t){var n=this._data,r=n.words,i=n.sigBytes,o=this.blockSize,a=i/(4*o),a=t?e.ceil(a):e.max((0|a)-this._minBufferSize,0);if(t=a*o,i=e.min(4*t,i),t){for(var u=0;u<t;u+=o)this._doProcessBlock(r,u);u=r.splice(0,t),n.sigBytes-=i}return new s.init(u,i)},clone:function(){var e=o.clone.call(this);return e._data=this._data.clone(),e},_minBufferSize:0});r.Hasher=h.extend({cfg:o.extend(),init:function(e){this.cfg=this.cfg.extend(e),this.reset()},reset:function(){h.reset.call(this),this._doReset()},update:function(e){return this._append(e),this._process(),this},finalize:function(e){return e&&this._append(e),this._doFinalize()},blockSize:16,_createHelper:function(e){return function(t,n){return new e.init(n).finalize(t)}},_createHmacHelper:function(e){return function(t,n){return new f.HMAC.init(e,n).finalize(t)}}});var f=n.algo={};return n}(Math);!function(e){for(var t=n,r=t.lib,i=r.WordArray,o=r.Hasher,r=t.algo,s=[],a=[],u=function(e){return 4294967296*(e-(0|e))|0},c=2,l=0;64>l;){var h;e:{h=c;for(var f=e.sqrt(h),d=2;d<=f;d++)if(!(h%d)){h=!1;break e}h=!0}h&&(8>l&&(s[l]=u(e.pow(c,.5))),a[l]=u(e.pow(c,1/3)),l++),c++}var p=[],r=r.SHA256=o.extend({_doReset:function(){this._hash=new i.init(s.slice(0))},_doProcessBlock:function(e,t){for(var n=this._hash.words,r=n[0],i=n[1],o=n[2],s=n[3],u=n[4],c=n[5],l=n[6],h=n[7],f=0;64>f;f++){if(16>f)p[f]=0|e[t+f];else{var d=p[f-15],g=p[f-2];p[f]=((d<<25|d>>>7)^(d<<14|d>>>18)^d>>>3)+p[f-7]+((g<<15|g>>>17)^(g<<13|g>>>19)^g>>>10)+p[f-16]}d=h+((u<<26|u>>>6)^(u<<21|u>>>11)^(u<<7|u>>>25))+(u&c^~u&l)+a[f]+p[f],g=((r<<30|r>>>2)^(r<<19|r>>>13)^(r<<10|r>>>22))+(r&i^r&o^i&o),h=l,l=c,c=u,u=s+d|0,s=o,o=i,i=r,r=d+g|0}n[0]=n[0]+r|0,n[1]=n[1]+i|0,n[2]=n[2]+o|0,n[3]=n[3]+s|0,n[4]=n[4]+u|0,n[5]=n[5]+c|0,n[6]=n[6]+l|0,n[7]=n[7]+h|0},_doFinalize:function(){var t=this._data,n=t.words,r=8*this._nDataBytes,i=8*t.sigBytes;return n[i>>>5]|=128<<24-i%32,n[14+(i+64>>>9<<4)]=e.floor(r/4294967296),n[15+(i+64>>>9<<4)]=r,t.sigBytes=4*n.length,this._process(),this._hash},clone:function(){var e=o.clone.call(this);return e._hash=this._hash.clone(),e}});t.SHA256=o._createHelper(r),t.HmacSHA256=o._createHmacHelper(r)}(Math),function(){var e=n,t=e.enc.Utf8;e.algo.HMAC=e.lib.Base.extend({init:function(e,n){e=this._hasher=new e.init,"string"==typeof n&&(n=t.parse(n));var r=e.blockSize,i=4*r;n.sigBytes>i&&(n=e.finalize(n)),n.clamp();for(var o=this._oKey=n.clone(),s=this._iKey=n.clone(),a=o.words,u=s.words,c=0;c<r;c++)a[c]^=1549556828,u[c]^=909522486;o.sigBytes=s.sigBytes=i,this.reset()},reset:function(){var e=this._hasher;e.reset(),e.update(this._iKey)},update:function(e){return this._hasher.update(e),this},finalize:function(e){var t=this._hasher;return e=t.finalize(e),t.reset(),t.finalize(this._oKey.clone().concat(e))}})}(),function(){var e=n,t=e.lib.WordArray;e.enc.Base64={stringify:function(e){var t=e.words,n=e.sigBytes,r=this._map;e.clamp(),e=[];for(var i=0;i<n;i+=3)for(var o=(t[i>>>2]>>>24-i%4*8&255)<<16|(t[i+1>>>2]>>>24-(i+1)%4*8&255)<<8|t[i+2>>>2]>>>24-(i+2)%4*8&255,s=0;4>s&&i+.75*s<n;s++)e.push(r.charAt(o>>>6*(3-s)&63));if(t=r.charAt(64))for(;e.length%4;)e.push(t);return e.join("")},parse:function(e){var n=e.length,r=this._map,i=r.charAt(64);i&&-1!=(i=e.indexOf(i))&&(n=i);for(var i=[],o=0,s=0;s<n;s++)if(s%4){var a=r.indexOf(e.charAt(s-1))<<s%4*2,u=r.indexOf(e.charAt(s))>>>6-s%4*2;i[o>>>2]|=(a|u)<<24-o%4*8,o++}return t.create(i,o)},_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="}}(),function(e){function t(e,t,n,r,i,o,s){return((e=e+(t&n|~t&r)+i+s)<<o|e>>>32-o)+t}function r(e,t,n,r,i,o,s){return((e=e+(t&r|n&~r)+i+s)<<o|e>>>32-o)+t}function i(e,t,n,r,i,o,s){return((e=e+(t^n^r)+i+s)<<o|e>>>32-o)+t}function o(e,t,n,r,i,o,s){return((e=e+(n^(t|~r))+i+s)<<o|e>>>32-o)+t}for(var s=n,a=s.lib,u=a.WordArray,c=a.Hasher,a=s.algo,l=[],h=0;64>h;h++)l[h]=4294967296*e.abs(e.sin(h+1))|0;a=a.MD5=c.extend({_doReset:function(){this._hash=new u.init([1732584193,4023233417,2562383102,271733878])},_doProcessBlock:function(e,n){for(var s=0;16>s;s++){var a=n+s,u=e[a];e[a]=16711935&(u<<8|u>>>24)|4278255360&(u<<24|u>>>8)}var s=this._hash.words,a=e[n+0],u=e[n+1],c=e[n+2],h=e[n+3],f=e[n+4],d=e[n+5],p=e[n+6],g=e[n+7],y=e[n+8],v=e[n+9],b=e[n+10],_=e[n+11],m=e[n+12],k=e[n+13],P=e[n+14],S=e[n+15],O=s[0],w=s[1],T=s[2],C=s[3],O=t(O,w,T,C,a,7,l[0]),C=t(C,O,w,T,u,12,l[1]),T=t(T,C,O,w,c,17,l[2]),w=t(w,T,C,O,h,22,l[3]),O=t(O,w,T,C,f,7,l[4]),C=t(C,O,w,T,d,12,l[5]),T=t(T,C,O,w,p,17,l[6]),w=t(w,T,C,O,g,22,l[7]),O=t(O,w,T,C,y,7,l[8]),C=t(C,O,w,T,v,12,l[9]),T=t(T,C,O,w,b,17,l[10]),w=t(w,T,C,O,_,22,l[11]),O=t(O,w,T,C,m,7,l[12]),C=t(C,O,w,T,k,12,l[13]),T=t(T,C,O,w,P,17,l[14]),w=t(w,T,C,O,S,22,l[15]),O=r(O,w,T,C,u,5,l[16]),C=r(C,O,w,T,p,9,l[17]),T=r(T,C,O,w,_,14,l[18]),w=r(w,T,C,O,a,20,l[19]),O=r(O,w,T,C,d,5,l[20]),C=r(C,O,w,T,b,9,l[21]),T=r(T,C,O,w,S,14,l[22]),w=r(w,T,C,O,f,20,l[23]),O=r(O,w,T,C,v,5,l[24]),C=r(C,O,w,T,P,9,l[25]),T=r(T,C,O,w,h,14,l[26]),w=r(w,T,C,O,y,20,l[27]),O=r(O,w,T,C,k,5,l[28]),C=r(C,O,w,T,c,9,l[29]),T=r(T,C,O,w,g,14,l[30]),w=r(w,T,C,O,m,20,l[31]),O=i(O,w,T,C,d,4,l[32]),C=i(C,O,w,T,y,11,l[33]),T=i(T,C,O,w,_,16,l[34]),w=i(w,T,C,O,P,23,l[35]),O=i(O,w,T,C,u,4,l[36]),C=i(C,O,w,T,f,11,l[37]),T=i(T,C,O,w,g,16,l[38]),w=i(w,T,C,O,b,23,l[39]),O=i(O,w,T,C,k,4,l[40]),C=i(C,O,w,T,a,11,l[41]),T=i(T,C,O,w,h,16,l[42]),w=i(w,T,C,O,p,23,l[43]),O=i(O,w,T,C,v,4,l[44]),C=i(C,O,w,T,m,11,l[45]),T=i(T,C,O,w,S,16,l[46]),w=i(w,T,C,O,c,23,l[47]),O=o(O,w,T,C,a,6,l[48]),C=o(C,O,w,T,g,10,l[49]),T=o(T,C,O,w,P,15,l[50]),w=o(w,T,C,O,d,21,l[51]),O=o(O,w,T,C,m,6,l[52]),C=o(C,O,w,T,h,10,l[53]),T=o(T,C,O,w,b,15,l[54]),w=o(w,T,C,O,u,21,l[55]),O=o(O,w,T,C,y,6,l[56]),C=o(C,O,w,T,S,10,l[57]),T=o(T,C,O,w,p,15,l[58]),w=o(w,T,C,O,k,21,l[59]),O=o(O,w,T,C,f,6,l[60]),C=o(C,O,w,T,_,10,l[61]),T=o(T,C,O,w,c,15,l[62]),w=o(w,T,C,O,v,21,l[63]);s[0]=s[0]+O|0,s[1]=s[1]+w|0,s[2]=s[2]+T|0,s[3]=s[3]+C|0},_doFinalize:function(){var t=this._data,n=t.words,r=8*this._nDataBytes,i=8*t.sigBytes;n[i>>>5]|=128<<24-i%32;var o=e.floor(r/4294967296);for(n[15+(i+64>>>9<<4)]=16711935&(o<<8|o>>>24)|4278255360&(o<<24|o>>>8),n[14+(i+64>>>9<<4)]=16711935&(r<<8|r>>>24)|4278255360&(r<<24|r>>>8),t.sigBytes=4*(n.length+1),this._process(),t=this._hash,n=t.words,r=0;4>r;r++)i=n[r],n[r]=16711935&(i<<8|i>>>24)|4278255360&(i<<24|i>>>8);return t},clone:function(){var e=c.clone.call(this);return e._hash=this._hash.clone(),e}}),s.MD5=c._createHelper(a),s.HmacMD5=c._createHmacHelper(a)}(Math),function(){var e=n,t=e.lib,r=t.Base,i=t.WordArray,t=e.algo,o=t.EvpKDF=r.extend({cfg:r.extend({keySize:4,hasher:t.MD5,iterations:1}),init:function(e){this.cfg=this.cfg.extend(e)},compute:function(e,t){for(var n=this.cfg,r=n.hasher.create(),o=i.create(),s=o.words,a=n.keySize,n=n.iterations;s.length<a;){u&&r.update(u);var u=r.update(e).finalize(t);r.reset();for(var c=1;c<n;c++)u=r.finalize(u),r.reset();o.concat(u)}return o.sigBytes=4*a,o}});e.EvpKDF=function(e,t,n){return o.create(n).compute(e,t)}}(),n.lib.Cipher||function(e){var t=n,r=t.lib,i=r.Base,o=r.WordArray,s=r.BufferedBlockAlgorithm,a=t.enc.Base64,u=t.algo.EvpKDF,c=r.Cipher=s.extend({cfg:i.extend(),createEncryptor:function(e,t){return this.create(this._ENC_XFORM_MODE,e,t)},createDecryptor:function(e,t){return this.create(this._DEC_XFORM_MODE,e,t)},init:function(e,t,n){this.cfg=this.cfg.extend(n),this._xformMode=e,this._key=t,this.reset()},reset:function(){s.reset.call(this),this._doReset()},process:function(e){return this._append(e),this._process()},finalize:function(e){return e&&this._append(e),this._doFinalize()},keySize:4,ivSize:4,_ENC_XFORM_MODE:1,_DEC_XFORM_MODE:2,_createHelper:function(e){return{encrypt:function(t,n,r){return("string"==typeof n?g:p).encrypt(e,t,n,r)},decrypt:function(t,n,r){return("string"==typeof n?g:p).decrypt(e,t,n,r)}}}});r.StreamCipher=c.extend({_doFinalize:function(){return this._process(!0)},blockSize:1});var l=t.mode={},h=function(e,t,n){var r=this._iv;r?this._iv=void 0:r=this._prevBlock;for(var i=0;i<n;i++)e[t+i]^=r[i]},f=(r.BlockCipherMode=i.extend({createEncryptor:function(e,t){return this.Encryptor.create(e,t)},createDecryptor:function(e,t){return this.Decryptor.create(e,t)},init:function(e,t){this._cipher=e,this._iv=t}})).extend();f.Encryptor=f.extend({processBlock:function(e,t){var n=this._cipher,r=n.blockSize;h.call(this,e,t,r),n.encryptBlock(e,t),this._prevBlock=e.slice(t,t+r)}}),f.Decryptor=f.extend({processBlock:function(e,t){var n=this._cipher,r=n.blockSize,i=e.slice(t,t+r);n.decryptBlock(e,t),h.call(this,e,t,r),this._prevBlock=i}}),l=l.CBC=f,f=(t.pad={}).Pkcs7={pad:function(e,t){for(var n=4*t,n=n-e.sigBytes%n,r=n<<24|n<<16|n<<8|n,i=[],s=0;s<n;s+=4)i.push(r);n=o.create(i,n),e.concat(n)},unpad:function(e){e.sigBytes-=255&e.words[e.sigBytes-1>>>2]}},r.BlockCipher=c.extend({cfg:c.cfg.extend({mode:l,padding:f}),reset:function(){c.reset.call(this);var e=this.cfg,t=e.iv,e=e.mode;if(this._xformMode==this._ENC_XFORM_MODE)var n=e.createEncryptor;else n=e.createDecryptor,this._minBufferSize=1;this._mode=n.call(e,this,t&&t.words)},_doProcessBlock:function(e,t){this._mode.processBlock(e,t)},_doFinalize:function(){var e=this.cfg.padding;if(this._xformMode==this._ENC_XFORM_MODE){e.pad(this._data,this.blockSize);var t=this._process(!0)}else t=this._process(!0),e.unpad(t);return t},blockSize:4});var d=r.CipherParams=i.extend({init:function(e){this.mixIn(e)},toString:function(e){return(e||this.formatter).stringify(this)}}),l=(t.format={}).OpenSSL={stringify:function(e){var t=e.ciphertext;return e=e.salt,(e?o.create([1398893684,1701076831]).concat(e).concat(t):t).toString(a)},parse:function(e){e=a.parse(e);var t=e.words;if(1398893684==t[0]&&1701076831==t[1]){var n=o.create(t.slice(2,4));t.splice(0,4),e.sigBytes-=16}return d.create({ciphertext:e,salt:n})}},p=r.SerializableCipher=i.extend({cfg:i.extend({format:l}),encrypt:function(e,t,n,r){r=this.cfg.extend(r);var i=e.createEncryptor(n,r);return t=i.finalize(t),i=i.cfg,d.create({ciphertext:t,key:n,iv:i.iv,algorithm:e,mode:i.mode,padding:i.padding,blockSize:e.blockSize,formatter:r.format})},decrypt:function(e,t,n,r){return r=this.cfg.extend(r),t=this._parse(t,r.format),e.createDecryptor(n,r).finalize(t.ciphertext)},_parse:function(e,t){return"string"==typeof e?t.parse(e,this):e}}),t=(t.kdf={}).OpenSSL={execute:function(e,t,n,r){return r||(r=o.random(8)),e=u.create({keySize:t+n}).compute(e,r),n=o.create(e.words.slice(t),4*n),e.sigBytes=4*t,d.create({key:e,iv:n,salt:r})}},g=r.PasswordBasedCipher=p.extend({cfg:p.cfg.extend({kdf:t}),encrypt:function(e,t,n,r){return r=this.cfg.extend(r),n=r.kdf.execute(n,e.keySize,e.ivSize),r.iv=n.iv,e=p.encrypt.call(this,e,t,n.key,r),e.mixIn(n),e},decrypt:function(e,t,n,r){return r=this.cfg.extend(r),t=this._parse(t,r.format),n=r.kdf.execute(n,e.keySize,e.ivSize,t.salt),r.iv=n.iv,p.decrypt.call(this,e,t,n.key,r)}})}(),function(){for(var e=n,t=e.lib.BlockCipher,r=e.algo,i=[],o=[],s=[],a=[],u=[],c=[],l=[],h=[],f=[],d=[],p=[],g=0;256>g;g++)p[g]=128>g?g<<1:g<<1^283;for(var y=0,v=0,g=0;256>g;g++){var b=v^v<<1^v<<2^v<<3^v<<4,b=b>>>8^255&b^99;i[y]=b,o[b]=y;var _=p[y],m=p[_],k=p[m],P=257*p[b]^16843008*b;s[y]=P<<24|P>>>8,a[y]=P<<16|P>>>16,u[y]=P<<8|P>>>24,c[y]=P,P=16843009*k^65537*m^257*_^16843008*y,l[b]=P<<24|P>>>8,h[b]=P<<16|P>>>16,f[b]=P<<8|P>>>24,d[b]=P,y?(y=_^p[p[p[k^_]]],v^=p[p[v]]):y=v=1}var S=[0,1,2,4,8,16,32,64,128,27,54],r=r.AES=t.extend({_doReset:function(){for(var e=this._key,t=e.words,n=e.sigBytes/4,e=4*((this._nRounds=n+6)+1),r=this._keySchedule=[],o=0;o<e;o++)if(o<n)r[o]=t[o];else{var s=r[o-1];o%n?6<n&&4==o%n&&(s=i[s>>>24]<<24|i[s>>>16&255]<<16|i[s>>>8&255]<<8|i[255&s]):(s=s<<8|s>>>24,s=i[s>>>24]<<24|i[s>>>16&255]<<16|i[s>>>8&255]<<8|i[255&s],s^=S[o/n|0]<<24),r[o]=r[o-n]^s}for(t=this._invKeySchedule=[],n=0;n<e;n++)o=e-n,s=n%4?r[o]:r[o-4],t[n]=4>n||4>=o?s:l[i[s>>>24]]^h[i[s>>>16&255]]^f[i[s>>>8&255]]^d[i[255&s]]},encryptBlock:function(e,t){this._doCryptBlock(e,t,this._keySchedule,s,a,u,c,i)},decryptBlock:function(e,t){var n=e[t+1];e[t+1]=e[t+3],e[t+3]=n,this._doCryptBlock(e,t,this._invKeySchedule,l,h,f,d,o),n=e[t+1],e[t+1]=e[t+3],e[t+3]=n},_doCryptBlock:function(e,t,n,r,i,o,s,a){for(var u=this._nRounds,c=e[t]^n[0],l=e[t+1]^n[1],h=e[t+2]^n[2],f=e[t+3]^n[3],d=4,p=1;p<u;p++)var g=r[c>>>24]^i[l>>>16&255]^o[h>>>8&255]^s[255&f]^n[d++],y=r[l>>>24]^i[h>>>16&255]^o[f>>>8&255]^s[255&c]^n[d++],v=r[h>>>24]^i[f>>>16&255]^o[c>>>8&255]^s[255&l]^n[d++],f=r[f>>>24]^i[c>>>16&255]^o[l>>>8&255]^s[255&h]^n[d++],c=g,l=y,h=v;g=(a[c>>>24]<<24|a[l>>>16&255]<<16|a[h>>>8&255]<<8|a[255&f])^n[d++],y=(a[l>>>24]<<24|a[h>>>16&255]<<16|a[f>>>8&255]<<8|a[255&c])^n[d++],v=(a[h>>>24]<<24|a[f>>>16&255]<<16|a[c>>>8&255]<<8|a[255&l])^n[d++],f=(a[f>>>24]<<24|a[c>>>16&255]<<16|a[l>>>8&255]<<8|a[255&h])^n[d++],e[t]=g,e[t+1]=y,e[t+2]=v,e[t+3]=f},keySize:8});e.AES=t._createHelper(r)}(),n.mode.ECB=function(){var e=n.lib.BlockCipherMode.extend();return e.Encryptor=e.extend({processBlock:function(e,t){this._cipher.encryptBlock(e,t)}}),e.Decryptor=e.extend({processBlock:function(e,t){this._cipher.decryptBlock(e,t)}}),e}(),e.exports=n},function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(t,"__esModule",{value:!0});var o=function(){function e(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(t,n,r){return n&&e(t.prototype,n),r&&e(t,r),t}}(),s=n(9),a=(r(s),n(7)),u=(r(a),n(12)),c=(r(u),n(14)),l=r(c),h=n(17),f=r(h),d=(n(8),n(13)),p=r(d),g=function(){function e(t){var n=t.subscribeEndpoint,r=t.leaveEndpoint,o=t.heartbeatEndpoint,s=t.setStateEndpoint,a=t.timeEndpoint,u=t.config,c=t.crypto,h=t.listenerManager;i(this,e),this._listenerManager=h,this._config=u,this._leaveEndpoint=r,this._heartbeatEndpoint=o,this._setStateEndpoint=s,this._subscribeEndpoint=n,this._crypto=c,this._channels={},this._presenceChannels={},this._channelGroups={},this._presenceChannelGroups={},this._pendingChannelSubscriptions=[],this._pendingChannelGroupSubscriptions=[],this._currentTimetoken=0,this._lastTimetoken=0,this._subscriptionStatusAnnounced=!1,this._reconnectionManager=new l.default({timeEndpoint:a})}return o(e,[{key:"adaptStateChange",value:function(e,t){var n=this,r=e.state,i=e.channels,o=void 0===i?[]:i,s=e.channelGroups,a=void 0===s?[]:s;return o.forEach(function(e){e in n._channels&&(n._channels[e].state=r)}),a.forEach(function(e){e in n._channelGroups&&(n._channelGroups[e].state=r)}),this._setStateEndpoint({state:r,channels:o,channelGroups:a},t)}},{key:"adaptSubscribeChange",value:function(e){var t=this,n=e.timetoken,r=e.channels,i=void 0===r?[]:r,o=e.channelGroups,s=void 0===o?[]:o,a=e.withPresence,u=void 0!==a&&a;if(!this._config.subscribeKey||""===this._config.subscribeKey)return void(console&&console.log&&console.log("subscribe key missing; aborting subscribe"));n&&(this._lastTimetoken=this._currentTimetoken,this._currentTimetoken=n),i.forEach(function(e){t._channels[e]={state:{}},u&&(t._presenceChannels[e]={}),t._pendingChannelSubscriptions.push(e)}),s.forEach(function(e){t._channelGroups[e]={state:{}},u&&(t._presenceChannelGroups[e]={}),t._pendingChannelGroupSubscriptions.push(e)}),this._subscriptionStatusAnnounced=!1,this.reconnect()}},{key:"adaptUnsubscribeChange",value:function(e,t){var n=this,r=e.channels,i=void 0===r?[]:r,o=e.channelGroups,s=void 0===o?[]:o;i.forEach(function(e){e in n._channels&&delete n._channels[e],e in n._presenceChannels&&delete n._presenceChannels[e]}),s.forEach(function(e){e in n._channelGroups&&delete n._channelGroups[e],e in n._presenceChannelGroups&&delete n._channelGroups[e]}),this._config.suppressLeaveEvents!==!1||t||this._leaveEndpoint({channels:i,channelGroups:s},function(e){e.affectedChannels=i,e.affectedChannelGroups=s,e.currentTimetoken=n._currentTimetoken,
e.lastTimetoken=n._lastTimetoken,n._listenerManager.announceStatus(e)}),0===Object.keys(this._channels).length&&0===Object.keys(this._presenceChannels).length&&0===Object.keys(this._channelGroups).length&&0===Object.keys(this._presenceChannelGroups).length&&(this._lastTimetoken=0,this._currentTimetoken=0,this._region=null,this._reconnectionManager.stopPolling()),this.reconnect()}},{key:"unsubscribeAll",value:function(e){this.adaptUnsubscribeChange({channels:this.getSubscribedChannels(),channelGroups:this.getSubscribedChannelGroups()},e)}},{key:"getSubscribedChannels",value:function(){return Object.keys(this._channels)}},{key:"getSubscribedChannelGroups",value:function(){return Object.keys(this._channelGroups)}},{key:"reconnect",value:function(){this._startSubscribeLoop(),this._registerHeartbeatTimer()}},{key:"disconnect",value:function(){this._stopSubscribeLoop(),this._stopHeartbeatTimer(),this._reconnectionManager.stopPolling()}},{key:"_registerHeartbeatTimer",value:function(){this._stopHeartbeatTimer(),this._performHeartbeatLoop(),this._heartbeatTimer=setInterval(this._performHeartbeatLoop.bind(this),1e3*this._config.getHeartbeatInterval())}},{key:"_stopHeartbeatTimer",value:function(){this._heartbeatTimer&&(clearInterval(this._heartbeatTimer),this._heartbeatTimer=null)}},{key:"_performHeartbeatLoop",value:function(){var e=this,t=Object.keys(this._channels),n=Object.keys(this._channelGroups),r={};if(0!==t.length||0!==n.length){t.forEach(function(t){var n=e._channels[t].state;Object.keys(n).length&&(r[t]=n)}),n.forEach(function(t){var n=e._channelGroups[t].state;Object.keys(n).length&&(r[t]=n)});var i=function(t){t.error&&e._config.announceFailedHeartbeats&&e._listenerManager.announceStatus(t),!t.error&&e._config.announceSuccessfulHeartbeats&&e._listenerManager.announceStatus(t)};this._heartbeatEndpoint({channels:t,channelGroups:n,state:r},i.bind(this))}}},{key:"_startSubscribeLoop",value:function(){this._stopSubscribeLoop();var e=[],t=[];if(Object.keys(this._channels).forEach(function(t){return e.push(t)}),Object.keys(this._presenceChannels).forEach(function(t){return e.push(t+"-pnpres")}),Object.keys(this._channelGroups).forEach(function(e){return t.push(e)}),Object.keys(this._presenceChannelGroups).forEach(function(e){return t.push(e+"-pnpres")}),0!==e.length||0!==t.length){var n={channels:e,channelGroups:t,timetoken:this._currentTimetoken,filterExpression:this._config.filterExpression,region:this._region};this._subscribeCall=this._subscribeEndpoint(n,this._processSubscribeResponse.bind(this))}}},{key:"_processSubscribeResponse",value:function(e,t){var n=this;if(e.error)return void(e.category===p.default.PNTimeoutCategory?this._startSubscribeLoop():e.category===p.default.PNNetworkIssuesCategory?(this.disconnect(),this._reconnectionManager.onReconnection(function(){n.reconnect(),n._subscriptionStatusAnnounced=!0;var t={category:p.default.PNReconnectedCategory,operation:e.operation,lastTimetoken:n._lastTimetoken,currentTimetoken:n._currentTimetoken};n._listenerManager.announceStatus(t)}),this._reconnectionManager.startPolling(),this._listenerManager.announceStatus(e)):this._listenerManager.announceStatus(e));if(this._lastTimetoken=this._currentTimetoken,this._currentTimetoken=t.metadata.timetoken,!this._subscriptionStatusAnnounced){var r={};r.category=p.default.PNConnectedCategory,r.operation=e.operation,r.affectedChannels=this._pendingChannelSubscriptions,r.affectedChannelGroups=this._pendingChannelGroupSubscriptions,r.lastTimetoken=this._lastTimetoken,r.currentTimetoken=this._currentTimetoken,this._subscriptionStatusAnnounced=!0,this._listenerManager.announceStatus(r),this._pendingChannelSubscriptions=[],this._pendingChannelGroupSubscriptions=[]}var i=t.messages||[],o=this._config.requestMessageCountThreshold;if(o&&i.length>=o){var s={};s.category=p.default.PNRequestMessageCountExceededCategory,s.operation=e.operation,this._listenerManager.announceStatus(s)}i.forEach(function(e){var t=e.channel,r=e.subscriptionMatch,i=e.publishMetaData;if(t===r&&(r=null),f.default.endsWith(e.channel,"-pnpres")){var o={};o.channel=null,o.subscription=null,o.actualChannel=null!=r?t:null,o.subscribedChannel=null!=r?r:t,t&&(o.channel=t.substring(0,t.lastIndexOf("-pnpres"))),r&&(o.subscription=r.substring(0,r.lastIndexOf("-pnpres"))),o.action=e.payload.action,o.state=e.payload.data,o.timetoken=i.publishTimetoken,o.occupancy=e.payload.occupancy,o.uuid=e.payload.uuid,o.timestamp=e.payload.timestamp,e.payload.join&&(o.join=e.payload.join),e.payload.leave&&(o.leave=e.payload.leave),e.payload.timeout&&(o.timeout=e.payload.timeout),n._listenerManager.announcePresence(o)}else{var s={};s.channel=null,s.subscription=null,s.actualChannel=null!=r?t:null,s.subscribedChannel=null!=r?r:t,s.channel=t,s.subscription=r,s.timetoken=i.publishTimetoken,s.publisher=e.issuingClientId,n._config.cipherKey?s.message=n._crypto.decrypt(e.payload):s.message=e.payload,n._listenerManager.announceMessage(s)}}),this._region=t.metadata.region,this._startSubscribeLoop()}},{key:"_stopSubscribeLoop",value:function(){this._subscribeCall&&(this._subscribeCall.abort(),this._subscribeCall=null)}}]),e}();t.default=g,e.exports=t.default},function(e,t,n){"use strict";function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(t,"__esModule",{value:!0});var i=function(){function e(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(t,n,r){return n&&e(t.prototype,n),r&&e(t,r),t}}(),o=(n(8),n(13)),s=function(e){return e&&e.__esModule?e:{default:e}}(o),a=function(){function e(){r(this,e),this._listeners=[]}return i(e,[{key:"addListener",value:function(e){this._listeners.push(e)}},{key:"removeListener",value:function(e){var t=[];this._listeners.forEach(function(n){n!==e&&t.push(n)}),this._listeners=t}},{key:"removeAllListeners",value:function(){this._listeners=[]}},{key:"announcePresence",value:function(e){this._listeners.forEach(function(t){t.presence&&t.presence(e)})}},{key:"announceStatus",value:function(e){this._listeners.forEach(function(t){t.status&&t.status(e)})}},{key:"announceMessage",value:function(e){this._listeners.forEach(function(t){t.message&&t.message(e)})}},{key:"announceNetworkUp",value:function(){var e={};e.category=s.default.PNNetworkUpCategory,this.announceStatus(e)}},{key:"announceNetworkDown",value:function(){var e={};e.category=s.default.PNNetworkDownCategory,this.announceStatus(e)}}]),e}();t.default=a,e.exports=t.default},function(e,t){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default={PNNetworkUpCategory:"PNNetworkUpCategory",PNNetworkDownCategory:"PNNetworkDownCategory",PNNetworkIssuesCategory:"PNNetworkIssuesCategory",PNTimeoutCategory:"PNTimeoutCategory",PNBadRequestCategory:"PNBadRequestCategory",PNAccessDeniedCategory:"PNAccessDeniedCategory",PNUnknownCategory:"PNUnknownCategory",PNReconnectedCategory:"PNReconnectedCategory",PNConnectedCategory:"PNConnectedCategory",PNRequestMessageCountExceededCategory:"PNRequestMessageCountExceededCategory"},e.exports=t.default},function(e,t,n){"use strict";function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(t,"__esModule",{value:!0});var i=function(){function e(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(t,n,r){return n&&e(t.prototype,n),r&&e(t,r),t}}(),o=n(15),s=(function(e){e&&e.__esModule?e:{default:e}}(o),n(8),function(){function e(t){var n=t.timeEndpoint;r(this,e),this._timeEndpoint=n}return i(e,[{key:"onReconnection",value:function(e){this._reconnectionCallback=e}},{key:"startPolling",value:function(){this._timeTimer=setInterval(this._performTimeLoop.bind(this),3e3)}},{key:"stopPolling",value:function(){clearInterval(this._timeTimer)}},{key:"_performTimeLoop",value:function(){var e=this;this._timeEndpoint(function(t){t.error||(clearInterval(e._timeTimer),e._reconnectionCallback())})}}]),e}());t.default=s,e.exports=t.default},function(e,t,n){"use strict";function r(){return h.default.PNTimeOperation}function i(){return"/time/0"}function o(e){return e.config.getTransactionTimeout()}function s(){return{}}function a(){return!1}function u(e,t){return{timetoken:t[0]}}function c(){}Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=r,t.getURL=i,t.getRequestTimeout=o,t.prepareParams=s,t.isAuthSupported=a,t.handleResponse=u,t.validateParams=c;var l=(n(8),n(16)),h=function(e){return e&&e.__esModule?e:{default:e}}(l)},function(e,t){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default={PNTimeOperation:"PNTimeOperation",PNHistoryOperation:"PNHistoryOperation",PNFetchMessagesOperation:"PNFetchMessagesOperation",PNSubscribeOperation:"PNSubscribeOperation",PNUnsubscribeOperation:"PNUnsubscribeOperation",PNPublishOperation:"PNPublishOperation",PNPushNotificationEnabledChannelsOperation:"PNPushNotificationEnabledChannelsOperation",PNRemoveAllPushNotificationsOperation:"PNRemoveAllPushNotificationsOperation",PNWhereNowOperation:"PNWhereNowOperation",PNSetStateOperation:"PNSetStateOperation",PNHereNowOperation:"PNHereNowOperation",PNGetStateOperation:"PNGetStateOperation",PNHeartbeatOperation:"PNHeartbeatOperation",PNChannelGroupsOperation:"PNChannelGroupsOperation",PNRemoveGroupOperation:"PNRemoveGroupOperation",PNChannelsForGroupOperation:"PNChannelsForGroupOperation",PNAddChannelsToGroupOperation:"PNAddChannelsToGroupOperation",PNRemoveChannelsFromGroupOperation:"PNRemoveChannelsFromGroupOperation",PNAccessManagerGrant:"PNAccessManagerGrant",PNAccessManagerAudit:"PNAccessManagerAudit"},e.exports=t.default},function(e,t){"use strict";function n(e){var t=[];return Object.keys(e).forEach(function(e){return t.push(e)}),t}function r(e){return encodeURIComponent(e).replace(/[!~*'()]/g,function(e){return"%"+e.charCodeAt(0).toString(16).toUpperCase()})}function i(e){return n(e).sort()}function o(e){return i(e).map(function(t){return t+"="+r(e[t])}).join("&")}function s(e,t){return e.indexOf(t,this.length-t.length)!==-1}function a(){var e=void 0,t=void 0;return{promise:new Promise(function(n,r){e=n,t=r}),reject:t,fulfill:e}}e.exports={signPamFromParams:o,endsWith:s,createPromise:a,encodeString:r}},function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function o(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function s(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}function a(e,t){return e.type=t,e.error=!0,e}function u(e){return a({message:e},"validationError")}function c(e,t,n){return e.usePost&&e.usePost(t,n)?e.postURL(t,n):e.getURL(t,n)}function l(e){var t="PubNub-JS-"+e.sdkFamily;return e.partnerId&&(t+="-"+e.partnerId),t+="/"+e.getVersion()}function h(e,t,n){var r=e.config,i=e.crypto;n.timestamp=Math.floor((new Date).getTime()/1e3);var o=r.subscribeKey+"\n"+r.publishKey+"\n"+t+"\n";o+=g.default.signPamFromParams(n);var s=i.HMACSHA256(o);s=s.replace(/\+/g,"-"),s=s.replace(/\//g,"_"),n.signature=s}Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){var n=e.networking,r=e.config,i=null,o=null,s={};t.getOperation()===b.default.PNTimeOperation||t.getOperation()===b.default.PNChannelGroupsOperation?i=arguments.length<=2?void 0:arguments[2]:(s=arguments.length<=2?void 0:arguments[2],i=arguments.length<=3?void 0:arguments[3]),"undefined"==typeof Promise||i||(o=g.default.createPromise());var a=t.validateParams(e,s);if(!a){var f=t.prepareParams(e,s),p=c(t,e,s),y=void 0,v={url:p,operation:t.getOperation(),timeout:t.getRequestTimeout(e)};f.uuid=r.UUID,f.pnsdk=l(r),r.useInstanceId&&(f.instanceid=r.instanceId),r.useRequestId&&(f.requestid=d.default.v4()),t.isAuthSupported()&&r.getAuthKey()&&(f.auth=r.getAuthKey()),r.secretKey&&h(e,p,f);var m=function(n,r){if(n.error)return void(i?i(n):o&&o.reject(new _("PubNub call failed, check status for details",n)));var a=t.handleResponse(e,r,s);i?i(n,a):o&&o.fulfill(a)};if(t.usePost&&t.usePost(e,s)){var k=t.postPayload(e,s);y=n.POST(f,k,v,m)}else y=n.GET(f,v,m);return t.getOperation()===b.default.PNSubscribeOperation?y:o?o.promise:void 0}return i?i(u(a)):o?(o.reject(new _("Validation failed, check status for details",u(a))),o.promise):void 0};var f=n(2),d=r(f),p=(n(8),n(17)),g=r(p),y=n(7),v=(r(y),n(16)),b=r(v),_=function(e){function t(e,n){i(this,t);var r=o(this,(t.__proto__||Object.getPrototypeOf(t)).call(this,e));return r.name=r.constructor.name,r.status=n,r.message=e,r}return s(t,e),t}(Error);e.exports=t.default},function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{default:e}}function i(){return f.default.PNAddChannelsToGroupOperation}function o(e,t){var n=t.channels,r=t.channelGroup,i=e.config;return r?n&&0!==n.length?i.subscribeKey?void 0:"Missing Subscribe Key":"Missing Channels":"Missing Channel Group"}function s(e,t){var n=t.channelGroup;return"/v1/channel-registration/sub-key/"+e.config.subscribeKey+"/channel-group/"+p.default.encodeString(n)}function a(e){return e.config.getTransactionTimeout()}function u(){return!0}function c(e,t){var n=t.channels;return{add:(void 0===n?[]:n).join(",")}}function l(){return{}}Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=i,t.validateParams=o,t.getURL=s,t.getRequestTimeout=a,t.isAuthSupported=u,t.prepareParams=c,t.handleResponse=l;var h=(n(8),n(16)),f=r(h),d=n(17),p=r(d)},function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{default:e}}function i(){return f.default.PNRemoveChannelsFromGroupOperation}function o(e,t){var n=t.channels,r=t.channelGroup,i=e.config;return r?n&&0!==n.length?i.subscribeKey?void 0:"Missing Subscribe Key":"Missing Channels":"Missing Channel Group"}function s(e,t){var n=t.channelGroup;return"/v1/channel-registration/sub-key/"+e.config.subscribeKey+"/channel-group/"+p.default.encodeString(n)}function a(e){return e.config.getTransactionTimeout()}function u(){return!0}function c(e,t){var n=t.channels;return{remove:(void 0===n?[]:n).join(",")}}function l(){return{}}Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=i,t.validateParams=o,t.getURL=s,t.getRequestTimeout=a,t.isAuthSupported=u,t.prepareParams=c,t.handleResponse=l;var h=(n(8),n(16)),f=r(h),d=n(17),p=r(d)},function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{default:e}}function i(){return f.default.PNRemoveGroupOperation}function o(e,t){var n=t.channelGroup,r=e.config;return n?r.subscribeKey?void 0:"Missing Subscribe Key":"Missing Channel Group"}function s(e,t){var n=t.channelGroup;return"/v1/channel-registration/sub-key/"+e.config.subscribeKey+"/channel-group/"+p.default.encodeString(n)+"/remove"}function a(){return!0}function u(e){return e.config.getTransactionTimeout()}function c(){return{}}function l(){return{}}Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=i,t.validateParams=o,t.getURL=s,t.isAuthSupported=a,t.getRequestTimeout=u,t.prepareParams=c,t.handleResponse=l;var h=(n(8),n(16)),f=r(h),d=n(17),p=r(d)},function(e,t,n){"use strict";function r(){return h.default.PNChannelGroupsOperation}function i(e){if(!e.config.subscribeKey)return"Missing Subscribe Key"}function o(e){return"/v1/channel-registration/sub-key/"+e.config.subscribeKey+"/channel-group"}function s(e){return e.config.getTransactionTimeout()}function a(){return!0}function u(){return{}}function c(e,t){return{groups:t.payload.groups}}Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=r,t.validateParams=i,t.getURL=o,t.getRequestTimeout=s,t.isAuthSupported=a,t.prepareParams=u,t.handleResponse=c;var l=(n(8),n(16)),h=function(e){return e&&e.__esModule?e:{default:e}}(l)},function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{default:e}}function i(){return f.default.PNChannelsForGroupOperation}function o(e,t){var n=t.channelGroup,r=e.config;return n?r.subscribeKey?void 0:"Missing Subscribe Key":"Missing Channel Group"}function s(e,t){var n=t.channelGroup;return"/v1/channel-registration/sub-key/"+e.config.subscribeKey+"/channel-group/"+p.default.encodeString(n)}function a(e){return e.config.getTransactionTimeout()}function u(){return!0}function c(){return{}}function l(e,t){return{channels:t.payload.channels}}Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=i,t.validateParams=o,t.getURL=s,t.getRequestTimeout=a,t.isAuthSupported=u,t.prepareParams=c,t.handleResponse=l;var h=(n(8),n(16)),f=r(h),d=n(17),p=r(d)},function(e,t,n){"use strict";function r(){return h.default.PNPushNotificationEnabledChannelsOperation}function i(e,t){var n=t.device,r=t.pushGateway,i=t.channels,o=e.config;return n?r?i&&0!==i.length?o.subscribeKey?void 0:"Missing Subscribe Key":"Missing Channels":"Missing GW Type (pushGateway: gcm or apns)":"Missing Device ID (device)"}function o(e,t){var n=t.device;return"/v1/push/sub-key/"+e.config.subscribeKey+"/devices/"+n}function s(e){return e.config.getTransactionTimeout()}function a(){return!0}function u(e,t){var n=t.pushGateway,r=t.channels;return{type:n,add:(void 0===r?[]:r).join(",")}}function c(){return{}}Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=r,t.validateParams=i,t.getURL=o,t.getRequestTimeout=s,t.isAuthSupported=a,t.prepareParams=u,t.handleResponse=c;var l=(n(8),n(16)),h=function(e){return e&&e.__esModule?e:{default:e}}(l)},function(e,t,n){"use strict";function r(){return h.default.PNPushNotificationEnabledChannelsOperation}function i(e,t){var n=t.device,r=t.pushGateway,i=t.channels,o=e.config;return n?r?i&&0!==i.length?o.subscribeKey?void 0:"Missing Subscribe Key":"Missing Channels":"Missing GW Type (pushGateway: gcm or apns)":"Missing Device ID (device)"}function o(e,t){var n=t.device;return"/v1/push/sub-key/"+e.config.subscribeKey+"/devices/"+n}function s(e){return e.config.getTransactionTimeout()}function a(){return!0}function u(e,t){var n=t.pushGateway,r=t.channels;return{type:n,remove:(void 0===r?[]:r).join(",")}}function c(){return{}}Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=r,t.validateParams=i,t.getURL=o,t.getRequestTimeout=s,t.isAuthSupported=a,t.prepareParams=u,t.handleResponse=c;var l=(n(8),n(16)),h=function(e){return e&&e.__esModule?e:{default:e}}(l)},function(e,t,n){"use strict";function r(){return h.default.PNPushNotificationEnabledChannelsOperation}function i(e,t){var n=t.device,r=t.pushGateway,i=e.config;return n?r?i.subscribeKey?void 0:"Missing Subscribe Key":"Missing GW Type (pushGateway: gcm or apns)":"Missing Device ID (device)"}function o(e,t){var n=t.device;return"/v1/push/sub-key/"+e.config.subscribeKey+"/devices/"+n}function s(e){return e.config.getTransactionTimeout()}function a(){return!0}function u(e,t){return{type:t.pushGateway}}function c(e,t){return{channels:t}}Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=r,t.validateParams=i,t.getURL=o,t.getRequestTimeout=s,t.isAuthSupported=a,t.prepareParams=u,t.handleResponse=c;var l=(n(8),n(16)),h=function(e){return e&&e.__esModule?e:{default:e}}(l)},function(e,t,n){"use strict";function r(){return h.default.PNRemoveAllPushNotificationsOperation}function i(e,t){var n=t.device,r=t.pushGateway,i=e.config;return n?r?i.subscribeKey?void 0:"Missing Subscribe Key":"Missing GW Type (pushGateway: gcm or apns)":"Missing Device ID (device)"}function o(e,t){var n=t.device;return"/v1/push/sub-key/"+e.config.subscribeKey+"/devices/"+n+"/remove"}function s(e){return e.config.getTransactionTimeout()}function a(){return!0}function u(e,t){return{type:t.pushGateway}}function c(){return{}}Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=r,t.validateParams=i,t.getURL=o,t.getRequestTimeout=s,t.isAuthSupported=a,t.prepareParams=u,t.handleResponse=c;var l=(n(8),n(16)),h=function(e){return e&&e.__esModule?e:{default:e}}(l)},function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{default:e}}function i(){return f.default.PNUnsubscribeOperation}function o(e){if(!e.config.subscribeKey)return"Missing Subscribe Key"}function s(e,t){var n=e.config,r=t.channels,i=void 0===r?[]:r,o=i.length>0?i.join(","):",";return"/v2/presence/sub-key/"+n.subscribeKey+"/channel/"+p.default.encodeString(o)+"/leave"}function a(e){return e.config.getTransactionTimeout()}function u(){return!0}function c(e,t){var n=t.channelGroups,r=void 0===n?[]:n,i={};return r.length>0&&(i["channel-group"]=r.join(",")),i}function l(){return{}}Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=i,t.validateParams=o,t.getURL=s,t.getRequestTimeout=a,t.isAuthSupported=u,t.prepareParams=c,t.handleResponse=l;var h=(n(8),n(16)),f=r(h),d=n(17),p=r(d)},function(e,t,n){"use strict";function r(){return h.default.PNWhereNowOperation}function i(e){if(!e.config.subscribeKey)return"Missing Subscribe Key"}function o(e,t){var n=e.config,r=t.uuid,i=void 0===r?n.UUID:r;return"/v2/presence/sub-key/"+n.subscribeKey+"/uuid/"+i}function s(e){return e.config.getTransactionTimeout()}function a(){return!0}function u(){return{}}function c(e,t){return{channels:t.payload.channels}}Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=r,t.validateParams=i,t.getURL=o,t.getRequestTimeout=s,t.isAuthSupported=a,t.prepareParams=u,t.handleResponse=c;var l=(n(8),n(16)),h=function(e){return e&&e.__esModule?e:{default:e}}(l)},function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{default:e}}function i(){return f.default.PNHeartbeatOperation}function o(e){if(!e.config.subscribeKey)return"Missing Subscribe Key"}function s(e,t){var n=e.config,r=t.channels,i=void 0===r?[]:r,o=i.length>0?i.join(","):",";return"/v2/presence/sub-key/"+n.subscribeKey+"/channel/"+p.default.encodeString(o)+"/heartbeat"}function a(){return!0}function u(e){return e.config.getTransactionTimeout()}function c(e,t){var n=t.channelGroups,r=void 0===n?[]:n,i=t.state,o=void 0===i?{}:i,s=e.config,a={};return r.length>0&&(a["channel-group"]=r.join(",")),a.state=JSON.stringify(o),a.heartbeat=s.getPresenceTimeout(),a}function l(){return{}}Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=i,t.validateParams=o,t.getURL=s,t.isAuthSupported=a,t.getRequestTimeout=u,t.prepareParams=c,t.handleResponse=l;var h=(n(8),n(16)),f=r(h),d=n(17),p=r(d)},function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{default:e}}function i(){return f.default.PNGetStateOperation}function o(e){if(!e.config.subscribeKey)return"Missing Subscribe Key"}function s(e,t){var n=e.config,r=t.uuid,i=void 0===r?n.UUID:r,o=t.channels,s=void 0===o?[]:o,a=s.length>0?s.join(","):",";return"/v2/presence/sub-key/"+n.subscribeKey+"/channel/"+p.default.encodeString(a)+"/uuid/"+i}function a(e){return e.config.getTransactionTimeout()}function u(){return!0}function c(e,t){var n=t.channelGroups,r=void 0===n?[]:n,i={};return r.length>0&&(i["channel-group"]=r.join(",")),i}function l(e,t,n){var r=n.channels,i=void 0===r?[]:r,o=n.channelGroups,s=void 0===o?[]:o,a={};return 1===i.length&&0===s.length?a[i[0]]=t.payload:a=t.payload,{channels:a}}Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=i,t.validateParams=o,t.getURL=s,t.getRequestTimeout=a,t.isAuthSupported=u,t.prepareParams=c,t.handleResponse=l;var h=(n(8),n(16)),f=r(h),d=n(17),p=r(d)},function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{default:e}}function i(){return f.default.PNSetStateOperation}function o(e,t){var n=e.config,r=t.state,i=t.channels,o=void 0===i?[]:i,s=t.channelGroups,a=void 0===s?[]:s;return r?n.subscribeKey?0===o.length&&0===a.length?"Please provide a list of channels and/or channel-groups":void 0:"Missing Subscribe Key":"Missing State"}function s(e,t){var n=e.config,r=t.channels,i=void 0===r?[]:r,o=i.length>0?i.join(","):",";return"/v2/presence/sub-key/"+n.subscribeKey+"/channel/"+p.default.encodeString(o)+"/uuid/"+n.UUID+"/data"}function a(e){return e.config.getTransactionTimeout()}function u(){return!0}function c(e,t){var n=t.state,r=t.channelGroups,i=void 0===r?[]:r,o={};return o.state=JSON.stringify(n),i.length>0&&(o["channel-group"]=i.join(",")),o}function l(e,t){return{state:t.payload}}Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=i,t.validateParams=o,t.getURL=s,t.getRequestTimeout=a,t.isAuthSupported=u,t.prepareParams=c,t.handleResponse=l;var h=(n(8),n(16)),f=r(h),d=n(17),p=r(d)},function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{default:e}}function i(){return f.default.PNHereNowOperation}function o(e){if(!e.config.subscribeKey)return"Missing Subscribe Key"}function s(e,t){var n=e.config,r=t.channels,i=void 0===r?[]:r,o=t.channelGroups,s=void 0===o?[]:o,a="/v2/presence/sub-key/"+n.subscribeKey;if(i.length>0||s.length>0){var u=i.length>0?i.join(","):",";a+="/channel/"+p.default.encodeString(u)}return a}function a(e){return e.config.getTransactionTimeout()}function u(){return!0}function c(e,t){var n=t.channelGroups,r=void 0===n?[]:n,i=t.includeUUIDs,o=void 0===i||i,s=t.includeState,a=void 0!==s&&s,u={};return o||(u.disable_uuids=1),a&&(u.state=1),r.length>0&&(u["channel-group"]=r.join(",")),u}function l(e,t,n){var r=n.channels,i=void 0===r?[]:r,o=n.channelGroups,s=void 0===o?[]:o,a=n.includeUUIDs,u=void 0===a||a,c=n.includeState,l=void 0!==c&&c;return i.length>1||s.length>0||0===s.length&&0===i.length?function(){var e={};return e.totalChannels=t.payload.total_channels,e.totalOccupancy=t.payload.total_occupancy,e.channels={},Object.keys(t.payload.channels).forEach(function(n){var r=t.payload.channels[n],i=[];return e.channels[n]={occupants:i,name:n,occupancy:r.occupancy},u&&r.uuids.forEach(function(e){l?i.push({state:e.state,uuid:e.uuid}):i.push({state:null,uuid:e})}),e}),e}():function(){var e={},n=[];return e.totalChannels=1,e.totalOccupancy=t.occupancy,e.channels={},e.channels[i[0]]={occupants:n,name:i[0],occupancy:t.occupancy},u&&t.uuids.forEach(function(e){l?n.push({state:e.state,uuid:e.uuid}):n.push({state:null,uuid:e})}),e}()}Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=i,t.validateParams=o,t.getURL=s,t.getRequestTimeout=a,t.isAuthSupported=u,t.prepareParams=c,t.handleResponse=l;var h=(n(8),n(16)),f=r(h),d=n(17),p=r(d)},function(e,t,n){"use strict";function r(){return h.default.PNAccessManagerAudit}function i(e){if(!e.config.subscribeKey)return"Missing Subscribe Key"}function o(e){return"/v2/auth/audit/sub-key/"+e.config.subscribeKey}function s(e){return e.config.getTransactionTimeout()}function a(){return!1}function u(e,t){var n=t.channel,r=t.channelGroup,i=t.authKeys,o=void 0===i?[]:i,s={};return n&&(s.channel=n),r&&(s["channel-group"]=r),o.length>0&&(s.auth=o.join(",")),s}function c(e,t){return t.payload}Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=r,t.validateParams=i,t.getURL=o,t.getRequestTimeout=s,t.isAuthSupported=a,t.prepareParams=u,t.handleResponse=c;var l=(n(8),n(16)),h=function(e){return e&&e.__esModule?e:{default:e}}(l)},function(e,t,n){"use strict";function r(){return h.default.PNAccessManagerGrant}function i(e){var t=e.config;return t.subscribeKey?t.publishKey?t.secretKey?void 0:"Missing Secret Key":"Missing Publish Key":"Missing Subscribe Key"}function o(e){return"/v2/auth/grant/sub-key/"+e.config.subscribeKey}function s(e){return e.config.getTransactionTimeout()}function a(){return!1}function u(e,t){var n=t.channels,r=void 0===n?[]:n,i=t.channelGroups,o=void 0===i?[]:i,s=t.ttl,a=t.read,u=void 0!==a&&a,c=t.write,l=void 0!==c&&c,h=t.manage,f=void 0!==h&&h,d=t.authKeys,p=void 0===d?[]:d,g={};return g.r=u?"1":"0",g.w=l?"1":"0",g.m=f?"1":"0",r.length>0&&(g.channel=r.join(",")),o.length>0&&(g["channel-group"]=o.join(",")),p.length>0&&(g.auth=p.join(",")),(s||0===s)&&(g.ttl=s),g}function c(){return{}}Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=r,t.validateParams=i,t.getURL=o,t.getRequestTimeout=s,t.isAuthSupported=a,t.prepareParams=u,t.handleResponse=c;var l=(n(8),n(16)),h=function(e){return e&&e.__esModule?e:{default:e}}(l)},function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{default:e}}function i(e,t){var n=e.crypto,r=e.config,i=JSON.stringify(t);return r.cipherKey&&(i=n.encrypt(i),i=JSON.stringify(i)),i}function o(){return v.default.PNPublishOperation}function s(e,t){var n=e.config,r=t.message;return t.channel?r?n.subscribeKey?void 0:"Missing Subscribe Key":"Missing Message":"Missing Channel"}function a(e,t){var n=t.sendByPost;return void 0!==n&&n}function u(e,t){var n=e.config,r=t.channel,o=t.message,s=i(e,o);return"/publish/"+n.publishKey+"/"+n.subscribeKey+"/0/"+_.default.encodeString(r)+"/0/"+_.default.encodeString(s)}function c(e,t){var n=e.config,r=t.channel;return"/publish/"+n.publishKey+"/"+n.subscribeKey+"/0/"+_.default.encodeString(r)+"/0"}function l(e){return e.config.getTransactionTimeout()}function h(){return!0}function f(e,t){return i(e,t.message)}function d(e,t){var n=t.meta,r=t.replicate,i=void 0===r||r,o=t.storeInHistory,s=t.ttl,a={};return null!=o&&(a.store=o?"1":"0"),s&&(a.ttl=s),i===!1&&(a.norep="true"),n&&"object"===(void 0===n?"undefined":g(n))&&(a.meta=JSON.stringify(n)),a}function p(e,t){return{timetoken:t[2]}}Object.defineProperty(t,"__esModule",{value:!0});var g="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};t.getOperation=o,t.validateParams=s,t.usePost=a,t.getURL=u,t.postURL=c,t.getRequestTimeout=l,t.isAuthSupported=h,t.postPayload=f,t.prepareParams=d,t.handleResponse=p;var y=(n(8),n(16)),v=r(y),b=n(17),_=r(b)},function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{default:e}}function i(e,t){var n=e.config,r=e.crypto;if(!n.cipherKey)return t;try{return r.decrypt(t)}catch(e){return t}}function o(){return d.default.PNHistoryOperation}function s(e,t){var n=t.channel,r=e.config;return n?r.subscribeKey?void 0:"Missing Subscribe Key":"Missing channel"}function a(e,t){var n=t.channel;return"/v2/history/sub-key/"+e.config.subscribeKey+"/channel/"+g.default.encodeString(n)}function u(e){return e.config.getTransactionTimeout()}function c(){return!0}function l(e,t){var n=t.start,r=t.end,i=t.reverse,o=t.count,s=void 0===o?100:o,a=t.stringifiedTimeToken,u=void 0!==a&&a,c={include_token:"true"};return c.count=s,n&&(c.start=n),r&&(c.end=r),u&&(c.string_message_token="true"),null!=i&&(c.reverse=i.toString()),c}function h(e,t){var n={messages:[],startTimeToken:t[1],endTimeToken:t[2]};return t[0].forEach(function(t){var r={timetoken:t.timetoken,entry:i(e,t.message)};n.messages.push(r)}),n}Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=o,t.validateParams=s,t.getURL=a,t.getRequestTimeout=u,t.isAuthSupported=c,t.prepareParams=l,t.handleResponse=h;var f=(n(8),n(16)),d=r(f),p=n(17),g=r(p)},function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{default:e}}function i(e,t){var n=e.config,r=e.crypto;if(!n.cipherKey)return t;try{return r.decrypt(t)}catch(e){return t}}function o(){return d.default.PNFetchMessagesOperation}function s(e,t){var n=t.channels,r=e.config;return n&&0!==n.length?r.subscribeKey?void 0:"Missing Subscribe Key":"Missing channels"}function a(e,t){var n=t.channels,r=void 0===n?[]:n,i=e.config,o=r.length>0?r.join(","):",";return"/v3/history/sub-key/"+i.subscribeKey+"/channel/"+g.default.encodeString(o)}function u(e){return e.config.getTransactionTimeout()}function c(){return!0}function l(e,t){var n=t.start,r=t.end,i=t.count,o={};return i&&(o.max=i),n&&(o.start=n),r&&(o.end=r),o}function h(e,t){var n={channels:{}}
;return Object.keys(t.channels||{}).forEach(function(r){n.channels[r]=[],(t.channels[r]||[]).forEach(function(t){var o={};o.channel=r,o.subscription=null,o.timetoken=t.timetoken,o.message=i(e,t.message),n.channels[r].push(o)})}),n}Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=o,t.validateParams=s,t.getURL=a,t.getRequestTimeout=u,t.isAuthSupported=c,t.prepareParams=l,t.handleResponse=h;var f=(n(8),n(16)),d=r(f),p=n(17),g=r(p)},function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{default:e}}function i(){return f.default.PNSubscribeOperation}function o(e){if(!e.config.subscribeKey)return"Missing Subscribe Key"}function s(e,t){var n=e.config,r=t.channels,i=void 0===r?[]:r,o=i.length>0?i.join(","):",";return"/v2/subscribe/"+n.subscribeKey+"/"+p.default.encodeString(o)+"/0"}function a(e){return e.config.getSubscribeTimeout()}function u(){return!0}function c(e,t){var n=e.config,r=t.channelGroups,i=void 0===r?[]:r,o=t.timetoken,s=t.filterExpression,a=t.region,u={heartbeat:n.getPresenceTimeout()};return i.length>0&&(u["channel-group"]=i.join(",")),s&&s.length>0&&(u["filter-expr"]=s),o&&(u.tt=o),a&&(u.tr=a),u}function l(e,t){var n=[];t.m.forEach(function(e){var t={publishTimetoken:e.p.t,region:e.p.r},r={shard:parseInt(e.a,10),subscriptionMatch:e.b,channel:e.c,payload:e.d,flags:e.f,issuingClientId:e.i,subscribeKey:e.k,originationTimetoken:e.o,publishMetaData:t};n.push(r)});var r={timetoken:t.t.t,region:t.t.r};return{messages:n,metadata:r}}Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=i,t.validateParams=o,t.getURL=s,t.getRequestTimeout=a,t.isAuthSupported=u,t.prepareParams=c,t.handleResponse=l;var h=(n(8),n(16)),f=r(h),d=n(17),p=r(d)},function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(t,"__esModule",{value:!0});var o=function(){function e(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(t,n,r){return n&&e(t.prototype,n),r&&e(t,r),t}}(),s=n(7),a=(r(s),n(13)),u=r(a),c=(n(8),function(){function e(t){var n=this;i(this,e),this._modules={},Object.keys(t).forEach(function(e){n._modules[e]=t[e].bind(n)})}return o(e,[{key:"init",value:function(e){this._config=e,this._maxSubDomain=20,this._currentSubDomain=Math.floor(Math.random()*this._maxSubDomain),this._providedFQDN=(this._config.secure?"https://":"http://")+this._config.origin,this._coreParams={},this.shiftStandardOrigin()}},{key:"nextOrigin",value:function(){if(this._providedFQDN.indexOf("pubsub.")===-1)return this._providedFQDN;var e=void 0;return this._currentSubDomain=this._currentSubDomain+1,this._currentSubDomain>=this._maxSubDomain&&(this._currentSubDomain=1),e=this._currentSubDomain.toString(),this._providedFQDN.replace("pubsub","ps"+e)}},{key:"shiftStandardOrigin",value:function(){var e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return this._standardOrigin=this.nextOrigin(e),this._standardOrigin}},{key:"getStandardOrigin",value:function(){return this._standardOrigin}},{key:"POST",value:function(e,t,n,r){return this._modules.post(e,t,n,r)}},{key:"GET",value:function(e,t,n){return this._modules.get(e,t,n)}},{key:"_detectErrorCategory",value:function(e){if("ENOTFOUND"===e.code)return u.default.PNNetworkIssuesCategory;if("ECONNREFUSED"===e.code)return u.default.PNNetworkIssuesCategory;if("ECONNRESET"===e.code)return u.default.PNNetworkIssuesCategory;if("EAI_AGAIN"===e.code)return u.default.PNNetworkIssuesCategory;if(0===e.status||e.hasOwnProperty("status")&&void 0===e.status)return u.default.PNNetworkIssuesCategory;if(e.timeout)return u.default.PNTimeoutCategory;if(e.response){if(e.response.badRequest)return u.default.PNBadRequestCategory;if(e.response.forbidden)return u.default.PNAccessDeniedCategory}return u.default.PNUnknownCategory}}]),e}());t.default=c,e.exports=t.default},function(e,t){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default={get:function(e){try{return localStorage.getItem(e)}catch(e){return null}},set:function(e,t){try{return localStorage.setItem(e,t)}catch(e){return null}}},e.exports=t.default},function(e,t,n){"use strict";function r(e){var t=(new Date).getTime(),n=(new Date).toISOString(),r=function(){return console&&console.log?console:window&&window.console&&window.console.log?window.console:console}();r.log("<<<<<"),r.log("["+n+"]","\n",e.url,"\n",e.qs),r.log("-----"),e.on("response",function(n){var i=(new Date).getTime(),o=i-t,s=(new Date).toISOString();r.log(">>>>>>"),r.log("["+s+" / "+o+"]","\n",e.url,"\n",e.qs,"\n",n.text),r.log("-----")})}function i(e,t,n){var i=this;return this._config.logVerbosity&&(e=e.use(r)),this._config.proxy&&this._modules.proxy&&(e=this._modules.proxy.call(this,e)),this._config.keepAlive&&this._modules.keepAlive&&(e=this._module.keepAlive(e)),e.timeout(t.timeout).end(function(e,r){var o={};if(o.error=null!==e,o.operation=t.operation,r&&r.status&&(o.statusCode=r.status),e)return o.errorData=e,o.category=i._detectErrorCategory(e),n(o,null);var s=JSON.parse(r.text);return n(o,s)})}function o(e,t,n){var r=u.default.get(this.getStandardOrigin()+t.url).query(e);return i.call(this,r,t,n)}function s(e,t,n,r){var o=u.default.post(this.getStandardOrigin()+n.url).query(e).send(t);return i.call(this,o,n,r)}Object.defineProperty(t,"__esModule",{value:!0}),t.get=o,t.post=s;var a=n(43),u=function(e){return e&&e.__esModule?e:{default:e}}(a);n(8)},function(e,t,n){function r(){}function i(e){if(!v(e))return e;var t=[];for(var n in e)o(t,n,e[n]);return t.join("&")}function o(e,t,n){if(null!=n)if(Array.isArray(n))n.forEach(function(n){o(e,t,n)});else if(v(n))for(var r in n)o(e,t+"["+r+"]",n[r]);else e.push(encodeURIComponent(t)+"="+encodeURIComponent(n));else null===n&&e.push(encodeURIComponent(t))}function s(e){for(var t,n,r={},i=e.split("&"),o=0,s=i.length;o<s;++o)t=i[o],n=t.indexOf("="),n==-1?r[decodeURIComponent(t)]="":r[decodeURIComponent(t.slice(0,n))]=decodeURIComponent(t.slice(n+1));return r}function a(e){var t,n,r,i,o=e.split(/\r?\n/),s={};o.pop();for(var a=0,u=o.length;a<u;++a)n=o[a],t=n.indexOf(":"),r=n.slice(0,t).toLowerCase(),i=_(n.slice(t+1)),s[r]=i;return s}function u(e){return/[\/+]json\b/.test(e)}function c(e){return e.split(/ *; */).shift()}function l(e){return e.split(/ *; */).reduce(function(e,t){var n=t.split(/ *= */),r=n.shift(),i=n.shift();return r&&i&&(e[r]=i),e},{})}function h(e,t){t=t||{},this.req=e,this.xhr=this.req.xhr,this.text="HEAD"!=this.req.method&&(""===this.xhr.responseType||"text"===this.xhr.responseType)||void 0===this.xhr.responseType?this.xhr.responseText:null,this.statusText=this.req.xhr.statusText,this._setStatusProperties(this.xhr.status),this.header=this.headers=a(this.xhr.getAllResponseHeaders()),this.header["content-type"]=this.xhr.getResponseHeader("content-type"),this._setHeaderProperties(this.header),this.body="HEAD"!=this.req.method?this._parseBody(this.text?this.text:this.xhr.response):null}function f(e,t){var n=this;this._query=this._query||[],this.method=e,this.url=t,this.header={},this._header={},this.on("end",function(){var e=null,t=null;try{t=new h(n)}catch(t){return e=new Error("Parser is unable to parse the response"),e.parse=!0,e.original=t,e.rawResponse=n.xhr&&n.xhr.responseText?n.xhr.responseText:null,e.statusCode=n.xhr&&n.xhr.status?n.xhr.status:null,n.callback(e)}n.emit("response",t);var r;try{(t.status<200||t.status>=300)&&(r=new Error(t.statusText||"Unsuccessful HTTP response"),r.original=e,r.response=t,r.status=t.status)}catch(e){r=e}r?n.callback(r,t):n.callback(null,t)})}function d(e,t){var n=b("DELETE",e);return t&&n.end(t),n}var p;"undefined"!=typeof window?p=window:"undefined"!=typeof self?p=self:(console.warn("Using browser-only version of superagent in non-browser environment"),p=this);var g=n(44),y=n(45),v=n(46),b=e.exports=n(47).bind(null,f);b.getXHR=function(){if(!(!p.XMLHttpRequest||p.location&&"file:"==p.location.protocol&&p.ActiveXObject))return new XMLHttpRequest;try{return new ActiveXObject("Microsoft.XMLHTTP")}catch(e){}try{return new ActiveXObject("Msxml2.XMLHTTP.6.0")}catch(e){}try{return new ActiveXObject("Msxml2.XMLHTTP.3.0")}catch(e){}try{return new ActiveXObject("Msxml2.XMLHTTP")}catch(e){}throw Error("Browser-only verison of superagent could not find XHR")};var _="".trim?function(e){return e.trim()}:function(e){return e.replace(/(^\s*|\s*$)/g,"")};b.serializeObject=i,b.parseString=s,b.types={html:"text/html",json:"application/json",xml:"application/xml",urlencoded:"application/x-www-form-urlencoded",form:"application/x-www-form-urlencoded","form-data":"application/x-www-form-urlencoded"},b.serialize={"application/x-www-form-urlencoded":i,"application/json":JSON.stringify},b.parse={"application/x-www-form-urlencoded":s,"application/json":JSON.parse},h.prototype.get=function(e){return this.header[e.toLowerCase()]},h.prototype._setHeaderProperties=function(e){var t=this.header["content-type"]||"";this.type=c(t);var n=l(t);for(var r in n)this[r]=n[r]},h.prototype._parseBody=function(e){var t=b.parse[this.type];return!t&&u(this.type)&&(t=b.parse["application/json"]),t&&e&&(e.length||e instanceof Object)?t(e):null},h.prototype._setStatusProperties=function(e){1223===e&&(e=204);var t=e/100|0;this.status=this.statusCode=e,this.statusType=t,this.info=1==t,this.ok=2==t,this.clientError=4==t,this.serverError=5==t,this.error=(4==t||5==t)&&this.toError(),this.accepted=202==e,this.noContent=204==e,this.badRequest=400==e,this.unauthorized=401==e,this.notAcceptable=406==e,this.notFound=404==e,this.forbidden=403==e},h.prototype.toError=function(){var e=this.req,t=e.method,n=e.url,r="cannot "+t+" "+n+" ("+this.status+")",i=new Error(r);return i.status=this.status,i.method=t,i.url=n,i},b.Response=h,g(f.prototype);for(var m in y)f.prototype[m]=y[m];f.prototype.type=function(e){return this.set("Content-Type",b.types[e]||e),this},f.prototype.responseType=function(e){return this._responseType=e,this},f.prototype.accept=function(e){return this.set("Accept",b.types[e]||e),this},f.prototype.auth=function(e,t,n){switch(n||(n={type:"basic"}),n.type){case"basic":var r=btoa(e+":"+t);this.set("Authorization","Basic "+r);break;case"auto":this.username=e,this.password=t}return this},f.prototype.query=function(e){return"string"!=typeof e&&(e=i(e)),e&&this._query.push(e),this},f.prototype.attach=function(e,t,n){return this._getFormData().append(e,t,n||t.name),this},f.prototype._getFormData=function(){return this._formData||(this._formData=new p.FormData),this._formData},f.prototype.callback=function(e,t){var n=this._callback;this.clearTimeout(),n(e,t)},f.prototype.crossDomainError=function(){var e=new Error("Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.");e.crossDomain=!0,e.status=this.status,e.method=this.method,e.url=this.url,this.callback(e)},f.prototype._timeoutError=function(){var e=this._timeout,t=new Error("timeout of "+e+"ms exceeded");t.timeout=e,this.callback(t)},f.prototype._appendQueryString=function(){var e=this._query.join("&");e&&(this.url+=~this.url.indexOf("?")?"&"+e:"?"+e)},f.prototype.end=function(e){var t=this,n=this.xhr=b.getXHR(),i=this._timeout,o=this._formData||this._data;this._callback=e||r,n.onreadystatechange=function(){if(4==n.readyState){var e;try{e=n.status}catch(t){e=0}if(0==e){if(t.timedout)return t._timeoutError();if(t._aborted)return;return t.crossDomainError()}t.emit("end")}};var s=function(e,n){n.total>0&&(n.percent=n.loaded/n.total*100),n.direction=e,t.emit("progress",n)};if(this.hasListeners("progress"))try{n.onprogress=s.bind(null,"download"),n.upload&&(n.upload.onprogress=s.bind(null,"upload"))}catch(e){}if(i&&!this._timer&&(this._timer=setTimeout(function(){t.timedout=!0,t.abort()},i)),this._appendQueryString(),this.username&&this.password?n.open(this.method,this.url,!0,this.username,this.password):n.open(this.method,this.url,!0),this._withCredentials&&(n.withCredentials=!0),"GET"!=this.method&&"HEAD"!=this.method&&"string"!=typeof o&&!this._isHost(o)){var a=this._header["content-type"],c=this._serializer||b.serialize[a?a.split(";")[0]:""];!c&&u(a)&&(c=b.serialize["application/json"]),c&&(o=c(o))}for(var l in this.header)null!=this.header[l]&&n.setRequestHeader(l,this.header[l]);return this._responseType&&(n.responseType=this._responseType),this.emit("request",this),n.send(void 0!==o?o:null),this},b.Request=f,b.get=function(e,t,n){var r=b("GET",e);return"function"==typeof t&&(n=t,t=null),t&&r.query(t),n&&r.end(n),r},b.head=function(e,t,n){var r=b("HEAD",e);return"function"==typeof t&&(n=t,t=null),t&&r.send(t),n&&r.end(n),r},b.options=function(e,t,n){var r=b("OPTIONS",e);return"function"==typeof t&&(n=t,t=null),t&&r.send(t),n&&r.end(n),r},b.del=d,b.delete=d,b.patch=function(e,t,n){var r=b("PATCH",e);return"function"==typeof t&&(n=t,t=null),t&&r.send(t),n&&r.end(n),r},b.post=function(e,t,n){var r=b("POST",e);return"function"==typeof t&&(n=t,t=null),t&&r.send(t),n&&r.end(n),r},b.put=function(e,t,n){var r=b("PUT",e);return"function"==typeof t&&(n=t,t=null),t&&r.send(t),n&&r.end(n),r}},function(e,t,n){function r(e){if(e)return i(e)}function i(e){for(var t in r.prototype)e[t]=r.prototype[t];return e}e.exports=r,r.prototype.on=r.prototype.addEventListener=function(e,t){return this._callbacks=this._callbacks||{},(this._callbacks["$"+e]=this._callbacks["$"+e]||[]).push(t),this},r.prototype.once=function(e,t){function n(){this.off(e,n),t.apply(this,arguments)}return n.fn=t,this.on(e,n),this},r.prototype.off=r.prototype.removeListener=r.prototype.removeAllListeners=r.prototype.removeEventListener=function(e,t){if(this._callbacks=this._callbacks||{},0==arguments.length)return this._callbacks={},this;var n=this._callbacks["$"+e];if(!n)return this;if(1==arguments.length)return delete this._callbacks["$"+e],this;for(var r,i=0;i<n.length;i++)if((r=n[i])===t||r.fn===t){n.splice(i,1);break}return this},r.prototype.emit=function(e){this._callbacks=this._callbacks||{};var t=[].slice.call(arguments,1),n=this._callbacks["$"+e];if(n){n=n.slice(0);for(var r=0,i=n.length;r<i;++r)n[r].apply(this,t)}return this},r.prototype.listeners=function(e){return this._callbacks=this._callbacks||{},this._callbacks["$"+e]||[]},r.prototype.hasListeners=function(e){return!!this.listeners(e).length}},function(e,t,n){var r=n(46);t.clearTimeout=function(){return this._timeout=0,clearTimeout(this._timer),this},t.parse=function(e){return this._parser=e,this},t.serialize=function(e){return this._serializer=e,this},t.timeout=function(e){return this._timeout=e,this},t.then=function(e,t){if(!this._fullfilledPromise){var n=this;this._fullfilledPromise=new Promise(function(e,t){n.end(function(n,r){n?t(n):e(r)})})}return this._fullfilledPromise.then(e,t)},t.catch=function(e){return this.then(void 0,e)},t.use=function(e){return e(this),this},t.get=function(e){return this._header[e.toLowerCase()]},t.getHeader=t.get,t.set=function(e,t){if(r(e)){for(var n in e)this.set(n,e[n]);return this}return this._header[e.toLowerCase()]=t,this.header[e]=t,this},t.unset=function(e){return delete this._header[e.toLowerCase()],delete this.header[e],this},t.field=function(e,t){if(null===e||void 0===e)throw new Error(".field(name, val) name can not be empty");if(r(e)){for(var n in e)this.field(n,e[n]);return this}if(null===t||void 0===t)throw new Error(".field(name, val) val can not be empty");return this._getFormData().append(e,t),this},t.abort=function(){return this._aborted?this:(this._aborted=!0,this.xhr&&this.xhr.abort(),this.req&&this.req.abort(),this.clearTimeout(),this.emit("abort"),this)},t.withCredentials=function(){return this._withCredentials=!0,this},t.redirects=function(e){return this._maxRedirects=e,this},t.toJSON=function(){return{method:this.method,url:this.url,data:this._data,headers:this._header}},t._isHost=function(e){switch({}.toString.call(e)){case"[object File]":case"[object Blob]":case"[object FormData]":return!0;default:return!1}},t.send=function(e){var t=r(e),n=this._header["content-type"];if(t&&r(this._data))for(var i in e)this._data[i]=e[i];else"string"==typeof e?(n||this.type("form"),n=this._header["content-type"],this._data="application/x-www-form-urlencoded"==n?this._data?this._data+"&"+e:e:(this._data||"")+e):this._data=e;return!t||this._isHost(e)?this:(n||this.type("json"),this)}},function(e,t){function n(e){return null!==e&&"object"==typeof e}e.exports=n},function(e,t){function n(e,t,n){return"function"==typeof n?new e("GET",t).end(n):2==arguments.length?new e("GET",t):new e(t,n)}e.exports=n}])});
},{}],10:[function(require,module,exports){

/**
 * Module dependencies.
 */

var url = require('./url');
var parser = require('socket.io-parser');
var Manager = require('./manager');
var debug = require('debug')('socket.io-client');

/**
 * Module exports.
 */

module.exports = exports = lookup;

/**
 * Managers cache.
 */

var cache = exports.managers = {};

/**
 * Looks up an existing `Manager` for multiplexing.
 * If the user summons:
 *
 *   `io('http://localhost/a');`
 *   `io('http://localhost/b');`
 *
 * We reuse the existing instance based on same scheme/port/host,
 * and we initialize sockets for each namespace.
 *
 * @api public
 */

function lookup (uri, opts) {
  if (typeof uri === 'object') {
    opts = uri;
    uri = undefined;
  }

  opts = opts || {};

  var parsed = url(uri);
  var source = parsed.source;
  var id = parsed.id;
  var path = parsed.path;
  var sameNamespace = cache[id] && path in cache[id].nsps;
  var newConnection = opts.forceNew || opts['force new connection'] ||
                      false === opts.multiplex || sameNamespace;

  var io;

  if (newConnection) {
    debug('ignoring socket cache for %s', source);
    io = Manager(source, opts);
  } else {
    if (!cache[id]) {
      debug('new io instance for %s', source);
      cache[id] = Manager(source, opts);
    }
    io = cache[id];
  }
  if (parsed.query && !opts.query) {
    opts.query = parsed.query;
  } else if (opts && 'object' === typeof opts.query) {
    opts.query = encodeQueryString(opts.query);
  }
  return io.socket(parsed.path, opts);
}
/**
 *  Helper method to parse query objects to string.
 * @param {object} query
 * @returns {string}
 */
function encodeQueryString (obj) {
  var str = [];
  for (var p in obj) {
    if (obj.hasOwnProperty(p)) {
      str.push(encodeURIComponent(p) + '=' + encodeURIComponent(obj[p]));
    }
  }
  return str.join('&');
}
/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = parser.protocol;

/**
 * `connect`.
 *
 * @param {String} uri
 * @api public
 */

exports.connect = lookup;

/**
 * Expose constructors for standalone build.
 *
 * @api public
 */

exports.Manager = require('./manager');
exports.Socket = require('./socket');

},{"./manager":11,"./socket":13,"./url":14,"debug":18,"socket.io-parser":48}],11:[function(require,module,exports){

/**
 * Module dependencies.
 */

var eio = require('engine.io-client');
var Socket = require('./socket');
var Emitter = require('component-emitter');
var parser = require('socket.io-parser');
var on = require('./on');
var bind = require('component-bind');
var debug = require('debug')('socket.io-client:manager');
var indexOf = require('indexof');
var Backoff = require('backo2');

/**
 * IE6+ hasOwnProperty
 */

var has = Object.prototype.hasOwnProperty;

/**
 * Module exports
 */

module.exports = Manager;

/**
 * `Manager` constructor.
 *
 * @param {String} engine instance or engine uri/opts
 * @param {Object} options
 * @api public
 */

function Manager (uri, opts) {
  if (!(this instanceof Manager)) return new Manager(uri, opts);
  if (uri && ('object' === typeof uri)) {
    opts = uri;
    uri = undefined;
  }
  opts = opts || {};

  opts.path = opts.path || '/socket.io';
  this.nsps = {};
  this.subs = [];
  this.opts = opts;
  this.reconnection(opts.reconnection !== false);
  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
  this.reconnectionDelay(opts.reconnectionDelay || 1000);
  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
  this.randomizationFactor(opts.randomizationFactor || 0.5);
  this.backoff = new Backoff({
    min: this.reconnectionDelay(),
    max: this.reconnectionDelayMax(),
    jitter: this.randomizationFactor()
  });
  this.timeout(null == opts.timeout ? 20000 : opts.timeout);
  this.readyState = 'closed';
  this.uri = uri;
  this.connecting = [];
  this.lastPing = null;
  this.encoding = false;
  this.packetBuffer = [];
  this.encoder = new parser.Encoder();
  this.decoder = new parser.Decoder();
  this.autoConnect = opts.autoConnect !== false;
  if (this.autoConnect) this.open();
}

/**
 * Propagate given event to sockets and emit on `this`
 *
 * @api private
 */

Manager.prototype.emitAll = function () {
  this.emit.apply(this, arguments);
  for (var nsp in this.nsps) {
    if (has.call(this.nsps, nsp)) {
      this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
    }
  }
};

/**
 * Update `socket.id` of all sockets
 *
 * @api private
 */

Manager.prototype.updateSocketIds = function () {
  for (var nsp in this.nsps) {
    if (has.call(this.nsps, nsp)) {
      this.nsps[nsp].id = this.engine.id;
    }
  }
};

/**
 * Mix in `Emitter`.
 */

Emitter(Manager.prototype);

/**
 * Sets the `reconnection` config.
 *
 * @param {Boolean} true/false if it should automatically reconnect
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnection = function (v) {
  if (!arguments.length) return this._reconnection;
  this._reconnection = !!v;
  return this;
};

/**
 * Sets the reconnection attempts config.
 *
 * @param {Number} max reconnection attempts before giving up
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionAttempts = function (v) {
  if (!arguments.length) return this._reconnectionAttempts;
  this._reconnectionAttempts = v;
  return this;
};

/**
 * Sets the delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelay = function (v) {
  if (!arguments.length) return this._reconnectionDelay;
  this._reconnectionDelay = v;
  this.backoff && this.backoff.setMin(v);
  return this;
};

Manager.prototype.randomizationFactor = function (v) {
  if (!arguments.length) return this._randomizationFactor;
  this._randomizationFactor = v;
  this.backoff && this.backoff.setJitter(v);
  return this;
};

/**
 * Sets the maximum delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelayMax = function (v) {
  if (!arguments.length) return this._reconnectionDelayMax;
  this._reconnectionDelayMax = v;
  this.backoff && this.backoff.setMax(v);
  return this;
};

/**
 * Sets the connection timeout. `false` to disable
 *
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.timeout = function (v) {
  if (!arguments.length) return this._timeout;
  this._timeout = v;
  return this;
};

/**
 * Starts trying to reconnect if reconnection is enabled and we have not
 * started reconnecting yet
 *
 * @api private
 */

Manager.prototype.maybeReconnectOnOpen = function () {
  // Only try to reconnect if it's the first time we're connecting
  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
    // keeps reconnection from firing twice for the same reconnection loop
    this.reconnect();
  }
};

/**
 * Sets the current transport `socket`.
 *
 * @param {Function} optional, callback
 * @return {Manager} self
 * @api public
 */

Manager.prototype.open =
Manager.prototype.connect = function (fn, opts) {
  debug('readyState %s', this.readyState);
  if (~this.readyState.indexOf('open')) return this;

  debug('opening %s', this.uri);
  this.engine = eio(this.uri, this.opts);
  var socket = this.engine;
  var self = this;
  this.readyState = 'opening';
  this.skipReconnect = false;

  // emit `open`
  var openSub = on(socket, 'open', function () {
    self.onopen();
    fn && fn();
  });

  // emit `connect_error`
  var errorSub = on(socket, 'error', function (data) {
    debug('connect_error');
    self.cleanup();
    self.readyState = 'closed';
    self.emitAll('connect_error', data);
    if (fn) {
      var err = new Error('Connection error');
      err.data = data;
      fn(err);
    } else {
      // Only do this if there is no fn to handle the error
      self.maybeReconnectOnOpen();
    }
  });

  // emit `connect_timeout`
  if (false !== this._timeout) {
    var timeout = this._timeout;
    debug('connect attempt will timeout after %d', timeout);

    // set timer
    var timer = setTimeout(function () {
      debug('connect attempt timed out after %d', timeout);
      openSub.destroy();
      socket.close();
      socket.emit('error', 'timeout');
      self.emitAll('connect_timeout', timeout);
    }, timeout);

    this.subs.push({
      destroy: function () {
        clearTimeout(timer);
      }
    });
  }

  this.subs.push(openSub);
  this.subs.push(errorSub);

  return this;
};

/**
 * Called upon transport open.
 *
 * @api private
 */

Manager.prototype.onopen = function () {
  debug('open');

  // clear old subs
  this.cleanup();

  // mark as open
  this.readyState = 'open';
  this.emit('open');

  // add new subs
  var socket = this.engine;
  this.subs.push(on(socket, 'data', bind(this, 'ondata')));
  this.subs.push(on(socket, 'ping', bind(this, 'onping')));
  this.subs.push(on(socket, 'pong', bind(this, 'onpong')));
  this.subs.push(on(socket, 'error', bind(this, 'onerror')));
  this.subs.push(on(socket, 'close', bind(this, 'onclose')));
  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));
};

/**
 * Called upon a ping.
 *
 * @api private
 */

Manager.prototype.onping = function () {
  this.lastPing = new Date();
  this.emitAll('ping');
};

/**
 * Called upon a packet.
 *
 * @api private
 */

Manager.prototype.onpong = function () {
  this.emitAll('pong', new Date() - this.lastPing);
};

/**
 * Called with data.
 *
 * @api private
 */

Manager.prototype.ondata = function (data) {
  this.decoder.add(data);
};

/**
 * Called when parser fully decodes a packet.
 *
 * @api private
 */

Manager.prototype.ondecoded = function (packet) {
  this.emit('packet', packet);
};

/**
 * Called upon socket error.
 *
 * @api private
 */

Manager.prototype.onerror = function (err) {
  debug('error', err);
  this.emitAll('error', err);
};

/**
 * Creates a new socket for the given `nsp`.
 *
 * @return {Socket}
 * @api public
 */

Manager.prototype.socket = function (nsp, opts) {
  var socket = this.nsps[nsp];
  if (!socket) {
    socket = new Socket(this, nsp, opts);
    this.nsps[nsp] = socket;
    var self = this;
    socket.on('connecting', onConnecting);
    socket.on('connect', function () {
      socket.id = self.engine.id;
    });

    if (this.autoConnect) {
      // manually call here since connecting evnet is fired before listening
      onConnecting();
    }
  }

  function onConnecting () {
    if (!~indexOf(self.connecting, socket)) {
      self.connecting.push(socket);
    }
  }

  return socket;
};

/**
 * Called upon a socket close.
 *
 * @param {Socket} socket
 */

Manager.prototype.destroy = function (socket) {
  var index = indexOf(this.connecting, socket);
  if (~index) this.connecting.splice(index, 1);
  if (this.connecting.length) return;

  this.close();
};

/**
 * Writes a packet.
 *
 * @param {Object} packet
 * @api private
 */

Manager.prototype.packet = function (packet) {
  debug('writing packet %j', packet);
  var self = this;
  if (packet.query && packet.type === 0) packet.nsp += '?' + packet.query;

  if (!self.encoding) {
    // encode, then write to engine with result
    self.encoding = true;
    this.encoder.encode(packet, function (encodedPackets) {
      for (var i = 0; i < encodedPackets.length; i++) {
        self.engine.write(encodedPackets[i], packet.options);
      }
      self.encoding = false;
      self.processPacketQueue();
    });
  } else { // add packet to the queue
    self.packetBuffer.push(packet);
  }
};

/**
 * If packet buffer is non-empty, begins encoding the
 * next packet in line.
 *
 * @api private
 */

Manager.prototype.processPacketQueue = function () {
  if (this.packetBuffer.length > 0 && !this.encoding) {
    var pack = this.packetBuffer.shift();
    this.packet(pack);
  }
};

/**
 * Clean up transport subscriptions and packet buffer.
 *
 * @api private
 */

Manager.prototype.cleanup = function () {
  debug('cleanup');

  var subsLength = this.subs.length;
  for (var i = 0; i < subsLength; i++) {
    var sub = this.subs.shift();
    sub.destroy();
  }

  this.packetBuffer = [];
  this.encoding = false;
  this.lastPing = null;

  this.decoder.destroy();
};

/**
 * Close the current socket.
 *
 * @api private
 */

Manager.prototype.close =
Manager.prototype.disconnect = function () {
  debug('disconnect');
  this.skipReconnect = true;
  this.reconnecting = false;
  if ('opening' === this.readyState) {
    // `onclose` will not fire because
    // an open event never happened
    this.cleanup();
  }
  this.backoff.reset();
  this.readyState = 'closed';
  if (this.engine) this.engine.close();
};

/**
 * Called upon engine close.
 *
 * @api private
 */

Manager.prototype.onclose = function (reason) {
  debug('onclose');

  this.cleanup();
  this.backoff.reset();
  this.readyState = 'closed';
  this.emit('close', reason);

  if (this._reconnection && !this.skipReconnect) {
    this.reconnect();
  }
};

/**
 * Attempt a reconnection.
 *
 * @api private
 */

Manager.prototype.reconnect = function () {
  if (this.reconnecting || this.skipReconnect) return this;

  var self = this;

  if (this.backoff.attempts >= this._reconnectionAttempts) {
    debug('reconnect failed');
    this.backoff.reset();
    this.emitAll('reconnect_failed');
    this.reconnecting = false;
  } else {
    var delay = this.backoff.duration();
    debug('will wait %dms before reconnect attempt', delay);

    this.reconnecting = true;
    var timer = setTimeout(function () {
      if (self.skipReconnect) return;

      debug('attempting reconnect');
      self.emitAll('reconnect_attempt', self.backoff.attempts);
      self.emitAll('reconnecting', self.backoff.attempts);

      // check again for the case socket closed in above events
      if (self.skipReconnect) return;

      self.open(function (err) {
        if (err) {
          debug('reconnect attempt error');
          self.reconnecting = false;
          self.reconnect();
          self.emitAll('reconnect_error', err.data);
        } else {
          debug('reconnect success');
          self.onreconnect();
        }
      });
    }, delay);

    this.subs.push({
      destroy: function () {
        clearTimeout(timer);
      }
    });
  }
};

/**
 * Called upon successful reconnect.
 *
 * @api private
 */

Manager.prototype.onreconnect = function () {
  var attempt = this.backoff.attempts;
  this.reconnecting = false;
  this.backoff.reset();
  this.updateSocketIds();
  this.emitAll('reconnect', attempt);
};

},{"./on":12,"./socket":13,"backo2":15,"component-bind":16,"component-emitter":17,"debug":18,"engine.io-client":21,"indexof":45,"socket.io-parser":48}],12:[function(require,module,exports){

/**
 * Module exports.
 */

module.exports = on;

/**
 * Helper for subscriptions.
 *
 * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
 * @param {String} event name
 * @param {Function} callback
 * @api public
 */

function on (obj, ev, fn) {
  obj.on(ev, fn);
  return {
    destroy: function () {
      obj.removeListener(ev, fn);
    }
  };
}

},{}],13:[function(require,module,exports){

/**
 * Module dependencies.
 */

var parser = require('socket.io-parser');
var Emitter = require('component-emitter');
var toArray = require('to-array');
var on = require('./on');
var bind = require('component-bind');
var debug = require('debug')('socket.io-client:socket');
var hasBin = require('has-binary');

/**
 * Module exports.
 */

module.exports = exports = Socket;

/**
 * Internal events (blacklisted).
 * These events can't be emitted by the user.
 *
 * @api private
 */

var events = {
  connect: 1,
  connect_error: 1,
  connect_timeout: 1,
  connecting: 1,
  disconnect: 1,
  error: 1,
  reconnect: 1,
  reconnect_attempt: 1,
  reconnect_failed: 1,
  reconnect_error: 1,
  reconnecting: 1,
  ping: 1,
  pong: 1
};

/**
 * Shortcut to `Emitter#emit`.
 */

var emit = Emitter.prototype.emit;

/**
 * `Socket` constructor.
 *
 * @api public
 */

function Socket (io, nsp, opts) {
  this.io = io;
  this.nsp = nsp;
  this.json = this; // compat
  this.ids = 0;
  this.acks = {};
  this.receiveBuffer = [];
  this.sendBuffer = [];
  this.connected = false;
  this.disconnected = true;
  if (opts && opts.query) {
    this.query = opts.query;
  }
  if (this.io.autoConnect) this.open();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Subscribe to open, close and packet events
 *
 * @api private
 */

Socket.prototype.subEvents = function () {
  if (this.subs) return;

  var io = this.io;
  this.subs = [
    on(io, 'open', bind(this, 'onopen')),
    on(io, 'packet', bind(this, 'onpacket')),
    on(io, 'close', bind(this, 'onclose'))
  ];
};

/**
 * "Opens" the socket.
 *
 * @api public
 */

Socket.prototype.open =
Socket.prototype.connect = function () {
  if (this.connected) return this;

  this.subEvents();
  this.io.open(); // ensure open
  if ('open' === this.io.readyState) this.onopen();
  this.emit('connecting');
  return this;
};

/**
 * Sends a `message` event.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.send = function () {
  var args = toArray(arguments);
  args.unshift('message');
  this.emit.apply(this, args);
  return this;
};

/**
 * Override `emit`.
 * If the event is in `events`, it's emitted normally.
 *
 * @param {String} event name
 * @return {Socket} self
 * @api public
 */

Socket.prototype.emit = function (ev) {
  if (events.hasOwnProperty(ev)) {
    emit.apply(this, arguments);
    return this;
  }

  var args = toArray(arguments);
  var parserType = parser.EVENT; // default
  if (hasBin(args)) { parserType = parser.BINARY_EVENT; } // binary
  var packet = { type: parserType, data: args };

  packet.options = {};
  packet.options.compress = !this.flags || false !== this.flags.compress;

  // event ack callback
  if ('function' === typeof args[args.length - 1]) {
    debug('emitting packet with ack id %d', this.ids);
    this.acks[this.ids] = args.pop();
    packet.id = this.ids++;
  }

  if (this.connected) {
    this.packet(packet);
  } else {
    this.sendBuffer.push(packet);
  }

  delete this.flags;

  return this;
};

/**
 * Sends a packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.packet = function (packet) {
  packet.nsp = this.nsp;
  this.io.packet(packet);
};

/**
 * Called upon engine `open`.
 *
 * @api private
 */

Socket.prototype.onopen = function () {
  debug('transport is open - connecting');

  // write connect packet if necessary
  if ('/' !== this.nsp) {
    if (this.query) {
      this.packet({type: parser.CONNECT, query: this.query});
    } else {
      this.packet({type: parser.CONNECT});
    }
  }
};

/**
 * Called upon engine `close`.
 *
 * @param {String} reason
 * @api private
 */

Socket.prototype.onclose = function (reason) {
  debug('close (%s)', reason);
  this.connected = false;
  this.disconnected = true;
  delete this.id;
  this.emit('disconnect', reason);
};

/**
 * Called with socket packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onpacket = function (packet) {
  if (packet.nsp !== this.nsp) return;

  switch (packet.type) {
    case parser.CONNECT:
      this.onconnect();
      break;

    case parser.EVENT:
      this.onevent(packet);
      break;

    case parser.BINARY_EVENT:
      this.onevent(packet);
      break;

    case parser.ACK:
      this.onack(packet);
      break;

    case parser.BINARY_ACK:
      this.onack(packet);
      break;

    case parser.DISCONNECT:
      this.ondisconnect();
      break;

    case parser.ERROR:
      this.emit('error', packet.data);
      break;
  }
};

/**
 * Called upon a server event.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onevent = function (packet) {
  var args = packet.data || [];
  debug('emitting event %j', args);

  if (null != packet.id) {
    debug('attaching ack callback to event');
    args.push(this.ack(packet.id));
  }

  if (this.connected) {
    emit.apply(this, args);
  } else {
    this.receiveBuffer.push(args);
  }
};

/**
 * Produces an ack callback to emit with an event.
 *
 * @api private
 */

Socket.prototype.ack = function (id) {
  var self = this;
  var sent = false;
  return function () {
    // prevent double callbacks
    if (sent) return;
    sent = true;
    var args = toArray(arguments);
    debug('sending ack %j', args);

    var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;
    self.packet({
      type: type,
      id: id,
      data: args
    });
  };
};

/**
 * Called upon a server acknowlegement.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onack = function (packet) {
  var ack = this.acks[packet.id];
  if ('function' === typeof ack) {
    debug('calling ack %s with %j', packet.id, packet.data);
    ack.apply(this, packet.data);
    delete this.acks[packet.id];
  } else {
    debug('bad ack %s', packet.id);
  }
};

/**
 * Called upon server connect.
 *
 * @api private
 */

Socket.prototype.onconnect = function () {
  this.connected = true;
  this.disconnected = false;
  this.emit('connect');
  this.emitBuffered();
};

/**
 * Emit buffered events (received and emitted).
 *
 * @api private
 */

Socket.prototype.emitBuffered = function () {
  var i;
  for (i = 0; i < this.receiveBuffer.length; i++) {
    emit.apply(this, this.receiveBuffer[i]);
  }
  this.receiveBuffer = [];

  for (i = 0; i < this.sendBuffer.length; i++) {
    this.packet(this.sendBuffer[i]);
  }
  this.sendBuffer = [];
};

/**
 * Called upon server disconnect.
 *
 * @api private
 */

Socket.prototype.ondisconnect = function () {
  debug('server disconnect (%s)', this.nsp);
  this.destroy();
  this.onclose('io server disconnect');
};

/**
 * Called upon forced client/server side disconnections,
 * this method ensures the manager stops tracking us and
 * that reconnections don't get triggered for this.
 *
 * @api private.
 */

Socket.prototype.destroy = function () {
  if (this.subs) {
    // clean subscriptions to avoid reconnections
    for (var i = 0; i < this.subs.length; i++) {
      this.subs[i].destroy();
    }
    this.subs = null;
  }

  this.io.destroy(this);
};

/**
 * Disconnects the socket manually.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.close =
Socket.prototype.disconnect = function () {
  if (this.connected) {
    debug('performing disconnect (%s)', this.nsp);
    this.packet({ type: parser.DISCONNECT });
  }

  // remove socket from pool
  this.destroy();

  if (this.connected) {
    // fire events
    this.onclose('io client disconnect');
  }
  return this;
};

/**
 * Sets the compress flag.
 *
 * @param {Boolean} if `true`, compresses the sending data
 * @return {Socket} self
 * @api public
 */

Socket.prototype.compress = function (compress) {
  this.flags = this.flags || {};
  this.flags.compress = compress;
  return this;
};

},{"./on":12,"component-bind":16,"component-emitter":17,"debug":18,"has-binary":43,"socket.io-parser":48,"to-array":56}],14:[function(require,module,exports){
(function (global){

/**
 * Module dependencies.
 */

var parseuri = require('parseuri');
var debug = require('debug')('socket.io-client:url');

/**
 * Module exports.
 */

module.exports = url;

/**
 * URL parser.
 *
 * @param {String} url
 * @param {Object} An object meant to mimic window.location.
 *                 Defaults to window.location.
 * @api public
 */

function url (uri, loc) {
  var obj = uri;

  // default to window.location
  loc = loc || global.location;
  if (null == uri) uri = loc.protocol + '//' + loc.host;

  // relative path support
  if ('string' === typeof uri) {
    if ('/' === uri.charAt(0)) {
      if ('/' === uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }

    if (!/^(https?|wss?):\/\//.test(uri)) {
      debug('protocol-less url %s', uri);
      if ('undefined' !== typeof loc) {
        uri = loc.protocol + '//' + uri;
      } else {
        uri = 'https://' + uri;
      }
    }

    // parse
    debug('parse %s', uri);
    obj = parseuri(uri);
  }

  // make sure we treat `localhost:80` and `localhost` equally
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = '80';
    } else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = '443';
    }
  }

  obj.path = obj.path || '/';

  var ipv6 = obj.host.indexOf(':') !== -1;
  var host = ipv6 ? '[' + obj.host + ']' : obj.host;

  // define unique id
  obj.id = obj.protocol + '://' + host + ':' + obj.port;
  // define href
  obj.href = obj.protocol + '://' + host + (loc && loc.port === obj.port ? '' : (':' + obj.port));

  return obj;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"debug":18,"parseuri":46}],15:[function(require,module,exports){

/**
 * Expose `Backoff`.
 */

module.exports = Backoff;

/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */

function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 10000;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}

/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */

Backoff.prototype.duration = function(){
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand =  Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};

/**
 * Reset the number of attempts.
 *
 * @api public
 */

Backoff.prototype.reset = function(){
  this.attempts = 0;
};

/**
 * Set the minimum duration
 *
 * @api public
 */

Backoff.prototype.setMin = function(min){
  this.ms = min;
};

/**
 * Set the maximum duration
 *
 * @api public
 */

Backoff.prototype.setMax = function(max){
  this.max = max;
};

/**
 * Set the jitter
 *
 * @api public
 */

Backoff.prototype.setJitter = function(jitter){
  this.jitter = jitter;
};


},{}],16:[function(require,module,exports){
/**
 * Slice reference.
 */

var slice = [].slice;

/**
 * Bind `obj` to `fn`.
 *
 * @param {Object} obj
 * @param {Function|String} fn or string
 * @return {Function}
 * @api public
 */

module.exports = function(obj, fn){
  if ('string' == typeof fn) fn = obj[fn];
  if ('function' != typeof fn) throw new Error('bind() requires a function');
  var args = slice.call(arguments, 2);
  return function(){
    return fn.apply(obj, args.concat(slice.call(arguments)));
  }
};

},{}],17:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

if (typeof module !== 'undefined') {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],18:[function(require,module,exports){
(function (process){

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && 'WebkitAppearance' in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (window.console && (console.firebug || (console.exception && console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs() {
  var args = arguments;
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return args;

  var c = 'color: ' + this.color;
  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
  return args;
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    return exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (typeof process !== 'undefined' && 'env' in process) {
    return process.env.DEBUG;
  }
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage(){
  try {
    return window.localStorage;
  } catch (e) {}
}

}).call(this,require('_process'))

},{"./debug":19,"_process":8}],19:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug.debug = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */

exports.formatters = {};

/**
 * Previously assigned color.
 */

var prevColor = 0;

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function debug(namespace) {

  // define the `disabled` version
  function disabled() {
  }
  disabled.enabled = false;

  // define the `enabled` version
  function enabled() {

    var self = enabled;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // add the `color` if not set
    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color && self.useColors) self.color = selectColor();

    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %o
      args = ['%o'].concat(args);
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting
    args = exports.formatArgs.apply(self, args);

    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/[\\^$+?.()|[\]{}]/g, '\\$&').replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":20}],20:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000
var m = s * 60
var h = m * 60
var d = h * 24
var y = d * 365.25

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function (val, options) {
  options = options || {}
  var type = typeof val
  if (type === 'string' && val.length > 0) {
    return parse(val)
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ?
			fmtLong(val) :
			fmtShort(val)
  }
  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val))
}

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str)
  if (str.length > 10000) {
    return
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str)
  if (!match) {
    return
  }
  var n = parseFloat(match[1])
  var type = (match[2] || 'ms').toLowerCase()
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y
    case 'days':
    case 'day':
    case 'd':
      return n * d
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n
    default:
      return undefined
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd'
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h'
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm'
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's'
  }
  return ms + 'ms'
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms'
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name
  }
  return Math.ceil(ms / n) + ' ' + name + 's'
}

},{}],21:[function(require,module,exports){

module.exports = require('./lib/index');

},{"./lib/index":22}],22:[function(require,module,exports){

module.exports = require('./socket');

/**
 * Exports parser
 *
 * @api public
 *
 */
module.exports.parser = require('engine.io-parser');

},{"./socket":23,"engine.io-parser":32}],23:[function(require,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var transports = require('./transports/index');
var Emitter = require('component-emitter');
var debug = require('debug')('engine.io-client:socket');
var index = require('indexof');
var parser = require('engine.io-parser');
var parseuri = require('parseuri');
var parsejson = require('parsejson');
var parseqs = require('parseqs');

/**
 * Module exports.
 */

module.exports = Socket;

/**
 * Socket constructor.
 *
 * @param {String|Object} uri or options
 * @param {Object} options
 * @api public
 */

function Socket (uri, opts) {
  if (!(this instanceof Socket)) return new Socket(uri, opts);

  opts = opts || {};

  if (uri && 'object' === typeof uri) {
    opts = uri;
    uri = null;
  }

  if (uri) {
    uri = parseuri(uri);
    opts.hostname = uri.host;
    opts.secure = uri.protocol === 'https' || uri.protocol === 'wss';
    opts.port = uri.port;
    if (uri.query) opts.query = uri.query;
  } else if (opts.host) {
    opts.hostname = parseuri(opts.host).host;
  }

  this.secure = null != opts.secure ? opts.secure
    : (global.location && 'https:' === location.protocol);

  if (opts.hostname && !opts.port) {
    // if no port is specified manually, use the protocol default
    opts.port = this.secure ? '443' : '80';
  }

  this.agent = opts.agent || false;
  this.hostname = opts.hostname ||
    (global.location ? location.hostname : 'localhost');
  this.port = opts.port || (global.location && location.port
      ? location.port
      : (this.secure ? 443 : 80));
  this.query = opts.query || {};
  if ('string' === typeof this.query) this.query = parseqs.decode(this.query);
  this.upgrade = false !== opts.upgrade;
  this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
  this.forceJSONP = !!opts.forceJSONP;
  this.jsonp = false !== opts.jsonp;
  this.forceBase64 = !!opts.forceBase64;
  this.enablesXDR = !!opts.enablesXDR;
  this.timestampParam = opts.timestampParam || 't';
  this.timestampRequests = opts.timestampRequests;
  this.transports = opts.transports || ['polling', 'websocket'];
  this.readyState = '';
  this.writeBuffer = [];
  this.prevBufferLen = 0;
  this.policyPort = opts.policyPort || 843;
  this.rememberUpgrade = opts.rememberUpgrade || false;
  this.binaryType = null;
  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
  this.perMessageDeflate = false !== opts.perMessageDeflate ? (opts.perMessageDeflate || {}) : false;

  if (true === this.perMessageDeflate) this.perMessageDeflate = {};
  if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {
    this.perMessageDeflate.threshold = 1024;
  }

  // SSL options for Node.js client
  this.pfx = opts.pfx || null;
  this.key = opts.key || null;
  this.passphrase = opts.passphrase || null;
  this.cert = opts.cert || null;
  this.ca = opts.ca || null;
  this.ciphers = opts.ciphers || null;
  this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? null : opts.rejectUnauthorized;
  this.forceNode = !!opts.forceNode;

  // other options for Node.js client
  var freeGlobal = typeof global === 'object' && global;
  if (freeGlobal.global === freeGlobal) {
    if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {
      this.extraHeaders = opts.extraHeaders;
    }

    if (opts.localAddress) {
      this.localAddress = opts.localAddress;
    }
  }

  // set on handshake
  this.id = null;
  this.upgrades = null;
  this.pingInterval = null;
  this.pingTimeout = null;

  // set on heartbeat
  this.pingIntervalTimer = null;
  this.pingTimeoutTimer = null;

  this.open();
}

Socket.priorWebsocketSuccess = false;

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Protocol version.
 *
 * @api public
 */

Socket.protocol = parser.protocol; // this is an int

/**
 * Expose deps for legacy compatibility
 * and standalone browser access.
 */

Socket.Socket = Socket;
Socket.Transport = require('./transport');
Socket.transports = require('./transports/index');
Socket.parser = require('engine.io-parser');

/**
 * Creates transport of the given type.
 *
 * @param {String} transport name
 * @return {Transport}
 * @api private
 */

Socket.prototype.createTransport = function (name) {
  debug('creating transport "%s"', name);
  var query = clone(this.query);

  // append engine.io protocol identifier
  query.EIO = parser.protocol;

  // transport name
  query.transport = name;

  // session id if we already have one
  if (this.id) query.sid = this.id;

  var transport = new transports[name]({
    agent: this.agent,
    hostname: this.hostname,
    port: this.port,
    secure: this.secure,
    path: this.path,
    query: query,
    forceJSONP: this.forceJSONP,
    jsonp: this.jsonp,
    forceBase64: this.forceBase64,
    enablesXDR: this.enablesXDR,
    timestampRequests: this.timestampRequests,
    timestampParam: this.timestampParam,
    policyPort: this.policyPort,
    socket: this,
    pfx: this.pfx,
    key: this.key,
    passphrase: this.passphrase,
    cert: this.cert,
    ca: this.ca,
    ciphers: this.ciphers,
    rejectUnauthorized: this.rejectUnauthorized,
    perMessageDeflate: this.perMessageDeflate,
    extraHeaders: this.extraHeaders,
    forceNode: this.forceNode,
    localAddress: this.localAddress
  });

  return transport;
};

function clone (obj) {
  var o = {};
  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      o[i] = obj[i];
    }
  }
  return o;
}

/**
 * Initializes transport to use and starts probe.
 *
 * @api private
 */
Socket.prototype.open = function () {
  var transport;
  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') !== -1) {
    transport = 'websocket';
  } else if (0 === this.transports.length) {
    // Emit error on next tick so it can be listened to
    var self = this;
    setTimeout(function () {
      self.emit('error', 'No transports available');
    }, 0);
    return;
  } else {
    transport = this.transports[0];
  }
  this.readyState = 'opening';

  // Retry with the next transport if the transport is disabled (jsonp: false)
  try {
    transport = this.createTransport(transport);
  } catch (e) {
    this.transports.shift();
    this.open();
    return;
  }

  transport.open();
  this.setTransport(transport);
};

/**
 * Sets the current transport. Disables the existing one (if any).
 *
 * @api private
 */

Socket.prototype.setTransport = function (transport) {
  debug('setting transport %s', transport.name);
  var self = this;

  if (this.transport) {
    debug('clearing existing transport %s', this.transport.name);
    this.transport.removeAllListeners();
  }

  // set up transport
  this.transport = transport;

  // set up transport listeners
  transport
  .on('drain', function () {
    self.onDrain();
  })
  .on('packet', function (packet) {
    self.onPacket(packet);
  })
  .on('error', function (e) {
    self.onError(e);
  })
  .on('close', function () {
    self.onClose('transport close');
  });
};

/**
 * Probes a transport.
 *
 * @param {String} transport name
 * @api private
 */

Socket.prototype.probe = function (name) {
  debug('probing transport "%s"', name);
  var transport = this.createTransport(name, { probe: 1 });
  var failed = false;
  var self = this;

  Socket.priorWebsocketSuccess = false;

  function onTransportOpen () {
    if (self.onlyBinaryUpgrades) {
      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
      failed = failed || upgradeLosesBinary;
    }
    if (failed) return;

    debug('probe transport "%s" opened', name);
    transport.send([{ type: 'ping', data: 'probe' }]);
    transport.once('packet', function (msg) {
      if (failed) return;
      if ('pong' === msg.type && 'probe' === msg.data) {
        debug('probe transport "%s" pong', name);
        self.upgrading = true;
        self.emit('upgrading', transport);
        if (!transport) return;
        Socket.priorWebsocketSuccess = 'websocket' === transport.name;

        debug('pausing current transport "%s"', self.transport.name);
        self.transport.pause(function () {
          if (failed) return;
          if ('closed' === self.readyState) return;
          debug('changing transport and sending upgrade packet');

          cleanup();

          self.setTransport(transport);
          transport.send([{ type: 'upgrade' }]);
          self.emit('upgrade', transport);
          transport = null;
          self.upgrading = false;
          self.flush();
        });
      } else {
        debug('probe transport "%s" failed', name);
        var err = new Error('probe error');
        err.transport = transport.name;
        self.emit('upgradeError', err);
      }
    });
  }

  function freezeTransport () {
    if (failed) return;

    // Any callback called by transport should be ignored since now
    failed = true;

    cleanup();

    transport.close();
    transport = null;
  }

  // Handle any error that happens while probing
  function onerror (err) {
    var error = new Error('probe error: ' + err);
    error.transport = transport.name;

    freezeTransport();

    debug('probe transport "%s" failed because of error: %s', name, err);

    self.emit('upgradeError', error);
  }

  function onTransportClose () {
    onerror('transport closed');
  }

  // When the socket is closed while we're probing
  function onclose () {
    onerror('socket closed');
  }

  // When the socket is upgraded while we're probing
  function onupgrade (to) {
    if (transport && to.name !== transport.name) {
      debug('"%s" works - aborting "%s"', to.name, transport.name);
      freezeTransport();
    }
  }

  // Remove all listeners on the transport and on self
  function cleanup () {
    transport.removeListener('open', onTransportOpen);
    transport.removeListener('error', onerror);
    transport.removeListener('close', onTransportClose);
    self.removeListener('close', onclose);
    self.removeListener('upgrading', onupgrade);
  }

  transport.once('open', onTransportOpen);
  transport.once('error', onerror);
  transport.once('close', onTransportClose);

  this.once('close', onclose);
  this.once('upgrading', onupgrade);

  transport.open();
};

/**
 * Called when connection is deemed open.
 *
 * @api public
 */

Socket.prototype.onOpen = function () {
  debug('socket open');
  this.readyState = 'open';
  Socket.priorWebsocketSuccess = 'websocket' === this.transport.name;
  this.emit('open');
  this.flush();

  // we check for `readyState` in case an `open`
  // listener already closed the socket
  if ('open' === this.readyState && this.upgrade && this.transport.pause) {
    debug('starting upgrade probes');
    for (var i = 0, l = this.upgrades.length; i < l; i++) {
      this.probe(this.upgrades[i]);
    }
  }
};

/**
 * Handles a packet.
 *
 * @api private
 */

Socket.prototype.onPacket = function (packet) {
  if ('opening' === this.readyState || 'open' === this.readyState ||
      'closing' === this.readyState) {
    debug('socket receive: type "%s", data "%s"', packet.type, packet.data);

    this.emit('packet', packet);

    // Socket is live - any packet counts
    this.emit('heartbeat');

    switch (packet.type) {
      case 'open':
        this.onHandshake(parsejson(packet.data));
        break;

      case 'pong':
        this.setPing();
        this.emit('pong');
        break;

      case 'error':
        var err = new Error('server error');
        err.code = packet.data;
        this.onError(err);
        break;

      case 'message':
        this.emit('data', packet.data);
        this.emit('message', packet.data);
        break;
    }
  } else {
    debug('packet received with socket readyState "%s"', this.readyState);
  }
};

/**
 * Called upon handshake completion.
 *
 * @param {Object} handshake obj
 * @api private
 */

Socket.prototype.onHandshake = function (data) {
  this.emit('handshake', data);
  this.id = data.sid;
  this.transport.query.sid = data.sid;
  this.upgrades = this.filterUpgrades(data.upgrades);
  this.pingInterval = data.pingInterval;
  this.pingTimeout = data.pingTimeout;
  this.onOpen();
  // In case open handler closes socket
  if ('closed' === this.readyState) return;
  this.setPing();

  // Prolong liveness of socket on heartbeat
  this.removeListener('heartbeat', this.onHeartbeat);
  this.on('heartbeat', this.onHeartbeat);
};

/**
 * Resets ping timeout.
 *
 * @api private
 */

Socket.prototype.onHeartbeat = function (timeout) {
  clearTimeout(this.pingTimeoutTimer);
  var self = this;
  self.pingTimeoutTimer = setTimeout(function () {
    if ('closed' === self.readyState) return;
    self.onClose('ping timeout');
  }, timeout || (self.pingInterval + self.pingTimeout));
};

/**
 * Pings server every `this.pingInterval` and expects response
 * within `this.pingTimeout` or closes connection.
 *
 * @api private
 */

Socket.prototype.setPing = function () {
  var self = this;
  clearTimeout(self.pingIntervalTimer);
  self.pingIntervalTimer = setTimeout(function () {
    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);
    self.ping();
    self.onHeartbeat(self.pingTimeout);
  }, self.pingInterval);
};

/**
* Sends a ping packet.
*
* @api private
*/

Socket.prototype.ping = function () {
  var self = this;
  this.sendPacket('ping', function () {
    self.emit('ping');
  });
};

/**
 * Called on `drain` event
 *
 * @api private
 */

Socket.prototype.onDrain = function () {
  this.writeBuffer.splice(0, this.prevBufferLen);

  // setting prevBufferLen = 0 is very important
  // for example, when upgrading, upgrade packet is sent over,
  // and a nonzero prevBufferLen could cause problems on `drain`
  this.prevBufferLen = 0;

  if (0 === this.writeBuffer.length) {
    this.emit('drain');
  } else {
    this.flush();
  }
};

/**
 * Flush write buffers.
 *
 * @api private
 */

Socket.prototype.flush = function () {
  if ('closed' !== this.readyState && this.transport.writable &&
    !this.upgrading && this.writeBuffer.length) {
    debug('flushing %d packets in socket', this.writeBuffer.length);
    this.transport.send(this.writeBuffer);
    // keep track of current length of writeBuffer
    // splice writeBuffer and callbackBuffer on `drain`
    this.prevBufferLen = this.writeBuffer.length;
    this.emit('flush');
  }
};

/**
 * Sends a message.
 *
 * @param {String} message.
 * @param {Function} callback function.
 * @param {Object} options.
 * @return {Socket} for chaining.
 * @api public
 */

Socket.prototype.write =
Socket.prototype.send = function (msg, options, fn) {
  this.sendPacket('message', msg, options, fn);
  return this;
};

/**
 * Sends a packet.
 *
 * @param {String} packet type.
 * @param {String} data.
 * @param {Object} options.
 * @param {Function} callback function.
 * @api private
 */

Socket.prototype.sendPacket = function (type, data, options, fn) {
  if ('function' === typeof data) {
    fn = data;
    data = undefined;
  }

  if ('function' === typeof options) {
    fn = options;
    options = null;
  }

  if ('closing' === this.readyState || 'closed' === this.readyState) {
    return;
  }

  options = options || {};
  options.compress = false !== options.compress;

  var packet = {
    type: type,
    data: data,
    options: options
  };
  this.emit('packetCreate', packet);
  this.writeBuffer.push(packet);
  if (fn) this.once('flush', fn);
  this.flush();
};

/**
 * Closes the connection.
 *
 * @api private
 */

Socket.prototype.close = function () {
  if ('opening' === this.readyState || 'open' === this.readyState) {
    this.readyState = 'closing';

    var self = this;

    if (this.writeBuffer.length) {
      this.once('drain', function () {
        if (this.upgrading) {
          waitForUpgrade();
        } else {
          close();
        }
      });
    } else if (this.upgrading) {
      waitForUpgrade();
    } else {
      close();
    }
  }

  function close () {
    self.onClose('forced close');
    debug('socket closing - telling transport to close');
    self.transport.close();
  }

  function cleanupAndClose () {
    self.removeListener('upgrade', cleanupAndClose);
    self.removeListener('upgradeError', cleanupAndClose);
    close();
  }

  function waitForUpgrade () {
    // wait for upgrade to finish since we can't send packets while pausing a transport
    self.once('upgrade', cleanupAndClose);
    self.once('upgradeError', cleanupAndClose);
  }

  return this;
};

/**
 * Called upon transport error
 *
 * @api private
 */

Socket.prototype.onError = function (err) {
  debug('socket error %j', err);
  Socket.priorWebsocketSuccess = false;
  this.emit('error', err);
  this.onClose('transport error', err);
};

/**
 * Called upon transport close.
 *
 * @api private
 */

Socket.prototype.onClose = function (reason, desc) {
  if ('opening' === this.readyState || 'open' === this.readyState || 'closing' === this.readyState) {
    debug('socket close with reason: "%s"', reason);
    var self = this;

    // clear timers
    clearTimeout(this.pingIntervalTimer);
    clearTimeout(this.pingTimeoutTimer);

    // stop event from firing again for transport
    this.transport.removeAllListeners('close');

    // ensure transport won't stay open
    this.transport.close();

    // ignore further transport communication
    this.transport.removeAllListeners();

    // set ready state
    this.readyState = 'closed';

    // clear session id
    this.id = null;

    // emit close event
    this.emit('close', reason, desc);

    // clean buffers after, so users can still
    // grab the buffers on `close` event
    self.writeBuffer = [];
    self.prevBufferLen = 0;
  }
};

/**
 * Filters upgrades, returning only those matching client transports.
 *
 * @param {Array} server upgrades
 * @api private
 *
 */

Socket.prototype.filterUpgrades = function (upgrades) {
  var filteredUpgrades = [];
  for (var i = 0, j = upgrades.length; i < j; i++) {
    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
  }
  return filteredUpgrades;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./transport":24,"./transports/index":25,"component-emitter":17,"debug":18,"engine.io-parser":32,"indexof":45,"parsejson":40,"parseqs":41,"parseuri":46}],24:[function(require,module,exports){
/**
 * Module dependencies.
 */

var parser = require('engine.io-parser');
var Emitter = require('component-emitter');

/**
 * Module exports.
 */

module.exports = Transport;

/**
 * Transport abstract constructor.
 *
 * @param {Object} options.
 * @api private
 */

function Transport (opts) {
  this.path = opts.path;
  this.hostname = opts.hostname;
  this.port = opts.port;
  this.secure = opts.secure;
  this.query = opts.query;
  this.timestampParam = opts.timestampParam;
  this.timestampRequests = opts.timestampRequests;
  this.readyState = '';
  this.agent = opts.agent || false;
  this.socket = opts.socket;
  this.enablesXDR = opts.enablesXDR;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;
  this.forceNode = opts.forceNode;

  // other options for Node.js client
  this.extraHeaders = opts.extraHeaders;
  this.localAddress = opts.localAddress;
}

/**
 * Mix in `Emitter`.
 */

Emitter(Transport.prototype);

/**
 * Emits an error.
 *
 * @param {String} str
 * @return {Transport} for chaining
 * @api public
 */

Transport.prototype.onError = function (msg, desc) {
  var err = new Error(msg);
  err.type = 'TransportError';
  err.description = desc;
  this.emit('error', err);
  return this;
};

/**
 * Opens the transport.
 *
 * @api public
 */

Transport.prototype.open = function () {
  if ('closed' === this.readyState || '' === this.readyState) {
    this.readyState = 'opening';
    this.doOpen();
  }

  return this;
};

/**
 * Closes the transport.
 *
 * @api private
 */

Transport.prototype.close = function () {
  if ('opening' === this.readyState || 'open' === this.readyState) {
    this.doClose();
    this.onClose();
  }

  return this;
};

/**
 * Sends multiple packets.
 *
 * @param {Array} packets
 * @api private
 */

Transport.prototype.send = function (packets) {
  if ('open' === this.readyState) {
    this.write(packets);
  } else {
    throw new Error('Transport not open');
  }
};

/**
 * Called upon open
 *
 * @api private
 */

Transport.prototype.onOpen = function () {
  this.readyState = 'open';
  this.writable = true;
  this.emit('open');
};

/**
 * Called with data.
 *
 * @param {String} data
 * @api private
 */

Transport.prototype.onData = function (data) {
  var packet = parser.decodePacket(data, this.socket.binaryType);
  this.onPacket(packet);
};

/**
 * Called with a decoded packet.
 */

Transport.prototype.onPacket = function (packet) {
  this.emit('packet', packet);
};

/**
 * Called upon close.
 *
 * @api private
 */

Transport.prototype.onClose = function () {
  this.readyState = 'closed';
  this.emit('close');
};

},{"component-emitter":17,"engine.io-parser":32}],25:[function(require,module,exports){
(function (global){
/**
 * Module dependencies
 */

var XMLHttpRequest = require('xmlhttprequest-ssl');
var XHR = require('./polling-xhr');
var JSONP = require('./polling-jsonp');
var websocket = require('./websocket');

/**
 * Export transports.
 */

exports.polling = polling;
exports.websocket = websocket;

/**
 * Polling transport polymorphic constructor.
 * Decides on xhr vs jsonp based on feature detection.
 *
 * @api private
 */

function polling (opts) {
  var xhr;
  var xd = false;
  var xs = false;
  var jsonp = false !== opts.jsonp;

  if (global.location) {
    var isSSL = 'https:' === location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    xd = opts.hostname !== location.hostname || port !== opts.port;
    xs = opts.secure !== isSSL;
  }

  opts.xdomain = xd;
  opts.xscheme = xs;
  xhr = new XMLHttpRequest(opts);

  if ('open' in xhr && !opts.forceJSONP) {
    return new XHR(opts);
  } else {
    if (!jsonp) throw new Error('JSONP disabled');
    return new JSONP(opts);
  }
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./polling-jsonp":26,"./polling-xhr":27,"./websocket":29,"xmlhttprequest-ssl":30}],26:[function(require,module,exports){
(function (global){

/**
 * Module requirements.
 */

var Polling = require('./polling');
var inherit = require('component-inherit');

/**
 * Module exports.
 */

module.exports = JSONPPolling;

/**
 * Cached regular expressions.
 */

var rNewline = /\n/g;
var rEscapedNewline = /\\n/g;

/**
 * Global JSONP callbacks.
 */

var callbacks;

/**
 * Noop.
 */

function empty () { }

/**
 * JSONP Polling constructor.
 *
 * @param {Object} opts.
 * @api public
 */

function JSONPPolling (opts) {
  Polling.call(this, opts);

  this.query = this.query || {};

  // define global callbacks array if not present
  // we do this here (lazily) to avoid unneeded global pollution
  if (!callbacks) {
    // we need to consider multiple engines in the same page
    if (!global.___eio) global.___eio = [];
    callbacks = global.___eio;
  }

  // callback identifier
  this.index = callbacks.length;

  // add callback to jsonp global
  var self = this;
  callbacks.push(function (msg) {
    self.onData(msg);
  });

  // append to query string
  this.query.j = this.index;

  // prevent spurious errors from being emitted when the window is unloaded
  if (global.document && global.addEventListener) {
    global.addEventListener('beforeunload', function () {
      if (self.script) self.script.onerror = empty;
    }, false);
  }
}

/**
 * Inherits from Polling.
 */

inherit(JSONPPolling, Polling);

/*
 * JSONP only supports binary as base64 encoded strings
 */

JSONPPolling.prototype.supportsBinary = false;

/**
 * Closes the socket.
 *
 * @api private
 */

JSONPPolling.prototype.doClose = function () {
  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  if (this.form) {
    this.form.parentNode.removeChild(this.form);
    this.form = null;
    this.iframe = null;
  }

  Polling.prototype.doClose.call(this);
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

JSONPPolling.prototype.doPoll = function () {
  var self = this;
  var script = document.createElement('script');

  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  script.async = true;
  script.src = this.uri();
  script.onerror = function (e) {
    self.onError('jsonp poll error', e);
  };

  var insertAt = document.getElementsByTagName('script')[0];
  if (insertAt) {
    insertAt.parentNode.insertBefore(script, insertAt);
  } else {
    (document.head || document.body).appendChild(script);
  }
  this.script = script;

  var isUAgecko = 'undefined' !== typeof navigator && /gecko/i.test(navigator.userAgent);

  if (isUAgecko) {
    setTimeout(function () {
      var iframe = document.createElement('iframe');
      document.body.appendChild(iframe);
      document.body.removeChild(iframe);
    }, 100);
  }
};

/**
 * Writes with a hidden iframe.
 *
 * @param {String} data to send
 * @param {Function} called upon flush.
 * @api private
 */

JSONPPolling.prototype.doWrite = function (data, fn) {
  var self = this;

  if (!this.form) {
    var form = document.createElement('form');
    var area = document.createElement('textarea');
    var id = this.iframeId = 'eio_iframe_' + this.index;
    var iframe;

    form.className = 'socketio';
    form.style.position = 'absolute';
    form.style.top = '-1000px';
    form.style.left = '-1000px';
    form.target = id;
    form.method = 'POST';
    form.setAttribute('accept-charset', 'utf-8');
    area.name = 'd';
    form.appendChild(area);
    document.body.appendChild(form);

    this.form = form;
    this.area = area;
  }

  this.form.action = this.uri();

  function complete () {
    initIframe();
    fn();
  }

  function initIframe () {
    if (self.iframe) {
      try {
        self.form.removeChild(self.iframe);
      } catch (e) {
        self.onError('jsonp polling iframe removal error', e);
      }
    }

    try {
      // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
      var html = '<iframe src="javascript:0" name="' + self.iframeId + '">';
      iframe = document.createElement(html);
    } catch (e) {
      iframe = document.createElement('iframe');
      iframe.name = self.iframeId;
      iframe.src = 'javascript:0';
    }

    iframe.id = self.iframeId;

    self.form.appendChild(iframe);
    self.iframe = iframe;
  }

  initIframe();

  // escape \n to prevent it from being converted into \r\n by some UAs
  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
  data = data.replace(rEscapedNewline, '\\\n');
  this.area.value = data.replace(rNewline, '\\n');

  try {
    this.form.submit();
  } catch (e) {}

  if (this.iframe.attachEvent) {
    this.iframe.onreadystatechange = function () {
      if (self.iframe.readyState === 'complete') {
        complete();
      }
    };
  } else {
    this.iframe.onload = complete;
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./polling":28,"component-inherit":31}],27:[function(require,module,exports){
(function (global){
/**
 * Module requirements.
 */

var XMLHttpRequest = require('xmlhttprequest-ssl');
var Polling = require('./polling');
var Emitter = require('component-emitter');
var inherit = require('component-inherit');
var debug = require('debug')('engine.io-client:polling-xhr');

/**
 * Module exports.
 */

module.exports = XHR;
module.exports.Request = Request;

/**
 * Empty function
 */

function empty () {}

/**
 * XHR Polling constructor.
 *
 * @param {Object} opts
 * @api public
 */

function XHR (opts) {
  Polling.call(this, opts);
  this.requestTimeout = opts.requestTimeout;

  if (global.location) {
    var isSSL = 'https:' === location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    this.xd = opts.hostname !== global.location.hostname ||
      port !== opts.port;
    this.xs = opts.secure !== isSSL;
  } else {
    this.extraHeaders = opts.extraHeaders;
  }
}

/**
 * Inherits from Polling.
 */

inherit(XHR, Polling);

/**
 * XHR supports binary
 */

XHR.prototype.supportsBinary = true;

/**
 * Creates a request.
 *
 * @param {String} method
 * @api private
 */

XHR.prototype.request = function (opts) {
  opts = opts || {};
  opts.uri = this.uri();
  opts.xd = this.xd;
  opts.xs = this.xs;
  opts.agent = this.agent || false;
  opts.supportsBinary = this.supportsBinary;
  opts.enablesXDR = this.enablesXDR;

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;
  opts.requestTimeout = this.requestTimeout;

  // other options for Node.js client
  opts.extraHeaders = this.extraHeaders;

  return new Request(opts);
};

/**
 * Sends data.
 *
 * @param {String} data to send.
 * @param {Function} called upon flush.
 * @api private
 */

XHR.prototype.doWrite = function (data, fn) {
  var isBinary = typeof data !== 'string' && data !== undefined;
  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });
  var self = this;
  req.on('success', fn);
  req.on('error', function (err) {
    self.onError('xhr post error', err);
  });
  this.sendXhr = req;
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

XHR.prototype.doPoll = function () {
  debug('xhr poll');
  var req = this.request();
  var self = this;
  req.on('data', function (data) {
    self.onData(data);
  });
  req.on('error', function (err) {
    self.onError('xhr poll error', err);
  });
  this.pollXhr = req;
};

/**
 * Request constructor
 *
 * @param {Object} options
 * @api public
 */

function Request (opts) {
  this.method = opts.method || 'GET';
  this.uri = opts.uri;
  this.xd = !!opts.xd;
  this.xs = !!opts.xs;
  this.async = false !== opts.async;
  this.data = undefined !== opts.data ? opts.data : null;
  this.agent = opts.agent;
  this.isBinary = opts.isBinary;
  this.supportsBinary = opts.supportsBinary;
  this.enablesXDR = opts.enablesXDR;
  this.requestTimeout = opts.requestTimeout;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;

  // other options for Node.js client
  this.extraHeaders = opts.extraHeaders;

  this.create();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Request.prototype);

/**
 * Creates the XHR object and sends the request.
 *
 * @api private
 */

Request.prototype.create = function () {
  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  var xhr = this.xhr = new XMLHttpRequest(opts);
  var self = this;

  try {
    debug('xhr open %s: %s', this.method, this.uri);
    xhr.open(this.method, this.uri, this.async);
    try {
      if (this.extraHeaders) {
        xhr.setDisableHeaderCheck(true);
        for (var i in this.extraHeaders) {
          if (this.extraHeaders.hasOwnProperty(i)) {
            xhr.setRequestHeader(i, this.extraHeaders[i]);
          }
        }
      }
    } catch (e) {}
    if (this.supportsBinary) {
      // This has to be done after open because Firefox is stupid
      // http://stackoverflow.com/questions/13216903/get-binary-data-with-xmlhttprequest-in-a-firefox-extension
      xhr.responseType = 'arraybuffer';
    }

    if ('POST' === this.method) {
      try {
        if (this.isBinary) {
          xhr.setRequestHeader('Content-type', 'application/octet-stream');
        } else {
          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
        }
      } catch (e) {}
    }

    try {
      xhr.setRequestHeader('Accept', '*/*');
    } catch (e) {}

    // ie6 check
    if ('withCredentials' in xhr) {
      xhr.withCredentials = true;
    }

    if (this.requestTimeout) {
      xhr.timeout = this.requestTimeout;
    }

    if (this.hasXDR()) {
      xhr.onload = function () {
        self.onLoad();
      };
      xhr.onerror = function () {
        self.onError(xhr.responseText);
      };
    } else {
      xhr.onreadystatechange = function () {
        if (4 !== xhr.readyState) return;
        if (200 === xhr.status || 1223 === xhr.status) {
          self.onLoad();
        } else {
          // make sure the `error` event handler that's user-set
          // does not throw in the same tick and gets caught here
          setTimeout(function () {
            self.onError(xhr.status);
          }, 0);
        }
      };
    }

    debug('xhr data %s', this.data);
    xhr.send(this.data);
  } catch (e) {
    // Need to defer since .create() is called directly fhrom the constructor
    // and thus the 'error' event can only be only bound *after* this exception
    // occurs.  Therefore, also, we cannot throw here at all.
    setTimeout(function () {
      self.onError(e);
    }, 0);
    return;
  }

  if (global.document) {
    this.index = Request.requestsCount++;
    Request.requests[this.index] = this;
  }
};

/**
 * Called upon successful response.
 *
 * @api private
 */

Request.prototype.onSuccess = function () {
  this.emit('success');
  this.cleanup();
};

/**
 * Called if we have data.
 *
 * @api private
 */

Request.prototype.onData = function (data) {
  this.emit('data', data);
  this.onSuccess();
};

/**
 * Called upon error.
 *
 * @api private
 */

Request.prototype.onError = function (err) {
  this.emit('error', err);
  this.cleanup(true);
};

/**
 * Cleans up house.
 *
 * @api private
 */

Request.prototype.cleanup = function (fromError) {
  if ('undefined' === typeof this.xhr || null === this.xhr) {
    return;
  }
  // xmlhttprequest
  if (this.hasXDR()) {
    this.xhr.onload = this.xhr.onerror = empty;
  } else {
    this.xhr.onreadystatechange = empty;
  }

  if (fromError) {
    try {
      this.xhr.abort();
    } catch (e) {}
  }

  if (global.document) {
    delete Request.requests[this.index];
  }

  this.xhr = null;
};

/**
 * Called upon load.
 *
 * @api private
 */

Request.prototype.onLoad = function () {
  var data;
  try {
    var contentType;
    try {
      contentType = this.xhr.getResponseHeader('Content-Type').split(';')[0];
    } catch (e) {}
    if (contentType === 'application/octet-stream') {
      data = this.xhr.response || this.xhr.responseText;
    } else {
      if (!this.supportsBinary) {
        data = this.xhr.responseText;
      } else {
        try {
          data = String.fromCharCode.apply(null, new Uint8Array(this.xhr.response));
        } catch (e) {
          var ui8Arr = new Uint8Array(this.xhr.response);
          var dataArray = [];
          for (var idx = 0, length = ui8Arr.length; idx < length; idx++) {
            dataArray.push(ui8Arr[idx]);
          }

          data = String.fromCharCode.apply(null, dataArray);
        }
      }
    }
  } catch (e) {
    this.onError(e);
  }
  if (null != data) {
    this.onData(data);
  }
};

/**
 * Check if it has XDomainRequest.
 *
 * @api private
 */

Request.prototype.hasXDR = function () {
  return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;
};

/**
 * Aborts the request.
 *
 * @api public
 */

Request.prototype.abort = function () {
  this.cleanup();
};

/**
 * Aborts pending requests when unloading the window. This is needed to prevent
 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
 * emitted.
 */

Request.requestsCount = 0;
Request.requests = {};

if (global.document) {
  if (global.attachEvent) {
    global.attachEvent('onunload', unloadHandler);
  } else if (global.addEventListener) {
    global.addEventListener('beforeunload', unloadHandler, false);
  }
}

function unloadHandler () {
  for (var i in Request.requests) {
    if (Request.requests.hasOwnProperty(i)) {
      Request.requests[i].abort();
    }
  }
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./polling":28,"component-emitter":17,"component-inherit":31,"debug":18,"xmlhttprequest-ssl":30}],28:[function(require,module,exports){
/**
 * Module dependencies.
 */

var Transport = require('../transport');
var parseqs = require('parseqs');
var parser = require('engine.io-parser');
var inherit = require('component-inherit');
var yeast = require('yeast');
var debug = require('debug')('engine.io-client:polling');

/**
 * Module exports.
 */

module.exports = Polling;

/**
 * Is XHR2 supported?
 */

var hasXHR2 = (function () {
  var XMLHttpRequest = require('xmlhttprequest-ssl');
  var xhr = new XMLHttpRequest({ xdomain: false });
  return null != xhr.responseType;
})();

/**
 * Polling interface.
 *
 * @param {Object} opts
 * @api private
 */

function Polling (opts) {
  var forceBase64 = (opts && opts.forceBase64);
  if (!hasXHR2 || forceBase64) {
    this.supportsBinary = false;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(Polling, Transport);

/**
 * Transport name.
 */

Polling.prototype.name = 'polling';

/**
 * Opens the socket (triggers polling). We write a PING message to determine
 * when the transport is open.
 *
 * @api private
 */

Polling.prototype.doOpen = function () {
  this.poll();
};

/**
 * Pauses polling.
 *
 * @param {Function} callback upon buffers are flushed and transport is paused
 * @api private
 */

Polling.prototype.pause = function (onPause) {
  var self = this;

  this.readyState = 'pausing';

  function pause () {
    debug('paused');
    self.readyState = 'paused';
    onPause();
  }

  if (this.polling || !this.writable) {
    var total = 0;

    if (this.polling) {
      debug('we are currently polling - waiting to pause');
      total++;
      this.once('pollComplete', function () {
        debug('pre-pause polling complete');
        --total || pause();
      });
    }

    if (!this.writable) {
      debug('we are currently writing - waiting to pause');
      total++;
      this.once('drain', function () {
        debug('pre-pause writing complete');
        --total || pause();
      });
    }
  } else {
    pause();
  }
};

/**
 * Starts polling cycle.
 *
 * @api public
 */

Polling.prototype.poll = function () {
  debug('polling');
  this.polling = true;
  this.doPoll();
  this.emit('poll');
};

/**
 * Overloads onData to detect payloads.
 *
 * @api private
 */

Polling.prototype.onData = function (data) {
  var self = this;
  debug('polling got data %s', data);
  var callback = function (packet, index, total) {
    // if its the first message we consider the transport open
    if ('opening' === self.readyState) {
      self.onOpen();
    }

    // if its a close packet, we close the ongoing requests
    if ('close' === packet.type) {
      self.onClose();
      return false;
    }

    // otherwise bypass onData and handle the message
    self.onPacket(packet);
  };

  // decode payload
  parser.decodePayload(data, this.socket.binaryType, callback);

  // if an event did not trigger closing
  if ('closed' !== this.readyState) {
    // if we got data we're not polling
    this.polling = false;
    this.emit('pollComplete');

    if ('open' === this.readyState) {
      this.poll();
    } else {
      debug('ignoring poll - transport state "%s"', this.readyState);
    }
  }
};

/**
 * For polling, send a close packet.
 *
 * @api private
 */

Polling.prototype.doClose = function () {
  var self = this;

  function close () {
    debug('writing close packet');
    self.write([{ type: 'close' }]);
  }

  if ('open' === this.readyState) {
    debug('transport open - closing');
    close();
  } else {
    // in case we're trying to close while
    // handshaking is in progress (GH-164)
    debug('transport not open - deferring close');
    this.once('open', close);
  }
};

/**
 * Writes a packets payload.
 *
 * @param {Array} data packets
 * @param {Function} drain callback
 * @api private
 */

Polling.prototype.write = function (packets) {
  var self = this;
  this.writable = false;
  var callbackfn = function () {
    self.writable = true;
    self.emit('drain');
  };

  parser.encodePayload(packets, this.supportsBinary, function (data) {
    self.doWrite(data, callbackfn);
  });
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

Polling.prototype.uri = function () {
  var query = this.query || {};
  var schema = this.secure ? 'https' : 'http';
  var port = '';

  // cache busting is forced
  if (false !== this.timestampRequests) {
    query[this.timestampParam] = yeast();
  }

  if (!this.supportsBinary && !query.sid) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // avoid port if default for schema
  if (this.port && (('https' === schema && Number(this.port) !== 443) ||
     ('http' === schema && Number(this.port) !== 80))) {
    port = ':' + this.port;
  }

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  var ipv6 = this.hostname.indexOf(':') !== -1;
  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
};

},{"../transport":24,"component-inherit":31,"debug":18,"engine.io-parser":32,"parseqs":41,"xmlhttprequest-ssl":30,"yeast":42}],29:[function(require,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var Transport = require('../transport');
var parser = require('engine.io-parser');
var parseqs = require('parseqs');
var inherit = require('component-inherit');
var yeast = require('yeast');
var debug = require('debug')('engine.io-client:websocket');
var BrowserWebSocket = global.WebSocket || global.MozWebSocket;
var NodeWebSocket;
if (typeof window === 'undefined') {
  try {
    NodeWebSocket = require('ws');
  } catch (e) { }
}

/**
 * Get either the `WebSocket` or `MozWebSocket` globals
 * in the browser or try to resolve WebSocket-compatible
 * interface exposed by `ws` for Node-like environment.
 */

var WebSocket = BrowserWebSocket;
if (!WebSocket && typeof window === 'undefined') {
  WebSocket = NodeWebSocket;
}

/**
 * Module exports.
 */

module.exports = WS;

/**
 * WebSocket transport constructor.
 *
 * @api {Object} connection options
 * @api public
 */

function WS (opts) {
  var forceBase64 = (opts && opts.forceBase64);
  if (forceBase64) {
    this.supportsBinary = false;
  }
  this.perMessageDeflate = opts.perMessageDeflate;
  this.usingBrowserWebSocket = BrowserWebSocket && !opts.forceNode;
  if (!this.usingBrowserWebSocket) {
    WebSocket = NodeWebSocket;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(WS, Transport);

/**
 * Transport name.
 *
 * @api public
 */

WS.prototype.name = 'websocket';

/*
 * WebSockets support binary
 */

WS.prototype.supportsBinary = true;

/**
 * Opens socket.
 *
 * @api private
 */

WS.prototype.doOpen = function () {
  if (!this.check()) {
    // let probe timeout
    return;
  }

  var uri = this.uri();
  var protocols = void (0);
  var opts = {
    agent: this.agent,
    perMessageDeflate: this.perMessageDeflate
  };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;
  if (this.extraHeaders) {
    opts.headers = this.extraHeaders;
  }
  if (this.localAddress) {
    opts.localAddress = this.localAddress;
  }

  try {
    this.ws = this.usingBrowserWebSocket ? new WebSocket(uri) : new WebSocket(uri, protocols, opts);
  } catch (err) {
    return this.emit('error', err);
  }

  if (this.ws.binaryType === undefined) {
    this.supportsBinary = false;
  }

  if (this.ws.supports && this.ws.supports.binary) {
    this.supportsBinary = true;
    this.ws.binaryType = 'nodebuffer';
  } else {
    this.ws.binaryType = 'arraybuffer';
  }

  this.addEventListeners();
};

/**
 * Adds event listeners to the socket
 *
 * @api private
 */

WS.prototype.addEventListeners = function () {
  var self = this;

  this.ws.onopen = function () {
    self.onOpen();
  };
  this.ws.onclose = function () {
    self.onClose();
  };
  this.ws.onmessage = function (ev) {
    self.onData(ev.data);
  };
  this.ws.onerror = function (e) {
    self.onError('websocket error', e);
  };
};

/**
 * Writes data to socket.
 *
 * @param {Array} array of packets.
 * @api private
 */

WS.prototype.write = function (packets) {
  var self = this;
  this.writable = false;

  // encodePacket efficient as it uses WS framing
  // no need for encodePayload
  var total = packets.length;
  for (var i = 0, l = total; i < l; i++) {
    (function (packet) {
      parser.encodePacket(packet, self.supportsBinary, function (data) {
        if (!self.usingBrowserWebSocket) {
          // always create a new object (GH-437)
          var opts = {};
          if (packet.options) {
            opts.compress = packet.options.compress;
          }

          if (self.perMessageDeflate) {
            var len = 'string' === typeof data ? global.Buffer.byteLength(data) : data.length;
            if (len < self.perMessageDeflate.threshold) {
              opts.compress = false;
            }
          }
        }

        // Sometimes the websocket has already been closed but the browser didn't
        // have a chance of informing us about it yet, in that case send will
        // throw an error
        try {
          if (self.usingBrowserWebSocket) {
            // TypeError is thrown when passing the second argument on Safari
            self.ws.send(data);
          } else {
            self.ws.send(data, opts);
          }
        } catch (e) {
          debug('websocket closed before onclose event');
        }

        --total || done();
      });
    })(packets[i]);
  }

  function done () {
    self.emit('flush');

    // fake drain
    // defer to next tick to allow Socket to clear writeBuffer
    setTimeout(function () {
      self.writable = true;
      self.emit('drain');
    }, 0);
  }
};

/**
 * Called upon close
 *
 * @api private
 */

WS.prototype.onClose = function () {
  Transport.prototype.onClose.call(this);
};

/**
 * Closes socket.
 *
 * @api private
 */

WS.prototype.doClose = function () {
  if (typeof this.ws !== 'undefined') {
    this.ws.close();
  }
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

WS.prototype.uri = function () {
  var query = this.query || {};
  var schema = this.secure ? 'wss' : 'ws';
  var port = '';

  // avoid port if default for schema
  if (this.port && (('wss' === schema && Number(this.port) !== 443) ||
    ('ws' === schema && Number(this.port) !== 80))) {
    port = ':' + this.port;
  }

  // append timestamp to URI
  if (this.timestampRequests) {
    query[this.timestampParam] = yeast();
  }

  // communicate binary support capabilities
  if (!this.supportsBinary) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  var ipv6 = this.hostname.indexOf(':') !== -1;
  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
};

/**
 * Feature detection for WebSocket.
 *
 * @return {Boolean} whether this transport is available.
 * @api public
 */

WS.prototype.check = function () {
  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../transport":24,"component-inherit":31,"debug":18,"engine.io-parser":32,"parseqs":41,"ws":2,"yeast":42}],30:[function(require,module,exports){
(function (global){
// browser shim for xmlhttprequest module

var hasCORS = require('has-cors');

module.exports = function (opts) {
  var xdomain = opts.xdomain;

  // scheme must be same when usign XDomainRequest
  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
  var xscheme = opts.xscheme;

  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
  // https://github.com/Automattic/engine.io-client/pull/217
  var enablesXDR = opts.enablesXDR;

  // XMLHttpRequest can be disabled on IE
  try {
    if ('undefined' !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) { }

  // Use XDomainRequest for IE8 if enablesXDR is true
  // because loading bar keeps flashing when using jsonp-polling
  // https://github.com/yujiosaka/socke.io-ie8-loading-example
  try {
    if ('undefined' !== typeof XDomainRequest && !xscheme && enablesXDR) {
      return new XDomainRequest();
    }
  } catch (e) { }

  if (!xdomain) {
    try {
      return new global[['Active'].concat('Object').join('X')]('Microsoft.XMLHTTP');
    } catch (e) { }
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"has-cors":39}],31:[function(require,module,exports){

module.exports = function(a, b){
  var fn = function(){};
  fn.prototype = b.prototype;
  a.prototype = new fn;
  a.prototype.constructor = a;
};
},{}],32:[function(require,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var keys = require('./keys');
var hasBinary = require('has-binary');
var sliceBuffer = require('arraybuffer.slice');
var after = require('after');
var utf8 = require('wtf-8');

var base64encoder;
if (global && global.ArrayBuffer) {
  base64encoder = require('base64-arraybuffer');
}

/**
 * Check if we are running an android browser. That requires us to use
 * ArrayBuffer with polling transports...
 *
 * http://ghinda.net/jpeg-blob-ajax-android/
 */

var isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);

/**
 * Check if we are running in PhantomJS.
 * Uploading a Blob with PhantomJS does not work correctly, as reported here:
 * https://github.com/ariya/phantomjs/issues/11395
 * @type boolean
 */
var isPhantomJS = typeof navigator !== 'undefined' && /PhantomJS/i.test(navigator.userAgent);

/**
 * When true, avoids using Blobs to encode payloads.
 * @type boolean
 */
var dontSendBlobs = isAndroid || isPhantomJS;

/**
 * Current protocol version.
 */

exports.protocol = 3;

/**
 * Packet types.
 */

var packets = exports.packets = {
    open:     0    // non-ws
  , close:    1    // non-ws
  , ping:     2
  , pong:     3
  , message:  4
  , upgrade:  5
  , noop:     6
};

var packetslist = keys(packets);

/**
 * Premade error packet.
 */

var err = { type: 'error', data: 'parser error' };

/**
 * Create a blob api even for blob builder when vendor prefixes exist
 */

var Blob = require('blob');

/**
 * Encodes a packet.
 *
 *     <packet type id> [ <data> ]
 *
 * Example:
 *
 *     5hello world
 *     3
 *     4
 *
 * Binary is encoded in an identical principle
 *
 * @api private
 */

exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
  if ('function' == typeof supportsBinary) {
    callback = supportsBinary;
    supportsBinary = false;
  }

  if ('function' == typeof utf8encode) {
    callback = utf8encode;
    utf8encode = null;
  }

  var data = (packet.data === undefined)
    ? undefined
    : packet.data.buffer || packet.data;

  if (global.ArrayBuffer && data instanceof ArrayBuffer) {
    return encodeArrayBuffer(packet, supportsBinary, callback);
  } else if (Blob && data instanceof global.Blob) {
    return encodeBlob(packet, supportsBinary, callback);
  }

  // might be an object with { base64: true, data: dataAsBase64String }
  if (data && data.base64) {
    return encodeBase64Object(packet, callback);
  }

  // Sending data as a utf-8 string
  var encoded = packets[packet.type];

  // data fragment is optional
  if (undefined !== packet.data) {
    encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data);
  }

  return callback('' + encoded);

};

function encodeBase64Object(packet, callback) {
  // packet data is an object { base64: true, data: dataAsBase64String }
  var message = 'b' + exports.packets[packet.type] + packet.data.data;
  return callback(message);
}

/**
 * Encode packet helpers for binary types
 */

function encodeArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var data = packet.data;
  var contentArray = new Uint8Array(data);
  var resultBuffer = new Uint8Array(1 + data.byteLength);

  resultBuffer[0] = packets[packet.type];
  for (var i = 0; i < contentArray.length; i++) {
    resultBuffer[i+1] = contentArray[i];
  }

  return callback(resultBuffer.buffer);
}

function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var fr = new FileReader();
  fr.onload = function() {
    packet.data = fr.result;
    exports.encodePacket(packet, supportsBinary, true, callback);
  };
  return fr.readAsArrayBuffer(packet.data);
}

function encodeBlob(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  if (dontSendBlobs) {
    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
  }

  var length = new Uint8Array(1);
  length[0] = packets[packet.type];
  var blob = new Blob([length.buffer, packet.data]);

  return callback(blob);
}

/**
 * Encodes a packet with binary data in a base64 string
 *
 * @param {Object} packet, has `type` and `data`
 * @return {String} base64 encoded message
 */

exports.encodeBase64Packet = function(packet, callback) {
  var message = 'b' + exports.packets[packet.type];
  if (Blob && packet.data instanceof global.Blob) {
    var fr = new FileReader();
    fr.onload = function() {
      var b64 = fr.result.split(',')[1];
      callback(message + b64);
    };
    return fr.readAsDataURL(packet.data);
  }

  var b64data;
  try {
    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
  } catch (e) {
    // iPhone Safari doesn't let you apply with typed arrays
    var typed = new Uint8Array(packet.data);
    var basic = new Array(typed.length);
    for (var i = 0; i < typed.length; i++) {
      basic[i] = typed[i];
    }
    b64data = String.fromCharCode.apply(null, basic);
  }
  message += global.btoa(b64data);
  return callback(message);
};

/**
 * Decodes a packet. Changes format to Blob if requested.
 *
 * @return {Object} with `type` and `data` (if any)
 * @api private
 */

exports.decodePacket = function (data, binaryType, utf8decode) {
  if (data === undefined) {
    return err;
  }
  // String data
  if (typeof data == 'string') {
    if (data.charAt(0) == 'b') {
      return exports.decodeBase64Packet(data.substr(1), binaryType);
    }

    if (utf8decode) {
      data = tryDecode(data);
      if (data === false) {
        return err;
      }
    }
    var type = data.charAt(0);

    if (Number(type) != type || !packetslist[type]) {
      return err;
    }

    if (data.length > 1) {
      return { type: packetslist[type], data: data.substring(1) };
    } else {
      return { type: packetslist[type] };
    }
  }

  var asArray = new Uint8Array(data);
  var type = asArray[0];
  var rest = sliceBuffer(data, 1);
  if (Blob && binaryType === 'blob') {
    rest = new Blob([rest]);
  }
  return { type: packetslist[type], data: rest };
};

function tryDecode(data) {
  try {
    data = utf8.decode(data);
  } catch (e) {
    return false;
  }
  return data;
}

/**
 * Decodes a packet encoded in a base64 string
 *
 * @param {String} base64 encoded message
 * @return {Object} with `type` and `data` (if any)
 */

exports.decodeBase64Packet = function(msg, binaryType) {
  var type = packetslist[msg.charAt(0)];
  if (!base64encoder) {
    return { type: type, data: { base64: true, data: msg.substr(1) } };
  }

  var data = base64encoder.decode(msg.substr(1));

  if (binaryType === 'blob' && Blob) {
    data = new Blob([data]);
  }

  return { type: type, data: data };
};

/**
 * Encodes multiple messages (payload).
 *
 *     <length>:data
 *
 * Example:
 *
 *     11:hello world2:hi
 *
 * If any contents are binary, they will be encoded as base64 strings. Base64
 * encoded strings are marked with a b before the length specifier
 *
 * @param {Array} packets
 * @api private
 */

exports.encodePayload = function (packets, supportsBinary, callback) {
  if (typeof supportsBinary == 'function') {
    callback = supportsBinary;
    supportsBinary = null;
  }

  var isBinary = hasBinary(packets);

  if (supportsBinary && isBinary) {
    if (Blob && !dontSendBlobs) {
      return exports.encodePayloadAsBlob(packets, callback);
    }

    return exports.encodePayloadAsArrayBuffer(packets, callback);
  }

  if (!packets.length) {
    return callback('0:');
  }

  function setLengthHeader(message) {
    return message.length + ':' + message;
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, !isBinary ? false : supportsBinary, true, function(message) {
      doneCallback(null, setLengthHeader(message));
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(results.join(''));
  });
};

/**
 * Async array map using after
 */

function map(ary, each, done) {
  var result = new Array(ary.length);
  var next = after(ary.length, done);

  var eachWithIndex = function(i, el, cb) {
    each(el, function(error, msg) {
      result[i] = msg;
      cb(error, result);
    });
  };

  for (var i = 0; i < ary.length; i++) {
    eachWithIndex(i, ary[i], next);
  }
}

/*
 * Decodes data when a payload is maybe expected. Possible binary contents are
 * decoded from their base64 representation
 *
 * @param {String} data, callback method
 * @api public
 */

exports.decodePayload = function (data, binaryType, callback) {
  if (typeof data != 'string') {
    return exports.decodePayloadAsBinary(data, binaryType, callback);
  }

  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var packet;
  if (data == '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

  var length = ''
    , n, msg;

  for (var i = 0, l = data.length; i < l; i++) {
    var chr = data.charAt(i);

    if (':' != chr) {
      length += chr;
    } else {
      if ('' == length || (length != (n = Number(length)))) {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

      msg = data.substr(i + 1, n);

      if (length != msg.length) {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

      if (msg.length) {
        packet = exports.decodePacket(msg, binaryType, true);

        if (err.type == packet.type && err.data == packet.data) {
          // parser error in individual packet - ignoring payload
          return callback(err, 0, 1);
        }

        var ret = callback(packet, i + n, l);
        if (false === ret) return;
      }

      // advance cursor
      i += n;
      length = '';
    }
  }

  if (length != '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

};

/**
 * Encodes multiple messages (payload) as binary.
 *
 * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
 * 255><data>
 *
 * Example:
 * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
 *
 * @param {Array} packets
 * @return {ArrayBuffer} encoded payload
 * @api private
 */

exports.encodePayloadAsArrayBuffer = function(packets, callback) {
  if (!packets.length) {
    return callback(new ArrayBuffer(0));
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(data) {
      return doneCallback(null, data);
    });
  }

  map(packets, encodeOne, function(err, encodedPackets) {
    var totalLength = encodedPackets.reduce(function(acc, p) {
      var len;
      if (typeof p === 'string'){
        len = p.length;
      } else {
        len = p.byteLength;
      }
      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
    }, 0);

    var resultArray = new Uint8Array(totalLength);

    var bufferIndex = 0;
    encodedPackets.forEach(function(p) {
      var isString = typeof p === 'string';
      var ab = p;
      if (isString) {
        var view = new Uint8Array(p.length);
        for (var i = 0; i < p.length; i++) {
          view[i] = p.charCodeAt(i);
        }
        ab = view.buffer;
      }

      if (isString) { // not true binary
        resultArray[bufferIndex++] = 0;
      } else { // true binary
        resultArray[bufferIndex++] = 1;
      }

      var lenStr = ab.byteLength.toString();
      for (var i = 0; i < lenStr.length; i++) {
        resultArray[bufferIndex++] = parseInt(lenStr[i]);
      }
      resultArray[bufferIndex++] = 255;

      var view = new Uint8Array(ab);
      for (var i = 0; i < view.length; i++) {
        resultArray[bufferIndex++] = view[i];
      }
    });

    return callback(resultArray.buffer);
  });
};

/**
 * Encode as Blob
 */

exports.encodePayloadAsBlob = function(packets, callback) {
  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(encoded) {
      var binaryIdentifier = new Uint8Array(1);
      binaryIdentifier[0] = 1;
      if (typeof encoded === 'string') {
        var view = new Uint8Array(encoded.length);
        for (var i = 0; i < encoded.length; i++) {
          view[i] = encoded.charCodeAt(i);
        }
        encoded = view.buffer;
        binaryIdentifier[0] = 0;
      }

      var len = (encoded instanceof ArrayBuffer)
        ? encoded.byteLength
        : encoded.size;

      var lenStr = len.toString();
      var lengthAry = new Uint8Array(lenStr.length + 1);
      for (var i = 0; i < lenStr.length; i++) {
        lengthAry[i] = parseInt(lenStr[i]);
      }
      lengthAry[lenStr.length] = 255;

      if (Blob) {
        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
        doneCallback(null, blob);
      }
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(new Blob(results));
  });
};

/*
 * Decodes data when a payload is maybe expected. Strings are decoded by
 * interpreting each byte as a key code for entries marked to start with 0. See
 * description of encodePayloadAsBinary
 *
 * @param {ArrayBuffer} data, callback method
 * @api public
 */

exports.decodePayloadAsBinary = function (data, binaryType, callback) {
  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var bufferTail = data;
  var buffers = [];

  var numberTooLong = false;
  while (bufferTail.byteLength > 0) {
    var tailArray = new Uint8Array(bufferTail);
    var isString = tailArray[0] === 0;
    var msgLength = '';

    for (var i = 1; ; i++) {
      if (tailArray[i] == 255) break;

      if (msgLength.length > 310) {
        numberTooLong = true;
        break;
      }

      msgLength += tailArray[i];
    }

    if(numberTooLong) return callback(err, 0, 1);

    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
    msgLength = parseInt(msgLength);

    var msg = sliceBuffer(bufferTail, 0, msgLength);
    if (isString) {
      try {
        msg = String.fromCharCode.apply(null, new Uint8Array(msg));
      } catch (e) {
        // iPhone Safari doesn't let you apply to typed arrays
        var typed = new Uint8Array(msg);
        msg = '';
        for (var i = 0; i < typed.length; i++) {
          msg += String.fromCharCode(typed[i]);
        }
      }
    }

    buffers.push(msg);
    bufferTail = sliceBuffer(bufferTail, msgLength);
  }

  var total = buffers.length;
  buffers.forEach(function(buffer, i) {
    callback(exports.decodePacket(buffer, binaryType, true), i, total);
  });
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./keys":33,"after":34,"arraybuffer.slice":35,"base64-arraybuffer":36,"blob":37,"has-binary":43,"wtf-8":38}],33:[function(require,module,exports){

/**
 * Gets the keys for an object.
 *
 * @return {Array} keys
 * @api private
 */

module.exports = Object.keys || function keys (obj){
  var arr = [];
  var has = Object.prototype.hasOwnProperty;

  for (var i in obj) {
    if (has.call(obj, i)) {
      arr.push(i);
    }
  }
  return arr;
};

},{}],34:[function(require,module,exports){
module.exports = after

function after(count, callback, err_cb) {
    var bail = false
    err_cb = err_cb || noop
    proxy.count = count

    return (count === 0) ? callback() : proxy

    function proxy(err, result) {
        if (proxy.count <= 0) {
            throw new Error('after called too many times')
        }
        --proxy.count

        // after first error, rest are passed to err_cb
        if (err) {
            bail = true
            callback(err)
            // future error callbacks will go to error handler
            callback = err_cb
        } else if (proxy.count === 0 && !bail) {
            callback(null, result)
        }
    }
}

function noop() {}

},{}],35:[function(require,module,exports){
/**
 * An abstraction for slicing an arraybuffer even when
 * ArrayBuffer.prototype.slice is not supported
 *
 * @api public
 */

module.exports = function(arraybuffer, start, end) {
  var bytes = arraybuffer.byteLength;
  start = start || 0;
  end = end || bytes;

  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }

  if (start < 0) { start += bytes; }
  if (end < 0) { end += bytes; }
  if (end > bytes) { end = bytes; }

  if (start >= bytes || start >= end || bytes === 0) {
    return new ArrayBuffer(0);
  }

  var abv = new Uint8Array(arraybuffer);
  var result = new Uint8Array(end - start);
  for (var i = start, ii = 0; i < end; i++, ii++) {
    result[ii] = abv[i];
  }
  return result.buffer;
};

},{}],36:[function(require,module,exports){
/*
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */
(function(){
  "use strict";

  var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

  // Use a lookup table to find the index.
  var lookup = new Uint8Array(256);
  for (var i = 0; i < chars.length; i++) {
    lookup[chars.charCodeAt(i)] = i;
  }

  exports.encode = function(arraybuffer) {
    var bytes = new Uint8Array(arraybuffer),
    i, len = bytes.length, base64 = "";

    for (i = 0; i < len; i+=3) {
      base64 += chars[bytes[i] >> 2];
      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
      base64 += chars[bytes[i + 2] & 63];
    }

    if ((len % 3) === 2) {
      base64 = base64.substring(0, base64.length - 1) + "=";
    } else if (len % 3 === 1) {
      base64 = base64.substring(0, base64.length - 2) + "==";
    }

    return base64;
  };

  exports.decode =  function(base64) {
    var bufferLength = base64.length * 0.75,
    len = base64.length, i, p = 0,
    encoded1, encoded2, encoded3, encoded4;

    if (base64[base64.length - 1] === "=") {
      bufferLength--;
      if (base64[base64.length - 2] === "=") {
        bufferLength--;
      }
    }

    var arraybuffer = new ArrayBuffer(bufferLength),
    bytes = new Uint8Array(arraybuffer);

    for (i = 0; i < len; i+=4) {
      encoded1 = lookup[base64.charCodeAt(i)];
      encoded2 = lookup[base64.charCodeAt(i+1)];
      encoded3 = lookup[base64.charCodeAt(i+2)];
      encoded4 = lookup[base64.charCodeAt(i+3)];

      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
    }

    return arraybuffer;
  };
})();

},{}],37:[function(require,module,exports){
(function (global){
/**
 * Create a blob builder even when vendor prefixes exist
 */

var BlobBuilder = global.BlobBuilder
  || global.WebKitBlobBuilder
  || global.MSBlobBuilder
  || global.MozBlobBuilder;

/**
 * Check if Blob constructor is supported
 */

var blobSupported = (function() {
  try {
    var a = new Blob(['hi']);
    return a.size === 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if Blob constructor supports ArrayBufferViews
 * Fails in Safari 6, so we need to map to ArrayBuffers there.
 */

var blobSupportsArrayBufferView = blobSupported && (function() {
  try {
    var b = new Blob([new Uint8Array([1,2])]);
    return b.size === 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if BlobBuilder is supported
 */

var blobBuilderSupported = BlobBuilder
  && BlobBuilder.prototype.append
  && BlobBuilder.prototype.getBlob;

/**
 * Helper function that maps ArrayBufferViews to ArrayBuffers
 * Used by BlobBuilder constructor and old browsers that didn't
 * support it in the Blob constructor.
 */

function mapArrayBufferViews(ary) {
  for (var i = 0; i < ary.length; i++) {
    var chunk = ary[i];
    if (chunk.buffer instanceof ArrayBuffer) {
      var buf = chunk.buffer;

      // if this is a subarray, make a copy so we only
      // include the subarray region from the underlying buffer
      if (chunk.byteLength !== buf.byteLength) {
        var copy = new Uint8Array(chunk.byteLength);
        copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));
        buf = copy.buffer;
      }

      ary[i] = buf;
    }
  }
}

function BlobBuilderConstructor(ary, options) {
  options = options || {};

  var bb = new BlobBuilder();
  mapArrayBufferViews(ary);

  for (var i = 0; i < ary.length; i++) {
    bb.append(ary[i]);
  }

  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
};

function BlobConstructor(ary, options) {
  mapArrayBufferViews(ary);
  return new Blob(ary, options || {});
};

module.exports = (function() {
  if (blobSupported) {
    return blobSupportsArrayBufferView ? global.Blob : BlobConstructor;
  } else if (blobBuilderSupported) {
    return BlobBuilderConstructor;
  } else {
    return undefined;
  }
})();

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],38:[function(require,module,exports){
(function (global){
/*! https://mths.be/wtf8 v1.0.0 by @mathias */
;(function(root) {

	// Detect free variables `exports`
	var freeExports = typeof exports == 'object' && exports;

	// Detect free variable `module`
	var freeModule = typeof module == 'object' && module &&
		module.exports == freeExports && module;

	// Detect free variable `global`, from Node.js or Browserified code,
	// and use it as `root`
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/*--------------------------------------------------------------------------*/

	var stringFromCharCode = String.fromCharCode;

	// Taken from https://mths.be/punycode
	function ucs2decode(string) {
		var output = [];
		var counter = 0;
		var length = string.length;
		var value;
		var extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	// Taken from https://mths.be/punycode
	function ucs2encode(array) {
		var length = array.length;
		var index = -1;
		var value;
		var output = '';
		while (++index < length) {
			value = array[index];
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
		}
		return output;
	}

	/*--------------------------------------------------------------------------*/

	function createByte(codePoint, shift) {
		return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
	}

	function encodeCodePoint(codePoint) {
		if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
			return stringFromCharCode(codePoint);
		}
		var symbol = '';
		if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
			symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
		}
		else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
			symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
			symbol += createByte(codePoint, 6);
		}
		else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
			symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
			symbol += createByte(codePoint, 12);
			symbol += createByte(codePoint, 6);
		}
		symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
		return symbol;
	}

	function wtf8encode(string) {
		var codePoints = ucs2decode(string);
		var length = codePoints.length;
		var index = -1;
		var codePoint;
		var byteString = '';
		while (++index < length) {
			codePoint = codePoints[index];
			byteString += encodeCodePoint(codePoint);
		}
		return byteString;
	}

	/*--------------------------------------------------------------------------*/

	function readContinuationByte() {
		if (byteIndex >= byteCount) {
			throw Error('Invalid byte index');
		}

		var continuationByte = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		if ((continuationByte & 0xC0) == 0x80) {
			return continuationByte & 0x3F;
		}

		// If we end up here, it’s not a continuation byte.
		throw Error('Invalid continuation byte');
	}

	function decodeSymbol() {
		var byte1;
		var byte2;
		var byte3;
		var byte4;
		var codePoint;

		if (byteIndex > byteCount) {
			throw Error('Invalid byte index');
		}

		if (byteIndex == byteCount) {
			return false;
		}

		// Read the first byte.
		byte1 = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		// 1-byte sequence (no continuation bytes)
		if ((byte1 & 0x80) == 0) {
			return byte1;
		}

		// 2-byte sequence
		if ((byte1 & 0xE0) == 0xC0) {
			var byte2 = readContinuationByte();
			codePoint = ((byte1 & 0x1F) << 6) | byte2;
			if (codePoint >= 0x80) {
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 3-byte sequence (may include unpaired surrogates)
		if ((byte1 & 0xF0) == 0xE0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
			if (codePoint >= 0x0800) {
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 4-byte sequence
		if ((byte1 & 0xF8) == 0xF0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			byte4 = readContinuationByte();
			codePoint = ((byte1 & 0x0F) << 0x12) | (byte2 << 0x0C) |
				(byte3 << 0x06) | byte4;
			if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
				return codePoint;
			}
		}

		throw Error('Invalid WTF-8 detected');
	}

	var byteArray;
	var byteCount;
	var byteIndex;
	function wtf8decode(byteString) {
		byteArray = ucs2decode(byteString);
		byteCount = byteArray.length;
		byteIndex = 0;
		var codePoints = [];
		var tmp;
		while ((tmp = decodeSymbol()) !== false) {
			codePoints.push(tmp);
		}
		return ucs2encode(codePoints);
	}

	/*--------------------------------------------------------------------------*/

	var wtf8 = {
		'version': '1.0.0',
		'encode': wtf8encode,
		'decode': wtf8decode
	};

	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define(function() {
			return wtf8;
		});
	}	else if (freeExports && !freeExports.nodeType) {
		if (freeModule) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = wtf8;
		} else { // in Narwhal or RingoJS v0.7.0-
			var object = {};
			var hasOwnProperty = object.hasOwnProperty;
			for (var key in wtf8) {
				hasOwnProperty.call(wtf8, key) && (freeExports[key] = wtf8[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.wtf8 = wtf8;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],39:[function(require,module,exports){

/**
 * Module exports.
 *
 * Logic borrowed from Modernizr:
 *
 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
 */

try {
  module.exports = typeof XMLHttpRequest !== 'undefined' &&
    'withCredentials' in new XMLHttpRequest();
} catch (err) {
  // if XMLHttp support is disabled in IE then it will throw
  // when trying to create
  module.exports = false;
}

},{}],40:[function(require,module,exports){
(function (global){
/**
 * JSON parse.
 *
 * @see Based on jQuery#parseJSON (MIT) and JSON2
 * @api private
 */

var rvalidchars = /^[\],:{}\s]*$/;
var rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
var rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
var rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g;
var rtrimLeft = /^\s+/;
var rtrimRight = /\s+$/;

module.exports = function parsejson(data) {
  if ('string' != typeof data || !data) {
    return null;
  }

  data = data.replace(rtrimLeft, '').replace(rtrimRight, '');

  // Attempt to parse using the native JSON parser first
  if (global.JSON && JSON.parse) {
    return JSON.parse(data);
  }

  if (rvalidchars.test(data.replace(rvalidescape, '@')
      .replace(rvalidtokens, ']')
      .replace(rvalidbraces, ''))) {
    return (new Function('return ' + data))();
  }
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],41:[function(require,module,exports){
/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */

exports.encode = function (obj) {
  var str = '';

  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length) str += '&';
      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
    }
  }

  return str;
};

/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */

exports.decode = function(qs){
  var qry = {};
  var pairs = qs.split('&');
  for (var i = 0, l = pairs.length; i < l; i++) {
    var pair = pairs[i].split('=');
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
};

},{}],42:[function(require,module,exports){
'use strict';

var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')
  , length = 64
  , map = {}
  , seed = 0
  , i = 0
  , prev;

/**
 * Return a string representing the specified number.
 *
 * @param {Number} num The number to convert.
 * @returns {String} The string representation of the number.
 * @api public
 */
function encode(num) {
  var encoded = '';

  do {
    encoded = alphabet[num % length] + encoded;
    num = Math.floor(num / length);
  } while (num > 0);

  return encoded;
}

/**
 * Return the integer value specified by the given string.
 *
 * @param {String} str The string to convert.
 * @returns {Number} The integer value represented by the string.
 * @api public
 */
function decode(str) {
  var decoded = 0;

  for (i = 0; i < str.length; i++) {
    decoded = decoded * length + map[str.charAt(i)];
  }

  return decoded;
}

/**
 * Yeast: A tiny growing id generator.
 *
 * @returns {String} A unique id.
 * @api public
 */
function yeast() {
  var now = encode(+new Date());

  if (now !== prev) return seed = 0, prev = now;
  return now +'.'+ encode(seed++);
}

//
// Map each character to its index.
//
for (; i < length; i++) map[alphabet[i]] = i;

//
// Expose the `yeast`, `encode` and `decode` functions.
//
yeast.encode = encode;
yeast.decode = decode;
module.exports = yeast;

},{}],43:[function(require,module,exports){
(function (global){

/*
 * Module requirements.
 */

var isArray = require('isarray');

/**
 * Module exports.
 */

module.exports = hasBinary;

/**
 * Checks for binary data.
 *
 * Right now only Buffer and ArrayBuffer are supported..
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary(data) {

  function _hasBinary(obj) {
    if (!obj) return false;

    if ( (global.Buffer && global.Buffer.isBuffer && global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||
         (global.Blob && obj instanceof Blob) ||
         (global.File && obj instanceof File)
        ) {
      return true;
    }

    if (isArray(obj)) {
      for (var i = 0; i < obj.length; i++) {
          if (_hasBinary(obj[i])) {
              return true;
          }
      }
    } else if (obj && 'object' == typeof obj) {
      // see: https://github.com/Automattic/has-binary/pull/4
      if (obj.toJSON && 'function' == typeof obj.toJSON) {
        obj = obj.toJSON();
      }

      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {
          return true;
        }
      }
    }

    return false;
  }

  return _hasBinary(data);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"isarray":44}],44:[function(require,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],45:[function(require,module,exports){

var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
},{}],46:[function(require,module,exports){
/**
 * Parses an URI
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */

var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

var parts = [
    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
];

module.exports = function parseuri(str) {
    var src = str,
        b = str.indexOf('['),
        e = str.indexOf(']');

    if (b != -1 && e != -1) {
        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
    }

    var m = re.exec(str || ''),
        uri = {},
        i = 14;

    while (i--) {
        uri[parts[i]] = m[i] || '';
    }

    if (b != -1 && e != -1) {
        uri.source = src;
        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
        uri.ipv6uri = true;
    }

    return uri;
};

},{}],47:[function(require,module,exports){
(function (global){
/*global Blob,File*/

/**
 * Module requirements
 */

var isArray = require('isarray');
var isBuf = require('./is-buffer');

/**
 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
 * Anything with blobs or files should be fed through removeBlobs before coming
 * here.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @api public
 */

exports.deconstructPacket = function(packet){
  var buffers = [];
  var packetData = packet.data;

  function _deconstructPacket(data) {
    if (!data) return data;

    if (isBuf(data)) {
      var placeholder = { _placeholder: true, num: buffers.length };
      buffers.push(data);
      return placeholder;
    } else if (isArray(data)) {
      var newData = new Array(data.length);
      for (var i = 0; i < data.length; i++) {
        newData[i] = _deconstructPacket(data[i]);
      }
      return newData;
    } else if ('object' == typeof data && !(data instanceof Date)) {
      var newData = {};
      for (var key in data) {
        newData[key] = _deconstructPacket(data[key]);
      }
      return newData;
    }
    return data;
  }

  var pack = packet;
  pack.data = _deconstructPacket(packetData);
  pack.attachments = buffers.length; // number of binary 'attachments'
  return {packet: pack, buffers: buffers};
};

/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @api public
 */

exports.reconstructPacket = function(packet, buffers) {
  var curPlaceHolder = 0;

  function _reconstructPacket(data) {
    if (data && data._placeholder) {
      var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)
      return buf;
    } else if (isArray(data)) {
      for (var i = 0; i < data.length; i++) {
        data[i] = _reconstructPacket(data[i]);
      }
      return data;
    } else if (data && 'object' == typeof data) {
      for (var key in data) {
        data[key] = _reconstructPacket(data[key]);
      }
      return data;
    }
    return data;
  }

  packet.data = _reconstructPacket(packet.data);
  packet.attachments = undefined; // no longer useful
  return packet;
};

/**
 * Asynchronously removes Blobs or Files from data via
 * FileReader's readAsArrayBuffer method. Used before encoding
 * data as msgpack. Calls callback with the blobless data.
 *
 * @param {Object} data
 * @param {Function} callback
 * @api private
 */

exports.removeBlobs = function(data, callback) {
  function _removeBlobs(obj, curKey, containingObject) {
    if (!obj) return obj;

    // convert any blob
    if ((global.Blob && obj instanceof Blob) ||
        (global.File && obj instanceof File)) {
      pendingBlobs++;

      // async filereader
      var fileReader = new FileReader();
      fileReader.onload = function() { // this.result == arraybuffer
        if (containingObject) {
          containingObject[curKey] = this.result;
        }
        else {
          bloblessData = this.result;
        }

        // if nothing pending its callback time
        if(! --pendingBlobs) {
          callback(bloblessData);
        }
      };

      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
    } else if (isArray(obj)) { // handle array
      for (var i = 0; i < obj.length; i++) {
        _removeBlobs(obj[i], i, obj);
      }
    } else if (obj && 'object' == typeof obj && !isBuf(obj)) { // and object
      for (var key in obj) {
        _removeBlobs(obj[key], key, obj);
      }
    }
  }

  var pendingBlobs = 0;
  var bloblessData = data;
  _removeBlobs(bloblessData);
  if (!pendingBlobs) {
    callback(bloblessData);
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./is-buffer":49,"isarray":54}],48:[function(require,module,exports){

/**
 * Module dependencies.
 */

var debug = require('debug')('socket.io-parser');
var json = require('json3');
var Emitter = require('component-emitter');
var binary = require('./binary');
var isBuf = require('./is-buffer');

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = 4;

/**
 * Packet types.
 *
 * @api public
 */

exports.types = [
  'CONNECT',
  'DISCONNECT',
  'EVENT',
  'ACK',
  'ERROR',
  'BINARY_EVENT',
  'BINARY_ACK'
];

/**
 * Packet type `connect`.
 *
 * @api public
 */

exports.CONNECT = 0;

/**
 * Packet type `disconnect`.
 *
 * @api public
 */

exports.DISCONNECT = 1;

/**
 * Packet type `event`.
 *
 * @api public
 */

exports.EVENT = 2;

/**
 * Packet type `ack`.
 *
 * @api public
 */

exports.ACK = 3;

/**
 * Packet type `error`.
 *
 * @api public
 */

exports.ERROR = 4;

/**
 * Packet type 'binary event'
 *
 * @api public
 */

exports.BINARY_EVENT = 5;

/**
 * Packet type `binary ack`. For acks with binary arguments.
 *
 * @api public
 */

exports.BINARY_ACK = 6;

/**
 * Encoder constructor.
 *
 * @api public
 */

exports.Encoder = Encoder;

/**
 * Decoder constructor.
 *
 * @api public
 */

exports.Decoder = Decoder;

/**
 * A socket.io Encoder instance
 *
 * @api public
 */

function Encoder() {}

/**
 * Encode a packet as a single string if non-binary, or as a
 * buffer sequence, depending on packet type.
 *
 * @param {Object} obj - packet object
 * @param {Function} callback - function to handle encodings (likely engine.write)
 * @return Calls callback with Array of encodings
 * @api public
 */

Encoder.prototype.encode = function(obj, callback){
  debug('encoding packet %j', obj);

  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
    encodeAsBinary(obj, callback);
  }
  else {
    var encoding = encodeAsString(obj);
    callback([encoding]);
  }
};

/**
 * Encode packet as string.
 *
 * @param {Object} packet
 * @return {String} encoded
 * @api private
 */

function encodeAsString(obj) {
  var str = '';
  var nsp = false;

  // first is type
  str += obj.type;

  // attachments if we have them
  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
    str += obj.attachments;
    str += '-';
  }

  // if we have a namespace other than `/`
  // we append it followed by a comma `,`
  if (obj.nsp && '/' != obj.nsp) {
    nsp = true;
    str += obj.nsp;
  }

  // immediately followed by the id
  if (null != obj.id) {
    if (nsp) {
      str += ',';
      nsp = false;
    }
    str += obj.id;
  }

  // json data
  if (null != obj.data) {
    if (nsp) str += ',';
    str += json.stringify(obj.data);
  }

  debug('encoded %j as %s', obj, str);
  return str;
}

/**
 * Encode packet as 'buffer sequence' by removing blobs, and
 * deconstructing packet into object with placeholders and
 * a list of buffers.
 *
 * @param {Object} packet
 * @return {Buffer} encoded
 * @api private
 */

function encodeAsBinary(obj, callback) {

  function writeEncoding(bloblessData) {
    var deconstruction = binary.deconstructPacket(bloblessData);
    var pack = encodeAsString(deconstruction.packet);
    var buffers = deconstruction.buffers;

    buffers.unshift(pack); // add packet info to beginning of data list
    callback(buffers); // write all the buffers
  }

  binary.removeBlobs(obj, writeEncoding);
}

/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 * @api public
 */

function Decoder() {
  this.reconstructor = null;
}

/**
 * Mix in `Emitter` with Decoder.
 */

Emitter(Decoder.prototype);

/**
 * Decodes an ecoded packet string into packet JSON.
 *
 * @param {String} obj - encoded packet
 * @return {Object} packet
 * @api public
 */

Decoder.prototype.add = function(obj) {
  var packet;
  if ('string' == typeof obj) {
    packet = decodeString(obj);
    if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) { // binary packet's json
      this.reconstructor = new BinaryReconstructor(packet);

      // no attachments, labeled binary but no binary data to follow
      if (this.reconstructor.reconPack.attachments === 0) {
        this.emit('decoded', packet);
      }
    } else { // non-binary full packet
      this.emit('decoded', packet);
    }
  }
  else if (isBuf(obj) || obj.base64) { // raw binary data
    if (!this.reconstructor) {
      throw new Error('got binary data when not reconstructing a packet');
    } else {
      packet = this.reconstructor.takeBinaryData(obj);
      if (packet) { // received final buffer
        this.reconstructor = null;
        this.emit('decoded', packet);
      }
    }
  }
  else {
    throw new Error('Unknown type: ' + obj);
  }
};

/**
 * Decode a packet String (JSON data)
 *
 * @param {String} str
 * @return {Object} packet
 * @api private
 */

function decodeString(str) {
  var p = {};
  var i = 0;

  // look up type
  p.type = Number(str.charAt(0));
  if (null == exports.types[p.type]) return error();

  // look up attachments if type binary
  if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {
    var buf = '';
    while (str.charAt(++i) != '-') {
      buf += str.charAt(i);
      if (i == str.length) break;
    }
    if (buf != Number(buf) || str.charAt(i) != '-') {
      throw new Error('Illegal attachments');
    }
    p.attachments = Number(buf);
  }

  // look up namespace (if any)
  if ('/' == str.charAt(i + 1)) {
    p.nsp = '';
    while (++i) {
      var c = str.charAt(i);
      if (',' == c) break;
      p.nsp += c;
      if (i == str.length) break;
    }
  } else {
    p.nsp = '/';
  }

  // look up id
  var next = str.charAt(i + 1);
  if ('' !== next && Number(next) == next) {
    p.id = '';
    while (++i) {
      var c = str.charAt(i);
      if (null == c || Number(c) != c) {
        --i;
        break;
      }
      p.id += str.charAt(i);
      if (i == str.length) break;
    }
    p.id = Number(p.id);
  }

  // look up json data
  if (str.charAt(++i)) {
    p = tryParse(p, str.substr(i));
  }

  debug('decoded %s as %j', str, p);
  return p;
}

function tryParse(p, str) {
  try {
    p.data = json.parse(str);
  } catch(e){
    return error();
  }
  return p; 
};

/**
 * Deallocates a parser's resources
 *
 * @api public
 */

Decoder.prototype.destroy = function() {
  if (this.reconstructor) {
    this.reconstructor.finishedReconstruction();
  }
};

/**
 * A manager of a binary event's 'buffer sequence'. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 * @api private
 */

function BinaryReconstructor(packet) {
  this.reconPack = packet;
  this.buffers = [];
}

/**
 * Method to be called when binary data received from connection
 * after a BINARY_EVENT packet.
 *
 * @param {Buffer | ArrayBuffer} binData - the raw binary data received
 * @return {null | Object} returns null if more binary data is expected or
 *   a reconstructed packet object if all buffers have been received.
 * @api private
 */

BinaryReconstructor.prototype.takeBinaryData = function(binData) {
  this.buffers.push(binData);
  if (this.buffers.length == this.reconPack.attachments) { // done with buffer list
    var packet = binary.reconstructPacket(this.reconPack, this.buffers);
    this.finishedReconstruction();
    return packet;
  }
  return null;
};

/**
 * Cleans up binary packet reconstruction variables.
 *
 * @api private
 */

BinaryReconstructor.prototype.finishedReconstruction = function() {
  this.reconPack = null;
  this.buffers = [];
};

function error(data){
  return {
    type: exports.ERROR,
    data: 'parser error'
  };
}

},{"./binary":47,"./is-buffer":49,"component-emitter":50,"debug":51,"json3":55}],49:[function(require,module,exports){
(function (global){

module.exports = isBuf;

/**
 * Returns true if obj is a buffer or an arraybuffer.
 *
 * @api private
 */

function isBuf(obj) {
  return (global.Buffer && global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer && obj instanceof ArrayBuffer);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],50:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

module.exports = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks[event] = this._callbacks[event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  var self = this;
  this._callbacks = this._callbacks || {};

  function on() {
    self.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks[event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks[event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks[event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks[event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],51:[function(require,module,exports){

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // is webkit? http://stackoverflow.com/a/16459606/376773
  return ('WebkitAppearance' in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (window.console && (console.firebug || (console.exception && console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  return JSON.stringify(v);
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs() {
  var args = arguments;
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return args;

  var c = 'color: ' + this.color;
  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
  return args;
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}
  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage(){
  try {
    return window.localStorage;
  } catch (e) {}
}

},{"./debug":52}],52:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */

exports.formatters = {};

/**
 * Previously assigned color.
 */

var prevColor = 0;

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function debug(namespace) {

  // define the `disabled` version
  function disabled() {
  }
  disabled.enabled = false;

  // define the `enabled` version
  function enabled() {

    var self = enabled;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // add the `color` if not set
    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color && self.useColors) self.color = selectColor();

    var args = Array.prototype.slice.call(arguments);

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %o
      args = ['%o'].concat(args);
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    if ('function' === typeof exports.formatArgs) {
      args = exports.formatArgs.apply(self, args);
    }
    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":53}],53:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options){
  options = options || {};
  if ('string' == typeof val) return parse(val);
  return options.long
    ? long(val)
    : short(val);
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = '' + str;
  if (str.length > 10000) return;
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
  if (!match) return;
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function short(ms) {
  if (ms >= d) return Math.round(ms / d) + 'd';
  if (ms >= h) return Math.round(ms / h) + 'h';
  if (ms >= m) return Math.round(ms / m) + 'm';
  if (ms >= s) return Math.round(ms / s) + 's';
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function long(ms) {
  return plural(ms, d, 'day')
    || plural(ms, h, 'hour')
    || plural(ms, m, 'minute')
    || plural(ms, s, 'second')
    || ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) return;
  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],54:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],55:[function(require,module,exports){
(function (global){
/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */
;(function () {
  // Detect the `define` function exposed by asynchronous module loaders. The
  // strict `define` check is necessary for compatibility with `r.js`.
  var isLoader = typeof define === "function" && define.amd;

  // A set of types used to distinguish objects from primitives.
  var objectTypes = {
    "function": true,
    "object": true
  };

  // Detect the `exports` object exposed by CommonJS implementations.
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  // Use the `global` object exposed by Node (including Browserify via
  // `insert-module-globals`), Narwhal, and Ringo as the default context,
  // and the `window` object in browsers. Rhino exports a `global` function
  // instead.
  var root = objectTypes[typeof window] && window || this,
      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == "object" && global;

  if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {
    root = freeGlobal;
  }

  // Public: Initializes JSON 3 using the given `context` object, attaching the
  // `stringify` and `parse` functions to the specified `exports` object.
  function runInContext(context, exports) {
    context || (context = root["Object"]());
    exports || (exports = root["Object"]());

    // Native constructor aliases.
    var Number = context["Number"] || root["Number"],
        String = context["String"] || root["String"],
        Object = context["Object"] || root["Object"],
        Date = context["Date"] || root["Date"],
        SyntaxError = context["SyntaxError"] || root["SyntaxError"],
        TypeError = context["TypeError"] || root["TypeError"],
        Math = context["Math"] || root["Math"],
        nativeJSON = context["JSON"] || root["JSON"];

    // Delegate to the native `stringify` and `parse` implementations.
    if (typeof nativeJSON == "object" && nativeJSON) {
      exports.stringify = nativeJSON.stringify;
      exports.parse = nativeJSON.parse;
    }

    // Convenience aliases.
    var objectProto = Object.prototype,
        getClass = objectProto.toString,
        isProperty, forEach, undef;

    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
    var isExtended = new Date(-3509827334573292);
    try {
      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
      // results for certain dates in Opera >= 10.53.
      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
        // Safari < 2.0.2 stores the internal millisecond time value correctly,
        // but clips the values returned by the date methods to the range of
        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
    } catch (exception) {}

    // Internal: Determines whether the native `JSON.stringify` and `parse`
    // implementations are spec-compliant. Based on work by Ken Snyder.
    function has(name) {
      if (has[name] !== undef) {
        // Return cached feature test result.
        return has[name];
      }
      var isSupported;
      if (name == "bug-string-char-index") {
        // IE <= 7 doesn't support accessing string characters using square
        // bracket notation. IE 8 only supports this for primitives.
        isSupported = "a"[0] != "a";
      } else if (name == "json") {
        // Indicates whether both `JSON.stringify` and `JSON.parse` are
        // supported.
        isSupported = has("json-stringify") && has("json-parse");
      } else {
        var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
        // Test `JSON.stringify`.
        if (name == "json-stringify") {
          var stringify = exports.stringify, stringifySupported = typeof stringify == "function" && isExtended;
          if (stringifySupported) {
            // A test function object with a custom `toJSON` method.
            (value = function () {
              return 1;
            }).toJSON = value;
            try {
              stringifySupported =
                // Firefox 3.1b1 and b2 serialize string, number, and boolean
                // primitives as object literals.
                stringify(0) === "0" &&
                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
                // literals.
                stringify(new Number()) === "0" &&
                stringify(new String()) == '""' &&
                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
                // does not define a canonical JSON representation (this applies to
                // objects with `toJSON` properties as well, *unless* they are nested
                // within an object or array).
                stringify(getClass) === undef &&
                // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
                // FF 3.1b3 pass this test.
                stringify(undef) === undef &&
                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
                // respectively, if the value is omitted entirely.
                stringify() === undef &&
                // FF 3.1b1, 2 throw an error if the given value is not a number,
                // string, array, object, Boolean, or `null` literal. This applies to
                // objects with custom `toJSON` methods as well, unless they are nested
                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
                // methods entirely.
                stringify(value) === "1" &&
                stringify([value]) == "[1]" &&
                // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
                // `"[null]"`.
                stringify([undef]) == "[null]" &&
                // YUI 3.0.0b1 fails to serialize `null` literals.
                stringify(null) == "null" &&
                // FF 3.1b1, 2 halts serialization if an array contains a function:
                // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
                // elides non-JSON values from objects and arrays, unless they
                // define custom `toJSON` methods.
                stringify([undef, getClass, null]) == "[null,null,null]" &&
                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
                // where character escape codes are expected (e.g., `\b` => `\u0008`).
                stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
                stringify(null, value) === "1" &&
                stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
                // serialize extended years.
                stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
                // The milliseconds are optional in ES 5, but required in 5.1.
                stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
                // four-digit years instead of six-digit years. Credits: @Yaffle.
                stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
                // values less than 1000. Credits: @Yaffle.
                stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
            } catch (exception) {
              stringifySupported = false;
            }
          }
          isSupported = stringifySupported;
        }
        // Test `JSON.parse`.
        if (name == "json-parse") {
          var parse = exports.parse;
          if (typeof parse == "function") {
            try {
              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
              // Conforming implementations should also coerce the initial argument to
              // a string prior to parsing.
              if (parse("0") === 0 && !parse(false)) {
                // Simple parsing test.
                value = parse(serialized);
                var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
                if (parseSupported) {
                  try {
                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                    parseSupported = !parse('"\t"');
                  } catch (exception) {}
                  if (parseSupported) {
                    try {
                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                      // certain octal literals.
                      parseSupported = parse("01") !== 1;
                    } catch (exception) {}
                  }
                  if (parseSupported) {
                    try {
                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                      // points. These environments, along with FF 3.1b1 and 2,
                      // also allow trailing commas in JSON objects and arrays.
                      parseSupported = parse("1.") !== 1;
                    } catch (exception) {}
                  }
                }
              }
            } catch (exception) {
              parseSupported = false;
            }
          }
          isSupported = parseSupported;
        }
      }
      return has[name] = !!isSupported;
    }

    if (!has("json")) {
      // Common `[[Class]]` name aliases.
      var functionClass = "[object Function]",
          dateClass = "[object Date]",
          numberClass = "[object Number]",
          stringClass = "[object String]",
          arrayClass = "[object Array]",
          booleanClass = "[object Boolean]";

      // Detect incomplete support for accessing string characters by index.
      var charIndexBuggy = has("bug-string-char-index");

      // Define additional utility methods if the `Date` methods are buggy.
      if (!isExtended) {
        var floor = Math.floor;
        // A mapping between the months of the year and the number of days between
        // January 1st and the first of the respective month.
        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
        // Internal: Calculates the number of days between the Unix epoch and the
        // first day of the given month.
        var getDay = function (year, month) {
          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
        };
      }

      // Internal: Determines if a property is a direct property of the given
      // object. Delegates to the native `Object#hasOwnProperty` method.
      if (!(isProperty = objectProto.hasOwnProperty)) {
        isProperty = function (property) {
          var members = {}, constructor;
          if ((members.__proto__ = null, members.__proto__ = {
            // The *proto* property cannot be set multiple times in recent
            // versions of Firefox and SeaMonkey.
            "toString": 1
          }, members).toString != getClass) {
            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
            // supports the mutable *proto* property.
            isProperty = function (property) {
              // Capture and break the object's prototype chain (see section 8.6.2
              // of the ES 5.1 spec). The parenthesized expression prevents an
              // unsafe transformation by the Closure Compiler.
              var original = this.__proto__, result = property in (this.__proto__ = null, this);
              // Restore the original prototype chain.
              this.__proto__ = original;
              return result;
            };
          } else {
            // Capture a reference to the top-level `Object` constructor.
            constructor = members.constructor;
            // Use the `constructor` property to simulate `Object#hasOwnProperty` in
            // other environments.
            isProperty = function (property) {
              var parent = (this.constructor || constructor).prototype;
              return property in this && !(property in parent && this[property] === parent[property]);
            };
          }
          members = null;
          return isProperty.call(this, property);
        };
      }

      // Internal: Normalizes the `for...in` iteration algorithm across
      // environments. Each enumerated key is yielded to a `callback` function.
      forEach = function (object, callback) {
        var size = 0, Properties, members, property;

        // Tests for bugs in the current environment's `for...in` algorithm. The
        // `valueOf` property inherits the non-enumerable flag from
        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
        (Properties = function () {
          this.valueOf = 0;
        }).prototype.valueOf = 0;

        // Iterate over a new instance of the `Properties` class.
        members = new Properties();
        for (property in members) {
          // Ignore all properties inherited from `Object.prototype`.
          if (isProperty.call(members, property)) {
            size++;
          }
        }
        Properties = members = null;

        // Normalize the iteration algorithm.
        if (!size) {
          // A list of non-enumerable properties inherited from `Object.prototype`.
          members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
          // properties.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, length;
            var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;
            for (property in object) {
              // Gecko <= 1.0 enumerates the `prototype` property of functions under
              // certain conditions; IE does not.
              if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
                callback(property);
              }
            }
            // Manually invoke the callback for each non-enumerable property.
            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
          };
        } else if (size == 2) {
          // Safari <= 2.0.4 enumerates shadowed properties twice.
          forEach = function (object, callback) {
            // Create a set of iterated properties.
            var members = {}, isFunction = getClass.call(object) == functionClass, property;
            for (property in object) {
              // Store each property name to prevent double enumeration. The
              // `prototype` property of functions is not enumerated due to cross-
              // environment inconsistencies.
              if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
                callback(property);
              }
            }
          };
        } else {
          // No bugs detected; use the standard `for...in` algorithm.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, isConstructor;
            for (property in object) {
              if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
                callback(property);
              }
            }
            // Manually invoke the callback for the `constructor` property due to
            // cross-environment inconsistencies.
            if (isConstructor || isProperty.call(object, (property = "constructor"))) {
              callback(property);
            }
          };
        }
        return forEach(object, callback);
      };

      // Public: Serializes a JavaScript `value` as a JSON string. The optional
      // `filter` argument may specify either a function that alters how object and
      // array members are serialized, or an array of strings and numbers that
      // indicates which properties should be serialized. The optional `width`
      // argument may be either a string or number that specifies the indentation
      // level of the output.
      if (!has("json-stringify")) {
        // Internal: A map of control characters and their escaped equivalents.
        var Escapes = {
          92: "\\\\",
          34: '\\"',
          8: "\\b",
          12: "\\f",
          10: "\\n",
          13: "\\r",
          9: "\\t"
        };

        // Internal: Converts `value` into a zero-padded string such that its
        // length is at least equal to `width`. The `width` must be <= 6.
        var leadingZeroes = "000000";
        var toPaddedString = function (width, value) {
          // The `|| 0` expression is necessary to work around a bug in
          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
          return (leadingZeroes + (value || 0)).slice(-width);
        };

        // Internal: Double-quotes a string `value`, replacing all ASCII control
        // characters (characters with code unit values between 0 and 31) with
        // their escaped equivalents. This is an implementation of the
        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
        var unicodePrefix = "\\u00";
        var quote = function (value) {
          var result = '"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;
          var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);
          for (; index < length; index++) {
            var charCode = value.charCodeAt(index);
            // If the character is a control character, append its Unicode or
            // shorthand escape sequence; otherwise, append the character as-is.
            switch (charCode) {
              case 8: case 9: case 10: case 12: case 13: case 34: case 92:
                result += Escapes[charCode];
                break;
              default:
                if (charCode < 32) {
                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                  break;
                }
                result += useCharIndex ? symbols[index] : value.charAt(index);
            }
          }
          return result + '"';
        };

        // Internal: Recursively serializes an object. Implements the
        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
          try {
            // Necessary for host object support.
            value = object[property];
          } catch (exception) {}
          if (typeof value == "object" && value) {
            className = getClass.call(value);
            if (className == dateClass && !isProperty.call(value, "toJSON")) {
              if (value > -1 / 0 && value < 1 / 0) {
                // Dates are serialized according to the `Date#toJSON` method
                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
                // for the ISO 8601 date time string format.
                if (getDay) {
                  // Manually compute the year, month, date, hours, minutes,
                  // seconds, and milliseconds if the `getUTC*` methods are
                  // buggy. Adapted from @Yaffle's `date-shim` project.
                  date = floor(value / 864e5);
                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
                  date = 1 + date - getDay(year, month);
                  // The `time` value specifies the time within the day (see ES
                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                  // to compute `A modulo B`, as the `%` operator does not
                  // correspond to the `modulo` operation for negative numbers.
                  time = (value % 864e5 + 864e5) % 864e5;
                  // The hours, minutes, seconds, and milliseconds are obtained by
                  // decomposing the time within the day. See section 15.9.1.10.
                  hours = floor(time / 36e5) % 24;
                  minutes = floor(time / 6e4) % 60;
                  seconds = floor(time / 1e3) % 60;
                  milliseconds = time % 1e3;
                } else {
                  year = value.getUTCFullYear();
                  month = value.getUTCMonth();
                  date = value.getUTCDate();
                  hours = value.getUTCHours();
                  minutes = value.getUTCMinutes();
                  seconds = value.getUTCSeconds();
                  milliseconds = value.getUTCMilliseconds();
                }
                // Serialize extended years correctly.
                value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
                  "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
                  // Months, dates, hours, minutes, and seconds should have two
                  // digits; milliseconds should have three.
                  "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
                  // Milliseconds are optional in ES 5.0, but required in 5.1.
                  "." + toPaddedString(3, milliseconds) + "Z";
              } else {
                value = null;
              }
            } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
              // ignores all `toJSON` methods on these objects unless they are
              // defined directly on an instance.
              value = value.toJSON(property);
            }
          }
          if (callback) {
            // If a replacement function was provided, call it to obtain the value
            // for serialization.
            value = callback.call(object, property, value);
          }
          if (value === null) {
            return "null";
          }
          className = getClass.call(value);
          if (className == booleanClass) {
            // Booleans are represented literally.
            return "" + value;
          } else if (className == numberClass) {
            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
            // `"null"`.
            return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
          } else if (className == stringClass) {
            // Strings are double-quoted and escaped.
            return quote("" + value);
          }
          // Recursively serialize objects and arrays.
          if (typeof value == "object") {
            // Check for cyclic structures. This is a linear search; performance
            // is inversely proportional to the number of unique nested objects.
            for (length = stack.length; length--;) {
              if (stack[length] === value) {
                // Cyclic structures cannot be serialized by `JSON.stringify`.
                throw TypeError();
              }
            }
            // Add the object to the stack of traversed objects.
            stack.push(value);
            results = [];
            // Save the current indentation level and indent one additional level.
            prefix = indentation;
            indentation += whitespace;
            if (className == arrayClass) {
              // Recursively serialize array elements.
              for (index = 0, length = value.length; index < length; index++) {
                element = serialize(index, value, callback, properties, whitespace, indentation, stack);
                results.push(element === undef ? "null" : element);
              }
              result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
            } else {
              // Recursively serialize object members. Members are selected from
              // either a user-specified list of property names, or the object
              // itself.
              forEach(properties || value, function (property) {
                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
                if (element !== undef) {
                  // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                  // is not the empty string, let `member` {quote(property) + ":"}
                  // be the concatenation of `member` and the `space` character."
                  // The "`space` character" refers to the literal space
                  // character, not the `space` {width} argument provided to
                  // `JSON.stringify`.
                  results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
                }
              });
              result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
            }
            // Remove the object from the traversed object stack.
            stack.pop();
            return result;
          }
        };

        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
        exports.stringify = function (source, filter, width) {
          var whitespace, callback, properties, className;
          if (objectTypes[typeof filter] && filter) {
            if ((className = getClass.call(filter)) == functionClass) {
              callback = filter;
            } else if (className == arrayClass) {
              // Convert the property names array into a makeshift set.
              properties = {};
              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
            }
          }
          if (width) {
            if ((className = getClass.call(width)) == numberClass) {
              // Convert the `width` to an integer and create a string containing
              // `width` number of space characters.
              if ((width -= width % 1) > 0) {
                for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
              }
            } else if (className == stringClass) {
              whitespace = width.length <= 10 ? width : width.slice(0, 10);
            }
          }
          // Opera <= 7.54u2 discards the values associated with empty string keys
          // (`""`) only if they are used directly within an object member list
          // (e.g., `!("" in { "": 1})`).
          return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
        };
      }

      // Public: Parses a JSON source string.
      if (!has("json-parse")) {
        var fromCharCode = String.fromCharCode;

        // Internal: A map of escaped control characters and their unescaped
        // equivalents.
        var Unescapes = {
          92: "\\",
          34: '"',
          47: "/",
          98: "\b",
          116: "\t",
          110: "\n",
          102: "\f",
          114: "\r"
        };

        // Internal: Stores the parser state.
        var Index, Source;

        // Internal: Resets the parser state and throws a `SyntaxError`.
        var abort = function () {
          Index = Source = null;
          throw SyntaxError();
        };

        // Internal: Returns the next token, or `"$"` if the parser has reached
        // the end of the source string. A token may be a string, number, `null`
        // literal, or Boolean literal.
        var lex = function () {
          var source = Source, length = source.length, value, begin, position, isSigned, charCode;
          while (Index < length) {
            charCode = source.charCodeAt(Index);
            switch (charCode) {
              case 9: case 10: case 13: case 32:
                // Skip whitespace tokens, including tabs, carriage returns, line
                // feeds, and space characters.
                Index++;
                break;
              case 123: case 125: case 91: case 93: case 58: case 44:
                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
                // the current position.
                value = charIndexBuggy ? source.charAt(Index) : source[Index];
                Index++;
                return value;
              case 34:
                // `"` delimits a JSON string; advance to the next character and
                // begin parsing the string. String tokens are prefixed with the
                // sentinel `@` character to distinguish them from punctuators and
                // end-of-string tokens.
                for (value = "@", Index++; Index < length;) {
                  charCode = source.charCodeAt(Index);
                  if (charCode < 32) {
                    // Unescaped ASCII control characters (those with a code unit
                    // less than the space character) are not permitted.
                    abort();
                  } else if (charCode == 92) {
                    // A reverse solidus (`\`) marks the beginning of an escaped
                    // control character (including `"`, `\`, and `/`) or Unicode
                    // escape sequence.
                    charCode = source.charCodeAt(++Index);
                    switch (charCode) {
                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
                        // Revive escaped control characters.
                        value += Unescapes[charCode];
                        Index++;
                        break;
                      case 117:
                        // `\u` marks the beginning of a Unicode escape sequence.
                        // Advance to the first character and validate the
                        // four-digit code point.
                        begin = ++Index;
                        for (position = Index + 4; Index < position; Index++) {
                          charCode = source.charCodeAt(Index);
                          // A valid sequence comprises four hexdigits (case-
                          // insensitive) that form a single hexadecimal value.
                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                            // Invalid Unicode escape sequence.
                            abort();
                          }
                        }
                        // Revive the escaped character.
                        value += fromCharCode("0x" + source.slice(begin, Index));
                        break;
                      default:
                        // Invalid escape sequence.
                        abort();
                    }
                  } else {
                    if (charCode == 34) {
                      // An unescaped double-quote character marks the end of the
                      // string.
                      break;
                    }
                    charCode = source.charCodeAt(Index);
                    begin = Index;
                    // Optimize for the common case where a string is valid.
                    while (charCode >= 32 && charCode != 92 && charCode != 34) {
                      charCode = source.charCodeAt(++Index);
                    }
                    // Append the string as-is.
                    value += source.slice(begin, Index);
                  }
                }
                if (source.charCodeAt(Index) == 34) {
                  // Advance to the next character and return the revived string.
                  Index++;
                  return value;
                }
                // Unterminated string.
                abort();
              default:
                // Parse numbers and literals.
                begin = Index;
                // Advance past the negative sign, if one is specified.
                if (charCode == 45) {
                  isSigned = true;
                  charCode = source.charCodeAt(++Index);
                }
                // Parse an integer or floating-point value.
                if (charCode >= 48 && charCode <= 57) {
                  // Leading zeroes are interpreted as octal literals.
                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
                    // Illegal octal literal.
                    abort();
                  }
                  isSigned = false;
                  // Parse the integer component.
                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
                  // Floats cannot contain a leading decimal point; however, this
                  // case is already accounted for by the parser.
                  if (source.charCodeAt(Index) == 46) {
                    position = ++Index;
                    // Parse the decimal component.
                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal trailing decimal.
                      abort();
                    }
                    Index = position;
                  }
                  // Parse exponents. The `e` denoting the exponent is
                  // case-insensitive.
                  charCode = source.charCodeAt(Index);
                  if (charCode == 101 || charCode == 69) {
                    charCode = source.charCodeAt(++Index);
                    // Skip past the sign following the exponent, if one is
                    // specified.
                    if (charCode == 43 || charCode == 45) {
                      Index++;
                    }
                    // Parse the exponential component.
                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal empty exponent.
                      abort();
                    }
                    Index = position;
                  }
                  // Coerce the parsed value to a JavaScript number.
                  return +source.slice(begin, Index);
                }
                // A negative sign may only precede numbers.
                if (isSigned) {
                  abort();
                }
                // `true`, `false`, and `null` literals.
                if (source.slice(Index, Index + 4) == "true") {
                  Index += 4;
                  return true;
                } else if (source.slice(Index, Index + 5) == "false") {
                  Index += 5;
                  return false;
                } else if (source.slice(Index, Index + 4) == "null") {
                  Index += 4;
                  return null;
                }
                // Unrecognized token.
                abort();
            }
          }
          // Return the sentinel `$` character if the parser has reached the end
          // of the source string.
          return "$";
        };

        // Internal: Parses a JSON `value` token.
        var get = function (value) {
          var results, hasMembers;
          if (value == "$") {
            // Unexpected end of input.
            abort();
          }
          if (typeof value == "string") {
            if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
              // Remove the sentinel `@` character.
              return value.slice(1);
            }
            // Parse object and array literals.
            if (value == "[") {
              // Parses a JSON array, returning a new JavaScript array.
              results = [];
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing square bracket marks the end of the array literal.
                if (value == "]") {
                  break;
                }
                // If the array literal contains elements, the current token
                // should be a comma separating the previous element from the
                // next.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "]") {
                      // Unexpected trailing `,` in array literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each array element.
                    abort();
                  }
                }
                // Elisions and leading commas are not permitted.
                if (value == ",") {
                  abort();
                }
                results.push(get(value));
              }
              return results;
            } else if (value == "{") {
              // Parses a JSON object, returning a new JavaScript object.
              results = {};
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing curly brace marks the end of the object literal.
                if (value == "}") {
                  break;
                }
                // If the object literal contains members, the current token
                // should be a comma separator.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "}") {
                      // Unexpected trailing `,` in object literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each object member.
                    abort();
                  }
                }
                // Leading commas are not permitted, object property names must be
                // double-quoted strings, and a `:` must separate each property
                // name and value.
                if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
                  abort();
                }
                results[value.slice(1)] = get(lex());
              }
              return results;
            }
            // Unexpected token encountered.
            abort();
          }
          return value;
        };

        // Internal: Updates a traversed object member.
        var update = function (source, property, callback) {
          var element = walk(source, property, callback);
          if (element === undef) {
            delete source[property];
          } else {
            source[property] = element;
          }
        };

        // Internal: Recursively traverses a parsed JSON object, invoking the
        // `callback` function for each value. This is an implementation of the
        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
        var walk = function (source, property, callback) {
          var value = source[property], length;
          if (typeof value == "object" && value) {
            // `forEach` can't be used to traverse an array in Opera <= 8.54
            // because its `Object#hasOwnProperty` implementation returns `false`
            // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
            if (getClass.call(value) == arrayClass) {
              for (length = value.length; length--;) {
                update(value, length, callback);
              }
            } else {
              forEach(value, function (property) {
                update(value, property, callback);
              });
            }
          }
          return callback.call(source, property, value);
        };

        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
        exports.parse = function (source, callback) {
          var result, value;
          Index = 0;
          Source = "" + source;
          result = get(lex());
          // If a JSON string contains multiple tokens, it is invalid.
          if (lex() != "$") {
            abort();
          }
          // Reset the parser state.
          Index = Source = null;
          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
        };
      }
    }

    exports["runInContext"] = runInContext;
    return exports;
  }

  if (freeExports && !isLoader) {
    // Export for CommonJS environments.
    runInContext(root, freeExports);
  } else {
    // Export for web browsers and JavaScript engines.
    var nativeJSON = root.JSON,
        previousJSON = root["JSON3"],
        isRestored = false;

    var JSON3 = runInContext(root, (root["JSON3"] = {
      // Public: Restores the original value of the global `JSON` object and
      // returns a reference to the `JSON3` object.
      "noConflict": function () {
        if (!isRestored) {
          isRestored = true;
          root.JSON = nativeJSON;
          root["JSON3"] = previousJSON;
          nativeJSON = previousJSON = null;
        }
        return JSON3;
      }
    }));

    root.JSON = {
      "parse": JSON3.parse,
      "stringify": JSON3.stringify
    };
  }

  // Export for asynchronous module loaders.
  if (isLoader) {
    define(function () {
      return JSON3;
    });
  }
}).call(this);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],56:[function(require,module,exports){
module.exports = toArray

function toArray(list, index) {
    var array = []

    index = index || 0

    for (var i = index || 0; i < list.length; i++) {
        array[i - index] = list[i]
    }

    return array
}

},{}],57:[function(require,module,exports){
"use strict";

// this is what is returned by new Rltm()
module.exports = function(setup) {

    // these are available realtime providers and their definitions
    const services = {
        ably: require('./services/ably'),
        pubnub: require('./services/pubnub'),
        socketio: require('./services/socketio')
    };

    // return error if service is not set
    let service = services[setup.service];

    if(!setup.service) {
        throw new Error('You must supply a service property.');
    }

    if(!service) {
        throw new Error('The service you supplied is invalid.');
    }

    // add config if doesn't exist
    setup.config = setup.config || {};

    // set a default uuid if it has not been set for this user
    setup.config.uuid = setup.config.uuid || new Date();

    // set this uuid if it is not set
    setup.config.state = setup.config.state || {};

    // immediately invoke and return the main function
    return new service(setup);

};

},{"./services/ably":58,"./services/pubnub":59,"./services/socketio":60}],58:[function(require,module,exports){
"use strict";

// include the NodeJS event emitter
const EventEmitter = require('events');

// include the Ably javascript sdk
const Ably = require('ably');

// represents a connection to a single channel
class Room extends EventEmitter {
    constructor(ably, channel, state) {
        // call the EventEmitter constructor
        super();

        // determine the user's state
        state = state || {};

        // assign the channel parameter as a property
        this.channelName = channel;
        this.channel = ably.channels.get(channel);

        // save Ably in the instance of room
        this.ably = ably;

        this.isReady = false;

        // use the Ably library to listen for messages
        this.channel.once('attached', () => {
            // tell the user that first connection made
            this.onReady();
        });

        this.channel.subscribe((message) => {
            // emit the message as an event
            this.emit('message', message.id, message.data);
        });

        this.channel.presence.subscribe((presenceEvent) => {
            if((presenceEvent.action === 'enter') || (presenceEvent.action === 'sync')) {
                this.emit('join',
                    presenceEvent.clientId, presenceEvent.data);
            }

            // someone leaves channel
            if(presenceEvent.action === 'leave') {
                this.emit('leave', presenceEvent.clientId);
            }

            // timeout event is not supported in Ably
            // this.emit('disconnect', presenceEvent.uuid);

            // someone's state is updated
            if(presenceEvent.action === 'update') {
                this.emit('state',
                    presenceEvent.clientId, presenceEvent.data);
            }
        });

        // explicitly attach to the channel, although it will implicilty be attached by calling subscribe above
        this.channel.attach();

        // enter the channel room automatically and be present
        this.channel.presence.enter();
    }

    onReady() {
        // waiting to be assigned by user
        return;
    }

    ready(fn) {
        this.onReady = fn;
    }

    message(data) {
        return new Promise((resolve, reject) => {
            // publish the given data over the Ably channel
            this.channel.publish(null, data);
        }, (err) => {
            if(err) {
                // if there's a problem publishing, reject
                reject(err);
            } else {
                resolve();
            }
        });
    }

    here() {
        return new Promise((resolve, reject) => {
            // ask Ably for information about members presence on this channel
            this.channel.presence.get((err, members) => {
                if(err) {
                    // if there's a problem with the get request, reject
                    reject(err)
                } else {
                    // build a userlist in rltm.js format
                    let userList = {};

                    // format the userList for rltm.js standard
                    for(let i in members) {
                        userList[members[i].clientId] = members[i].data;
                    }

                    // respond with formatted list
                    resolve(userList);
                }
            });
        });
    }

    state(state) {
        return new Promise((resolve, reject) => {
            // Update presence state
            this.channel.presence.update(state, (err) => {
                if(err) {
                    // if there's a problem with the update request, reject
                    reject(err);
                } else {
                    resolve();
                }
            });
        });
    }

    history() {
        return new Promise((resolve, reject) => {
            // retrieved the message history
            this.channel.history({ count: 100 }, (err, page) => {
                if(err) {
                    // if there's a problem with the history request, reject
                    reject(err);
                } else {
                    // create our return array
                    let data = [];

                    // loop through response and push data to array
                    for(let i in page.items) {
                        data.push({
                            uuid: page.items[i].clientId,
                            data: page.items[i].data
                        });
                    }

                    // respond with the history data
                    resolve(data);
                }
            });
        });
    }

    leave() {
        return new Promise((resolve, reject) => {
            // tell Ably to complete leave and detach from this channel
            this.channel.detach((err) => {
                if(err) {
                    // if there's a problem detaching, reject
                    reject(err);
                } else {
                    resolve();
                }
            });
        });
    }
}

// export a generic function expected by rltm.js
module.exports = function(setup) {
    // convenience method to assign the service string name to itself
    this.service = setup.service;

    // initialize Ably with supplied config information
    let ably = new Ably.Realtime(setup.config);

    // clientId may be assigned from the token issued to the client so
    // only assign once the client has connected
    ably.connection.once('connected', () => {
        setup.config.uuid = ably.auth.clientId;
    });

    this.ably = ably;

    // expose the join method to create new room connections
    this.join = (channel, state) => {
        return new Room(this.ably, channel, state);
    }

    // return the instance of this service
    return this;

};

},{"ably":1,"events":7}],59:[function(require,module,exports){
"use strict";

// include the NodeJS event emitter
const EventEmitter = require('events');

// include the PubNub javascript sdk v4
const PubNub = require('pubnub');
let globalReady = false;

// represents a connection to a single channel
class Room extends EventEmitter {

    constructor(pubnub, channel, uuid, state) {

        // call the EventEmitter constructor
        super();

        // determine the user's state 
        state = state || {};

        // store this users uuid
        this.uuid = uuid;

        // assign the channel parameter as a property
        this.channel = channel;

        // save pubnub in the instance of room
        this.pubnub = pubnub;

        this.isReady = false;
        
        // use the PubNub library to listen for messages
        this.pubnub.addListener({

            status: (statusEvent) => {

                // detect if this is a connection event on this channel
                if (statusEvent.category === "PNConnectedCategory" 
                    && !this.isReady
                    && statusEvent.affectedChannels.indexOf(channel) > -1) {

                    globalReady = true;

                    // tell the user that first connection made
                    this.onReady();

                }
            }
        });

        this.pubnub.addListener({
            message: (m) => {

                // if message is sent to this specific channel
                if(channel == m.channel) {

                    // emit the message as an event
                    this.emit('message', m.message.uuid, m.message.data);   

                }
            },
            presence: (presenceEvent) => {

                // make sure channel matches this channel
                if(channel == presenceEvent.channel) {

                    // someone joins channel
                    if(presenceEvent.action == "join") {

                        this.emit('join', 
                            presenceEvent.uuid, presenceEvent.state);
                    }

                    // someone leaves channel
                    if(presenceEvent.action == "leave") {
                        this.emit('leave', presenceEvent.uuid);
                    }

                    // someone timesout
                    if(presenceEvent.action == "timeout") {
                        this.emit('disconnect', presenceEvent.uuid);
                    }
                    
                    // someone's state is updated
                    if(presenceEvent.action == "state-change") {
                        this.emit('state', 
                            presenceEvent.uuid, presenceEvent.state);
                    }
                       
                }

            }
        });

        // tell PubNub to subscribe to the supplied channel
        this.pubnub.subscribe({ 
            channels: [channel],
            withPresence: true,
            state: state
        });

    }

    // ready is a callback and not an event because pubnub may be ready
    // immediately, which doesn't allow time to register an event handler
    // this can be solved with setTimeout(() => {}, 10) to let the 
    onReady() {

        // waiting to be assigned by user
        return;

    }

    ready (fn) {
        
        this.onReady = fn;

        if(globalReady) {
            this.onReady()
            this.isReady = true;
        }

    }

    message (data) {

        return new Promise((resolve, reject) => {
          
          // publish the given data over PubNub channel
          this.pubnub.publish({
              channel: this.channel,
              message: {
                  uuid: this.uuid,
                  data: data
              }
          }, (status, response) => {

            if(status.error) {
                // if there's a problem publishing, reject
                reject(status);
            } else {
                resolve();
            }

          });

        });

    };

    here() {

        return new Promise((resolve, reject) => {
        
            // ask PubNub for information about connected users in this channel
            this.pubnub.hereNow({
                channels: [this.channel],
                includeUUIDs: true,
                includeState: true
            }, (status, response) => {

                if(status.error) {
                    // if there's a problem with the request, reject
                    reject(status)
                } else {

                    // build a userlist in rltm.js format
                    let userList = {};

                    // get the list of occupants in this channel
                    let occupants = response.channels[this.channel].occupants;

                    // format the userList for rltm.js standard
                    for(let i in occupants) {
                        userList[occupants[i].uuid] = occupants[i].state;
                    }

                    // respond with formatted list
                    resolve(userList);

                }

            });

        });

    }

    state(state) {

        return new Promise((resolve, reject) => {
            
            // use PubNub state function to update state for channel
            this.pubnub.setState({
                state: state,
                uuid: this.uuid,
                channels: [this.channel]
            }, (status, response) => {
                
                if(status.error) {
                    // if there's a problem with the request log it
                    reject(status);            
                } else {
                    resolve();
                }

            });

        });

    }

    history() {
        
        return new Promise((resolve, reject) => {

            // retrieved the message history with PubNub
            this.pubnub.history({
                channel: this.channel,
                count: 100 // how many items to fetch
            }, (status, response) => {

                if(status.error) {
                    // if there's a problem with the request log it
                    reject(status);            
                } else {
                    
                    // create our return array
                    let data = [];

                    // loop through response and push data to array
                    for(let i in response.messages) {
                        data.push(response.messages[i].entry)
                    }   

                    // reverse the array so newest are first
                    data = data.reverse();

                    // respond with the history data
                    resolve(data);

                }

            });

        });

    }

    leave() {

        return new Promise((resolve, reject) => {
            
            // tell PubNub to manually unsubscribe from this channel        
            this.pubnub.unsubscribe({
                channels: [this.channel],
            });

            resolve();

        });

    }
}

// export a generic function expected by rltm.js
module.exports = function(setup) {

    // convenience method to assign the service string name to itself
    this.service = setup.service;

    // initialize PubNub with supplied config information
    this.pubnub = new PubNub(setup.config);

    // expose the join method to create new room connections
    this.join = (channel, state) => {
        return new Room(this.pubnub, channel, setup.config.uuid, state);
    }

    // return the instance of this service
    return this;

};

},{"events":7,"pubnub":9}],60:[function(require,module,exports){
"use strict";

// include NodeJS event emitter
const EventEmitter = require('events');

// include the Socket.io user library
const io = require('socket.io-client');

// represents a connection to a single channel
class Room extends EventEmitter {

    constructor(endpoint, channel, uuid, state) {

        // call the EventEmitter constructor
        super();

        // store this users uuid
        this.uuid = uuid;

        // assign the channel parameter as a property
        this.channel = channel;

        this.isReady = false;

        // create a connection to the socketio endpoint
        this.socket = io.connect(endpoint, {multiplex: true});

        // subscribe to the socket.io connection event
        this.socket.on('connect', () => {

            // tell the server that we want to join a channel
            this.socket.emit('channel', channel, this.uuid, state);

            // tell the user the server is ready
            this.onReady();
            this.isReady = true;

        });

        // server says someone has joined
        this.socket.on('join', (channel, uuid, state) => {

            // make sure the channel is this channel
            if(this.channel == channel) {

                // emit the 'join' event to the user
                this.emit('join', uuid, state);

            }

        });

        // server says someone has left
        this.socket.on('leave', (channel, uuid) => {

            // make sure it's on this channel
            if(this.channel == channel) {

                // emit the 'leave' event to the user
                this.emit('leave', uuid);
            }

        });


        // server says someone has disconnected
        this.socket.on('disconnect', (channel, uuid) => {

            // make sure it's on this channel
            if(this.channel == channel) {

                // emit the 'leave' event to the user
                this.emit('disconnect', uuid);
            }

        });

        // a message is sent from the srever
        this.socket.on('message', (channel, uuid, data) => {

            // make sure it is on this channel
            if(this.channel == channel) {

                // tell the user of the new message
                this.emit('message', uuid, data);
            }

        });

        // a user sets their state
        this.socket.on('state', (channel, uuid, state) => {

            // make sure it is on this channel
            if(this.channel == channel) {

                // tell the user of the set state
                this.emit('state', uuid, state);
            }

        });

    }
    ready(fn) {
        
        this.onReady = fn;
        
        if(this.isReady) {
            this.onReady();
        }

    }
    onReady() {
        // waiting to be assigned by user
        return;
    }
    message(data) {

        return new Promise((resolve, reject) => {

            // publish the data to the socket.io server
            this.socket.emit('publish', this.channel, this.uuid, data, () =>{
                resolve();
            });

        });

    }
    here() {
        
        // ask socket.io-server for a list of online users
        return new Promise((resolve, reject) => {
            
            this.socket.emit('whosonline', this.channel, null, function(users) {

                // callback with an object of users
                resolve(users);

            });

        });

    }
    state(state) {
        
        return new Promise((resolve, reject) => {

            // tell socket.io-server to update this user's state
            this.socket.emit('setState', this.channel, this.uuid, state, () => {
                resolve();
            });

        });

    }
    history() {
        
        return new Promise((resolve, reject) => {
                        
            // ask socket.io-server for the history of messages published
            this.socket.emit('history', this.channel, (data) => {

                // callback with an array of messages
                resolve(data);

            });

        });

    }
    leave(channel) {
        
        return new Promise((resolve, reject) => {

            // manually disconnect from socket.io-server
            this.socket.emit('leave', this.uuid, channel, () => {

                resolve();

            });

        });

    }
    
}

module.exports = function (setup) {

    // convenience method to assign the service string name to itself
    this.service = setup.service;

    this.join = (channel, state) => {
        return new Room(setup.config.endpoint, channel, setup.config.uuid, setup.config.state);
    };

    return this;

};

},{"events":7,"socket.io-client":10}]},{},[57])(57)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYWJseS9icm93c2VyL3N0YXRpYy9hYmx5LWNvbW1vbmpzLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9lbXB0eS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9wdWJudWIvZGlzdC93ZWIvcHVibnViLm1pbi5qcyIsIm5vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L2xpYi9tYW5hZ2VyLmpzIiwibm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbGliL29uLmpzIiwibm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbGliL3NvY2tldC5qcyIsIm5vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L2xpYi91cmwuanMiLCJub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvYmFja28yL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbm9kZV9tb2R1bGVzL2NvbXBvbmVudC1iaW5kL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbm9kZV9tb2R1bGVzL2NvbXBvbmVudC1lbWl0dGVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbm9kZV9tb2R1bGVzL2RlYnVnL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZGVidWcvZGVidWcuanMiLCJub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZGVidWcvbm9kZV9tb2R1bGVzL21zL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvc29ja2V0LmpzIiwibm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydC5qcyIsIm5vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvcG9sbGluZy1qc29ucC5qcyIsIm5vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3BvbGxpbmcteGhyLmpzIiwibm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvcG9sbGluZy5qcyIsIm5vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3dlYnNvY2tldC5qcyIsIm5vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi94bWxodHRwcmVxdWVzdC5qcyIsIm5vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9jb21wb25lbnQtaW5oZXJpdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tcGFyc2VyL2xpYi9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1wYXJzZXIvbGliL2tleXMuanMiLCJub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9ub2RlX21vZHVsZXMvYWZ0ZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9ub2RlX21vZHVsZXMvYXJyYXlidWZmZXIuc2xpY2UvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9ub2RlX21vZHVsZXMvYmFzZTY0LWFycmF5YnVmZmVyL2xpYi9iYXNlNjQtYXJyYXlidWZmZXIuanMiLCJub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9ub2RlX21vZHVsZXMvYmxvYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tcGFyc2VyL25vZGVfbW9kdWxlcy93dGYtOC93dGYtOC5qcyIsIm5vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9oYXMtY29ycy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9wYXJzZWpzb24vaW5kZXguanMiLCJub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9ub2RlX21vZHVsZXMvcGFyc2Vxcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L25vZGVfbW9kdWxlcy95ZWFzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9oYXMtYmluYXJ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbm9kZV9tb2R1bGVzL2hhcy1iaW5hcnkvbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvaW5kZXhvZi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9wYXJzZXVyaS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL2JpbmFyeS5qcyIsIm5vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbm9kZV9tb2R1bGVzL3NvY2tldC5pby1wYXJzZXIvaXMtYnVmZmVyLmpzIiwibm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbm9kZV9tb2R1bGVzL3NvY2tldC5pby1wYXJzZXIvbm9kZV9tb2R1bGVzL2NvbXBvbmVudC1lbWl0dGVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbm9kZV9tb2R1bGVzL3NvY2tldC5pby1wYXJzZXIvbm9kZV9tb2R1bGVzL2RlYnVnL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9ub2RlX21vZHVsZXMvZGVidWcvZGVidWcuanMiLCJub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9ub2RlX21vZHVsZXMvZGVidWcvbm9kZV9tb2R1bGVzL21zL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbm9kZV9tb2R1bGVzL3NvY2tldC5pby1wYXJzZXIvbm9kZV9tb2R1bGVzL2pzb24zL2xpYi9qc29uMy5qcyIsIm5vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L25vZGVfbW9kdWxlcy90by1hcnJheS9pbmRleC5qcyIsInNyYy9pbmRleC5qcyIsInNyYy9zZXJ2aWNlcy9hYmx5LmpzIiwic3JjL3NlcnZpY2VzL3B1Ym51Yi5qcyIsInNyYy9zZXJ2aWNlcy9zb2NrZXRpby5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDemlXQTs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzd2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTEE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ25hQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ25LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2pMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbHVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM3SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN2T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3hhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM3UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqbUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNEQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDN0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcFpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDck1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM3SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdDRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8qKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IDIwMTcsIEFibHlcbiAqXG4gKiBBYmx5IEphdmFTY3JpcHQgTGlicmFyeSB2MS4wLjNcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9hYmx5L2FibHktanNcbiAqXG4gKiBBYmx5IFJlYWx0aW1lIE1lc3NhZ2luZ1xuICogaHR0cHM6Ly93d3cuYWJseS5pb1xuICpcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5jZSB2Mi4wXG4gKi9cblxudmFyIEFibHkgPSB7fTtcblxuLyoqXG4gKiBDcnlwdG9KUyBjb3JlIGNvbXBvbmVudHMuXG4gKi9cbnZhciBDcnlwdG9KUyA9IENyeXB0b0pTIHx8IChmdW5jdGlvbiAoTWF0aCwgdW5kZWZpbmVkKSB7XG4gICAgLyoqXG4gICAgICogQ3J5cHRvSlMgbmFtZXNwYWNlLlxuICAgICAqL1xuICAgIHZhciBDID0ge307XG5cbiAgICAvKipcbiAgICAgKiBMaWJyYXJ5IG5hbWVzcGFjZS5cbiAgICAgKi9cbiAgICB2YXIgQ19saWIgPSBDLmxpYiA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQmFzZSBvYmplY3QgZm9yIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UuXG4gICAgICovXG4gICAgdmFyIEJhc2UgPSBDX2xpYi5CYXNlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRigpIHt9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIHRoaXMgb2JqZWN0LlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdmVycmlkZXMgUHJvcGVydGllcyB0byBjb3B5IGludG8gdGhlIG5ldyBvYmplY3QuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgbmV3IG9iamVjdC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgICAgdmFyIE15VHlwZSA9IENyeXB0b0pTLmxpYi5CYXNlLmV4dGVuZCh7XG4gICAgICAgICAgICAgKiAgICAgICAgIGZpZWxkOiAndmFsdWUnLFxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICAgICAgICAgbWV0aG9kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgKiAgICAgICAgIH1cbiAgICAgICAgICAgICAqICAgICB9KTtcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZXh0ZW5kOiBmdW5jdGlvbiAob3ZlcnJpZGVzKSB7XG4gICAgICAgICAgICAgICAgLy8gU3Bhd25cbiAgICAgICAgICAgICAgICBGLnByb3RvdHlwZSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdmFyIHN1YnR5cGUgPSBuZXcgRigpO1xuXG4gICAgICAgICAgICAgICAgLy8gQXVnbWVudFxuICAgICAgICAgICAgICAgIGlmIChvdmVycmlkZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VidHlwZS5taXhJbihvdmVycmlkZXMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBkZWZhdWx0IGluaXRpYWxpemVyXG4gICAgICAgICAgICAgICAgaWYgKCFzdWJ0eXBlLmhhc093blByb3BlcnR5KCdpbml0JykpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VidHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VidHlwZS4kc3VwZXIuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEluaXRpYWxpemVyJ3MgcHJvdG90eXBlIGlzIHRoZSBzdWJ0eXBlIG9iamVjdFxuICAgICAgICAgICAgICAgIHN1YnR5cGUuaW5pdC5wcm90b3R5cGUgPSBzdWJ0eXBlO1xuXG4gICAgICAgICAgICAgICAgLy8gUmVmZXJlbmNlIHN1cGVydHlwZVxuICAgICAgICAgICAgICAgIHN1YnR5cGUuJHN1cGVyID0gdGhpcztcblxuICAgICAgICAgICAgICAgIHJldHVybiBzdWJ0eXBlO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBFeHRlbmRzIHRoaXMgb2JqZWN0IGFuZCBydW5zIHRoZSBpbml0IG1ldGhvZC5cbiAgICAgICAgICAgICAqIEFyZ3VtZW50cyB0byBjcmVhdGUoKSB3aWxsIGJlIHBhc3NlZCB0byBpbml0KCkuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgbmV3IG9iamVjdC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgICAgdmFyIGluc3RhbmNlID0gTXlUeXBlLmNyZWF0ZSgpO1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSB0aGlzLmV4dGVuZCgpO1xuICAgICAgICAgICAgICAgIGluc3RhbmNlLmluaXQuYXBwbHkoaW5zdGFuY2UsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBvYmplY3QuXG4gICAgICAgICAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBhZGQgc29tZSBsb2dpYyB3aGVuIHlvdXIgb2JqZWN0cyBhcmUgY3JlYXRlZC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICAgICB2YXIgTXlUeXBlID0gQ3J5cHRvSlMubGliLkJhc2UuZXh0ZW5kKHtcbiAgICAgICAgICAgICAqICAgICAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICogICAgICAgICAgICAgLy8gLi4uXG4gICAgICAgICAgICAgKiAgICAgICAgIH1cbiAgICAgICAgICAgICAqICAgICB9KTtcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDb3BpZXMgcHJvcGVydGllcyBpbnRvIHRoaXMgb2JqZWN0LlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIFRoZSBwcm9wZXJ0aWVzIHRvIG1peCBpbi5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICAgICBNeVR5cGUubWl4SW4oe1xuICAgICAgICAgICAgICogICAgICAgICBmaWVsZDogJ3ZhbHVlJ1xuICAgICAgICAgICAgICogICAgIH0pO1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBtaXhJbjogZnVuY3Rpb24gKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eU5hbWUgaW4gcHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW3Byb3BlcnR5TmFtZV0gPSBwcm9wZXJ0aWVzW3Byb3BlcnR5TmFtZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBJRSB3b24ndCBjb3B5IHRvU3RyaW5nIHVzaW5nIHRoZSBsb29wIGFib3ZlXG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoJ3RvU3RyaW5nJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b1N0cmluZyA9IHByb3BlcnRpZXMudG9TdHJpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDcmVhdGVzIGEgY29weSBvZiB0aGlzIG9iamVjdC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjbG9uZS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICAgICB2YXIgY2xvbmUgPSBpbnN0YW5jZS5jbG9uZSgpO1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmluaXQucHJvdG90eXBlLmV4dGVuZCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2YgMzItYml0IHdvcmRzLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gd29yZHMgVGhlIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gc2lnQnl0ZXMgVGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBieXRlcyBpbiB0aGlzIHdvcmQgYXJyYXkuXG4gICAgICovXG4gICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheSA9IEJhc2UuZXh0ZW5kKHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCB3b3JkIGFycmF5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSB3b3JkcyAoT3B0aW9uYWwpIEFuIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHNpZ0J5dGVzIChPcHRpb25hbCkgVGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBieXRlcyBpbiB0aGUgd29yZHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUoKTtcbiAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZShbMHgwMDAxMDIwMywgMHgwNDA1MDYwN10pO1xuICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKFsweDAwMDEwMjAzLCAweDA0MDUwNjA3XSwgNik7XG4gICAgICAgICAqL1xuICAgICAgICBpbml0OiBmdW5jdGlvbiAod29yZHMsIHNpZ0J5dGVzKSB7XG4gICAgICAgICAgICB3b3JkcyA9IHRoaXMud29yZHMgPSB3b3JkcyB8fCBbXTtcblxuICAgICAgICAgICAgaWYgKHNpZ0J5dGVzICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2lnQnl0ZXMgPSBzaWdCeXRlcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaWdCeXRlcyA9IHdvcmRzLmxlbmd0aCAqIDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIHRoaXMgd29yZCBhcnJheSB0byBhIHN0cmluZy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyIChPcHRpb25hbCkgVGhlIGVuY29kaW5nIHN0cmF0ZWd5IHRvIHVzZS4gRGVmYXVsdDogQ3J5cHRvSlMuZW5jLkhleFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBzdHJpbmdpZmllZCB3b3JkIGFycmF5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHN0cmluZyA9IHdvcmRBcnJheSArICcnO1xuICAgICAgICAgKiAgICAgdmFyIHN0cmluZyA9IHdvcmRBcnJheS50b1N0cmluZygpO1xuICAgICAgICAgKiAgICAgdmFyIHN0cmluZyA9IHdvcmRBcnJheS50b1N0cmluZyhDcnlwdG9KUy5lbmMuVXRmOCk7XG4gICAgICAgICAqL1xuICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKGVuY29kZXIpIHtcbiAgICAgICAgICAgIHJldHVybiAoZW5jb2RlciB8fCBIZXgpLnN0cmluZ2lmeSh0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uY2F0ZW5hdGVzIGEgd29yZCBhcnJheSB0byB0aGlzIHdvcmQgYXJyYXkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkgdG8gYXBwZW5kLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoaXMgd29yZCBhcnJheS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHdvcmRBcnJheTEuY29uY2F0KHdvcmRBcnJheTIpO1xuICAgICAgICAgKi9cbiAgICAgICAgY29uY2F0OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XG4gICAgICAgICAgICAvLyBTaG9ydGN1dHNcbiAgICAgICAgICAgIHZhciB0aGlzV29yZHMgPSB0aGlzLndvcmRzO1xuICAgICAgICAgICAgdmFyIHRoYXRXb3JkcyA9IHdvcmRBcnJheS53b3JkcztcbiAgICAgICAgICAgIHZhciB0aGlzU2lnQnl0ZXMgPSB0aGlzLnNpZ0J5dGVzO1xuICAgICAgICAgICAgdmFyIHRoYXRTaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcblxuICAgICAgICAgICAgLy8gQ2xhbXAgZXhjZXNzIGJpdHNcbiAgICAgICAgICAgIHRoaXMuY2xhbXAoKTtcblxuICAgICAgICAgICAgLy8gQ29uY2F0XG4gICAgICAgICAgICBpZiAodGhpc1NpZ0J5dGVzICUgNCkge1xuICAgICAgICAgICAgICAgIC8vIENvcHkgb25lIGJ5dGUgYXQgYSB0aW1lXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGF0U2lnQnl0ZXM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGhhdEJ5dGUgPSAodGhhdFdvcmRzW2kgPj4+IDJdID4+PiAoMjQgLSAoaSAlIDQpICogOCkpICYgMHhmZjtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1dvcmRzWyh0aGlzU2lnQnl0ZXMgKyBpKSA+Pj4gMl0gfD0gdGhhdEJ5dGUgPDwgKDI0IC0gKCh0aGlzU2lnQnl0ZXMgKyBpKSAlIDQpICogOCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGF0V29yZHMubGVuZ3RoID4gMHhmZmZmKSB7XG4gICAgICAgICAgICAgICAgLy8gQ29weSBvbmUgd29yZCBhdCBhIHRpbWVcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoYXRTaWdCeXRlczsgaSArPSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNXb3Jkc1sodGhpc1NpZ0J5dGVzICsgaSkgPj4+IDJdID0gdGhhdFdvcmRzW2kgPj4+IDJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQ29weSBhbGwgd29yZHMgYXQgb25jZVxuICAgICAgICAgICAgICAgIHRoaXNXb3Jkcy5wdXNoLmFwcGx5KHRoaXNXb3JkcywgdGhhdFdvcmRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2lnQnl0ZXMgKz0gdGhhdFNpZ0J5dGVzO1xuXG4gICAgICAgICAgICAvLyBDaGFpbmFibGVcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIGluc2lnbmlmaWNhbnQgYml0cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHdvcmRBcnJheS5jbGFtcCgpO1xuICAgICAgICAgKi9cbiAgICAgICAgY2xhbXA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuICAgICAgICAgICAgdmFyIHdvcmRzID0gdGhpcy53b3JkcztcbiAgICAgICAgICAgIHZhciBzaWdCeXRlcyA9IHRoaXMuc2lnQnl0ZXM7XG5cbiAgICAgICAgICAgIC8vIENsYW1wXG4gICAgICAgICAgICB3b3Jkc1tzaWdCeXRlcyA+Pj4gMl0gJj0gMHhmZmZmZmZmZiA8PCAoMzIgLSAoc2lnQnl0ZXMgJSA0KSAqIDgpO1xuICAgICAgICAgICAgd29yZHMubGVuZ3RoID0gTWF0aC5jZWlsKHNpZ0J5dGVzIC8gNCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgd29yZCBhcnJheS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgY2xvbmUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgY2xvbmUgPSB3b3JkQXJyYXkuY2xvbmUoKTtcbiAgICAgICAgICovXG4gICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2xvbmUgPSBCYXNlLmNsb25lLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBjbG9uZS53b3JkcyA9IHRoaXMud29yZHMuc2xpY2UoMCk7XG5cbiAgICAgICAgICAgIHJldHVybiBjbG9uZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHdvcmQgYXJyYXkgZmlsbGVkIHdpdGggcmFuZG9tIGJ5dGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbkJ5dGVzIFRoZSBudW1iZXIgb2YgcmFuZG9tIGJ5dGVzIHRvIGdlbmVyYXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSByYW5kb20gd29yZCBhcnJheS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkucmFuZG9tKDE2KTtcbiAgICAgICAgICovXG4gICAgICAgIHJhbmRvbTogZnVuY3Rpb24gKG5CeXRlcykge1xuICAgICAgICAgICAgdmFyIHdvcmRzID0gW107XG5cbiAgICAgICAgICAgIHZhciByID0gKGZ1bmN0aW9uIChtX3cpIHtcbiAgICAgICAgICAgICAgICB2YXIgbV93ID0gbV93O1xuICAgICAgICAgICAgICAgIHZhciBtX3ogPSAweDNhZGU2OGIxO1xuICAgICAgICAgICAgICAgIHZhciBtYXNrID0gMHhmZmZmZmZmZjtcblxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIG1feiA9ICgweDkwNjkgKiAobV96ICYgMHhGRkZGKSArIChtX3ogPj4gMHgxMCkpICYgbWFzaztcbiAgICAgICAgICAgICAgICAgICAgbV93ID0gKDB4NDY1MCAqIChtX3cgJiAweEZGRkYpICsgKG1fdyA+PiAweDEwKSkgJiBtYXNrO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gKChtX3ogPDwgMHgxMCkgKyBtX3cpICYgbWFzaztcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0IC89IDB4MTAwMDAwMDAwO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gMC41O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICogKE1hdGgucmFuZG9tKCkgPiAuNSA/IDEgOiAtMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCByY2FjaGU7IGkgPCBuQnl0ZXM7IGkgKz0gNCkge1xuICAgICAgICAgICAgICAgIHZhciBfciA9IHIoKHJjYWNoZSB8fCBNYXRoLnJhbmRvbSgpKSAqIDB4MTAwMDAwMDAwKTtcblxuICAgICAgICAgICAgICAgIHJjYWNoZSA9IF9yKCkgKiAweDNhZGU2N2I3O1xuICAgICAgICAgICAgICAgIHdvcmRzLnB1c2goKF9yKCkgKiAweDEwMDAwMDAwMCkgfCAwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBXb3JkQXJyYXkuaW5pdCh3b3JkcywgbkJ5dGVzKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogRW5jb2RlciBuYW1lc3BhY2UuXG4gICAgICovXG4gICAgdmFyIENfZW5jID0gQy5lbmMgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEhleCBlbmNvZGluZyBzdHJhdGVneS5cbiAgICAgKi9cbiAgICB2YXIgSGV4ID0gQ19lbmMuSGV4ID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgaGV4IHN0cmluZy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgaGV4IHN0cmluZy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIGhleFN0cmluZyA9IENyeXB0b0pTLmVuYy5IZXguc3RyaW5naWZ5KHdvcmRBcnJheSk7XG4gICAgICAgICAqL1xuICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcbiAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuICAgICAgICAgICAgdmFyIHdvcmRzID0gd29yZEFycmF5LndvcmRzO1xuICAgICAgICAgICAgdmFyIHNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xuXG4gICAgICAgICAgICAvLyBDb252ZXJ0XG4gICAgICAgICAgICB2YXIgaGV4Q2hhcnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnQnl0ZXM7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBiaXRlID0gKHdvcmRzW2kgPj4+IDJdID4+PiAoMjQgLSAoaSAlIDQpICogOCkpICYgMHhmZjtcbiAgICAgICAgICAgICAgICBoZXhDaGFycy5wdXNoKChiaXRlID4+PiA0KS50b1N0cmluZygxNikpO1xuICAgICAgICAgICAgICAgIGhleENoYXJzLnB1c2goKGJpdGUgJiAweDBmKS50b1N0cmluZygxNikpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaGV4Q2hhcnMuam9pbignJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIGEgaGV4IHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBoZXhTdHIgVGhlIGhleCBzdHJpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuSGV4LnBhcnNlKGhleFN0cmluZyk7XG4gICAgICAgICAqL1xuICAgICAgICBwYXJzZTogZnVuY3Rpb24gKGhleFN0cikge1xuICAgICAgICAgICAgLy8gU2hvcnRjdXRcbiAgICAgICAgICAgIHZhciBoZXhTdHJMZW5ndGggPSBoZXhTdHIubGVuZ3RoO1xuXG4gICAgICAgICAgICAvLyBDb252ZXJ0XG4gICAgICAgICAgICB2YXIgd29yZHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGV4U3RyTGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICB3b3Jkc1tpID4+PiAzXSB8PSBwYXJzZUludChoZXhTdHIuc3Vic3RyKGksIDIpLCAxNikgPDwgKDI0IC0gKGkgJSA4KSAqIDQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3IFdvcmRBcnJheS5pbml0KHdvcmRzLCBoZXhTdHJMZW5ndGggLyAyKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBMYXRpbjEgZW5jb2Rpbmcgc3RyYXRlZ3kuXG4gICAgICovXG4gICAgdmFyIExhdGluMSA9IENfZW5jLkxhdGluMSA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIExhdGluMSBzdHJpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIExhdGluMSBzdHJpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciBsYXRpbjFTdHJpbmcgPSBDcnlwdG9KUy5lbmMuTGF0aW4xLnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuICAgICAgICAgKi9cbiAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XG4gICAgICAgICAgICAvLyBTaG9ydGN1dHNcbiAgICAgICAgICAgIHZhciB3b3JkcyA9IHdvcmRBcnJheS53b3JkcztcbiAgICAgICAgICAgIHZhciBzaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcblxuICAgICAgICAgICAgLy8gQ29udmVydFxuICAgICAgICAgICAgdmFyIGxhdGluMUNoYXJzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZ0J5dGVzOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYml0ZSA9ICh3b3Jkc1tpID4+PiAyXSA+Pj4gKDI0IC0gKGkgJSA0KSAqIDgpKSAmIDB4ZmY7XG4gICAgICAgICAgICAgICAgbGF0aW4xQ2hhcnMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGJpdGUpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGxhdGluMUNoYXJzLmpvaW4oJycpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyBhIExhdGluMSBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGF0aW4xU3RyIFRoZSBMYXRpbjEgc3RyaW5nLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLkxhdGluMS5wYXJzZShsYXRpbjFTdHJpbmcpO1xuICAgICAgICAgKi9cbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChsYXRpbjFTdHIpIHtcbiAgICAgICAgICAgIC8vIFNob3J0Y3V0XG4gICAgICAgICAgICB2YXIgbGF0aW4xU3RyTGVuZ3RoID0gbGF0aW4xU3RyLmxlbmd0aDtcblxuICAgICAgICAgICAgLy8gQ29udmVydFxuICAgICAgICAgICAgdmFyIHdvcmRzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhdGluMVN0ckxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgd29yZHNbaSA+Pj4gMl0gfD0gKGxhdGluMVN0ci5jaGFyQ29kZUF0KGkpICYgMHhmZikgPDwgKDI0IC0gKGkgJSA0KSAqIDgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3IFdvcmRBcnJheS5pbml0KHdvcmRzLCBsYXRpbjFTdHJMZW5ndGgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVURi04IGVuY29kaW5nIHN0cmF0ZWd5LlxuICAgICAqL1xuICAgIHZhciBVdGY4ID0gQ19lbmMuVXRmOCA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIFVURi04IHN0cmluZy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgVVRGLTggc3RyaW5nLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgdXRmOFN0cmluZyA9IENyeXB0b0pTLmVuYy5VdGY4LnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuICAgICAgICAgKi9cbiAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKExhdGluMS5zdHJpbmdpZnkod29yZEFycmF5KSkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWFsZm9ybWVkIFVURi04IGRhdGEnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgYSBVVEYtOCBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXRmOFN0ciBUaGUgVVRGLTggc3RyaW5nLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLlV0ZjgucGFyc2UodXRmOFN0cmluZyk7XG4gICAgICAgICAqL1xuICAgICAgICBwYXJzZTogZnVuY3Rpb24gKHV0ZjhTdHIpIHtcbiAgICAgICAgICAgIHJldHVybiBMYXRpbjEucGFyc2UodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHV0ZjhTdHIpKSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWJzdHJhY3QgYnVmZmVyZWQgYmxvY2sgYWxnb3JpdGhtIHRlbXBsYXRlLlxuICAgICAqXG4gICAgICogVGhlIHByb3BlcnR5IGJsb2NrU2l6ZSBtdXN0IGJlIGltcGxlbWVudGVkIGluIGEgY29uY3JldGUgc3VidHlwZS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfbWluQnVmZmVyU2l6ZSBUaGUgbnVtYmVyIG9mIGJsb2NrcyB0aGF0IHNob3VsZCBiZSBrZXB0IHVucHJvY2Vzc2VkIGluIHRoZSBidWZmZXIuIERlZmF1bHQ6IDBcbiAgICAgKi9cbiAgICB2YXIgQnVmZmVyZWRCbG9ja0FsZ29yaXRobSA9IENfbGliLkJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0gPSBCYXNlLmV4dGVuZCh7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXNldHMgdGhpcyBibG9jayBhbGdvcml0aG0ncyBkYXRhIGJ1ZmZlciB0byBpdHMgaW5pdGlhbCBzdGF0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0ucmVzZXQoKTtcbiAgICAgICAgICovXG4gICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBJbml0aWFsIHZhbHVlc1xuICAgICAgICAgICAgdGhpcy5fZGF0YSA9IG5ldyBXb3JkQXJyYXkuaW5pdCgpO1xuICAgICAgICAgICAgdGhpcy5fbkRhdGFCeXRlcyA9IDA7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgbmV3IGRhdGEgdG8gdGhpcyBibG9jayBhbGdvcml0aG0ncyBidWZmZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gZGF0YSBUaGUgZGF0YSB0byBhcHBlbmQuIFN0cmluZ3MgYXJlIGNvbnZlcnRlZCB0byBhIFdvcmRBcnJheSB1c2luZyBVVEYtOC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uX2FwcGVuZCgnZGF0YScpO1xuICAgICAgICAgKiAgICAgYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5fYXBwZW5kKHdvcmRBcnJheSk7XG4gICAgICAgICAqL1xuICAgICAgICBfYXBwZW5kOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgLy8gQ29udmVydCBzdHJpbmcgdG8gV29yZEFycmF5LCBlbHNlIGFzc3VtZSBXb3JkQXJyYXkgYWxyZWFkeVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IFV0ZjgucGFyc2UoZGF0YSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFwcGVuZFxuICAgICAgICAgICAgdGhpcy5fZGF0YS5jb25jYXQoZGF0YSk7XG4gICAgICAgICAgICB0aGlzLl9uRGF0YUJ5dGVzICs9IGRhdGEuc2lnQnl0ZXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2Nlc3NlcyBhdmFpbGFibGUgZGF0YSBibG9ja3MuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIGludm9rZXMgX2RvUHJvY2Vzc0Jsb2NrKG9mZnNldCksIHdoaWNoIG11c3QgYmUgaW1wbGVtZW50ZWQgYnkgYSBjb25jcmV0ZSBzdWJ0eXBlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRvRmx1c2ggV2hldGhlciBhbGwgYmxvY2tzIGFuZCBwYXJ0aWFsIGJsb2NrcyBzaG91bGQgYmUgcHJvY2Vzc2VkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBwcm9jZXNzZWQgZGF0YS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciBwcm9jZXNzZWREYXRhID0gYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5fcHJvY2VzcygpO1xuICAgICAgICAgKiAgICAgdmFyIHByb2Nlc3NlZERhdGEgPSBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLl9wcm9jZXNzKCEhJ2ZsdXNoJyk7XG4gICAgICAgICAqL1xuICAgICAgICBfcHJvY2VzczogZnVuY3Rpb24gKGRvRmx1c2gpIHtcbiAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuICAgICAgICAgICAgdmFyIGRhdGFXb3JkcyA9IGRhdGEud29yZHM7XG4gICAgICAgICAgICB2YXIgZGF0YVNpZ0J5dGVzID0gZGF0YS5zaWdCeXRlcztcbiAgICAgICAgICAgIHZhciBibG9ja1NpemUgPSB0aGlzLmJsb2NrU2l6ZTtcbiAgICAgICAgICAgIHZhciBibG9ja1NpemVCeXRlcyA9IGJsb2NrU2l6ZSAqIDQ7XG5cbiAgICAgICAgICAgIC8vIENvdW50IGJsb2NrcyByZWFkeVxuICAgICAgICAgICAgdmFyIG5CbG9ja3NSZWFkeSA9IGRhdGFTaWdCeXRlcyAvIGJsb2NrU2l6ZUJ5dGVzO1xuICAgICAgICAgICAgaWYgKGRvRmx1c2gpIHtcbiAgICAgICAgICAgICAgICAvLyBSb3VuZCB1cCB0byBpbmNsdWRlIHBhcnRpYWwgYmxvY2tzXG4gICAgICAgICAgICAgICAgbkJsb2Nrc1JlYWR5ID0gTWF0aC5jZWlsKG5CbG9ja3NSZWFkeSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFJvdW5kIGRvd24gdG8gaW5jbHVkZSBvbmx5IGZ1bGwgYmxvY2tzLFxuICAgICAgICAgICAgICAgIC8vIGxlc3MgdGhlIG51bWJlciBvZiBibG9ja3MgdGhhdCBtdXN0IHJlbWFpbiBpbiB0aGUgYnVmZmVyXG4gICAgICAgICAgICAgICAgbkJsb2Nrc1JlYWR5ID0gTWF0aC5tYXgoKG5CbG9ja3NSZWFkeSB8IDApIC0gdGhpcy5fbWluQnVmZmVyU2l6ZSwgMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENvdW50IHdvcmRzIHJlYWR5XG4gICAgICAgICAgICB2YXIgbldvcmRzUmVhZHkgPSBuQmxvY2tzUmVhZHkgKiBibG9ja1NpemU7XG5cbiAgICAgICAgICAgIC8vIENvdW50IGJ5dGVzIHJlYWR5XG4gICAgICAgICAgICB2YXIgbkJ5dGVzUmVhZHkgPSBNYXRoLm1pbihuV29yZHNSZWFkeSAqIDQsIGRhdGFTaWdCeXRlcyk7XG5cbiAgICAgICAgICAgIC8vIFByb2Nlc3MgYmxvY2tzXG4gICAgICAgICAgICBpZiAobldvcmRzUmVhZHkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBvZmZzZXQgPSAwOyBvZmZzZXQgPCBuV29yZHNSZWFkeTsgb2Zmc2V0ICs9IGJsb2NrU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWFsZ29yaXRobSBsb2dpY1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kb1Byb2Nlc3NCbG9jayhkYXRhV29yZHMsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHByb2Nlc3NlZCB3b3Jkc1xuICAgICAgICAgICAgICAgIHZhciBwcm9jZXNzZWRXb3JkcyA9IGRhdGFXb3Jkcy5zcGxpY2UoMCwgbldvcmRzUmVhZHkpO1xuICAgICAgICAgICAgICAgIGRhdGEuc2lnQnl0ZXMgLT0gbkJ5dGVzUmVhZHk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJldHVybiBwcm9jZXNzZWQgd29yZHNcbiAgICAgICAgICAgIHJldHVybiBuZXcgV29yZEFycmF5LmluaXQocHJvY2Vzc2VkV29yZHMsIG5CeXRlc1JlYWR5KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNsb25lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIGNsb25lID0gYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5jbG9uZSgpO1xuICAgICAgICAgKi9cbiAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjbG9uZSA9IEJhc2UuY2xvbmUuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIGNsb25lLl9kYXRhID0gdGhpcy5fZGF0YS5jbG9uZSgpO1xuXG4gICAgICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX21pbkJ1ZmZlclNpemU6IDBcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEFic3RyYWN0IGhhc2hlciB0ZW1wbGF0ZS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBibG9ja1NpemUgVGhlIG51bWJlciBvZiAzMi1iaXQgd29yZHMgdGhpcyBoYXNoZXIgb3BlcmF0ZXMgb24uIERlZmF1bHQ6IDE2ICg1MTIgYml0cylcbiAgICAgKi9cbiAgICB2YXIgSGFzaGVyID0gQ19saWIuSGFzaGVyID0gQnVmZmVyZWRCbG9ja0FsZ29yaXRobS5leHRlbmQoe1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuICAgICAgICAgKi9cbiAgICAgICAgY2ZnOiBCYXNlLmV4dGVuZCgpLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgaGFzaGVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgaGFzaCBjb21wdXRhdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciBoYXNoZXIgPSBDcnlwdG9KUy5hbGdvLlNIQTI1Ni5jcmVhdGUoKTtcbiAgICAgICAgICovXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uIChjZmcpIHtcbiAgICAgICAgICAgIC8vIEFwcGx5IGNvbmZpZyBkZWZhdWx0c1xuICAgICAgICAgICAgdGhpcy5jZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcblxuICAgICAgICAgICAgLy8gU2V0IGluaXRpYWwgdmFsdWVzXG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc2V0cyB0aGlzIGhhc2hlciB0byBpdHMgaW5pdGlhbCBzdGF0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIGhhc2hlci5yZXNldCgpO1xuICAgICAgICAgKi9cbiAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIFJlc2V0IGRhdGEgYnVmZmVyXG4gICAgICAgICAgICBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtLnJlc2V0LmNhbGwodGhpcyk7XG5cbiAgICAgICAgICAgIC8vIFBlcmZvcm0gY29uY3JldGUtaGFzaGVyIGxvZ2ljXG4gICAgICAgICAgICB0aGlzLl9kb1Jlc2V0KCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZXMgdGhpcyBoYXNoZXIgd2l0aCBhIG1lc3NhZ2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZVVwZGF0ZSBUaGUgbWVzc2FnZSB0byBhcHBlbmQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0hhc2hlcn0gVGhpcyBoYXNoZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICBoYXNoZXIudXBkYXRlKCdtZXNzYWdlJyk7XG4gICAgICAgICAqICAgICBoYXNoZXIudXBkYXRlKHdvcmRBcnJheSk7XG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uIChtZXNzYWdlVXBkYXRlKSB7XG4gICAgICAgICAgICAvLyBBcHBlbmRcbiAgICAgICAgICAgIHRoaXMuX2FwcGVuZChtZXNzYWdlVXBkYXRlKTtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBoYXNoXG4gICAgICAgICAgICB0aGlzLl9wcm9jZXNzKCk7XG5cbiAgICAgICAgICAgIC8vIENoYWluYWJsZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpbmFsaXplcyB0aGUgaGFzaCBjb21wdXRhdGlvbi5cbiAgICAgICAgICogTm90ZSB0aGF0IHRoZSBmaW5hbGl6ZSBvcGVyYXRpb24gaXMgZWZmZWN0aXZlbHkgYSBkZXN0cnVjdGl2ZSwgcmVhZC1vbmNlIG9wZXJhdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlVXBkYXRlIChPcHRpb25hbCkgQSBmaW5hbCBtZXNzYWdlIHVwZGF0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgaGFzaC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciBoYXNoID0gaGFzaGVyLmZpbmFsaXplKCk7XG4gICAgICAgICAqICAgICB2YXIgaGFzaCA9IGhhc2hlci5maW5hbGl6ZSgnbWVzc2FnZScpO1xuICAgICAgICAgKiAgICAgdmFyIGhhc2ggPSBoYXNoZXIuZmluYWxpemUod29yZEFycmF5KTtcbiAgICAgICAgICovXG4gICAgICAgIGZpbmFsaXplOiBmdW5jdGlvbiAobWVzc2FnZVVwZGF0ZSkge1xuICAgICAgICAgICAgLy8gRmluYWwgbWVzc2FnZSB1cGRhdGVcbiAgICAgICAgICAgIGlmIChtZXNzYWdlVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXBwZW5kKG1lc3NhZ2VVcGRhdGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWhhc2hlciBsb2dpY1xuICAgICAgICAgICAgdmFyIGhhc2ggPSB0aGlzLl9kb0ZpbmFsaXplKCk7XG5cbiAgICAgICAgICAgIHJldHVybiBoYXNoO1xuICAgICAgICB9LFxuXG4gICAgICAgIGJsb2NrU2l6ZTogNTEyLzMyLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgc2hvcnRjdXQgZnVuY3Rpb24gdG8gYSBoYXNoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0hhc2hlcn0gaGFzaGVyIFRoZSBoYXNoZXIgdG8gY3JlYXRlIGEgaGVscGVyIGZvci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBzaG9ydGN1dCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIFNIQTI1NiA9IENyeXB0b0pTLmxpYi5IYXNoZXIuX2NyZWF0ZUhlbHBlcihDcnlwdG9KUy5hbGdvLlNIQTI1Nik7XG4gICAgICAgICAqL1xuICAgICAgICBfY3JlYXRlSGVscGVyOiBmdW5jdGlvbiAoaGFzaGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1lc3NhZ2UsIGNmZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaGFzaGVyLmluaXQoY2ZnKS5maW5hbGl6ZShtZXNzYWdlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBzaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgSE1BQydzIG9iamVjdCBpbnRlcmZhY2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7SGFzaGVyfSBoYXNoZXIgVGhlIGhhc2hlciB0byB1c2UgaW4gdGhpcyBITUFDIGhlbHBlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBzaG9ydGN1dCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIEhtYWNTSEEyNTYgPSBDcnlwdG9KUy5saWIuSGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKENyeXB0b0pTLmFsZ28uU0hBMjU2KTtcbiAgICAgICAgICovXG4gICAgICAgIF9jcmVhdGVIbWFjSGVscGVyOiBmdW5jdGlvbiAoaGFzaGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1lc3NhZ2UsIGtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ19hbGdvLkhNQUMuaW5pdChoYXNoZXIsIGtleSkuZmluYWxpemUobWVzc2FnZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBBbGdvcml0aG0gbmFtZXNwYWNlLlxuICAgICAqL1xuICAgIHZhciBDX2FsZ28gPSBDLmFsZ28gPSB7fTtcblxuICAgIHJldHVybiBDO1xufShNYXRoKSk7XG5cbihmdW5jdGlvbiAoTWF0aCkge1xuICAgIC8vIFNob3J0Y3V0c1xuICAgIHZhciBDID0gQ3J5cHRvSlM7XG4gICAgdmFyIENfbGliID0gQy5saWI7XG4gICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcbiAgICB2YXIgSGFzaGVyID0gQ19saWIuSGFzaGVyO1xuICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cbiAgICAvLyBJbml0aWFsaXphdGlvbiBhbmQgcm91bmQgY29uc3RhbnRzIHRhYmxlc1xuICAgIHZhciBIID0gW107XG4gICAgdmFyIEsgPSBbXTtcblxuICAgIC8vIENvbXB1dGUgY29uc3RhbnRzXG4gICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gaXNQcmltZShuKSB7XG4gICAgICAgICAgICB2YXIgc3FydE4gPSBNYXRoLnNxcnQobik7XG4gICAgICAgICAgICBmb3IgKHZhciBmYWN0b3IgPSAyOyBmYWN0b3IgPD0gc3FydE47IGZhY3RvcisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEobiAlIGZhY3RvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRGcmFjdGlvbmFsQml0cyhuKSB7XG4gICAgICAgICAgICByZXR1cm4gKChuIC0gKG4gfCAwKSkgKiAweDEwMDAwMDAwMCkgfCAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG4gPSAyO1xuICAgICAgICB2YXIgblByaW1lID0gMDtcbiAgICAgICAgd2hpbGUgKG5QcmltZSA8IDY0KSB7XG4gICAgICAgICAgICBpZiAoaXNQcmltZShuKSkge1xuICAgICAgICAgICAgICAgIGlmIChuUHJpbWUgPCA4KSB7XG4gICAgICAgICAgICAgICAgICAgIEhbblByaW1lXSA9IGdldEZyYWN0aW9uYWxCaXRzKE1hdGgucG93KG4sIDEgLyAyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIEtbblByaW1lXSA9IGdldEZyYWN0aW9uYWxCaXRzKE1hdGgucG93KG4sIDEgLyAzKSk7XG5cbiAgICAgICAgICAgICAgICBuUHJpbWUrKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbisrO1xuICAgICAgICB9XG4gICAgfSgpKTtcblxuICAgIC8vIFJldXNhYmxlIG9iamVjdFxuICAgIHZhciBXID0gW107XG5cbiAgICAvKipcbiAgICAgKiBTSEEtMjU2IGhhc2ggYWxnb3JpdGhtLlxuICAgICAqL1xuICAgIHZhciBTSEEyNTYgPSBDX2FsZ28uU0hBMjU2ID0gSGFzaGVyLmV4dGVuZCh7XG4gICAgICAgIF9kb1Jlc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9oYXNoID0gbmV3IFdvcmRBcnJheS5pbml0KEguc2xpY2UoMCkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9kb1Byb2Nlc3NCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xuICAgICAgICAgICAgLy8gU2hvcnRjdXRcbiAgICAgICAgICAgIHZhciBIID0gdGhpcy5faGFzaC53b3JkcztcblxuICAgICAgICAgICAgLy8gV29ya2luZyB2YXJpYWJsZXNcbiAgICAgICAgICAgIHZhciBhID0gSFswXTtcbiAgICAgICAgICAgIHZhciBiID0gSFsxXTtcbiAgICAgICAgICAgIHZhciBjID0gSFsyXTtcbiAgICAgICAgICAgIHZhciBkID0gSFszXTtcbiAgICAgICAgICAgIHZhciBlID0gSFs0XTtcbiAgICAgICAgICAgIHZhciBmID0gSFs1XTtcbiAgICAgICAgICAgIHZhciBnID0gSFs2XTtcbiAgICAgICAgICAgIHZhciBoID0gSFs3XTtcblxuICAgICAgICAgICAgLy8gQ29tcHV0YXRpb25cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpIDwgMTYpIHtcbiAgICAgICAgICAgICAgICAgICAgV1tpXSA9IE1bb2Zmc2V0ICsgaV0gfCAwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBnYW1tYTB4ID0gV1tpIC0gMTVdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ2FtbWEwICA9ICgoZ2FtbWEweCA8PCAyNSkgfCAoZ2FtbWEweCA+Pj4gNykpICBeXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKChnYW1tYTB4IDw8IDE0KSB8IChnYW1tYTB4ID4+PiAxOCkpIF5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGdhbW1hMHggPj4+IDMpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBnYW1tYTF4ID0gV1tpIC0gMl07XG4gICAgICAgICAgICAgICAgICAgIHZhciBnYW1tYTEgID0gKChnYW1tYTF4IDw8IDE1KSB8IChnYW1tYTF4ID4+PiAxNykpIF5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKGdhbW1hMXggPDwgMTMpIHwgKGdhbW1hMXggPj4+IDE5KSkgXlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZ2FtbWExeCA+Pj4gMTApO1xuXG4gICAgICAgICAgICAgICAgICAgIFdbaV0gPSBnYW1tYTAgKyBXW2kgLSA3XSArIGdhbW1hMSArIFdbaSAtIDE2XTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgY2ggID0gKGUgJiBmKSBeICh+ZSAmIGcpO1xuICAgICAgICAgICAgICAgIHZhciBtYWogPSAoYSAmIGIpIF4gKGEgJiBjKSBeIChiICYgYyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgc2lnbWEwID0gKChhIDw8IDMwKSB8IChhID4+PiAyKSkgXiAoKGEgPDwgMTkpIHwgKGEgPj4+IDEzKSkgXiAoKGEgPDwgMTApIHwgKGEgPj4+IDIyKSk7XG4gICAgICAgICAgICAgICAgdmFyIHNpZ21hMSA9ICgoZSA8PCAyNikgfCAoZSA+Pj4gNikpIF4gKChlIDw8IDIxKSB8IChlID4+PiAxMSkpIF4gKChlIDw8IDcpICB8IChlID4+PiAyNSkpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHQxID0gaCArIHNpZ21hMSArIGNoICsgS1tpXSArIFdbaV07XG4gICAgICAgICAgICAgICAgdmFyIHQyID0gc2lnbWEwICsgbWFqO1xuXG4gICAgICAgICAgICAgICAgaCA9IGc7XG4gICAgICAgICAgICAgICAgZyA9IGY7XG4gICAgICAgICAgICAgICAgZiA9IGU7XG4gICAgICAgICAgICAgICAgZSA9IChkICsgdDEpIHwgMDtcbiAgICAgICAgICAgICAgICBkID0gYztcbiAgICAgICAgICAgICAgICBjID0gYjtcbiAgICAgICAgICAgICAgICBiID0gYTtcbiAgICAgICAgICAgICAgICBhID0gKHQxICsgdDIpIHwgMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSW50ZXJtZWRpYXRlIGhhc2ggdmFsdWVcbiAgICAgICAgICAgIEhbMF0gPSAoSFswXSArIGEpIHwgMDtcbiAgICAgICAgICAgIEhbMV0gPSAoSFsxXSArIGIpIHwgMDtcbiAgICAgICAgICAgIEhbMl0gPSAoSFsyXSArIGMpIHwgMDtcbiAgICAgICAgICAgIEhbM10gPSAoSFszXSArIGQpIHwgMDtcbiAgICAgICAgICAgIEhbNF0gPSAoSFs0XSArIGUpIHwgMDtcbiAgICAgICAgICAgIEhbNV0gPSAoSFs1XSArIGYpIHwgMDtcbiAgICAgICAgICAgIEhbNl0gPSAoSFs2XSArIGcpIHwgMDtcbiAgICAgICAgICAgIEhbN10gPSAoSFs3XSArIGgpIHwgMDtcbiAgICAgICAgfSxcblxuICAgICAgICBfZG9GaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgICAgICAgICB2YXIgZGF0YVdvcmRzID0gZGF0YS53b3JkcztcblxuICAgICAgICAgICAgdmFyIG5CaXRzVG90YWwgPSB0aGlzLl9uRGF0YUJ5dGVzICogODtcbiAgICAgICAgICAgIHZhciBuQml0c0xlZnQgPSBkYXRhLnNpZ0J5dGVzICogODtcblxuICAgICAgICAgICAgLy8gQWRkIHBhZGRpbmdcbiAgICAgICAgICAgIGRhdGFXb3Jkc1tuQml0c0xlZnQgPj4+IDVdIHw9IDB4ODAgPDwgKDI0IC0gbkJpdHNMZWZ0ICUgMzIpO1xuICAgICAgICAgICAgZGF0YVdvcmRzWygoKG5CaXRzTGVmdCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNF0gPSBNYXRoLmZsb29yKG5CaXRzVG90YWwgLyAweDEwMDAwMDAwMCk7XG4gICAgICAgICAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE1XSA9IG5CaXRzVG90YWw7XG4gICAgICAgICAgICBkYXRhLnNpZ0J5dGVzID0gZGF0YVdvcmRzLmxlbmd0aCAqIDQ7XG5cbiAgICAgICAgICAgIC8vIEhhc2ggZmluYWwgYmxvY2tzXG4gICAgICAgICAgICB0aGlzLl9wcm9jZXNzKCk7XG5cbiAgICAgICAgICAgIC8vIFJldHVybiBmaW5hbCBjb21wdXRlZCBoYXNoXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faGFzaDtcbiAgICAgICAgfSxcblxuICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNsb25lID0gSGFzaGVyLmNsb25lLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBjbG9uZS5faGFzaCA9IHRoaXMuX2hhc2guY2xvbmUoKTtcblxuICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuICAgICAqXG4gICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgaGFzaC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEEyNTYoJ21lc3NhZ2UnKTtcbiAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEEyNTYod29yZEFycmF5KTtcbiAgICAgKi9cbiAgICBDLlNIQTI1NiA9IEhhc2hlci5fY3JlYXRlSGVscGVyKFNIQTI1Nik7XG5cbiAgICAvKipcbiAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgSE1BQydzIG9iamVjdCBpbnRlcmZhY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cbiAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGtleSBUaGUgc2VjcmV0IGtleS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIEhNQUMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgIHZhciBobWFjID0gQ3J5cHRvSlMuSG1hY1NIQTI1NihtZXNzYWdlLCBrZXkpO1xuICAgICAqL1xuICAgIEMuSG1hY1NIQTI1NiA9IEhhc2hlci5fY3JlYXRlSG1hY0hlbHBlcihTSEEyNTYpO1xufShNYXRoKSk7XG5cbihmdW5jdGlvbiAoKSB7XG4gICAgLy8gU2hvcnRjdXRzXG4gICAgdmFyIEMgPSBDcnlwdG9KUztcbiAgICB2YXIgQ19saWIgPSBDLmxpYjtcbiAgICB2YXIgQmFzZSA9IENfbGliLkJhc2U7XG4gICAgdmFyIENfZW5jID0gQy5lbmM7XG4gICAgdmFyIFV0ZjggPSBDX2VuYy5VdGY4O1xuICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cbiAgICAvKipcbiAgICAgKiBITUFDIGFsZ29yaXRobS5cbiAgICAgKi9cbiAgICB2YXIgSE1BQyA9IENfYWxnby5ITUFDID0gQmFzZS5leHRlbmQoe1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIEhNQUMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7SGFzaGVyfSBoYXNoZXIgVGhlIGhhc2ggYWxnb3JpdGhtIHRvIHVzZS5cbiAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBrZXkgVGhlIHNlY3JldCBrZXkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgaG1hY0hhc2hlciA9IENyeXB0b0pTLmFsZ28uSE1BQy5jcmVhdGUoQ3J5cHRvSlMuYWxnby5TSEEyNTYsIGtleSk7XG4gICAgICAgICAqL1xuICAgICAgICBpbml0OiBmdW5jdGlvbiAoaGFzaGVyLCBrZXkpIHtcbiAgICAgICAgICAgIC8vIEluaXQgaGFzaGVyXG4gICAgICAgICAgICBoYXNoZXIgPSB0aGlzLl9oYXNoZXIgPSBuZXcgaGFzaGVyLmluaXQoKTtcblxuICAgICAgICAgICAgLy8gQ29udmVydCBzdHJpbmcgdG8gV29yZEFycmF5LCBlbHNlIGFzc3VtZSBXb3JkQXJyYXkgYWxyZWFkeVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBVdGY4LnBhcnNlKGtleSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuICAgICAgICAgICAgdmFyIGhhc2hlckJsb2NrU2l6ZSA9IGhhc2hlci5ibG9ja1NpemU7XG4gICAgICAgICAgICB2YXIgaGFzaGVyQmxvY2tTaXplQnl0ZXMgPSBoYXNoZXJCbG9ja1NpemUgKiA0O1xuXG4gICAgICAgICAgICAvLyBBbGxvdyBhcmJpdHJhcnkgbGVuZ3RoIGtleXNcbiAgICAgICAgICAgIGlmIChrZXkuc2lnQnl0ZXMgPiBoYXNoZXJCbG9ja1NpemVCeXRlcykge1xuICAgICAgICAgICAgICAgIGtleSA9IGhhc2hlci5maW5hbGl6ZShrZXkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDbGFtcCBleGNlc3MgYml0c1xuICAgICAgICAgICAga2V5LmNsYW1wKCk7XG5cbiAgICAgICAgICAgIC8vIENsb25lIGtleSBmb3IgaW5uZXIgYW5kIG91dGVyIHBhZHNcbiAgICAgICAgICAgIHZhciBvS2V5ID0gdGhpcy5fb0tleSA9IGtleS5jbG9uZSgpO1xuICAgICAgICAgICAgdmFyIGlLZXkgPSB0aGlzLl9pS2V5ID0ga2V5LmNsb25lKCk7XG5cbiAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuICAgICAgICAgICAgdmFyIG9LZXlXb3JkcyA9IG9LZXkud29yZHM7XG4gICAgICAgICAgICB2YXIgaUtleVdvcmRzID0gaUtleS53b3JkcztcblxuICAgICAgICAgICAgLy8gWE9SIGtleXMgd2l0aCBwYWQgY29uc3RhbnRzXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhc2hlckJsb2NrU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb0tleVdvcmRzW2ldIF49IDB4NWM1YzVjNWM7XG4gICAgICAgICAgICAgICAgaUtleVdvcmRzW2ldIF49IDB4MzYzNjM2MzY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvS2V5LnNpZ0J5dGVzID0gaUtleS5zaWdCeXRlcyA9IGhhc2hlckJsb2NrU2l6ZUJ5dGVzO1xuXG4gICAgICAgICAgICAvLyBTZXQgaW5pdGlhbCB2YWx1ZXNcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVzZXRzIHRoaXMgSE1BQyB0byBpdHMgaW5pdGlhbCBzdGF0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIGhtYWNIYXNoZXIucmVzZXQoKTtcbiAgICAgICAgICovXG4gICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBTaG9ydGN1dFxuICAgICAgICAgICAgdmFyIGhhc2hlciA9IHRoaXMuX2hhc2hlcjtcblxuICAgICAgICAgICAgLy8gUmVzZXRcbiAgICAgICAgICAgIGhhc2hlci5yZXNldCgpO1xuICAgICAgICAgICAgaGFzaGVyLnVwZGF0ZSh0aGlzLl9pS2V5KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlcyB0aGlzIEhNQUMgd2l0aCBhIG1lc3NhZ2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZVVwZGF0ZSBUaGUgbWVzc2FnZSB0byBhcHBlbmQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0hNQUN9IFRoaXMgSE1BQyBpbnN0YW5jZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIGhtYWNIYXNoZXIudXBkYXRlKCdtZXNzYWdlJyk7XG4gICAgICAgICAqICAgICBobWFjSGFzaGVyLnVwZGF0ZSh3b3JkQXJyYXkpO1xuICAgICAgICAgKi9cbiAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAobWVzc2FnZVVwZGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5faGFzaGVyLnVwZGF0ZShtZXNzYWdlVXBkYXRlKTtcblxuICAgICAgICAgICAgLy8gQ2hhaW5hYmxlXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRmluYWxpemVzIHRoZSBITUFDIGNvbXB1dGF0aW9uLlxuICAgICAgICAgKiBOb3RlIHRoYXQgdGhlIGZpbmFsaXplIG9wZXJhdGlvbiBpcyBlZmZlY3RpdmVseSBhIGRlc3RydWN0aXZlLCByZWFkLW9uY2Ugb3BlcmF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2VVcGRhdGUgKE9wdGlvbmFsKSBBIGZpbmFsIG1lc3NhZ2UgdXBkYXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBITUFDLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIGhtYWMgPSBobWFjSGFzaGVyLmZpbmFsaXplKCk7XG4gICAgICAgICAqICAgICB2YXIgaG1hYyA9IGhtYWNIYXNoZXIuZmluYWxpemUoJ21lc3NhZ2UnKTtcbiAgICAgICAgICogICAgIHZhciBobWFjID0gaG1hY0hhc2hlci5maW5hbGl6ZSh3b3JkQXJyYXkpO1xuICAgICAgICAgKi9cbiAgICAgICAgZmluYWxpemU6IGZ1bmN0aW9uIChtZXNzYWdlVXBkYXRlKSB7XG4gICAgICAgICAgICAvLyBTaG9ydGN1dFxuICAgICAgICAgICAgdmFyIGhhc2hlciA9IHRoaXMuX2hhc2hlcjtcblxuICAgICAgICAgICAgLy8gQ29tcHV0ZSBITUFDXG4gICAgICAgICAgICB2YXIgaW5uZXJIYXNoID0gaGFzaGVyLmZpbmFsaXplKG1lc3NhZ2VVcGRhdGUpO1xuICAgICAgICAgICAgaGFzaGVyLnJlc2V0KCk7XG4gICAgICAgICAgICB2YXIgaG1hYyA9IGhhc2hlci5maW5hbGl6ZSh0aGlzLl9vS2V5LmNsb25lKCkuY29uY2F0KGlubmVySGFzaCkpO1xuXG4gICAgICAgICAgICByZXR1cm4gaG1hYztcbiAgICAgICAgfVxuICAgIH0pO1xufSgpKTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBTaG9ydGN1dHNcbiAgICB2YXIgQyA9IENyeXB0b0pTO1xuICAgIHZhciBDX2xpYiA9IEMubGliO1xuICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG4gICAgdmFyIENfZW5jID0gQy5lbmM7XG5cbiAgICAvKipcbiAgICAgKiBCYXNlNjQgZW5jb2Rpbmcgc3RyYXRlZ3kuXG4gICAgICovXG4gICAgdmFyIEJhc2U2NCA9IENfZW5jLkJhc2U2NCA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIEJhc2U2NCBzdHJpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIEJhc2U2NCBzdHJpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciBiYXNlNjRTdHJpbmcgPSBDcnlwdG9KUy5lbmMuQmFzZTY0LnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuICAgICAgICAgKi9cbiAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XG4gICAgICAgICAgICAvLyBTaG9ydGN1dHNcbiAgICAgICAgICAgIHZhciB3b3JkcyA9IHdvcmRBcnJheS53b3JkcztcbiAgICAgICAgICAgIHZhciBzaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcbiAgICAgICAgICAgIHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cbiAgICAgICAgICAgIC8vIENsYW1wIGV4Y2VzcyBiaXRzXG4gICAgICAgICAgICB3b3JkQXJyYXkuY2xhbXAoKTtcblxuICAgICAgICAgICAgLy8gQ29udmVydFxuICAgICAgICAgICAgdmFyIGJhc2U2NENoYXJzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZ0J5dGVzOyBpICs9IDMpIHtcbiAgICAgICAgICAgICAgICB2YXIgYnl0ZTEgPSAod29yZHNbaSA+Pj4gMl0gICAgICAgPj4+ICgyNCAtIChpICUgNCkgKiA4KSkgICAgICAgJiAweGZmO1xuICAgICAgICAgICAgICAgIHZhciBieXRlMiA9ICh3b3Jkc1soaSArIDEpID4+PiAyXSA+Pj4gKDI0IC0gKChpICsgMSkgJSA0KSAqIDgpKSAmIDB4ZmY7XG4gICAgICAgICAgICAgICAgdmFyIGJ5dGUzID0gKHdvcmRzWyhpICsgMikgPj4+IDJdID4+PiAoMjQgLSAoKGkgKyAyKSAlIDQpICogOCkpICYgMHhmZjtcblxuICAgICAgICAgICAgICAgIHZhciB0cmlwbGV0ID0gKGJ5dGUxIDw8IDE2KSB8IChieXRlMiA8PCA4KSB8IGJ5dGUzO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IChqIDwgNCkgJiYgKGkgKyBqICogMC43NSA8IHNpZ0J5dGVzKTsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhc2U2NENoYXJzLnB1c2gobWFwLmNoYXJBdCgodHJpcGxldCA+Pj4gKDYgKiAoMyAtIGopKSkgJiAweDNmKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBZGQgcGFkZGluZ1xuICAgICAgICAgICAgdmFyIHBhZGRpbmdDaGFyID0gbWFwLmNoYXJBdCg2NCk7XG4gICAgICAgICAgICBpZiAocGFkZGluZ0NoYXIpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoYmFzZTY0Q2hhcnMubGVuZ3RoICUgNCkge1xuICAgICAgICAgICAgICAgICAgICBiYXNlNjRDaGFycy5wdXNoKHBhZGRpbmdDaGFyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBiYXNlNjRDaGFycy5qb2luKCcnKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgYSBCYXNlNjQgc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGJhc2U2NFN0ciBUaGUgQmFzZTY0IHN0cmluZy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5CYXNlNjQucGFyc2UoYmFzZTY0U3RyaW5nKTtcbiAgICAgICAgICovXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbiAoYmFzZTY0U3RyKSB7XG4gICAgICAgICAgICAvLyBTaG9ydGN1dHNcbiAgICAgICAgICAgIHZhciBiYXNlNjRTdHJMZW5ndGggPSBiYXNlNjRTdHIubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIG1hcCA9IHRoaXMuX21hcDtcblxuICAgICAgICAgICAgLy8gSWdub3JlIHBhZGRpbmdcbiAgICAgICAgICAgIHZhciBwYWRkaW5nQ2hhciA9IG1hcC5jaGFyQXQoNjQpO1xuICAgICAgICAgICAgaWYgKHBhZGRpbmdDaGFyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhZGRpbmdJbmRleCA9IGJhc2U2NFN0ci5pbmRleE9mKHBhZGRpbmdDaGFyKTtcbiAgICAgICAgICAgICAgICBpZiAocGFkZGluZ0luZGV4ICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhc2U2NFN0ckxlbmd0aCA9IHBhZGRpbmdJbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENvbnZlcnRcbiAgICAgICAgICAgIHZhciB3b3JkcyA9IFtdO1xuICAgICAgICAgICAgdmFyIG5CeXRlcyA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhc2U2NFN0ckxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgJSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiaXRzMSA9IG1hcC5pbmRleE9mKGJhc2U2NFN0ci5jaGFyQXQoaSAtIDEpKSA8PCAoKGkgJSA0KSAqIDIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYml0czIgPSBtYXAuaW5kZXhPZihiYXNlNjRTdHIuY2hhckF0KGkpKSA+Pj4gKDYgLSAoaSAlIDQpICogMik7XG4gICAgICAgICAgICAgICAgICAgIHdvcmRzW25CeXRlcyA+Pj4gMl0gfD0gKGJpdHMxIHwgYml0czIpIDw8ICgyNCAtIChuQnl0ZXMgJSA0KSAqIDgpO1xuICAgICAgICAgICAgICAgICAgICBuQnl0ZXMrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBXb3JkQXJyYXkuY3JlYXRlKHdvcmRzLCBuQnl0ZXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9tYXA6ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSdcbiAgICB9O1xufSgpKTtcblxuLyoqXG4gKiBDaXBoZXIgY29yZSBjb21wb25lbnRzLlxuICovXG5DcnlwdG9KUy5saWIuQ2lwaGVyIHx8IChmdW5jdGlvbiAodW5kZWZpbmVkKSB7XG4gICAgLy8gU2hvcnRjdXRzXG4gICAgdmFyIEMgPSBDcnlwdG9KUztcbiAgICB2YXIgQ19saWIgPSBDLmxpYjtcbiAgICB2YXIgQmFzZSA9IENfbGliLkJhc2U7XG4gICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcbiAgICB2YXIgQnVmZmVyZWRCbG9ja0FsZ29yaXRobSA9IENfbGliLkJ1ZmZlcmVkQmxvY2tBbGdvcml0aG07XG4gICAgdmFyIENfZW5jID0gQy5lbmM7XG4gICAgdmFyIFV0ZjggPSBDX2VuYy5VdGY4O1xuICAgIHZhciBCYXNlNjQgPSBDX2VuYy5CYXNlNjQ7XG4gICAgdmFyIENfYWxnbyA9IEMuYWxnbztcbiAgICB2YXIgRXZwS0RGID0gQ19hbGdvLkV2cEtERjtcblxuICAgIC8qKlxuICAgICAqIEFic3RyYWN0IGJhc2UgY2lwaGVyIHRlbXBsYXRlLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGtleVNpemUgVGhpcyBjaXBoZXIncyBrZXkgc2l6ZS4gRGVmYXVsdDogNCAoMTI4IGJpdHMpXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGl2U2l6ZSBUaGlzIGNpcGhlcidzIElWIHNpemUuIERlZmF1bHQ6IDQgKDEyOCBiaXRzKVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfRU5DX1hGT1JNX01PREUgQSBjb25zdGFudCByZXByZXNlbnRpbmcgZW5jcnlwdGlvbiBtb2RlLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfREVDX1hGT1JNX01PREUgQSBjb25zdGFudCByZXByZXNlbnRpbmcgZGVjcnlwdGlvbiBtb2RlLlxuICAgICAqL1xuICAgIHZhciBDaXBoZXIgPSBDX2xpYi5DaXBoZXIgPSBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtLmV4dGVuZCh7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7V29yZEFycmF5fSBpdiBUaGUgSVYgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIGNmZzogQmFzZS5leHRlbmQoKSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyB0aGlzIGNpcGhlciBpbiBlbmNyeXB0aW9uIG1vZGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBrZXkgVGhlIGtleS5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7Q2lwaGVyfSBBIGNpcGhlciBpbnN0YW5jZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIGNpcGhlciA9IENyeXB0b0pTLmFsZ28uQUVTLmNyZWF0ZUVuY3J5cHRvcihrZXlXb3JkQXJyYXksIHsgaXY6IGl2V29yZEFycmF5IH0pO1xuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlRW5jcnlwdG9yOiBmdW5jdGlvbiAoa2V5LCBjZmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZSh0aGlzLl9FTkNfWEZPUk1fTU9ERSwga2V5LCBjZmcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIHRoaXMgY2lwaGVyIGluIGRlY3J5cHRpb24gbW9kZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGtleSBUaGUga2V5LlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJ9IEEgY2lwaGVyIGluc3RhbmNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgY2lwaGVyID0gQ3J5cHRvSlMuYWxnby5BRVMuY3JlYXRlRGVjcnlwdG9yKGtleVdvcmRBcnJheSwgeyBpdjogaXZXb3JkQXJyYXkgfSk7XG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVEZWNyeXB0b3I6IGZ1bmN0aW9uIChrZXksIGNmZykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlKHRoaXMuX0RFQ19YRk9STV9NT0RFLCBrZXksIGNmZyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBjaXBoZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4Zm9ybU1vZGUgRWl0aGVyIHRoZSBlbmNyeXB0aW9uIG9yIGRlY3J5cHRpb24gdHJhbnNvcm1hdGlvbiBtb2RlIGNvbnN0YW50LlxuICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0ga2V5IFRoZSBrZXkuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgY2lwaGVyID0gQ3J5cHRvSlMuYWxnby5BRVMuY3JlYXRlKENyeXB0b0pTLmFsZ28uQUVTLl9FTkNfWEZPUk1fTU9ERSwga2V5V29yZEFycmF5LCB7IGl2OiBpdldvcmRBcnJheSB9KTtcbiAgICAgICAgICovXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uICh4Zm9ybU1vZGUsIGtleSwgY2ZnKSB7XG4gICAgICAgICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcbiAgICAgICAgICAgIHRoaXMuY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XG5cbiAgICAgICAgICAgIC8vIFN0b3JlIHRyYW5zZm9ybSBtb2RlIGFuZCBrZXlcbiAgICAgICAgICAgIHRoaXMuX3hmb3JtTW9kZSA9IHhmb3JtTW9kZTtcbiAgICAgICAgICAgIHRoaXMuX2tleSA9IGtleTtcblxuICAgICAgICAgICAgLy8gU2V0IGluaXRpYWwgdmFsdWVzXG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc2V0cyB0aGlzIGNpcGhlciB0byBpdHMgaW5pdGlhbCBzdGF0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIGNpcGhlci5yZXNldCgpO1xuICAgICAgICAgKi9cbiAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIFJlc2V0IGRhdGEgYnVmZmVyXG4gICAgICAgICAgICBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtLnJlc2V0LmNhbGwodGhpcyk7XG5cbiAgICAgICAgICAgIC8vIFBlcmZvcm0gY29uY3JldGUtY2lwaGVyIGxvZ2ljXG4gICAgICAgICAgICB0aGlzLl9kb1Jlc2V0KCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgZGF0YSB0byBiZSBlbmNyeXB0ZWQgb3IgZGVjcnlwdGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGRhdGFVcGRhdGUgVGhlIGRhdGEgdG8gZW5jcnlwdCBvciBkZWNyeXB0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBkYXRhIGFmdGVyIHByb2Nlc3NpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgZW5jcnlwdGVkID0gY2lwaGVyLnByb2Nlc3MoJ2RhdGEnKTtcbiAgICAgICAgICogICAgIHZhciBlbmNyeXB0ZWQgPSBjaXBoZXIucHJvY2Vzcyh3b3JkQXJyYXkpO1xuICAgICAgICAgKi9cbiAgICAgICAgcHJvY2VzczogZnVuY3Rpb24gKGRhdGFVcGRhdGUpIHtcbiAgICAgICAgICAgIC8vIEFwcGVuZFxuICAgICAgICAgICAgdGhpcy5fYXBwZW5kKGRhdGFVcGRhdGUpO1xuXG4gICAgICAgICAgICAvLyBQcm9jZXNzIGF2YWlsYWJsZSBibG9ja3NcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcm9jZXNzKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpbmFsaXplcyB0aGUgZW5jcnlwdGlvbiBvciBkZWNyeXB0aW9uIHByb2Nlc3MuXG4gICAgICAgICAqIE5vdGUgdGhhdCB0aGUgZmluYWxpemUgb3BlcmF0aW9uIGlzIGVmZmVjdGl2ZWx5IGEgZGVzdHJ1Y3RpdmUsIHJlYWQtb25jZSBvcGVyYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gZGF0YVVwZGF0ZSBUaGUgZmluYWwgZGF0YSB0byBlbmNyeXB0IG9yIGRlY3J5cHQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGRhdGEgYWZ0ZXIgZmluYWwgcHJvY2Vzc2luZy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciBlbmNyeXB0ZWQgPSBjaXBoZXIuZmluYWxpemUoKTtcbiAgICAgICAgICogICAgIHZhciBlbmNyeXB0ZWQgPSBjaXBoZXIuZmluYWxpemUoJ2RhdGEnKTtcbiAgICAgICAgICogICAgIHZhciBlbmNyeXB0ZWQgPSBjaXBoZXIuZmluYWxpemUod29yZEFycmF5KTtcbiAgICAgICAgICovXG4gICAgICAgIGZpbmFsaXplOiBmdW5jdGlvbiAoZGF0YVVwZGF0ZSkge1xuICAgICAgICAgICAgLy8gRmluYWwgZGF0YSB1cGRhdGVcbiAgICAgICAgICAgIGlmIChkYXRhVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXBwZW5kKGRhdGFVcGRhdGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWNpcGhlciBsb2dpY1xuICAgICAgICAgICAgdmFyIGZpbmFsUHJvY2Vzc2VkRGF0YSA9IHRoaXMuX2RvRmluYWxpemUoKTtcblxuICAgICAgICAgICAgcmV0dXJuIGZpbmFsUHJvY2Vzc2VkRGF0YTtcbiAgICAgICAgfSxcblxuICAgICAgICBrZXlTaXplOiAxMjgvMzIsXG5cbiAgICAgICAgaXZTaXplOiAxMjgvMzIsXG5cbiAgICAgICAgX0VOQ19YRk9STV9NT0RFOiAxLFxuXG4gICAgICAgIF9ERUNfWEZPUk1fTU9ERTogMixcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBzaG9ydGN1dCBmdW5jdGlvbnMgdG8gYSBjaXBoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIFRoZSBjaXBoZXIgdG8gY3JlYXRlIGEgaGVscGVyIGZvci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBlbmNyeXB0IGFuZCBkZWNyeXB0IHNob3J0Y3V0IGZ1bmN0aW9ucy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIEFFUyA9IENyeXB0b0pTLmxpYi5DaXBoZXIuX2NyZWF0ZUhlbHBlcihDcnlwdG9KUy5hbGdvLkFFUyk7XG4gICAgICAgICAqL1xuICAgICAgICBfY3JlYXRlSGVscGVyOiAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gc2VsZWN0Q2lwaGVyU3RyYXRlZ3koa2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBhc3N3b3JkQmFzZWRDaXBoZXI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNlcmlhbGl6YWJsZUNpcGhlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoY2lwaGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZW5jcnlwdDogZnVuY3Rpb24gKG1lc3NhZ2UsIGtleSwgY2ZnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZWN0Q2lwaGVyU3RyYXRlZ3koa2V5KS5lbmNyeXB0KGNpcGhlciwgbWVzc2FnZSwga2V5LCBjZmcpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIGRlY3J5cHQ6IGZ1bmN0aW9uIChjaXBoZXJ0ZXh0LCBrZXksIGNmZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdENpcGhlclN0cmF0ZWd5KGtleSkuZGVjcnlwdChjaXBoZXIsIGNpcGhlcnRleHQsIGtleSwgY2ZnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KCkpXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBBYnN0cmFjdCBiYXNlIHN0cmVhbSBjaXBoZXIgdGVtcGxhdGUuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYmxvY2tTaXplIFRoZSBudW1iZXIgb2YgMzItYml0IHdvcmRzIHRoaXMgY2lwaGVyIG9wZXJhdGVzIG9uLiBEZWZhdWx0OiAxICgzMiBiaXRzKVxuICAgICAqL1xuICAgIHZhciBTdHJlYW1DaXBoZXIgPSBDX2xpYi5TdHJlYW1DaXBoZXIgPSBDaXBoZXIuZXh0ZW5kKHtcbiAgICAgICAgX2RvRmluYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIFByb2Nlc3MgcGFydGlhbCBibG9ja3NcbiAgICAgICAgICAgIHZhciBmaW5hbFByb2Nlc3NlZEJsb2NrcyA9IHRoaXMuX3Byb2Nlc3MoISEnZmx1c2gnKTtcblxuICAgICAgICAgICAgcmV0dXJuIGZpbmFsUHJvY2Vzc2VkQmxvY2tzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGJsb2NrU2l6ZTogMVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogTW9kZSBuYW1lc3BhY2UuXG4gICAgICovXG4gICAgdmFyIENfbW9kZSA9IEMubW9kZSA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQWJzdHJhY3QgYmFzZSBibG9jayBjaXBoZXIgbW9kZSB0ZW1wbGF0ZS5cbiAgICAgKi9cbiAgICB2YXIgQmxvY2tDaXBoZXJNb2RlID0gQ19saWIuQmxvY2tDaXBoZXJNb2RlID0gQmFzZS5leHRlbmQoe1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyB0aGlzIG1vZGUgZm9yIGVuY3J5cHRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgQSBibG9jayBjaXBoZXIgaW5zdGFuY2UuXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGl2IFRoZSBJViB3b3Jkcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIG1vZGUgPSBDcnlwdG9KUy5tb2RlLkNCQy5jcmVhdGVFbmNyeXB0b3IoY2lwaGVyLCBpdi53b3Jkcyk7XG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVFbmNyeXB0b3I6IGZ1bmN0aW9uIChjaXBoZXIsIGl2KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5FbmNyeXB0b3IuY3JlYXRlKGNpcGhlciwgaXYpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIHRoaXMgbW9kZSBmb3IgZGVjcnlwdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBBIGJsb2NrIGNpcGhlciBpbnN0YW5jZS5cbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gaXYgVGhlIElWIHdvcmRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgbW9kZSA9IENyeXB0b0pTLm1vZGUuQ0JDLmNyZWF0ZURlY3J5cHRvcihjaXBoZXIsIGl2LndvcmRzKTtcbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZURlY3J5cHRvcjogZnVuY3Rpb24gKGNpcGhlciwgaXYpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkRlY3J5cHRvci5jcmVhdGUoY2lwaGVyLCBpdik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBtb2RlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIEEgYmxvY2sgY2lwaGVyIGluc3RhbmNlLlxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBpdiBUaGUgSVYgd29yZHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgbW9kZSA9IENyeXB0b0pTLm1vZGUuQ0JDLkVuY3J5cHRvci5jcmVhdGUoY2lwaGVyLCBpdi53b3Jkcyk7XG4gICAgICAgICAqL1xuICAgICAgICBpbml0OiBmdW5jdGlvbiAoY2lwaGVyLCBpdikge1xuICAgICAgICAgICAgdGhpcy5fY2lwaGVyID0gY2lwaGVyO1xuICAgICAgICAgICAgdGhpcy5faXYgPSBpdjtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ2lwaGVyIEJsb2NrIENoYWluaW5nIG1vZGUuXG4gICAgICovXG4gICAgdmFyIENCQyA9IENfbW9kZS5DQkMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQWJzdHJhY3QgYmFzZSBDQkMgbW9kZS5cbiAgICAgICAgICovXG4gICAgICAgIHZhciBDQkMgPSBCbG9ja0NpcGhlck1vZGUuZXh0ZW5kKCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENCQyBlbmNyeXB0b3IuXG4gICAgICAgICAqL1xuICAgICAgICBDQkMuRW5jcnlwdG9yID0gQ0JDLmV4dGVuZCh7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFByb2Nlc3NlcyB0aGUgZGF0YSBibG9jayBhdCBvZmZzZXQuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheX0gd29yZHMgVGhlIGRhdGEgd29yZHMgdG8gb3BlcmF0ZSBvbi5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgVGhlIG9mZnNldCB3aGVyZSB0aGUgYmxvY2sgc3RhcnRzLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogICAgIG1vZGUucHJvY2Vzc0Jsb2NrKGRhdGEud29yZHMsIG9mZnNldCk7XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHByb2Nlc3NCbG9jazogZnVuY3Rpb24gKHdvcmRzLCBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dHNcbiAgICAgICAgICAgICAgICB2YXIgY2lwaGVyID0gdGhpcy5fY2lwaGVyO1xuICAgICAgICAgICAgICAgIHZhciBibG9ja1NpemUgPSBjaXBoZXIuYmxvY2tTaXplO1xuXG4gICAgICAgICAgICAgICAgLy8gWE9SIGFuZCBlbmNyeXB0XG4gICAgICAgICAgICAgICAgeG9yQmxvY2suY2FsbCh0aGlzLCB3b3Jkcywgb2Zmc2V0LCBibG9ja1NpemUpO1xuICAgICAgICAgICAgICAgIGNpcGhlci5lbmNyeXB0QmxvY2sod29yZHMsIG9mZnNldCk7XG5cbiAgICAgICAgICAgICAgICAvLyBSZW1lbWJlciB0aGlzIGJsb2NrIHRvIHVzZSB3aXRoIG5leHQgYmxvY2tcbiAgICAgICAgICAgICAgICB0aGlzLl9wcmV2QmxvY2sgPSB3b3Jkcy5zbGljZShvZmZzZXQsIG9mZnNldCArIGJsb2NrU2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDQkMgZGVjcnlwdG9yLlxuICAgICAgICAgKi9cbiAgICAgICAgQ0JDLkRlY3J5cHRvciA9IENCQy5leHRlbmQoe1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBQcm9jZXNzZXMgdGhlIGRhdGEgYmxvY2sgYXQgb2Zmc2V0LlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHdvcmRzIFRoZSBkYXRhIHdvcmRzIHRvIG9wZXJhdGUgb24uXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IFRoZSBvZmZzZXQgd2hlcmUgdGhlIGJsb2NrIHN0YXJ0cy5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICAgICBtb2RlLnByb2Nlc3NCbG9jayhkYXRhLndvcmRzLCBvZmZzZXQpO1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBwcm9jZXNzQmxvY2s6IGZ1bmN0aW9uICh3b3Jkcywgb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG4gICAgICAgICAgICAgICAgdmFyIGNpcGhlciA9IHRoaXMuX2NpcGhlcjtcbiAgICAgICAgICAgICAgICB2YXIgYmxvY2tTaXplID0gY2lwaGVyLmJsb2NrU2l6ZTtcblxuICAgICAgICAgICAgICAgIC8vIFJlbWVtYmVyIHRoaXMgYmxvY2sgdG8gdXNlIHdpdGggbmV4dCBibG9ja1xuICAgICAgICAgICAgICAgIHZhciB0aGlzQmxvY2sgPSB3b3Jkcy5zbGljZShvZmZzZXQsIG9mZnNldCArIGJsb2NrU2l6ZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBEZWNyeXB0IGFuZCBYT1JcbiAgICAgICAgICAgICAgICBjaXBoZXIuZGVjcnlwdEJsb2NrKHdvcmRzLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIHhvckJsb2NrLmNhbGwodGhpcywgd29yZHMsIG9mZnNldCwgYmxvY2tTaXplKTtcblxuICAgICAgICAgICAgICAgIC8vIFRoaXMgYmxvY2sgYmVjb21lcyB0aGUgcHJldmlvdXMgYmxvY2tcbiAgICAgICAgICAgICAgICB0aGlzLl9wcmV2QmxvY2sgPSB0aGlzQmxvY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZ1bmN0aW9uIHhvckJsb2NrKHdvcmRzLCBvZmZzZXQsIGJsb2NrU2l6ZSkge1xuICAgICAgICAgICAgLy8gU2hvcnRjdXRcbiAgICAgICAgICAgIHZhciBpdiA9IHRoaXMuX2l2O1xuXG4gICAgICAgICAgICAvLyBDaG9vc2UgbWl4aW5nIGJsb2NrXG4gICAgICAgICAgICBpZiAoaXYpIHtcbiAgICAgICAgICAgICAgICB2YXIgYmxvY2sgPSBpdjtcblxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBJViBmb3Igc3Vic2VxdWVudCBibG9ja3NcbiAgICAgICAgICAgICAgICB0aGlzLl9pdiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGJsb2NrID0gdGhpcy5fcHJldkJsb2NrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBYT1IgYmxvY2tzXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJsb2NrU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgd29yZHNbb2Zmc2V0ICsgaV0gXj0gYmxvY2tbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gQ0JDO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBQYWRkaW5nIG5hbWVzcGFjZS5cbiAgICAgKi9cbiAgICB2YXIgQ19wYWQgPSBDLnBhZCA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogUEtDUyAjNS83IHBhZGRpbmcgc3RyYXRlZ3kuXG4gICAgICovXG4gICAgdmFyIFBrY3M3ID0gQ19wYWQuUGtjczcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQYWRzIGRhdGEgdXNpbmcgdGhlIGFsZ29yaXRobSBkZWZpbmVkIGluIFBLQ1MgIzUvNy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGRhdGEgVGhlIGRhdGEgdG8gcGFkLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gYmxvY2tTaXplIFRoZSBtdWx0aXBsZSB0aGF0IHRoZSBkYXRhIHNob3VsZCBiZSBwYWRkZWQgdG8uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIENyeXB0b0pTLnBhZC5Qa2NzNy5wYWQod29yZEFycmF5LCA0KTtcbiAgICAgICAgICovXG4gICAgICAgIHBhZDogZnVuY3Rpb24gKGRhdGEsIGJsb2NrU2l6ZSkge1xuICAgICAgICAgICAgLy8gU2hvcnRjdXRcbiAgICAgICAgICAgIHZhciBibG9ja1NpemVCeXRlcyA9IGJsb2NrU2l6ZSAqIDQ7XG5cbiAgICAgICAgICAgIC8vIENvdW50IHBhZGRpbmcgYnl0ZXNcbiAgICAgICAgICAgIHZhciBuUGFkZGluZ0J5dGVzID0gYmxvY2tTaXplQnl0ZXMgLSBkYXRhLnNpZ0J5dGVzICUgYmxvY2tTaXplQnl0ZXM7XG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSBwYWRkaW5nIHdvcmRcbiAgICAgICAgICAgIHZhciBwYWRkaW5nV29yZCA9IChuUGFkZGluZ0J5dGVzIDw8IDI0KSB8IChuUGFkZGluZ0J5dGVzIDw8IDE2KSB8IChuUGFkZGluZ0J5dGVzIDw8IDgpIHwgblBhZGRpbmdCeXRlcztcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIHBhZGRpbmdcbiAgICAgICAgICAgIHZhciBwYWRkaW5nV29yZHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgblBhZGRpbmdCeXRlczsgaSArPSA0KSB7XG4gICAgICAgICAgICAgICAgcGFkZGluZ1dvcmRzLnB1c2gocGFkZGluZ1dvcmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHBhZGRpbmcgPSBXb3JkQXJyYXkuY3JlYXRlKHBhZGRpbmdXb3JkcywgblBhZGRpbmdCeXRlcyk7XG5cbiAgICAgICAgICAgIC8vIEFkZCBwYWRkaW5nXG4gICAgICAgICAgICBkYXRhLmNvbmNhdChwYWRkaW5nKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVW5wYWRzIGRhdGEgdGhhdCBoYWQgYmVlbiBwYWRkZWQgdXNpbmcgdGhlIGFsZ29yaXRobSBkZWZpbmVkIGluIFBLQ1MgIzUvNy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGRhdGEgVGhlIGRhdGEgdG8gdW5wYWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIENyeXB0b0pTLnBhZC5Qa2NzNy51bnBhZCh3b3JkQXJyYXkpO1xuICAgICAgICAgKi9cbiAgICAgICAgdW5wYWQ6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAvLyBHZXQgbnVtYmVyIG9mIHBhZGRpbmcgYnl0ZXMgZnJvbSBsYXN0IGJ5dGVcbiAgICAgICAgICAgIHZhciBuUGFkZGluZ0J5dGVzID0gZGF0YS53b3Jkc1soZGF0YS5zaWdCeXRlcyAtIDEpID4+PiAyXSAmIDB4ZmY7XG5cbiAgICAgICAgICAgIC8vIFJlbW92ZSBwYWRkaW5nXG4gICAgICAgICAgICBkYXRhLnNpZ0J5dGVzIC09IG5QYWRkaW5nQnl0ZXM7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWJzdHJhY3QgYmFzZSBibG9jayBjaXBoZXIgdGVtcGxhdGUuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYmxvY2tTaXplIFRoZSBudW1iZXIgb2YgMzItYml0IHdvcmRzIHRoaXMgY2lwaGVyIG9wZXJhdGVzIG9uLiBEZWZhdWx0OiA0ICgxMjggYml0cylcbiAgICAgKi9cbiAgICB2YXIgQmxvY2tDaXBoZXIgPSBDX2xpYi5CbG9ja0NpcGhlciA9IENpcGhlci5leHRlbmQoe1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkge01vZGV9IG1vZGUgVGhlIGJsb2NrIG1vZGUgdG8gdXNlLiBEZWZhdWx0OiBDQkNcbiAgICAgICAgICogQHByb3BlcnR5IHtQYWRkaW5nfSBwYWRkaW5nIFRoZSBwYWRkaW5nIHN0cmF0ZWd5IHRvIHVzZS4gRGVmYXVsdDogUGtjczdcbiAgICAgICAgICovXG4gICAgICAgIGNmZzogQ2lwaGVyLmNmZy5leHRlbmQoe1xuICAgICAgICAgICAgbW9kZTogQ0JDLFxuICAgICAgICAgICAgcGFkZGluZzogUGtjczdcbiAgICAgICAgfSksXG5cbiAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIFJlc2V0IGNpcGhlclxuICAgICAgICAgICAgQ2lwaGVyLnJlc2V0LmNhbGwodGhpcyk7XG5cbiAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuICAgICAgICAgICAgdmFyIGNmZyA9IHRoaXMuY2ZnO1xuICAgICAgICAgICAgdmFyIGl2ID0gY2ZnLml2O1xuICAgICAgICAgICAgdmFyIG1vZGUgPSBjZmcubW9kZTtcblxuICAgICAgICAgICAgLy8gUmVzZXQgYmxvY2sgbW9kZVxuICAgICAgICAgICAgaWYgKHRoaXMuX3hmb3JtTW9kZSA9PSB0aGlzLl9FTkNfWEZPUk1fTU9ERSkge1xuICAgICAgICAgICAgICAgIHZhciBtb2RlQ3JlYXRvciA9IG1vZGUuY3JlYXRlRW5jcnlwdG9yO1xuICAgICAgICAgICAgfSBlbHNlIC8qIGlmICh0aGlzLl94Zm9ybU1vZGUgPT0gdGhpcy5fREVDX1hGT1JNX01PREUpICovIHtcbiAgICAgICAgICAgICAgICB2YXIgbW9kZUNyZWF0b3IgPSBtb2RlLmNyZWF0ZURlY3J5cHRvcjtcblxuICAgICAgICAgICAgICAgIC8vIEtlZXAgYXQgbGVhc3Qgb25lIGJsb2NrIGluIHRoZSBidWZmZXIgZm9yIHVucGFkZGluZ1xuICAgICAgICAgICAgICAgIHRoaXMuX21pbkJ1ZmZlclNpemUgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbW9kZSA9IG1vZGVDcmVhdG9yLmNhbGwobW9kZSwgdGhpcywgaXYgJiYgaXYud29yZHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9kb1Byb2Nlc3NCbG9jazogZnVuY3Rpb24gKHdvcmRzLCBvZmZzZXQpIHtcbiAgICAgICAgICAgIHRoaXMuX21vZGUucHJvY2Vzc0Jsb2NrKHdvcmRzLCBvZmZzZXQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9kb0ZpbmFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBTaG9ydGN1dFxuICAgICAgICAgICAgdmFyIHBhZGRpbmcgPSB0aGlzLmNmZy5wYWRkaW5nO1xuXG4gICAgICAgICAgICAvLyBGaW5hbGl6ZVxuICAgICAgICAgICAgaWYgKHRoaXMuX3hmb3JtTW9kZSA9PSB0aGlzLl9FTkNfWEZPUk1fTU9ERSkge1xuICAgICAgICAgICAgICAgIC8vIFBhZCBkYXRhXG4gICAgICAgICAgICAgICAgcGFkZGluZy5wYWQodGhpcy5fZGF0YSwgdGhpcy5ibG9ja1NpemUpO1xuXG4gICAgICAgICAgICAgICAgLy8gUHJvY2VzcyBmaW5hbCBibG9ja3NcbiAgICAgICAgICAgICAgICB2YXIgZmluYWxQcm9jZXNzZWRCbG9ja3MgPSB0aGlzLl9wcm9jZXNzKCEhJ2ZsdXNoJyk7XG4gICAgICAgICAgICB9IGVsc2UgLyogaWYgKHRoaXMuX3hmb3JtTW9kZSA9PSB0aGlzLl9ERUNfWEZPUk1fTU9ERSkgKi8ge1xuICAgICAgICAgICAgICAgIC8vIFByb2Nlc3MgZmluYWwgYmxvY2tzXG4gICAgICAgICAgICAgICAgdmFyIGZpbmFsUHJvY2Vzc2VkQmxvY2tzID0gdGhpcy5fcHJvY2VzcyghISdmbHVzaCcpO1xuXG4gICAgICAgICAgICAgICAgLy8gVW5wYWQgZGF0YVxuICAgICAgICAgICAgICAgIHBhZGRpbmcudW5wYWQoZmluYWxQcm9jZXNzZWRCbG9ja3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmluYWxQcm9jZXNzZWRCbG9ja3M7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYmxvY2tTaXplOiAxMjgvMzJcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEEgY29sbGVjdGlvbiBvZiBjaXBoZXIgcGFyYW1ldGVycy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB7V29yZEFycmF5fSBjaXBoZXJ0ZXh0IFRoZSByYXcgY2lwaGVydGV4dC5cbiAgICAgKiBAcHJvcGVydHkge1dvcmRBcnJheX0ga2V5IFRoZSBrZXkgdG8gdGhpcyBjaXBoZXJ0ZXh0LlxuICAgICAqIEBwcm9wZXJ0eSB7V29yZEFycmF5fSBpdiBUaGUgSVYgdXNlZCBpbiB0aGUgY2lwaGVyaW5nIG9wZXJhdGlvbi5cbiAgICAgKiBAcHJvcGVydHkge1dvcmRBcnJheX0gc2FsdCBUaGUgc2FsdCB1c2VkIHdpdGggYSBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbi5cbiAgICAgKiBAcHJvcGVydHkge0NpcGhlcn0gYWxnb3JpdGhtIFRoZSBjaXBoZXIgYWxnb3JpdGhtLlxuICAgICAqIEBwcm9wZXJ0eSB7TW9kZX0gbW9kZSBUaGUgYmxvY2sgbW9kZSB1c2VkIGluIHRoZSBjaXBoZXJpbmcgb3BlcmF0aW9uLlxuICAgICAqIEBwcm9wZXJ0eSB7UGFkZGluZ30gcGFkZGluZyBUaGUgcGFkZGluZyBzY2hlbWUgdXNlZCBpbiB0aGUgY2lwaGVyaW5nIG9wZXJhdGlvbi5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYmxvY2tTaXplIFRoZSBibG9jayBzaXplIG9mIHRoZSBjaXBoZXIuXG4gICAgICogQHByb3BlcnR5IHtGb3JtYXR9IGZvcm1hdHRlciBUaGUgZGVmYXVsdCBmb3JtYXR0aW5nIHN0cmF0ZWd5IHRvIGNvbnZlcnQgdGhpcyBjaXBoZXIgcGFyYW1zIG9iamVjdCB0byBhIHN0cmluZy5cbiAgICAgKi9cbiAgICB2YXIgQ2lwaGVyUGFyYW1zID0gQ19saWIuQ2lwaGVyUGFyYW1zID0gQmFzZS5leHRlbmQoe1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2lwaGVyUGFyYW1zIEFuIG9iamVjdCB3aXRoIGFueSBvZiB0aGUgcG9zc2libGUgY2lwaGVyIHBhcmFtZXRlcnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgY2lwaGVyUGFyYW1zID0gQ3J5cHRvSlMubGliLkNpcGhlclBhcmFtcy5jcmVhdGUoe1xuICAgICAgICAgKiAgICAgICAgIGNpcGhlcnRleHQ6IGNpcGhlcnRleHRXb3JkQXJyYXksXG4gICAgICAgICAqICAgICAgICAga2V5OiBrZXlXb3JkQXJyYXksXG4gICAgICAgICAqICAgICAgICAgaXY6IGl2V29yZEFycmF5LFxuICAgICAgICAgKiAgICAgICAgIHNhbHQ6IHNhbHRXb3JkQXJyYXksXG4gICAgICAgICAqICAgICAgICAgYWxnb3JpdGhtOiBDcnlwdG9KUy5hbGdvLkFFUyxcbiAgICAgICAgICogICAgICAgICBtb2RlOiBDcnlwdG9KUy5tb2RlLkNCQyxcbiAgICAgICAgICogICAgICAgICBwYWRkaW5nOiBDcnlwdG9KUy5wYWQuUEtDUzcsXG4gICAgICAgICAqICAgICAgICAgYmxvY2tTaXplOiA0LFxuICAgICAgICAgKiAgICAgICAgIGZvcm1hdHRlcjogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0xcbiAgICAgICAgICogICAgIH0pO1xuICAgICAgICAgKi9cbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKGNpcGhlclBhcmFtcykge1xuICAgICAgICAgICAgdGhpcy5taXhJbihjaXBoZXJQYXJhbXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIGNpcGhlciBwYXJhbXMgb2JqZWN0IHRvIGEgc3RyaW5nLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0Zvcm1hdH0gZm9ybWF0dGVyIChPcHRpb25hbCkgVGhlIGZvcm1hdHRpbmcgc3RyYXRlZ3kgdG8gdXNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBzdHJpbmdpZmllZCBjaXBoZXIgcGFyYW1zLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdGhyb3dzIEVycm9yIElmIG5laXRoZXIgdGhlIGZvcm1hdHRlciBub3IgdGhlIGRlZmF1bHQgZm9ybWF0dGVyIGlzIHNldC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciBzdHJpbmcgPSBjaXBoZXJQYXJhbXMgKyAnJztcbiAgICAgICAgICogICAgIHZhciBzdHJpbmcgPSBjaXBoZXJQYXJhbXMudG9TdHJpbmcoKTtcbiAgICAgICAgICogICAgIHZhciBzdHJpbmcgPSBjaXBoZXJQYXJhbXMudG9TdHJpbmcoQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wpO1xuICAgICAgICAgKi9cbiAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uIChmb3JtYXR0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiAoZm9ybWF0dGVyIHx8IHRoaXMuZm9ybWF0dGVyKS5zdHJpbmdpZnkodGhpcyk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEZvcm1hdCBuYW1lc3BhY2UuXG4gICAgICovXG4gICAgdmFyIENfZm9ybWF0ID0gQy5mb3JtYXQgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIE9wZW5TU0wgZm9ybWF0dGluZyBzdHJhdGVneS5cbiAgICAgKi9cbiAgICB2YXIgT3BlblNTTEZvcm1hdHRlciA9IENfZm9ybWF0Lk9wZW5TU0wgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyBhIGNpcGhlciBwYXJhbXMgb2JqZWN0IHRvIGFuIE9wZW5TU0wtY29tcGF0aWJsZSBzdHJpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyUGFyYW1zfSBjaXBoZXJQYXJhbXMgVGhlIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBPcGVuU1NMLWNvbXBhdGlibGUgc3RyaW5nLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgb3BlblNTTFN0cmluZyA9IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMLnN0cmluZ2lmeShjaXBoZXJQYXJhbXMpO1xuICAgICAgICAgKi9cbiAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAoY2lwaGVyUGFyYW1zKSB7XG4gICAgICAgICAgICAvLyBTaG9ydGN1dHNcbiAgICAgICAgICAgIHZhciBjaXBoZXJ0ZXh0ID0gY2lwaGVyUGFyYW1zLmNpcGhlcnRleHQ7XG4gICAgICAgICAgICB2YXIgc2FsdCA9IGNpcGhlclBhcmFtcy5zYWx0O1xuXG4gICAgICAgICAgICAvLyBGb3JtYXRcbiAgICAgICAgICAgIGlmIChzYWx0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHdvcmRBcnJheSA9IFdvcmRBcnJheS5jcmVhdGUoWzB4NTM2MTZjNzQsIDB4NjU2NDVmNWZdKS5jb25jYXQoc2FsdCkuY29uY2F0KGNpcGhlcnRleHQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgd29yZEFycmF5ID0gY2lwaGVydGV4dDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHdvcmRBcnJheS50b1N0cmluZyhCYXNlNjQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyBhbiBPcGVuU1NMLWNvbXBhdGlibGUgc3RyaW5nIHRvIGEgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcGVuU1NMU3RyIFRoZSBPcGVuU1NMLWNvbXBhdGlibGUgc3RyaW5nLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJQYXJhbXN9IFRoZSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIGNpcGhlclBhcmFtcyA9IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMLnBhcnNlKG9wZW5TU0xTdHJpbmcpO1xuICAgICAgICAgKi9cbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChvcGVuU1NMU3RyKSB7XG4gICAgICAgICAgICAvLyBQYXJzZSBiYXNlNjRcbiAgICAgICAgICAgIHZhciBjaXBoZXJ0ZXh0ID0gQmFzZTY0LnBhcnNlKG9wZW5TU0xTdHIpO1xuXG4gICAgICAgICAgICAvLyBTaG9ydGN1dFxuICAgICAgICAgICAgdmFyIGNpcGhlcnRleHRXb3JkcyA9IGNpcGhlcnRleHQud29yZHM7XG5cbiAgICAgICAgICAgIC8vIFRlc3QgZm9yIHNhbHRcbiAgICAgICAgICAgIGlmIChjaXBoZXJ0ZXh0V29yZHNbMF0gPT0gMHg1MzYxNmM3NCAmJiBjaXBoZXJ0ZXh0V29yZHNbMV0gPT0gMHg2NTY0NWY1Zikge1xuICAgICAgICAgICAgICAgIC8vIEV4dHJhY3Qgc2FsdFxuICAgICAgICAgICAgICAgIHZhciBzYWx0ID0gV29yZEFycmF5LmNyZWF0ZShjaXBoZXJ0ZXh0V29yZHMuc2xpY2UoMiwgNCkpO1xuXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHNhbHQgZnJvbSBjaXBoZXJ0ZXh0XG4gICAgICAgICAgICAgICAgY2lwaGVydGV4dFdvcmRzLnNwbGljZSgwLCA0KTtcbiAgICAgICAgICAgICAgICBjaXBoZXJ0ZXh0LnNpZ0J5dGVzIC09IDE2O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gQ2lwaGVyUGFyYW1zLmNyZWF0ZSh7IGNpcGhlcnRleHQ6IGNpcGhlcnRleHQsIHNhbHQ6IHNhbHQgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQSBjaXBoZXIgd3JhcHBlciB0aGF0IHJldHVybnMgY2lwaGVydGV4dCBhcyBhIHNlcmlhbGl6YWJsZSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cbiAgICAgKi9cbiAgICB2YXIgU2VyaWFsaXphYmxlQ2lwaGVyID0gQ19saWIuU2VyaWFsaXphYmxlQ2lwaGVyID0gQmFzZS5leHRlbmQoe1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkge0Zvcm1hdHRlcn0gZm9ybWF0IFRoZSBmb3JtYXR0aW5nIHN0cmF0ZWd5IHRvIGNvbnZlcnQgY2lwaGVyIHBhcmFtIG9iamVjdHMgdG8gYW5kIGZyb20gYSBzdHJpbmcuIERlZmF1bHQ6IE9wZW5TU0xcbiAgICAgICAgICovXG4gICAgICAgIGNmZzogQmFzZS5leHRlbmQoe1xuICAgICAgICAgICAgZm9ybWF0OiBPcGVuU1NMRm9ybWF0dGVyXG4gICAgICAgIH0pLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNyeXB0cyBhIG1lc3NhZ2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgVGhlIGNpcGhlciBhbGdvcml0aG0gdG8gdXNlLlxuICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gZW5jcnlwdC5cbiAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGtleSBUaGUga2V5LlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJQYXJhbXN9IEEgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0UGFyYW1zID0gQ3J5cHRvSlMubGliLlNlcmlhbGl6YWJsZUNpcGhlci5lbmNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBtZXNzYWdlLCBrZXkpO1xuICAgICAgICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyLmVuY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIG1lc3NhZ2UsIGtleSwgeyBpdjogaXYgfSk7XG4gICAgICAgICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5TZXJpYWxpemFibGVDaXBoZXIuZW5jcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgbWVzc2FnZSwga2V5LCB7IGl2OiBpdiwgZm9ybWF0OiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCB9KTtcbiAgICAgICAgICovXG4gICAgICAgIGVuY3J5cHQ6IGZ1bmN0aW9uIChjaXBoZXIsIG1lc3NhZ2UsIGtleSwgY2ZnKSB7XG4gICAgICAgICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcbiAgICAgICAgICAgIGNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xuXG4gICAgICAgICAgICAvLyBFbmNyeXB0XG4gICAgICAgICAgICB2YXIgZW5jcnlwdG9yID0gY2lwaGVyLmNyZWF0ZUVuY3J5cHRvcihrZXksIGNmZyk7XG4gICAgICAgICAgICB2YXIgY2lwaGVydGV4dCA9IGVuY3J5cHRvci5maW5hbGl6ZShtZXNzYWdlKTtcblxuICAgICAgICAgICAgLy8gU2hvcnRjdXRcbiAgICAgICAgICAgIHZhciBjaXBoZXJDZmcgPSBlbmNyeXB0b3IuY2ZnO1xuXG4gICAgICAgICAgICAvLyBDcmVhdGUgYW5kIHJldHVybiBzZXJpYWxpemFibGUgY2lwaGVyIHBhcmFtc1xuICAgICAgICAgICAgcmV0dXJuIENpcGhlclBhcmFtcy5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIGNpcGhlcnRleHQ6IGNpcGhlcnRleHQsXG4gICAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgICAgaXY6IGNpcGhlckNmZy5pdixcbiAgICAgICAgICAgICAgICBhbGdvcml0aG06IGNpcGhlcixcbiAgICAgICAgICAgICAgICBtb2RlOiBjaXBoZXJDZmcubW9kZSxcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiBjaXBoZXJDZmcucGFkZGluZyxcbiAgICAgICAgICAgICAgICBibG9ja1NpemU6IGNpcGhlci5ibG9ja1NpemUsXG4gICAgICAgICAgICAgICAgZm9ybWF0dGVyOiBjZmcuZm9ybWF0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjcnlwdHMgc2VyaWFsaXplZCBjaXBoZXJ0ZXh0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIFRoZSBjaXBoZXIgYWxnb3JpdGhtIHRvIHVzZS5cbiAgICAgICAgICogQHBhcmFtIHtDaXBoZXJQYXJhbXN8c3RyaW5nfSBjaXBoZXJ0ZXh0IFRoZSBjaXBoZXJ0ZXh0IHRvIGRlY3J5cHQuXG4gICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBrZXkgVGhlIGtleS5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgcGxhaW50ZXh0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcGxhaW50ZXh0ID0gQ3J5cHRvSlMubGliLlNlcmlhbGl6YWJsZUNpcGhlci5kZWNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBmb3JtYXR0ZWRDaXBoZXJ0ZXh0LCBrZXksIHsgaXY6IGl2LCBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xuICAgICAgICAgKiAgICAgdmFyIHBsYWludGV4dCA9IENyeXB0b0pTLmxpYi5TZXJpYWxpemFibGVDaXBoZXIuZGVjcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgY2lwaGVydGV4dFBhcmFtcywga2V5LCB7IGl2OiBpdiwgZm9ybWF0OiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCB9KTtcbiAgICAgICAgICovXG4gICAgICAgIGRlY3J5cHQ6IGZ1bmN0aW9uIChjaXBoZXIsIGNpcGhlcnRleHQsIGtleSwgY2ZnKSB7XG4gICAgICAgICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcbiAgICAgICAgICAgIGNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xuXG4gICAgICAgICAgICAvLyBDb252ZXJ0IHN0cmluZyB0byBDaXBoZXJQYXJhbXNcbiAgICAgICAgICAgIGNpcGhlcnRleHQgPSB0aGlzLl9wYXJzZShjaXBoZXJ0ZXh0LCBjZmcuZm9ybWF0KTtcblxuICAgICAgICAgICAgLy8gRGVjcnlwdFxuICAgICAgICAgICAgdmFyIHBsYWludGV4dCA9IGNpcGhlci5jcmVhdGVEZWNyeXB0b3Ioa2V5LCBjZmcpLmZpbmFsaXplKGNpcGhlcnRleHQuY2lwaGVydGV4dCk7XG5cbiAgICAgICAgICAgIHJldHVybiBwbGFpbnRleHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIHNlcmlhbGl6ZWQgY2lwaGVydGV4dCB0byBDaXBoZXJQYXJhbXMsXG4gICAgICAgICAqIGVsc2UgYXNzdW1lZCBDaXBoZXJQYXJhbXMgYWxyZWFkeSBhbmQgcmV0dXJucyBjaXBoZXJ0ZXh0IHVuY2hhbmdlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtDaXBoZXJQYXJhbXN8c3RyaW5nfSBjaXBoZXJ0ZXh0IFRoZSBjaXBoZXJ0ZXh0LlxuICAgICAgICAgKiBAcGFyYW0ge0Zvcm1hdHRlcn0gZm9ybWF0IFRoZSBmb3JtYXR0aW5nIHN0cmF0ZWd5IHRvIHVzZSB0byBwYXJzZSBzZXJpYWxpemVkIGNpcGhlcnRleHQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0NpcGhlclBhcmFtc30gVGhlIHVuc2VyaWFsaXplZCBjaXBoZXJ0ZXh0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5TZXJpYWxpemFibGVDaXBoZXIuX3BhcnNlKGNpcGhlcnRleHRTdHJpbmdPclBhcmFtcywgZm9ybWF0KTtcbiAgICAgICAgICovXG4gICAgICAgIF9wYXJzZTogZnVuY3Rpb24gKGNpcGhlcnRleHQsIGZvcm1hdCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaXBoZXJ0ZXh0ID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdC5wYXJzZShjaXBoZXJ0ZXh0LCB0aGlzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNpcGhlcnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uIG5hbWVzcGFjZS5cbiAgICAgKi9cbiAgICB2YXIgQ19rZGYgPSBDLmtkZiA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogT3BlblNTTCBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICB2YXIgT3BlblNTTEtkZiA9IENfa2RmLk9wZW5TU0wgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXJpdmVzIGEga2V5IGFuZCBJViBmcm9tIGEgcGFzc3dvcmQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCBUaGUgcGFzc3dvcmQgdG8gZGVyaXZlIGZyb20uXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrZXlTaXplIFRoZSBzaXplIGluIHdvcmRzIG9mIHRoZSBrZXkgdG8gZ2VuZXJhdGUuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpdlNpemUgVGhlIHNpemUgaW4gd29yZHMgb2YgdGhlIElWIHRvIGdlbmVyYXRlLlxuICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IHNhbHQgKE9wdGlvbmFsKSBBIDY0LWJpdCBzYWx0IHRvIHVzZS4gSWYgb21pdHRlZCwgYSBzYWx0IHdpbGwgYmUgZ2VuZXJhdGVkIHJhbmRvbWx5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJQYXJhbXN9IEEgY2lwaGVyIHBhcmFtcyBvYmplY3Qgd2l0aCB0aGUga2V5LCBJViwgYW5kIHNhbHQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciBkZXJpdmVkUGFyYW1zID0gQ3J5cHRvSlMua2RmLk9wZW5TU0wuZXhlY3V0ZSgnUGFzc3dvcmQnLCAyNTYvMzIsIDEyOC8zMik7XG4gICAgICAgICAqICAgICB2YXIgZGVyaXZlZFBhcmFtcyA9IENyeXB0b0pTLmtkZi5PcGVuU1NMLmV4ZWN1dGUoJ1Bhc3N3b3JkJywgMjU2LzMyLCAxMjgvMzIsICdzYWx0c2FsdCcpO1xuICAgICAgICAgKi9cbiAgICAgICAgZXhlY3V0ZTogZnVuY3Rpb24gKHBhc3N3b3JkLCBrZXlTaXplLCBpdlNpemUsIHNhbHQpIHtcbiAgICAgICAgICAgIC8vIEdlbmVyYXRlIHJhbmRvbSBzYWx0XG4gICAgICAgICAgICBpZiAoIXNhbHQpIHtcbiAgICAgICAgICAgICAgICBzYWx0ID0gV29yZEFycmF5LnJhbmRvbSg2NC84KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRGVyaXZlIGtleSBhbmQgSVZcbiAgICAgICAgICAgIHZhciBrZXkgPSBFdnBLREYuY3JlYXRlKHsga2V5U2l6ZToga2V5U2l6ZSArIGl2U2l6ZSB9KS5jb21wdXRlKHBhc3N3b3JkLCBzYWx0KTtcblxuICAgICAgICAgICAgLy8gU2VwYXJhdGUga2V5IGFuZCBJVlxuICAgICAgICAgICAgdmFyIGl2ID0gV29yZEFycmF5LmNyZWF0ZShrZXkud29yZHMuc2xpY2Uoa2V5U2l6ZSksIGl2U2l6ZSAqIDQpO1xuICAgICAgICAgICAga2V5LnNpZ0J5dGVzID0ga2V5U2l6ZSAqIDQ7XG5cbiAgICAgICAgICAgIC8vIFJldHVybiBwYXJhbXNcbiAgICAgICAgICAgIHJldHVybiBDaXBoZXJQYXJhbXMuY3JlYXRlKHsga2V5OiBrZXksIGl2OiBpdiwgc2FsdDogc2FsdCB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBIHNlcmlhbGl6YWJsZSBjaXBoZXIgd3JhcHBlciB0aGF0IGRlcml2ZXMgdGhlIGtleSBmcm9tIGEgcGFzc3dvcmQsXG4gICAgICogYW5kIHJldHVybnMgY2lwaGVydGV4dCBhcyBhIHNlcmlhbGl6YWJsZSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cbiAgICAgKi9cbiAgICB2YXIgUGFzc3dvcmRCYXNlZENpcGhlciA9IENfbGliLlBhc3N3b3JkQmFzZWRDaXBoZXIgPSBTZXJpYWxpemFibGVDaXBoZXIuZXh0ZW5kKHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IHtLREZ9IGtkZiBUaGUga2V5IGRlcml2YXRpb24gZnVuY3Rpb24gdG8gdXNlIHRvIGdlbmVyYXRlIGEga2V5IGFuZCBJViBmcm9tIGEgcGFzc3dvcmQuIERlZmF1bHQ6IE9wZW5TU0xcbiAgICAgICAgICovXG4gICAgICAgIGNmZzogU2VyaWFsaXphYmxlQ2lwaGVyLmNmZy5leHRlbmQoe1xuICAgICAgICAgICAga2RmOiBPcGVuU1NMS2RmXG4gICAgICAgIH0pLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNyeXB0cyBhIG1lc3NhZ2UgdXNpbmcgYSBwYXNzd29yZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBUaGUgY2lwaGVyIGFsZ29yaXRobSB0byB1c2UuXG4gICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBlbmNyeXB0LlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgVGhlIHBhc3N3b3JkLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJQYXJhbXN9IEEgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0UGFyYW1zID0gQ3J5cHRvSlMubGliLlBhc3N3b3JkQmFzZWRDaXBoZXIuZW5jcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgbWVzc2FnZSwgJ3Bhc3N3b3JkJyk7XG4gICAgICAgICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5QYXNzd29yZEJhc2VkQ2lwaGVyLmVuY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIG1lc3NhZ2UsICdwYXNzd29yZCcsIHsgZm9ybWF0OiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCB9KTtcbiAgICAgICAgICovXG4gICAgICAgIGVuY3J5cHQ6IGZ1bmN0aW9uIChjaXBoZXIsIG1lc3NhZ2UsIHBhc3N3b3JkLCBjZmcpIHtcbiAgICAgICAgICAgIC8vIEFwcGx5IGNvbmZpZyBkZWZhdWx0c1xuICAgICAgICAgICAgY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XG5cbiAgICAgICAgICAgIC8vIERlcml2ZSBrZXkgYW5kIG90aGVyIHBhcmFtc1xuICAgICAgICAgICAgdmFyIGRlcml2ZWRQYXJhbXMgPSBjZmcua2RmLmV4ZWN1dGUocGFzc3dvcmQsIGNpcGhlci5rZXlTaXplLCBjaXBoZXIuaXZTaXplKTtcblxuICAgICAgICAgICAgLy8gQWRkIElWIHRvIGNvbmZpZ1xuICAgICAgICAgICAgY2ZnLml2ID0gZGVyaXZlZFBhcmFtcy5pdjtcblxuICAgICAgICAgICAgLy8gRW5jcnlwdFxuICAgICAgICAgICAgdmFyIGNpcGhlcnRleHQgPSBTZXJpYWxpemFibGVDaXBoZXIuZW5jcnlwdC5jYWxsKHRoaXMsIGNpcGhlciwgbWVzc2FnZSwgZGVyaXZlZFBhcmFtcy5rZXksIGNmZyk7XG5cbiAgICAgICAgICAgIC8vIE1peCBpbiBkZXJpdmVkIHBhcmFtc1xuICAgICAgICAgICAgY2lwaGVydGV4dC5taXhJbihkZXJpdmVkUGFyYW1zKTtcblxuICAgICAgICAgICAgcmV0dXJuIGNpcGhlcnRleHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY3J5cHRzIHNlcmlhbGl6ZWQgY2lwaGVydGV4dCB1c2luZyBhIHBhc3N3b3JkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIFRoZSBjaXBoZXIgYWxnb3JpdGhtIHRvIHVzZS5cbiAgICAgICAgICogQHBhcmFtIHtDaXBoZXJQYXJhbXN8c3RyaW5nfSBjaXBoZXJ0ZXh0IFRoZSBjaXBoZXJ0ZXh0IHRvIGRlY3J5cHQuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCBUaGUgcGFzc3dvcmQuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHBsYWludGV4dC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHBsYWludGV4dCA9IENyeXB0b0pTLmxpYi5QYXNzd29yZEJhc2VkQ2lwaGVyLmRlY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIGZvcm1hdHRlZENpcGhlcnRleHQsICdwYXNzd29yZCcsIHsgZm9ybWF0OiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCB9KTtcbiAgICAgICAgICogICAgIHZhciBwbGFpbnRleHQgPSBDcnlwdG9KUy5saWIuUGFzc3dvcmRCYXNlZENpcGhlci5kZWNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBjaXBoZXJ0ZXh0UGFyYW1zLCAncGFzc3dvcmQnLCB7IGZvcm1hdDogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wgfSk7XG4gICAgICAgICAqL1xuICAgICAgICBkZWNyeXB0OiBmdW5jdGlvbiAoY2lwaGVyLCBjaXBoZXJ0ZXh0LCBwYXNzd29yZCwgY2ZnKSB7XG4gICAgICAgICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcbiAgICAgICAgICAgIGNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xuXG4gICAgICAgICAgICAvLyBDb252ZXJ0IHN0cmluZyB0byBDaXBoZXJQYXJhbXNcbiAgICAgICAgICAgIGNpcGhlcnRleHQgPSB0aGlzLl9wYXJzZShjaXBoZXJ0ZXh0LCBjZmcuZm9ybWF0KTtcblxuICAgICAgICAgICAgLy8gRGVyaXZlIGtleSBhbmQgb3RoZXIgcGFyYW1zXG4gICAgICAgICAgICB2YXIgZGVyaXZlZFBhcmFtcyA9IGNmZy5rZGYuZXhlY3V0ZShwYXNzd29yZCwgY2lwaGVyLmtleVNpemUsIGNpcGhlci5pdlNpemUsIGNpcGhlcnRleHQuc2FsdCk7XG5cbiAgICAgICAgICAgIC8vIEFkZCBJViB0byBjb25maWdcbiAgICAgICAgICAgIGNmZy5pdiA9IGRlcml2ZWRQYXJhbXMuaXY7XG5cbiAgICAgICAgICAgIC8vIERlY3J5cHRcbiAgICAgICAgICAgIHZhciBwbGFpbnRleHQgPSBTZXJpYWxpemFibGVDaXBoZXIuZGVjcnlwdC5jYWxsKHRoaXMsIGNpcGhlciwgY2lwaGVydGV4dCwgZGVyaXZlZFBhcmFtcy5rZXksIGNmZyk7XG5cbiAgICAgICAgICAgIHJldHVybiBwbGFpbnRleHQ7XG4gICAgICAgIH1cbiAgICB9KTtcbn0oKSk7XG5cbihmdW5jdGlvbiAoKSB7XG4gICAgLy8gU2hvcnRjdXRzXG4gICAgdmFyIEMgPSBDcnlwdG9KUztcbiAgICB2YXIgQ19saWIgPSBDLmxpYjtcbiAgICB2YXIgQmxvY2tDaXBoZXIgPSBDX2xpYi5CbG9ja0NpcGhlcjtcbiAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXG4gICAgLy8gTG9va3VwIHRhYmxlc1xuICAgIHZhciBTQk9YID0gW107XG4gICAgdmFyIElOVl9TQk9YID0gW107XG4gICAgdmFyIFNVQl9NSVhfMCA9IFtdO1xuICAgIHZhciBTVUJfTUlYXzEgPSBbXTtcbiAgICB2YXIgU1VCX01JWF8yID0gW107XG4gICAgdmFyIFNVQl9NSVhfMyA9IFtdO1xuICAgIHZhciBJTlZfU1VCX01JWF8wID0gW107XG4gICAgdmFyIElOVl9TVUJfTUlYXzEgPSBbXTtcbiAgICB2YXIgSU5WX1NVQl9NSVhfMiA9IFtdO1xuICAgIHZhciBJTlZfU1VCX01JWF8zID0gW107XG5cbiAgICAvLyBDb21wdXRlIGxvb2t1cCB0YWJsZXNcbiAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBDb21wdXRlIGRvdWJsZSB0YWJsZVxuICAgICAgICB2YXIgZCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSA8IDEyOCkge1xuICAgICAgICAgICAgICAgIGRbaV0gPSBpIDw8IDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRbaV0gPSAoaSA8PCAxKSBeIDB4MTFiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2FsayBHRigyXjgpXG4gICAgICAgIHZhciB4ID0gMDtcbiAgICAgICAgdmFyIHhpID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgICAgICAgLy8gQ29tcHV0ZSBzYm94XG4gICAgICAgICAgICB2YXIgc3ggPSB4aSBeICh4aSA8PCAxKSBeICh4aSA8PCAyKSBeICh4aSA8PCAzKSBeICh4aSA8PCA0KTtcbiAgICAgICAgICAgIHN4ID0gKHN4ID4+PiA4KSBeIChzeCAmIDB4ZmYpIF4gMHg2MztcbiAgICAgICAgICAgIFNCT1hbeF0gPSBzeDtcbiAgICAgICAgICAgIElOVl9TQk9YW3N4XSA9IHg7XG5cbiAgICAgICAgICAgIC8vIENvbXB1dGUgbXVsdGlwbGljYXRpb25cbiAgICAgICAgICAgIHZhciB4MiA9IGRbeF07XG4gICAgICAgICAgICB2YXIgeDQgPSBkW3gyXTtcbiAgICAgICAgICAgIHZhciB4OCA9IGRbeDRdO1xuXG4gICAgICAgICAgICAvLyBDb21wdXRlIHN1YiBieXRlcywgbWl4IGNvbHVtbnMgdGFibGVzXG4gICAgICAgICAgICB2YXIgdCA9IChkW3N4XSAqIDB4MTAxKSBeIChzeCAqIDB4MTAxMDEwMCk7XG4gICAgICAgICAgICBTVUJfTUlYXzBbeF0gPSAodCA8PCAyNCkgfCAodCA+Pj4gOCk7XG4gICAgICAgICAgICBTVUJfTUlYXzFbeF0gPSAodCA8PCAxNikgfCAodCA+Pj4gMTYpO1xuICAgICAgICAgICAgU1VCX01JWF8yW3hdID0gKHQgPDwgOCkgIHwgKHQgPj4+IDI0KTtcbiAgICAgICAgICAgIFNVQl9NSVhfM1t4XSA9IHQ7XG5cbiAgICAgICAgICAgIC8vIENvbXB1dGUgaW52IHN1YiBieXRlcywgaW52IG1peCBjb2x1bW5zIHRhYmxlc1xuICAgICAgICAgICAgdmFyIHQgPSAoeDggKiAweDEwMTAxMDEpIF4gKHg0ICogMHgxMDAwMSkgXiAoeDIgKiAweDEwMSkgXiAoeCAqIDB4MTAxMDEwMCk7XG4gICAgICAgICAgICBJTlZfU1VCX01JWF8wW3N4XSA9ICh0IDw8IDI0KSB8ICh0ID4+PiA4KTtcbiAgICAgICAgICAgIElOVl9TVUJfTUlYXzFbc3hdID0gKHQgPDwgMTYpIHwgKHQgPj4+IDE2KTtcbiAgICAgICAgICAgIElOVl9TVUJfTUlYXzJbc3hdID0gKHQgPDwgOCkgIHwgKHQgPj4+IDI0KTtcbiAgICAgICAgICAgIElOVl9TVUJfTUlYXzNbc3hdID0gdDtcblxuICAgICAgICAgICAgLy8gQ29tcHV0ZSBuZXh0IGNvdW50ZXJcbiAgICAgICAgICAgIGlmICgheCkge1xuICAgICAgICAgICAgICAgIHggPSB4aSA9IDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHggPSB4MiBeIGRbZFtkW3g4IF4geDJdXV07XG4gICAgICAgICAgICAgICAgeGkgXj0gZFtkW3hpXV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KCkpO1xuXG4gICAgLy8gUHJlY29tcHV0ZWQgUmNvbiBsb29rdXBcbiAgICB2YXIgUkNPTiA9IFsweDAwLCAweDAxLCAweDAyLCAweDA0LCAweDA4LCAweDEwLCAweDIwLCAweDQwLCAweDgwLCAweDFiLCAweDM2XTtcblxuICAgIC8qKlxuICAgICAqIEFFUyBibG9jayBjaXBoZXIgYWxnb3JpdGhtLlxuICAgICAqL1xuICAgIHZhciBBRVMgPSBDX2FsZ28uQUVTID0gQmxvY2tDaXBoZXIuZXh0ZW5kKHtcbiAgICAgICAgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuICAgICAgICAgICAgdmFyIGtleSA9IHRoaXMuX2tleTtcbiAgICAgICAgICAgIHZhciBrZXlXb3JkcyA9IGtleS53b3JkcztcbiAgICAgICAgICAgIHZhciBrZXlTaXplID0ga2V5LnNpZ0J5dGVzIC8gNDtcblxuICAgICAgICAgICAgLy8gQ29tcHV0ZSBudW1iZXIgb2Ygcm91bmRzXG4gICAgICAgICAgICB2YXIgblJvdW5kcyA9IHRoaXMuX25Sb3VuZHMgPSBrZXlTaXplICsgNlxuXG4gICAgICAgICAgICAvLyBDb21wdXRlIG51bWJlciBvZiBrZXkgc2NoZWR1bGUgcm93c1xuICAgICAgICAgICAgdmFyIGtzUm93cyA9IChuUm91bmRzICsgMSkgKiA0O1xuXG4gICAgICAgICAgICAvLyBDb21wdXRlIGtleSBzY2hlZHVsZVxuICAgICAgICAgICAgdmFyIGtleVNjaGVkdWxlID0gdGhpcy5fa2V5U2NoZWR1bGUgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGtzUm93ID0gMDsga3NSb3cgPCBrc1Jvd3M7IGtzUm93KyspIHtcbiAgICAgICAgICAgICAgICBpZiAoa3NSb3cgPCBrZXlTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleVNjaGVkdWxlW2tzUm93XSA9IGtleVdvcmRzW2tzUm93XTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGtleVNjaGVkdWxlW2tzUm93IC0gMV07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoa3NSb3cgJSBrZXlTaXplKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUm90IHdvcmRcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSAodCA8PCA4KSB8ICh0ID4+PiAyNCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1YiB3b3JkXG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gKFNCT1hbdCA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyh0ID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsodCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbdCAmIDB4ZmZdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNaXggUmNvblxuICAgICAgICAgICAgICAgICAgICAgICAgdCBePSBSQ09OWyhrc1JvdyAvIGtleVNpemUpIHwgMF0gPDwgMjQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5U2l6ZSA+IDYgJiYga3NSb3cgJSBrZXlTaXplID09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1YiB3b3JkXG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gKFNCT1hbdCA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyh0ID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsodCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbdCAmIDB4ZmZdO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAga2V5U2NoZWR1bGVba3NSb3ddID0ga2V5U2NoZWR1bGVba3NSb3cgLSBrZXlTaXplXSBeIHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDb21wdXRlIGludiBrZXkgc2NoZWR1bGVcbiAgICAgICAgICAgIHZhciBpbnZLZXlTY2hlZHVsZSA9IHRoaXMuX2ludktleVNjaGVkdWxlID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpbnZLc1JvdyA9IDA7IGludktzUm93IDwga3NSb3dzOyBpbnZLc1JvdysrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtzUm93ID0ga3NSb3dzIC0gaW52S3NSb3c7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW52S3NSb3cgJSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0ga2V5U2NoZWR1bGVba3NSb3ddO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0ga2V5U2NoZWR1bGVba3NSb3cgLSA0XTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaW52S3NSb3cgPCA0IHx8IGtzUm93IDw9IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID0gdDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPSBJTlZfU1VCX01JWF8wW1NCT1hbdCA+Pj4gMjRdXSBeIElOVl9TVUJfTUlYXzFbU0JPWFsodCA+Pj4gMTYpICYgMHhmZl1dIF5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSU5WX1NVQl9NSVhfMltTQk9YWyh0ID4+PiA4KSAmIDB4ZmZdXSBeIElOVl9TVUJfTUlYXzNbU0JPWFt0ICYgMHhmZl1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBlbmNyeXB0QmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcbiAgICAgICAgICAgIHRoaXMuX2RvQ3J5cHRCbG9jayhNLCBvZmZzZXQsIHRoaXMuX2tleVNjaGVkdWxlLCBTVUJfTUlYXzAsIFNVQl9NSVhfMSwgU1VCX01JWF8yLCBTVUJfTUlYXzMsIFNCT1gpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRlY3J5cHRCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xuICAgICAgICAgICAgLy8gU3dhcCAybmQgYW5kIDR0aCByb3dzXG4gICAgICAgICAgICB2YXIgdCA9IE1bb2Zmc2V0ICsgMV07XG4gICAgICAgICAgICBNW29mZnNldCArIDFdID0gTVtvZmZzZXQgKyAzXTtcbiAgICAgICAgICAgIE1bb2Zmc2V0ICsgM10gPSB0O1xuXG4gICAgICAgICAgICB0aGlzLl9kb0NyeXB0QmxvY2soTSwgb2Zmc2V0LCB0aGlzLl9pbnZLZXlTY2hlZHVsZSwgSU5WX1NVQl9NSVhfMCwgSU5WX1NVQl9NSVhfMSwgSU5WX1NVQl9NSVhfMiwgSU5WX1NVQl9NSVhfMywgSU5WX1NCT1gpO1xuXG4gICAgICAgICAgICAvLyBJbnYgc3dhcCAybmQgYW5kIDR0aCByb3dzXG4gICAgICAgICAgICB2YXIgdCA9IE1bb2Zmc2V0ICsgMV07XG4gICAgICAgICAgICBNW29mZnNldCArIDFdID0gTVtvZmZzZXQgKyAzXTtcbiAgICAgICAgICAgIE1bb2Zmc2V0ICsgM10gPSB0O1xuICAgICAgICB9LFxuXG4gICAgICAgIF9kb0NyeXB0QmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQsIGtleVNjaGVkdWxlLCBTVUJfTUlYXzAsIFNVQl9NSVhfMSwgU1VCX01JWF8yLCBTVUJfTUlYXzMsIFNCT1gpIHtcbiAgICAgICAgICAgIC8vIFNob3J0Y3V0XG4gICAgICAgICAgICB2YXIgblJvdW5kcyA9IHRoaXMuX25Sb3VuZHM7XG5cbiAgICAgICAgICAgIC8vIEdldCBpbnB1dCwgYWRkIHJvdW5kIGtleVxuICAgICAgICAgICAgdmFyIHMwID0gTVtvZmZzZXRdICAgICBeIGtleVNjaGVkdWxlWzBdO1xuICAgICAgICAgICAgdmFyIHMxID0gTVtvZmZzZXQgKyAxXSBeIGtleVNjaGVkdWxlWzFdO1xuICAgICAgICAgICAgdmFyIHMyID0gTVtvZmZzZXQgKyAyXSBeIGtleVNjaGVkdWxlWzJdO1xuICAgICAgICAgICAgdmFyIHMzID0gTVtvZmZzZXQgKyAzXSBeIGtleVNjaGVkdWxlWzNdO1xuXG4gICAgICAgICAgICAvLyBLZXkgc2NoZWR1bGUgcm93IGNvdW50ZXJcbiAgICAgICAgICAgIHZhciBrc1JvdyA9IDQ7XG5cbiAgICAgICAgICAgIC8vIFJvdW5kc1xuICAgICAgICAgICAgZm9yICh2YXIgcm91bmQgPSAxOyByb3VuZCA8IG5Sb3VuZHM7IHJvdW5kKyspIHtcbiAgICAgICAgICAgICAgICAvLyBTaGlmdCByb3dzLCBzdWIgYnl0ZXMsIG1peCBjb2x1bW5zLCBhZGQgcm91bmQga2V5XG4gICAgICAgICAgICAgICAgdmFyIHQwID0gU1VCX01JWF8wW3MwID4+PiAyNF0gXiBTVUJfTUlYXzFbKHMxID4+PiAxNikgJiAweGZmXSBeIFNVQl9NSVhfMlsoczIgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYXzNbczMgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xuICAgICAgICAgICAgICAgIHZhciB0MSA9IFNVQl9NSVhfMFtzMSA+Pj4gMjRdIF4gU1VCX01JWF8xWyhzMiA+Pj4gMTYpICYgMHhmZl0gXiBTVUJfTUlYXzJbKHMzID4+PiA4KSAmIDB4ZmZdIF4gU1VCX01JWF8zW3MwICYgMHhmZl0gXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcbiAgICAgICAgICAgICAgICB2YXIgdDIgPSBTVUJfTUlYXzBbczIgPj4+IDI0XSBeIFNVQl9NSVhfMVsoczMgPj4+IDE2KSAmIDB4ZmZdIF4gU1VCX01JWF8yWyhzMCA+Pj4gOCkgJiAweGZmXSBeIFNVQl9NSVhfM1tzMSAmIDB4ZmZdIF4ga2V5U2NoZWR1bGVba3NSb3crK107XG4gICAgICAgICAgICAgICAgdmFyIHQzID0gU1VCX01JWF8wW3MzID4+PiAyNF0gXiBTVUJfTUlYXzFbKHMwID4+PiAxNikgJiAweGZmXSBeIFNVQl9NSVhfMlsoczEgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYXzNbczIgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xuXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHN0YXRlXG4gICAgICAgICAgICAgICAgczAgPSB0MDtcbiAgICAgICAgICAgICAgICBzMSA9IHQxO1xuICAgICAgICAgICAgICAgIHMyID0gdDI7XG4gICAgICAgICAgICAgICAgczMgPSB0MztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2hpZnQgcm93cywgc3ViIGJ5dGVzLCBhZGQgcm91bmQga2V5XG4gICAgICAgICAgICB2YXIgdDAgPSAoKFNCT1hbczAgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsoczEgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyhzMiA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbczMgJiAweGZmXSkgXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcbiAgICAgICAgICAgIHZhciB0MSA9ICgoU0JPWFtzMSA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyhzMiA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHMzID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFtzMCAmIDB4ZmZdKSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xuICAgICAgICAgICAgdmFyIHQyID0gKChTQk9YW3MyID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHMzID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsoczAgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3MxICYgMHhmZl0pIF4ga2V5U2NoZWR1bGVba3NSb3crK107XG4gICAgICAgICAgICB2YXIgdDMgPSAoKFNCT1hbczMgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsoczAgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyhzMSA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbczIgJiAweGZmXSkgXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcblxuICAgICAgICAgICAgLy8gU2V0IG91dHB1dFxuICAgICAgICAgICAgTVtvZmZzZXRdICAgICA9IHQwO1xuICAgICAgICAgICAgTVtvZmZzZXQgKyAxXSA9IHQxO1xuICAgICAgICAgICAgTVtvZmZzZXQgKyAyXSA9IHQyO1xuICAgICAgICAgICAgTVtvZmZzZXQgKyAzXSA9IHQzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGtleVNpemU6IDI1Ni8zMlxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogU2hvcnRjdXQgZnVuY3Rpb25zIHRvIHRoZSBjaXBoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICB2YXIgY2lwaGVydGV4dCA9IENyeXB0b0pTLkFFUy5lbmNyeXB0KG1lc3NhZ2UsIGtleSwgY2ZnKTtcbiAgICAgKiAgICAgdmFyIHBsYWludGV4dCAgPSBDcnlwdG9KUy5BRVMuZGVjcnlwdChjaXBoZXJ0ZXh0LCBrZXksIGNmZyk7XG4gICAgICovXG4gICAgQy5BRVMgPSBCbG9ja0NpcGhlci5fY3JlYXRlSGVscGVyKEFFUyk7XG59KCkpO1xuXG4oZnVuY3Rpb24gKCkge1xuICAgIC8vIENoZWNrIGlmIHR5cGVkIGFycmF5cyBhcmUgc3VwcG9ydGVkXG4gICAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFNob3J0Y3V0c1xuICAgIHZhciBDID0gQ3J5cHRvSlM7XG4gICAgdmFyIENfbGliID0gQy5saWI7XG4gICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcblxuICAgIC8vIFJlZmVyZW5jZSBvcmlnaW5hbCBpbml0XG4gICAgdmFyIHN1cGVySW5pdCA9IFdvcmRBcnJheS5pbml0O1xuXG4gICAgLy8gQXVnbWVudCBXb3JkQXJyYXkuaW5pdCB0byBoYW5kbGUgdHlwZWQgYXJyYXlzXG4gICAgdmFyIHN1YkluaXQgPSBXb3JkQXJyYXkuaW5pdCA9IGZ1bmN0aW9uICh0eXBlZEFycmF5KSB7XG4gICAgICAgIC8vIENvbnZlcnQgYnVmZmVycyB0byB1aW50OFxuICAgICAgICBpZiAodHlwZWRBcnJheSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICB0eXBlZEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodHlwZWRBcnJheSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb252ZXJ0IG90aGVyIGFycmF5IHZpZXdzIHRvIHVpbnQ4XG4gICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAgICAgdHlwZWRBcnJheSBpbnN0YW5jZW9mIEludDhBcnJheSB8fFxuICAgICAgICAgICAgKHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZWRBcnJheSBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5KSB8fFxuICAgICAgICAgICAgdHlwZWRBcnJheSBpbnN0YW5jZW9mIEludDE2QXJyYXkgfHxcbiAgICAgICAgICAgIHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBVaW50MTZBcnJheSB8fFxuICAgICAgICAgICAgdHlwZWRBcnJheSBpbnN0YW5jZW9mIEludDMyQXJyYXkgfHxcbiAgICAgICAgICAgIHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBVaW50MzJBcnJheSB8fFxuICAgICAgICAgICAgKHR5cGVvZiBGbG9hdDMyQXJyYXkgIT09ICd1bmRlZmluZWQnICYmIHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpIHx8XG4gICAgICAgICAgICAodHlwZW9mIEZsb2F0NjRBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZWRBcnJheSBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0eXBlZEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodHlwZWRBcnJheS5idWZmZXIsIHR5cGVkQXJyYXkuYnl0ZU9mZnNldCwgdHlwZWRBcnJheS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhhbmRsZSBVaW50OEFycmF5XG4gICAgICAgIGlmICh0eXBlZEFycmF5IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgLy8gU2hvcnRjdXRcbiAgICAgICAgICAgIHZhciB0eXBlZEFycmF5Qnl0ZUxlbmd0aCA9IHR5cGVkQXJyYXkuYnl0ZUxlbmd0aDtcblxuICAgICAgICAgICAgLy8gRXh0cmFjdCBieXRlc1xuICAgICAgICAgICAgdmFyIHdvcmRzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVkQXJyYXlCeXRlTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB3b3Jkc1tpID4+PiAyXSB8PSB0eXBlZEFycmF5W2ldIDw8ICgyNCAtIChpICUgNCkgKiA4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGlzIHdvcmQgYXJyYXlcbiAgICAgICAgICAgIHN1cGVySW5pdC5jYWxsKHRoaXMsIHdvcmRzLCB0eXBlZEFycmF5Qnl0ZUxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBFbHNlIGNhbGwgbm9ybWFsIGluaXRcbiAgICAgICAgICAgIHN1cGVySW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHN1YkluaXQucHJvdG90eXBlID0gV29yZEFycmF5O1xufSgpKTtcblxudmFyIERvbUV2ZW50ID0gKGZ1bmN0aW9uKCkge1xuXHRmdW5jdGlvbiBEb21FdmVudCgpIHt9XG5cblx0RG9tRXZlbnQuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0YXJnZXQsIGV2ZW50LCBsaXN0ZW5lcikge1xuXHRcdGlmKHRhcmdldC5hZGRFdmVudExpc3RlbmVyKSB7XG5cdFx0XHR0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGZhbHNlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFyZ2V0LmF0dGFjaEV2ZW50KCdvbicrZXZlbnQsIGZ1bmN0aW9uKCkgeyBsaXN0ZW5lci5hcHBseSh0YXJnZXQsIGFyZ3VtZW50cyk7IH0pO1xuXHRcdH1cblx0fTtcblxuXHREb21FdmVudC5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHRhcmdldCwgZXZlbnQsIGxpc3RlbmVyKSB7XG5cdFx0aWYodGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcblx0XHRcdHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXQuZGV0YWNoRXZlbnQoJ29uJytldmVudCwgZnVuY3Rpb24oKSB7IGxpc3RlbmVyLmFwcGx5KHRhcmdldCwgYXJndW1lbnRzKTsgfSk7XG5cdFx0fVxuXHR9O1xuXG5cdERvbUV2ZW50LmFkZE1lc3NhZ2VMaXN0ZW5lciA9IGZ1bmN0aW9uKHRhcmdldCwgbGlzdGVuZXIpIHtcblx0XHREb21FdmVudC5hZGRMaXN0ZW5lcih0YXJnZXQsICdtZXNzYWdlJywgbGlzdGVuZXIpO1xuXHR9O1xuXG5cdERvbUV2ZW50LnJlbW92ZU1lc3NhZ2VMaXN0ZW5lciA9IGZ1bmN0aW9uKHRhcmdldCwgbGlzdGVuZXIpIHtcblx0XHREb21FdmVudC5yZW1vdmVMaXN0ZW5lcih0YXJnZXQsICdtZXNzYWdlJywgbGlzdGVuZXIpO1xuXHR9O1xuXG5cdERvbUV2ZW50LmFkZFVubG9hZExpc3RlbmVyID0gZnVuY3Rpb24obGlzdGVuZXIpIHtcblx0XHREb21FdmVudC5hZGRMaXN0ZW5lcih3aW5kb3csICd1bmxvYWQnLCBsaXN0ZW5lcik7XG5cdH07XG5cblx0cmV0dXJuIERvbUV2ZW50O1xufSkoKTtcblxudmFyIG1zZ3BhY2sgPSAoZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdHZhciBleHBvcnRzID0ge307XG5cblx0ZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdDtcblx0ZnVuY3Rpb24gaW5zcGVjdChidWZmZXIpIHtcblx0XHRpZiAoYnVmZmVyID09PSB1bmRlZmluZWQpXG5cdFx0XHRyZXR1cm4gXCJ1bmRlZmluZWRcIjtcblx0XHR2YXIgdmlldztcblx0XHR2YXIgdHlwZTtcblx0XHRpZiAoIGJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG5cdFx0XHR0eXBlID0gXCJBcnJheUJ1ZmZlclwiO1xuXHRcdFx0dmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xuXHRcdH0gZWxzZSBpZiAoIGJ1ZmZlciBpbnN0YW5jZW9mIERhdGFWaWV3KSB7XG5cdFx0XHR0eXBlID0gXCJEYXRhVmlld1wiO1xuXHRcdFx0dmlldyA9IGJ1ZmZlcjtcblx0XHR9XG5cdFx0aWYgKCF2aWV3KVxuXHRcdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KGJ1ZmZlcik7XG5cdFx0dmFyIGJ5dGVzID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXIuYnl0ZUxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAoaSA+IDIwKSB7XG5cdFx0XHRcdGJ5dGVzLnB1c2goXCIuLi5cIik7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGJ5dGVfID0gdmlldy5nZXRVaW50OChpKS50b1N0cmluZygxNik7XG5cdFx0XHRpZiAoYnl0ZV8ubGVuZ3RoID09PSAxKVxuXHRcdFx0XHRieXRlXyA9IFwiMFwiICsgYnl0ZV87XG5cdFx0XHRieXRlcy5wdXNoKGJ5dGVfKTtcblx0XHR9XG5cdFx0cmV0dXJuIFwiPFwiICsgdHlwZSArIFwiIFwiICsgYnl0ZXMuam9pbihcIiBcIikgKyBcIj5cIjtcblx0fVxuXG5cdC8vIEVuY29kZSBzdHJpbmcgYXMgdXRmOCBpbnRvIGRhdGF2aWV3IGF0IG9mZnNldFxuXHRleHBvcnRzLnV0ZjhXcml0ZSA9IHV0ZjhXcml0ZTtcblx0ZnVuY3Rpb24gdXRmOFdyaXRlKHZpZXcsIG9mZnNldCwgc3RyaW5nKSB7XG5cdFx0dmFyIGJ5dGVMZW5ndGggPSB2aWV3LmJ5dGVMZW5ndGg7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzdHJpbmcubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG5cblx0XHRcdC8vIE9uZSBieXRlIG9mIFVURi04XG5cdFx0XHRpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuXHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBjb2RlUG9pbnQgPj4+IDAgJiAweDdmIHwgMHgwMCk7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUd28gYnl0ZXMgb2YgVVRGLThcblx0XHRcdGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuXHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBjb2RlUG9pbnQgPj4+IDYgJiAweDFmIHwgMHhjMCk7XG5cdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGNvZGVQb2ludCA+Pj4gMCAmIDB4M2YgfCAweDgwKTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRocmVlIGJ5dGVzIG9mIFVURi04LlxuXHRcdFx0aWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcblx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQrKywgY29kZVBvaW50ID4+PiAxMiAmIDB4MGYgfCAweGUwKTtcblx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQrKywgY29kZVBvaW50ID4+PiA2ICYgMHgzZiB8IDB4ODApO1xuXHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBjb2RlUG9pbnQgPj4+IDAgJiAweDNmIHwgMHg4MCk7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGb3VyIGJ5dGVzIG9mIFVURi04XG5cdFx0XHRpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcblx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQrKywgY29kZVBvaW50ID4+PiAxOCAmIDB4MDcgfCAweGYwKTtcblx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQrKywgY29kZVBvaW50ID4+PiAxMiAmIDB4M2YgfCAweDgwKTtcblx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQrKywgY29kZVBvaW50ID4+PiA2ICYgMHgzZiB8IDB4ODApO1xuXHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBjb2RlUG9pbnQgPj4+IDAgJiAweDNmIHwgMHg4MCk7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiYmFkIGNvZGVwb2ludCBcIiArIGNvZGVQb2ludCk7XG5cdFx0fVxuXHR9XG5cblxuXHRleHBvcnRzLnV0ZjhSZWFkID0gdXRmOFJlYWQ7XG5cdGZ1bmN0aW9uIHV0ZjhSZWFkKHZpZXcsIG9mZnNldCwgbGVuZ3RoKSB7XG5cdFx0dmFyIHN0cmluZyA9IFwiXCI7XG5cdFx0Zm9yICh2YXIgaSA9IG9mZnNldCwgZW5kID0gb2Zmc2V0ICsgbGVuZ3RoOyBpIDwgZW5kOyBpKyspIHtcblx0XHRcdHZhciBieXRlXyA9IHZpZXcuZ2V0VWludDgoaSk7XG5cdFx0XHQvLyBPbmUgYnl0ZSBjaGFyYWN0ZXJcblx0XHRcdGlmICgoYnl0ZV8gJiAweDgwKSA9PT0gMHgwMCkge1xuXHRcdFx0XHRzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlXyk7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0Ly8gVHdvIGJ5dGUgY2hhcmFjdGVyXG5cdFx0XHRpZiAoKGJ5dGVfICYgMHhlMCkgPT09IDB4YzApIHtcblx0XHRcdFx0c3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChieXRlXyAmIDB4MGYpIDw8IDYpIHwgKHZpZXcuZ2V0VWludDgoKytpKSAmIDB4M2YpKTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHQvLyBUaHJlZSBieXRlIGNoYXJhY3RlclxuXHRcdFx0aWYgKChieXRlXyAmIDB4ZjApID09PSAweGUwKSB7XG5cdFx0XHRcdHN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYnl0ZV8gJiAweDBmKSA8PCAxMikgfCAoKHZpZXcuZ2V0VWludDgoKytpKSAmIDB4M2YpIDw8IDYpIHwgKCh2aWV3LmdldFVpbnQ4KCsraSkgJiAweDNmKSA8PCAwKSk7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0Ly8gRm91ciBieXRlIGNoYXJhY3RlclxuXHRcdFx0aWYgKChieXRlXyAmIDB4ZjgpID09PSAweGYwKSB7XG5cdFx0XHRcdHN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYnl0ZV8gJiAweDA3KSA8PCAxOCkgfCAoKHZpZXcuZ2V0VWludDgoKytpKSAmIDB4M2YpIDw8IDEyKSB8ICgodmlldy5nZXRVaW50OCgrK2kpICYgMHgzZikgPDwgNikgfCAoKHZpZXcuZ2V0VWludDgoKytpKSAmIDB4M2YpIDw8IDApKTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGJ5dGUgXCIgKyBieXRlXy50b1N0cmluZygxNikpO1xuXHRcdH1cblx0XHRyZXR1cm4gc3RyaW5nO1xuXHR9XG5cblxuXHRleHBvcnRzLnV0ZjhCeXRlQ291bnQgPSB1dGY4Qnl0ZUNvdW50O1xuXHRmdW5jdGlvbiB1dGY4Qnl0ZUNvdW50KHN0cmluZykge1xuXHRcdHZhciBjb3VudCA9IDA7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzdHJpbmcubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG5cdFx0XHRpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuXHRcdFx0XHRjb3VudCArPSAxO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuXHRcdFx0XHRjb3VudCArPSAyO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG5cdFx0XHRcdGNvdW50ICs9IDM7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG5cdFx0XHRcdGNvdW50ICs9IDQ7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiYmFkIGNvZGVwb2ludCBcIiArIGNvZGVQb2ludCk7XG5cdFx0fVxuXHRcdHJldHVybiBjb3VudDtcblx0fVxuXG5cblx0ZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbih2YWx1ZSwgc3BhcnNlKSB7XG5cdFx0dmFyIHNpemUgPSBzaXplb2YodmFsdWUsIHNwYXJzZSk7XG5cdFx0aWYoc2l6ZSA9PSAwKVxuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHR2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHNpemUpO1xuXHRcdHZhciB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG5cdFx0ZW5jb2RlKHZhbHVlLCB2aWV3LCAwLCBzcGFyc2UpO1xuXHRcdHJldHVybiBidWZmZXI7XG5cdH07XG5cblx0ZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG5cblx0dmFyIFNIX0xfMzIgPSAoMSA8PCAxNikgKiAoMSA8PCAxNiksIFNIX1JfMzIgPSAxIC8gU0hfTF8zMjtcblx0ZnVuY3Rpb24gZ2V0SW50NjQodmlldywgb2Zmc2V0KSB7XG5cdFx0b2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG5cdFx0cmV0dXJuIHZpZXcuZ2V0SW50MzIob2Zmc2V0KSAqIFNIX0xfMzIgKyB2aWV3LmdldFVpbnQzMihvZmZzZXQgKyA0KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldFVpbnQ2NCh2aWV3LCBvZmZzZXQpIHtcblx0XHRvZmZzZXQgPSBvZmZzZXQgfHwgMDtcblx0XHRyZXR1cm4gdmlldy5nZXRVaW50MzIob2Zmc2V0KSAqIFNIX0xfMzIgKyB2aWV3LmdldFVpbnQzMihvZmZzZXQgKyA0KTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNldEludDY0KHZpZXcsIG9mZnNldCwgdmFsKSB7XG5cdFx0aWYgKHZhbCA8IDB4ODAwMDAwMDAwMDAwMDAwMCkge1xuXHRcdFx0dmlldy5zZXRJbnQzMihvZmZzZXQsIE1hdGguZmxvb3IodmFsICogU0hfUl8zMikpO1xuXHRcdFx0dmlldy5zZXRJbnQzMihvZmZzZXQgKyA0LCB2YWwgJiAtMSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZpZXcuc2V0VWludDMyKG9mZnNldCwgMHg3ZmZmZmZmZik7XG5cdFx0XHR2aWV3LnNldFVpbnQzMihvZmZzZXQgKyA0LCAweDdmZmZmZmZmKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBzZXRVaW50NjQodmlldywgb2Zmc2V0LCB2YWwpIHtcblx0XHRpZiAodmFsIDwgMHgxMDAwMDAwMDAwMDAwMDAwMCkge1xuXHRcdFx0dmlldy5zZXRVaW50MzIob2Zmc2V0LCBNYXRoLmZsb29yKHZhbCAqIFNIX1JfMzIpKTtcblx0XHRcdHZpZXcuc2V0SW50MzIob2Zmc2V0ICsgNCwgdmFsICYgLTEpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2aWV3LnNldFVpbnQzMihvZmZzZXQsIDB4ZmZmZmZmZmYpO1xuXHRcdFx0dmlldy5zZXRVaW50MzIob2Zmc2V0ICsgNCwgMHhmZmZmZmZmZik7XG5cdFx0fVxuXHR9XG5cbi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2Zyc3l1a2kvNTQzMjU1OSAtIHY1IHNwZWNcbi8vXG4vLyBJJ3ZlIHVzZWQgb25lIGV4dGVuc2lvbiBwb2ludCBmcm9tIGBmaXhleHQgMWAgdG8gc3RvcmUgYHVuZGVmaW5lZGAuIE9uIHRoZSB3aXJlIHRoaXNcbi8vIHNob3VsZCB0cmFuc2xhdGUgdG8gZXhhY3RseSAweGQ0MDAwMFxuLy9cbi8vICstLS0tLS0tLSstLS0tLS0tLSstLS0tLS0tLStcbi8vIHwgIDB4ZDQgIHwgIDB4MDAgIHwgIDB4MDAgIHxcbi8vICstLS0tLS0tLSstLS0tLS0tLSstLS0tLS0tLStcbi8vICAgIF4gZml4ZXh0IHwgICAgICAgIF4gdmFsdWUgcGFydCB1bnVzZWQgKGZpeGVkIHRvIGJlIDApXG4vLyAgICAgICAgICAgICBeIGluZGljYXRlcyB1bmRlZmluZWQgdmFsdWVcbi8vXG5cblx0ZnVuY3Rpb24gRGVjb2Rlcih2aWV3LCBvZmZzZXQpIHtcblx0XHR0aGlzLm9mZnNldCA9IG9mZnNldCB8fCAwO1xuXHRcdHRoaXMudmlldyA9IHZpZXc7XG5cdH1cblxuXG5cdERlY29kZXIucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uKGxlbmd0aCkge1xuXHRcdHZhciB2YWx1ZSA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBrZXkgPSB0aGlzLnBhcnNlKCk7XG5cdFx0XHR2YWx1ZVtrZXldID0gdGhpcy5wYXJzZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdmFsdWU7XG5cdH07XG5cblx0RGVjb2Rlci5wcm90b3R5cGUuYmluID0gRGVjb2Rlci5wcm90b3R5cGUuYnVmID0gZnVuY3Rpb24obGVuZ3RoKSB7XG5cdFx0dmFyIHZhbHVlID0gbmV3IEFycmF5QnVmZmVyKGxlbmd0aCk7XG5cdFx0KG5ldyBVaW50OEFycmF5KHZhbHVlKSkuc2V0KG5ldyBVaW50OEFycmF5KHRoaXMudmlldy5idWZmZXIsIHRoaXMub2Zmc2V0LCBsZW5ndGgpLCAwKTtcblx0XHR0aGlzLm9mZnNldCArPSBsZW5ndGg7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9O1xuXG5cdERlY29kZXIucHJvdG90eXBlLnN0ciA9IGZ1bmN0aW9uKGxlbmd0aCkge1xuXHRcdHZhciB2YWx1ZSA9IHV0ZjhSZWFkKHRoaXMudmlldywgdGhpcy5vZmZzZXQsIGxlbmd0aCk7XG5cdFx0dGhpcy5vZmZzZXQgKz0gbGVuZ3RoO1xuXHRcdHJldHVybiB2YWx1ZTtcblx0fTtcblxuXHREZWNvZGVyLnByb3RvdHlwZS5hcnJheSA9IGZ1bmN0aW9uKGxlbmd0aCkge1xuXHRcdHZhciB2YWx1ZSA9IG5ldyBBcnJheShsZW5ndGgpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhbHVlW2ldID0gdGhpcy5wYXJzZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdmFsdWU7XG5cdH07XG5cblx0RGVjb2Rlci5wcm90b3R5cGUuZXh0ID0gZnVuY3Rpb24obGVuZ3RoKSB7XG5cdFx0dmFyIHZhbHVlID0ge307XG5cdFx0Ly8gR2V0IHRoZSB0eXBlIGJ5dGVcblx0XHR2YWx1ZVsndHlwZSddID0gdGhpcy52aWV3LmdldEludDgodGhpcy5vZmZzZXQpO1xuXHRcdHRoaXMub2Zmc2V0Kys7XG5cdFx0Ly8gR2V0IHRoZSBkYXRhIGFycmF5IChsZW5ndGgpXG5cdFx0dmFsdWVbJ2RhdGEnXSA9IHRoaXMuYnVmKGxlbmd0aCk7XG5cdFx0dGhpcy5vZmZzZXQgKz0gbGVuZ3RoO1xuXHRcdHJldHVybiB2YWx1ZTtcblx0fTtcblxuXHREZWNvZGVyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0eXBlID0gdGhpcy52aWV3LmdldFVpbnQ4KHRoaXMub2Zmc2V0KTtcblx0XHR2YXIgdmFsdWUsIGxlbmd0aDtcblxuXHRcdC8vIFBvc2l0aXZlIEZpeEludCAtIDB4eHh4eHh4XG5cdFx0aWYgKCh0eXBlICYgMHg4MCkgPT09IDB4MDApIHtcblx0XHRcdHRoaXMub2Zmc2V0Kys7XG5cdFx0XHRyZXR1cm4gdHlwZTtcblx0XHR9XG5cblx0XHQvLyBGaXhNYXAgLSAxMDAweHh4eFxuXHRcdGlmICgodHlwZSAmIDB4ZjApID09PSAweDgwKSB7XG5cdFx0XHRsZW5ndGggPSB0eXBlICYgMHgwZjtcblx0XHRcdHRoaXMub2Zmc2V0Kys7XG5cdFx0XHRyZXR1cm4gdGhpcy5tYXAobGVuZ3RoKTtcblx0XHR9XG5cblx0XHQvLyBGaXhBcnJheSAtIDEwMDF4eHh4XG5cdFx0aWYgKCh0eXBlICYgMHhmMCkgPT09IDB4OTApIHtcblx0XHRcdGxlbmd0aCA9IHR5cGUgJiAweDBmO1xuXHRcdFx0dGhpcy5vZmZzZXQrKztcblx0XHRcdHJldHVybiB0aGlzLmFycmF5KGxlbmd0aCk7XG5cdFx0fVxuXG5cdFx0Ly8gRml4U3RyIC0gMTAxeHh4eHhcblx0XHRpZiAoKHR5cGUgJiAweGUwKSA9PT0gMHhhMCkge1xuXHRcdFx0bGVuZ3RoID0gdHlwZSAmIDB4MWY7XG5cdFx0XHR0aGlzLm9mZnNldCsrO1xuXHRcdFx0cmV0dXJuIHRoaXMuc3RyKGxlbmd0aCk7XG5cdFx0fVxuXG5cdFx0Ly8gTmVnYXRpdmUgRml4SW50IC0gMTExeHh4eHhcblx0XHRpZiAoKHR5cGUgJiAweGUwKSA9PT0gMHhlMCkge1xuXHRcdFx0dmFsdWUgPSB0aGlzLnZpZXcuZ2V0SW50OCh0aGlzLm9mZnNldCk7XG5cdFx0XHR0aGlzLm9mZnNldCsrO1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH1cblxuXHRcdHN3aXRjaCAodHlwZSkge1xuXG5cdFx0XHQvLyBuaWxcblx0XHRcdGNhc2UgMHhjMDpcblx0XHRcdFx0dGhpcy5vZmZzZXQrKztcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHRcdC8vIDB4YzEgbmV2ZXIgdXNlZCAtIHVzZSBmb3IgdW5kZWZpbmVkIChOT04tU1RBTkRBUkQpXG5cdFx0XHRjYXNlIDB4YzE6XG5cdFx0XHRcdHRoaXMub2Zmc2V0Kys7XG5cdFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cblx0XHRcdC8vIGZhbHNlXG5cdFx0XHRjYXNlIDB4YzI6XG5cdFx0XHRcdHRoaXMub2Zmc2V0Kys7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0Ly8gdHJ1ZVxuXHRcdFx0Y2FzZSAweGMzOlxuXHRcdFx0XHR0aGlzLm9mZnNldCsrO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0Ly8gYmluIDhcblx0XHRcdGNhc2UgMHhjNDpcblx0XHRcdFx0bGVuZ3RoID0gdGhpcy52aWV3LmdldFVpbnQ4KHRoaXMub2Zmc2V0ICsgMSk7XG5cdFx0XHRcdHRoaXMub2Zmc2V0ICs9IDI7XG5cdFx0XHRcdHJldHVybiB0aGlzLmJpbihsZW5ndGgpO1xuXG5cdFx0XHQvLyBiaW4gMTZcblx0XHRcdGNhc2UgMHhjNTpcblx0XHRcdFx0bGVuZ3RoID0gdGhpcy52aWV3LmdldFVpbnQxNih0aGlzLm9mZnNldCArIDEpO1xuXHRcdFx0XHR0aGlzLm9mZnNldCArPSAzO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5iaW4obGVuZ3RoKTtcblxuXHRcdFx0Ly8gYmluIDMyXG5cdFx0XHRjYXNlIDB4YzY6XG5cdFx0XHRcdGxlbmd0aCA9IHRoaXMudmlldy5nZXRVaW50MzIodGhpcy5vZmZzZXQgKyAxKTtcblx0XHRcdFx0dGhpcy5vZmZzZXQgKz0gNTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuYmluKGxlbmd0aCk7XG5cblx0XHRcdC8vIGV4dCA4XG5cdFx0XHRjYXNlIDB4Yzc6XG5cdFx0XHRcdGxlbmd0aCA9IHRoaXMudmlldy5nZXRVaW50OCh0aGlzLm9mZnNldCArIDEpO1xuXHRcdFx0XHR0aGlzLm9mZnNldCArPSAyO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5leHQobGVuZ3RoKTtcblxuXHRcdFx0Ly8gZXh0IDE2XG5cdFx0XHRjYXNlIDB4Yzg6XG5cdFx0XHRcdGxlbmd0aCA9IHRoaXMudmlldy5nZXRVaW50MTYodGhpcy5vZmZzZXQgKyAxKTtcblx0XHRcdFx0dGhpcy5vZmZzZXQgKz0gMztcblx0XHRcdFx0cmV0dXJuIHRoaXMuZXh0KGxlbmd0aCk7XG5cblx0XHRcdC8vIGV4dCAzMlxuXHRcdFx0Y2FzZSAweGM5OlxuXHRcdFx0XHRsZW5ndGggPSB0aGlzLnZpZXcuZ2V0VWludDMyKHRoaXMub2Zmc2V0ICsgMSk7XG5cdFx0XHRcdHRoaXMub2Zmc2V0ICs9IDU7XG5cdFx0XHRcdHJldHVybiB0aGlzLmV4dChsZW5ndGgpO1xuXG5cdFx0XHQvLyBmbG9hdCAzMlxuXHRcdFx0Y2FzZSAweGNhOlxuXHRcdFx0XHR2YWx1ZSA9IHRoaXMudmlldy5nZXRGbG9hdDMyKHRoaXMub2Zmc2V0ICsgMSk7XG5cdFx0XHRcdHRoaXMub2Zmc2V0ICs9IDU7XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblxuXHRcdFx0Ly8gZmxvYXQgNjRcblx0XHRcdGNhc2UgMHhjYjpcblx0XHRcdFx0dmFsdWUgPSB0aGlzLnZpZXcuZ2V0RmxvYXQ2NCh0aGlzLm9mZnNldCArIDEpO1xuXHRcdFx0XHR0aGlzLm9mZnNldCArPSA5O1xuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cblx0XHRcdC8vIHVpbnQ4XG5cdFx0XHRjYXNlIDB4Y2M6XG5cdFx0XHRcdHZhbHVlID0gdGhpcy52aWV3LmdldFVpbnQ4KHRoaXMub2Zmc2V0ICsgMSk7XG5cdFx0XHRcdHRoaXMub2Zmc2V0ICs9IDI7XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblxuXHRcdFx0Ly8gdWludCAxNlxuXHRcdFx0Y2FzZSAweGNkOlxuXHRcdFx0XHR2YWx1ZSA9IHRoaXMudmlldy5nZXRVaW50MTYodGhpcy5vZmZzZXQgKyAxKTtcblx0XHRcdFx0dGhpcy5vZmZzZXQgKz0gMztcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXG5cdFx0XHQvLyB1aW50IDMyXG5cdFx0XHRjYXNlIDB4Y2U6XG5cdFx0XHRcdHZhbHVlID0gdGhpcy52aWV3LmdldFVpbnQzMih0aGlzLm9mZnNldCArIDEpO1xuXHRcdFx0XHR0aGlzLm9mZnNldCArPSA1O1xuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cblx0XHRcdC8vIHVpbnQgNjRcblx0XHRcdGNhc2UgMHhjZjpcblx0XHRcdFx0dmFsdWUgPSBnZXRVaW50NjQodGhpcy52aWV3LCB0aGlzLm9mZnNldCArIDEpO1xuXHRcdFx0XHR0aGlzLm9mZnNldCArPSA5O1xuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cblx0XHRcdC8vIGludCA4XG5cdFx0XHRjYXNlIDB4ZDA6XG5cdFx0XHRcdHZhbHVlID0gdGhpcy52aWV3LmdldEludDgodGhpcy5vZmZzZXQgKyAxKTtcblx0XHRcdFx0dGhpcy5vZmZzZXQgKz0gMjtcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXG5cdFx0XHQvLyBpbnQgMTZcblx0XHRcdGNhc2UgMHhkMTpcblx0XHRcdFx0dmFsdWUgPSB0aGlzLnZpZXcuZ2V0SW50MTYodGhpcy5vZmZzZXQgKyAxKTtcblx0XHRcdFx0dGhpcy5vZmZzZXQgKz0gMztcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXG5cdFx0XHQvLyBpbnQgMzJcblx0XHRcdGNhc2UgMHhkMjpcblx0XHRcdFx0dmFsdWUgPSB0aGlzLnZpZXcuZ2V0SW50MzIodGhpcy5vZmZzZXQgKyAxKTtcblx0XHRcdFx0dGhpcy5vZmZzZXQgKz0gNTtcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXG5cdFx0XHQvLyBpbnQgNjRcblx0XHRcdGNhc2UgMHhkMzpcblx0XHRcdFx0dmFsdWUgPSBnZXRJbnQ2NCh0aGlzLnZpZXcsIHRoaXMub2Zmc2V0ICsgMSk7XG5cdFx0XHRcdHRoaXMub2Zmc2V0ICs9IDk7XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblxuXHRcdFx0Ly8gZml4ZXh0IDFcblx0XHRcdGNhc2UgMHhkNDpcblx0XHRcdFx0bGVuZ3RoID0gMTtcblx0XHRcdFx0dGhpcy5vZmZzZXQrKztcblx0XHRcdFx0cmV0dXJuIHRoaXMuZXh0KGxlbmd0aCk7XG5cblx0XHRcdC8vIGZpeGV4dCAyXG5cdFx0XHRjYXNlIDB4ZDU6XG5cdFx0XHRcdGxlbmd0aCA9IDI7XG5cdFx0XHRcdHRoaXMub2Zmc2V0Kys7XG5cdFx0XHRcdHJldHVybiB0aGlzLmV4dChsZW5ndGgpO1xuXG5cdFx0XHQvLyBmaXhleHQgNFxuXHRcdFx0Y2FzZSAweGQ2OlxuXHRcdFx0XHRsZW5ndGggPSA0O1xuXHRcdFx0XHR0aGlzLm9mZnNldCsrO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5leHQobGVuZ3RoKTtcblxuXHRcdFx0Ly8gZml4ZXh0IDhcblx0XHRcdGNhc2UgMHhkNzpcblx0XHRcdFx0bGVuZ3RoID0gODtcblx0XHRcdFx0dGhpcy5vZmZzZXQrKztcblx0XHRcdFx0cmV0dXJuIHRoaXMuZXh0KGxlbmd0aCk7XG5cblx0XHRcdC8vIGZpeGV4dCAxNlxuXHRcdFx0Y2FzZSAweGQ4OlxuXHRcdFx0XHRsZW5ndGggPSAxNjtcblx0XHRcdFx0dGhpcy5vZmZzZXQrKztcblx0XHRcdFx0cmV0dXJuIHRoaXMuZXh0KGxlbmd0aCk7XG5cblx0XHRcdC8vIHN0cjhcblx0XHRcdGNhc2UgMHhkOTpcblx0XHRcdFx0bGVuZ3RoID0gdGhpcy52aWV3LmdldFVpbnQ4KHRoaXMub2Zmc2V0ICsgMSk7XG5cdFx0XHRcdHRoaXMub2Zmc2V0ICs9IDI7XG5cdFx0XHRcdHJldHVybiB0aGlzLnN0cihsZW5ndGgpO1xuXG5cdFx0XHQvLyBzdHIgMTZcblx0XHRcdGNhc2UgMHhkYTpcblx0XHRcdFx0bGVuZ3RoID0gdGhpcy52aWV3LmdldFVpbnQxNih0aGlzLm9mZnNldCArIDEpO1xuXHRcdFx0XHR0aGlzLm9mZnNldCArPSAzO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5zdHIobGVuZ3RoKTtcblxuXHRcdFx0Ly8gc3RyIDMyXG5cdFx0XHRjYXNlIDB4ZGI6XG5cdFx0XHRcdGxlbmd0aCA9IHRoaXMudmlldy5nZXRVaW50MzIodGhpcy5vZmZzZXQgKyAxKTtcblx0XHRcdFx0dGhpcy5vZmZzZXQgKz0gNTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuc3RyKGxlbmd0aCk7XG5cblx0XHRcdC8vIGFycmF5IDE2XG5cdFx0XHRjYXNlIDB4ZGM6XG5cdFx0XHRcdGxlbmd0aCA9IHRoaXMudmlldy5nZXRVaW50MTYodGhpcy5vZmZzZXQgKyAxKTtcblx0XHRcdFx0dGhpcy5vZmZzZXQgKz0gMztcblx0XHRcdFx0cmV0dXJuIHRoaXMuYXJyYXkobGVuZ3RoKTtcblxuXHRcdFx0Ly8gYXJyYXkgMzJcblx0XHRcdGNhc2UgMHhkZDpcblx0XHRcdFx0bGVuZ3RoID0gdGhpcy52aWV3LmdldFVpbnQzMih0aGlzLm9mZnNldCArIDEpO1xuXHRcdFx0XHR0aGlzLm9mZnNldCArPSA1O1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5hcnJheShsZW5ndGgpO1xuXG5cdFx0XHQvLyBtYXAgMTZcblx0XHRcdGNhc2UgMHhkZTpcblx0XHRcdFx0bGVuZ3RoID0gdGhpcy52aWV3LmdldFVpbnQxNih0aGlzLm9mZnNldCArIDEpO1xuXHRcdFx0XHR0aGlzLm9mZnNldCArPSAzO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5tYXAobGVuZ3RoKTtcblxuXHRcdFx0Ly8gbWFwIDMyXG5cdFx0XHRjYXNlIDB4ZGY6XG5cdFx0XHRcdGxlbmd0aCA9IHRoaXMudmlldy5nZXRVaW50MzIodGhpcy5vZmZzZXQgKyAxKTtcblx0XHRcdFx0dGhpcy5vZmZzZXQgKz0gNTtcblx0XHRcdFx0cmV0dXJuIHRoaXMubWFwKGxlbmd0aCk7XG5cdFx0fVxuXHRcdHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdHlwZSAweFwiICsgdHlwZS50b1N0cmluZygxNikpO1xuXHR9O1xuXG5cdGZ1bmN0aW9uIGRlY29kZShidWZmZXIpIHtcblx0XHR2YXIgdmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xuXHRcdHZhciBkZWNvZGVyID0gbmV3IERlY29kZXIodmlldyk7XG5cdFx0dmFyIHZhbHVlID0gZGVjb2Rlci5wYXJzZSgpO1xuXHRcdGlmIChkZWNvZGVyLm9mZnNldCAhPT0gYnVmZmVyLmJ5dGVMZW5ndGgpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoKGJ1ZmZlci5ieXRlTGVuZ3RoIC0gZGVjb2Rlci5vZmZzZXQpICsgXCIgdHJhaWxpbmcgYnl0ZXNcIik7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9XG5cblx0ZnVuY3Rpb24gZW5jb2RlYWJsZUtleXModmFsdWUsIHNwYXJzZSkge1xuXHRcdHJldHVybiBVdGlscy5rZXlzQXJyYXkodmFsdWUsIHRydWUpLmZpbHRlcihmdW5jdGlvbiAoZSkge1xuXHRcdFx0dmFyIHZhbCA9IHZhbHVlW2VdLCB0eXBlID0gdHlwZW9mKHZhbCk7XG5cdFx0XHRyZXR1cm4gKCFzcGFyc2UgfHwgKHZhbCAhPT0gdW5kZWZpbmVkICYmIHZhbCAhPT0gbnVsbCkpICYmICgnZnVuY3Rpb24nICE9PSB0eXBlIHx8ICEhdmFsLnRvSlNPTik7XG5cdFx0fSlcblx0fVxuXG5cdGZ1bmN0aW9uIGVuY29kZSh2YWx1ZSwgdmlldywgb2Zmc2V0LCBzcGFyc2UpIHtcblx0XHR2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuXHRcdC8vIFN0cmluZ3MgQnl0ZXNcblx0XHQvLyBUaGVyZSBhcmUgZm91ciBzdHJpbmcgdHlwZXM6IGZpeHN0ci9zdHI4L3N0cjE2L3N0cjMyXG5cdFx0aWYgKHR5cGUgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdHZhciBsZW5ndGggPSB1dGY4Qnl0ZUNvdW50KHZhbHVlKTtcblxuXHRcdFx0Ly8gZml4c3RyXG5cdFx0XHRpZiAobGVuZ3RoIDwgMHgyMCkge1xuXHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCwgbGVuZ3RoIHwgMHhhMCk7XG5cdFx0XHRcdHV0ZjhXcml0ZSh2aWV3LCBvZmZzZXQgKyAxLCB2YWx1ZSk7XG5cdFx0XHRcdHJldHVybiAxICsgbGVuZ3RoO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBzdHI4XG5cdFx0XHRpZiAobGVuZ3RoIDwgMHgxMDApIHtcblx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQsIDB4ZDkpO1xuXHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCArIDEsIGxlbmd0aCk7XG5cdFx0XHRcdHV0ZjhXcml0ZSh2aWV3LCBvZmZzZXQgKyAyLCB2YWx1ZSk7XG5cdFx0XHRcdHJldHVybiAyICsgbGVuZ3RoO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBzdHIxNlxuXHRcdFx0aWYgKGxlbmd0aCA8IDB4MTAwMDApIHtcblx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQsIDB4ZGEpO1xuXHRcdFx0XHR2aWV3LnNldFVpbnQxNihvZmZzZXQgKyAxLCBsZW5ndGgpO1xuXHRcdFx0XHR1dGY4V3JpdGUodmlldywgb2Zmc2V0ICsgMywgdmFsdWUpO1xuXHRcdFx0XHRyZXR1cm4gMyArIGxlbmd0aDtcblx0XHRcdH1cblx0XHRcdC8vIHN0cjMyXG5cdFx0XHRpZiAobGVuZ3RoIDwgMHgxMDAwMDAwMDApIHtcblx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQsIDB4ZGIpO1xuXHRcdFx0XHR2aWV3LnNldFVpbnQzMihvZmZzZXQgKyAxLCBsZW5ndGgpO1xuXHRcdFx0XHR1dGY4V3JpdGUodmlldywgb2Zmc2V0ICsgNSwgdmFsdWUpO1xuXHRcdFx0XHRyZXR1cm4gNSArIGxlbmd0aDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBUaGVyZSBhcmUgdGhyZWUgYmluIHR5cGVzOiBiaW44L2JpbjE2L2JpbjMyXG5cdFx0aWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcblx0XHRcdHZhciBsZW5ndGggPSB2YWx1ZS5ieXRlTGVuZ3RoO1xuXG5cdFx0XHQvLyBiaW44XG5cdFx0XHRpZiAobGVuZ3RoIDwgMHgxMDApIHtcblx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQsIDB4YzQpO1xuXHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCArIDEsIGxlbmd0aCk7XG5cdFx0XHRcdChuZXcgVWludDhBcnJheSh2aWV3LmJ1ZmZlcikpLnNldChuZXcgVWludDhBcnJheSh2YWx1ZSksIG9mZnNldCArIDIpO1xuXHRcdFx0XHRyZXR1cm4gMiArIGxlbmd0aDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gYmluMTZcblx0XHRcdGlmIChsZW5ndGggPCAweDEwMDAwKSB7XG5cdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0LCAweGM1KTtcblx0XHRcdFx0dmlldy5zZXRVaW50MTYob2Zmc2V0ICsgMSwgbGVuZ3RoKTtcblx0XHRcdFx0KG5ldyBVaW50OEFycmF5KHZpZXcuYnVmZmVyKSkuc2V0KG5ldyBVaW50OEFycmF5KHZhbHVlKSwgb2Zmc2V0ICsgMyk7XG5cdFx0XHRcdHJldHVybiAzICsgbGVuZ3RoO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBiaW4gMzJcblx0XHRcdGlmIChsZW5ndGggPCAweDEwMDAwMDAwMCkge1xuXHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCwgMHhjNik7XG5cdFx0XHRcdHZpZXcuc2V0VWludDMyKG9mZnNldCArIDEsIGxlbmd0aCk7XG5cdFx0XHRcdChuZXcgVWludDhBcnJheSh2aWV3LmJ1ZmZlcikpLnNldChuZXcgVWludDhBcnJheSh2YWx1ZSksIG9mZnNldCArIDUpO1xuXHRcdFx0XHRyZXR1cm4gNSArIGxlbmd0aDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAodHlwZSA9PT0gXCJudW1iZXJcIikge1xuXG5cdFx0XHQvLyBGbG9hdGluZyBQb2ludFxuXHRcdFx0Ly8gTk9URTogV2UncmUgYWx3YXlzIHVzaW5nIGZsb2F0NjRcblx0XHRcdGlmIChNYXRoLmZsb29yKHZhbHVlKSAhPT0gdmFsdWUpIHtcblx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQsIDB4Y2IpO1xuXHRcdFx0XHR2aWV3LnNldEZsb2F0NjQob2Zmc2V0ICsgMSwgdmFsdWUpO1xuXHRcdFx0XHRyZXR1cm4gOTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSW50ZWdlcnNcblx0XHRcdGlmICh2YWx1ZSA+PSAwKSB7XG5cdFx0XHRcdC8vIHBvc2l0aXZlIGZpeG51bVxuXHRcdFx0XHRpZiAodmFsdWUgPCAweDgwKSB7XG5cdFx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQsIHZhbHVlKTtcblx0XHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyB1aW50IDhcblx0XHRcdFx0aWYgKHZhbHVlIDwgMHgxMDApIHtcblx0XHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCwgMHhjYyk7XG5cdFx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQgKyAxLCB2YWx1ZSk7XG5cdFx0XHRcdFx0cmV0dXJuIDI7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gdWludCAxNlxuXHRcdFx0XHRpZiAodmFsdWUgPCAweDEwMDAwKSB7XG5cdFx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQsIDB4Y2QpO1xuXHRcdFx0XHRcdHZpZXcuc2V0VWludDE2KG9mZnNldCArIDEsIHZhbHVlKTtcblx0XHRcdFx0XHRyZXR1cm4gMztcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyB1aW50IDMyXG5cdFx0XHRcdGlmICh2YWx1ZSA8IDB4MTAwMDAwMDAwKSB7XG5cdFx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQsIDB4Y2UpO1xuXHRcdFx0XHRcdHZpZXcuc2V0VWludDMyKG9mZnNldCArIDEsIHZhbHVlKTtcblx0XHRcdFx0XHRyZXR1cm4gNTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyB1aW50IDY0XG5cdFx0XHRcdGlmICh2YWx1ZSA8IDB4MTAwMDAwMDAwMDAwMDAwMDApIHtcblx0XHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCwgMHhjZik7XG5cdFx0XHRcdFx0c2V0VWludDY0KHZpZXcsIG9mZnNldCArIDEsIHZhbHVlKTtcblx0XHRcdFx0XHRyZXR1cm4gOTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJOdW1iZXIgdG9vIGJpZyAweFwiICsgdmFsdWUudG9TdHJpbmcoMTYpKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gbmVnYXRpdmUgZml4bnVtXG5cdFx0XHRpZiAodmFsdWUgPj0gLTB4MjApIHtcblx0XHRcdFx0dmlldy5zZXRJbnQ4KG9mZnNldCwgdmFsdWUpO1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblx0XHRcdC8vIGludCA4XG5cdFx0XHRpZiAodmFsdWUgPj0gLTB4ODApIHtcblx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQsIDB4ZDApO1xuXHRcdFx0XHR2aWV3LnNldEludDgob2Zmc2V0ICsgMSwgdmFsdWUpO1xuXHRcdFx0XHRyZXR1cm4gMjtcblx0XHRcdH1cblx0XHRcdC8vIGludCAxNlxuXHRcdFx0aWYgKHZhbHVlID49IC0weDgwMDApIHtcblx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQsIDB4ZDEpO1xuXHRcdFx0XHR2aWV3LnNldEludDE2KG9mZnNldCArIDEsIHZhbHVlKTtcblx0XHRcdFx0cmV0dXJuIDM7XG5cdFx0XHR9XG5cdFx0XHQvLyBpbnQgMzJcblx0XHRcdGlmICh2YWx1ZSA+PSAtMHg4MDAwMDAwMCkge1xuXHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCwgMHhkMik7XG5cdFx0XHRcdHZpZXcuc2V0SW50MzIob2Zmc2V0ICsgMSwgdmFsdWUpO1xuXHRcdFx0XHRyZXR1cm4gNTtcblx0XHRcdH1cblx0XHRcdC8vIGludCA2NFxuXHRcdFx0aWYgKHZhbHVlID49IC0weDgwMDAwMDAwMDAwMDAwMDApIHtcblx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQsIDB4ZDMpO1xuXHRcdFx0XHRzZXRJbnQ2NCh2aWV3LCBvZmZzZXQgKyAxLCB2YWx1ZSk7XG5cdFx0XHRcdHJldHVybiA5O1xuXHRcdFx0fVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiTnVtYmVyIHRvbyBzbWFsbCAtMHhcIiArICgtdmFsdWUpLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSkpO1xuXHRcdH1cblxuXHRcdC8vIHVuZGVmaW5lZCAtIHVzZSBkNCAoTk9OLVNUQU5EQVJEKVxuXHRcdGlmICh0eXBlID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHRpZihzcGFyc2UpIHJldHVybiAwO1xuXHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQsIDB4ZDQpO1xuXHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQgKyAxLCAweDAwKTtcblx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0ICsgMiwgMHgwMCk7XG5cdFx0XHRyZXR1cm4gMztcblx0XHR9XG5cblx0XHQvLyBudWxsXG5cdFx0aWYgKHZhbHVlID09PSBudWxsKSB7XG5cdFx0XHRpZihzcGFyc2UpIHJldHVybiAwO1xuXHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQsIDB4YzApO1xuXHRcdFx0cmV0dXJuIDE7XG5cdFx0fVxuXG5cdFx0Ly8gQm9vbGVhblxuXHRcdGlmICh0eXBlID09PSBcImJvb2xlYW5cIikge1xuXHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQsIHZhbHVlID8gMHhjMyA6IDB4YzIpO1xuXHRcdFx0cmV0dXJuIDE7XG5cdFx0fVxuXG5cdFx0aWYoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIHZhbHVlLnRvSlNPTilcblx0XHRcdHJldHVybiBlbmNvZGUodmFsdWUudG9KU09OKCksIHZpZXcsIG9mZnNldCwgc3BhcnNlKTtcblxuXHRcdC8vIENvbnRhaW5lciBUeXBlc1xuXHRcdGlmICh0eXBlID09PSBcIm9iamVjdFwiKSB7XG5cdFx0XHR2YXIgbGVuZ3RoLCBzaXplID0gMDtcblx0XHRcdHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG5cblx0XHRcdGlmIChpc0FycmF5KSB7XG5cdFx0XHRcdGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBrZXlzID0gZW5jb2RlYWJsZUtleXModmFsdWUsIHNwYXJzZSk7XG5cdFx0XHRcdGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgc2l6ZTtcblx0XHRcdGlmIChsZW5ndGggPCAweDEwKSB7XG5cdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0LCBsZW5ndGggfCAoIGlzQXJyYXkgPyAweDkwIDogMHg4MCkpO1xuXHRcdFx0XHRzaXplID0gMTtcblx0XHRcdH0gZWxzZSBpZiAobGVuZ3RoIDwgMHgxMDAwMCkge1xuXHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCwgaXNBcnJheSA/IDB4ZGMgOiAweGRlKTtcblx0XHRcdFx0dmlldy5zZXRVaW50MTYob2Zmc2V0ICsgMSwgbGVuZ3RoKTtcblx0XHRcdFx0c2l6ZSA9IDM7XG5cdFx0XHR9IGVsc2UgaWYgKGxlbmd0aCA8IDB4MTAwMDAwMDAwKSB7XG5cdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0LCBpc0FycmF5ID8gMHhkZCA6IDB4ZGYpO1xuXHRcdFx0XHR2aWV3LnNldFVpbnQzMihvZmZzZXQgKyAxLCBsZW5ndGgpO1xuXHRcdFx0XHRzaXplID0gNTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGlzQXJyYXkpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHNpemUgKz0gZW5jb2RlKHZhbHVlW2ldLCB2aWV3LCBvZmZzZXQgKyBzaXplLCBzcGFyc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0dmFyIGtleSA9IGtleXNbaV07XG5cdFx0XHRcdFx0c2l6ZSArPSBlbmNvZGUoa2V5LCB2aWV3LCBvZmZzZXQgKyBzaXplKTtcblx0XHRcdFx0XHRzaXplICs9IGVuY29kZSh2YWx1ZVtrZXldLCB2aWV3LCBvZmZzZXQgKyBzaXplLCBzcGFyc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBzaXplO1xuXHRcdH1cblx0XHRpZih0eXBlID09PSBcImZ1bmN0aW9uXCIpXG5cdFx0XHRyZXR1cm4gMDtcblxuXHRcdHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdHlwZSBcIiArIHR5cGUpO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2l6ZW9mKHZhbHVlLCBzcGFyc2UpIHtcblx0XHR2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuXHRcdC8vIGZpeHN0ciBvciBzdHI4IG9yIHN0cjE2IG9yIHN0cjMyXG5cdFx0aWYgKHR5cGUgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdHZhciBsZW5ndGggPSB1dGY4Qnl0ZUNvdW50KHZhbHVlKTtcblx0XHRcdGlmIChsZW5ndGggPCAweDIwKSB7XG5cdFx0XHRcdHJldHVybiAxICsgbGVuZ3RoO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGxlbmd0aCA8IDB4MTAwKSB7XG5cdFx0XHRcdHJldHVybiAyICsgbGVuZ3RoO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGxlbmd0aCA8IDB4MTAwMDApIHtcblx0XHRcdFx0cmV0dXJuIDMgKyBsZW5ndGg7XG5cdFx0XHR9XG5cdFx0XHRpZiAobGVuZ3RoIDwgMHgxMDAwMDAwMDApIHtcblx0XHRcdFx0cmV0dXJuIDUgKyBsZW5ndGg7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gYmluOCBvciBiaW4xNiBvciBiaW4zMlxuXHRcdGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG5cdFx0XHR2YXIgbGVuZ3RoID0gdmFsdWUuYnl0ZUxlbmd0aDtcblx0XHRcdGlmIChsZW5ndGggPCAweDEwMCkge1xuXHRcdFx0XHRyZXR1cm4gMiArIGxlbmd0aDtcblx0XHRcdH1cblx0XHRcdGlmIChsZW5ndGggPCAweDEwMDAwKSB7XG5cdFx0XHRcdHJldHVybiAzICsgbGVuZ3RoO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGxlbmd0aCA8IDB4MTAwMDAwMDAwKSB7XG5cdFx0XHRcdHJldHVybiA1ICsgbGVuZ3RoO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh0eXBlID09PSBcIm51bWJlclwiKSB7XG5cdFx0XHQvLyBGbG9hdGluZyBQb2ludCAoMzIgYml0cylcblx0XHRcdC8vIGRvdWJsZVxuXHRcdFx0aWYgKE1hdGguZmxvb3IodmFsdWUpICE9PSB2YWx1ZSlcblx0XHRcdFx0cmV0dXJuIDk7XG5cblx0XHRcdC8vIEludGVnZXJzXG5cdFx0XHRpZiAodmFsdWUgPj0gMCkge1xuXHRcdFx0XHQvLyBwb3NpdGl2ZSBmaXhpbnRcblx0XHRcdFx0aWYgKHZhbHVlIDwgMHg4MClcblx0XHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdFx0Ly8gdWludCA4XG5cdFx0XHRcdGlmICh2YWx1ZSA8IDB4MTAwKVxuXHRcdFx0XHRcdHJldHVybiAyO1xuXHRcdFx0XHQvLyB1aW50IDE2XG5cdFx0XHRcdGlmICh2YWx1ZSA8IDB4MTAwMDApXG5cdFx0XHRcdFx0cmV0dXJuIDM7XG5cdFx0XHRcdC8vIHVpbnQgMzJcblx0XHRcdFx0aWYgKHZhbHVlIDwgMHgxMDAwMDAwMDApXG5cdFx0XHRcdFx0cmV0dXJuIDU7XG5cdFx0XHRcdC8vIHVpbnQgNjRcblx0XHRcdFx0aWYgKHZhbHVlIDwgMHgxMDAwMDAwMDAwMDAwMDAwMClcblx0XHRcdFx0XHRyZXR1cm4gOTtcblx0XHRcdFx0Ly8gVG9vIGJpZ1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJOdW1iZXIgdG9vIGJpZyAweFwiICsgdmFsdWUudG9TdHJpbmcoMTYpKTtcblx0XHRcdH1cblx0XHRcdC8vIG5lZ2F0aXZlIGZpeGludFxuXHRcdFx0aWYgKHZhbHVlID49IC0weDIwKVxuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdC8vIGludCA4XG5cdFx0XHRpZiAodmFsdWUgPj0gLTB4ODApXG5cdFx0XHRcdHJldHVybiAyO1xuXHRcdFx0Ly8gaW50IDE2XG5cdFx0XHRpZiAodmFsdWUgPj0gLTB4ODAwMClcblx0XHRcdFx0cmV0dXJuIDM7XG5cdFx0XHQvLyBpbnQgMzJcblx0XHRcdGlmICh2YWx1ZSA+PSAtMHg4MDAwMDAwMClcblx0XHRcdFx0cmV0dXJuIDU7XG5cdFx0XHQvLyBpbnQgNjRcblx0XHRcdGlmICh2YWx1ZSA+PSAtMHg4MDAwMDAwMDAwMDAwMDAwKVxuXHRcdFx0XHRyZXR1cm4gOTtcblx0XHRcdC8vIFRvbyBzbWFsbFxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiTnVtYmVyIHRvbyBzbWFsbCAtMHhcIiArIHZhbHVlLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSkpO1xuXHRcdH1cblxuXHRcdC8vIEJvb2xlYW5cblx0XHRpZiAodHlwZSA9PT0gXCJib29sZWFuXCIpIHJldHVybiAxO1xuXG5cdFx0Ly8gdW5kZWZpbmVkLCBudWxsXG5cdFx0aWYgKHZhbHVlID09PSBudWxsKSByZXR1cm4gc3BhcnNlID8gMCA6IDE7XG5cdFx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiBzcGFyc2UgPyAwIDogMztcblxuXHRcdGlmKCdmdW5jdGlvbicgPT09IHR5cGVvZiB2YWx1ZS50b0pTT04pXG5cdFx0XHRyZXR1cm4gc2l6ZW9mKHZhbHVlLnRvSlNPTigpLCBzcGFyc2UpO1xuXG5cdFx0Ly8gQ29udGFpbmVyIFR5cGVzXG5cdFx0aWYgKHR5cGUgPT09IFwib2JqZWN0XCIpIHtcblx0XHRcdHZhciBsZW5ndGgsIHNpemUgPSAwO1xuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHRcdGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHNpemUgKz0gc2l6ZW9mKHZhbHVlW2ldLCBzcGFyc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIga2V5cyA9IGVuY29kZWFibGVLZXlzKHZhbHVlLCBzcGFyc2UpXG5cdFx0XHRcdGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0dmFyIGtleSA9IGtleXNbaV07XG5cdFx0XHRcdFx0c2l6ZSArPSBzaXplb2Yoa2V5KSArIHNpemVvZih2YWx1ZVtrZXldLCBzcGFyc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAobGVuZ3RoIDwgMHgxMCkge1xuXHRcdFx0XHRyZXR1cm4gMSArIHNpemU7XG5cdFx0XHR9XG5cdFx0XHRpZiAobGVuZ3RoIDwgMHgxMDAwMCkge1xuXHRcdFx0XHRyZXR1cm4gMyArIHNpemU7XG5cdFx0XHR9XG5cdFx0XHRpZiAobGVuZ3RoIDwgMHgxMDAwMDAwMDApIHtcblx0XHRcdFx0cmV0dXJuIDUgKyBzaXplO1xuXHRcdFx0fVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiQXJyYXkgb3Igb2JqZWN0IHRvbyBsb25nIDB4XCIgKyBsZW5ndGgudG9TdHJpbmcoMTYpKTtcblx0XHR9XG5cdFx0aWYodHlwZSA9PT0gXCJmdW5jdGlvblwiKVxuXHRcdFx0cmV0dXJuIDA7XG5cblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHR5cGUgXCIgKyB0eXBlKTtcblx0fVxuXG5cdHJldHVybiBleHBvcnRzO1xufSkoKTtcblxuaWYodHlwZW9mIHdpbmRvdyAhPT0gJ29iamVjdCcpIHtcblx0Y29uc29sZS5sb2coXCJXYXJuaW5nOiB0aGlzIGRpc3RyaWJ1dGlvbiBvZiBBYmx5IGlzIGludGVuZGVkIGZvciBicm93c2Vycy4gT24gbm9kZWpzLCBwbGVhc2UgdXNlIHRoZSAnYWJseScgcGFja2FnZSBvbiBucG1cIik7XG59XG5cbnZhciBQbGF0Zm9ybSA9IHtcblx0bGlidmVyOiAnanMtd2ViLScsXG5cdG5vVXBncmFkZTogbmF2aWdhdG9yICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9TdHJpbmcoKS5tYXRjaCgvTVNJRVxcczhcXC4wLyksXG5cdGJpbmFyeVR5cGU6ICdhcnJheWJ1ZmZlcicsXG5cdFdlYlNvY2tldDogd2luZG93LldlYlNvY2tldCB8fCB3aW5kb3cuTW96V2ViU29ja2V0LFxuXHR4aHJTdXBwb3J0ZWQ6ICh3aW5kb3cuWE1MSHR0cFJlcXVlc3QgJiYgJ3dpdGhDcmVkZW50aWFscycgaW4gbmV3IFhNTEh0dHBSZXF1ZXN0KCkpLFxuXHRzdHJlYW1pbmdTdXBwb3J0ZWQ6IHRydWUsXG5cdHVzZVByb3RvY29sSGVhcnRiZWF0czogdHJ1ZSxcblx0Y3JlYXRlSG1hYzogbnVsbCxcblx0bXNncGFjazogbXNncGFjayxcblx0c3VwcG9ydHNCaW5hcnk6ICEhd2luZG93LlRleHREZWNvZGVyLFxuXHRwcmVmZXJCaW5hcnk6IGZhbHNlLFxuXHRBcnJheUJ1ZmZlcjogd2luZG93LkFycmF5QnVmZmVyLFxuXHRhdG9iOiB3aW5kb3cuYXRvYixcblx0bmV4dFRpY2s6IGZ1bmN0aW9uKGYpIHsgc2V0VGltZW91dChmLCAwKTsgfSxcblx0YWRkRXZlbnRMaXN0ZW5lcjogd2luZG93LmFkZEV2ZW50TGlzdGVuZXIsXG5cdGluc3BlY3Q6IEpTT04uc3RyaW5naWZ5LFxuXHRnZXRSYW5kb21WYWx1ZXM6IChmdW5jdGlvbihjcnlwdG8pIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oYXJyLCBjYWxsYmFjaykge1xuXHRcdFx0Y3J5cHRvLmdldFJhbmRvbVZhbHVlcyhhcnIpO1xuXHRcdFx0Y2FsbGJhY2sobnVsbCk7XG5cdFx0fTtcblx0fSkod2luZG93LmNyeXB0byB8fCB3aW5kb3cubXNDcnlwdG8pIC8vIG1zY3J5cHRvIGZvciBJRTExXG59O1xuXG5cbnZhciBDcnlwdG8gPSAoZnVuY3Rpb24oKSB7XG5cdHZhciBERUZBVUxUX0FMR09SSVRITSA9ICdhZXMnO1xuXHR2YXIgREVGQVVMVF9LRVlMRU5HVEggPSAyNTY7IC8vIGJpdHNcblx0dmFyIERFRkFVTFRfTU9ERSA9ICdjYmMnO1xuXHR2YXIgREVGQVVMVF9CTE9DS0xFTkdUSCA9IDE2OyAvLyBieXRlc1xuXHR2YXIgREVGQVVMVF9CTE9DS0xFTkdUSF9XT1JEUyA9IDQ7IC8vIDMyLWJpdCB3b3Jkc1xuXHR2YXIgVUlOVDMyX1NVUCA9IDB4MTAwMDAwMDAwO1xuXHR2YXIgSU5UMzJfU1VQID0gMHg4MDAwMDAwMDtcblx0dmFyIFdvcmRBcnJheSA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXk7XG5cblx0LyoqXG5cdCAqIEludGVybmFsOiBnZW5lcmF0ZSBhbiBhcnJheSBvZiBzZWN1cmUgcmFuZG9tIHdvcmRzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGxlbmd0aCBvZiBieXRlc1xuXHQgKiBAcGFyYW0gYnl0ZXNcblx0ICogQHBhcmFtIGNhbGxiYWNrXG5cdCAqL1xuXHR2YXIgZ2VuZXJhdGVSYW5kb207XG5cdGlmKHR5cGVvZiBVaW50MzJBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgUGxhdGZvcm0uZ2V0UmFuZG9tVmFsdWVzKSB7XG5cdFx0dmFyIGJsb2NrUmFuZG9tQXJyYXkgPSBuZXcgVWludDMyQXJyYXkoREVGQVVMVF9CTE9DS0xFTkdUSF9XT1JEUyk7XG5cdFx0Z2VuZXJhdGVSYW5kb20gPSBmdW5jdGlvbihieXRlcywgY2FsbGJhY2spIHtcblx0XHRcdHZhciB3b3JkcyA9IGJ5dGVzIC8gNCwgbmF0aXZlQXJyYXkgPSAod29yZHMgPT0gREVGQVVMVF9CTE9DS0xFTkdUSF9XT1JEUykgPyBibG9ja1JhbmRvbUFycmF5IDogbmV3IFVpbnQzMkFycmF5KHdvcmRzKTtcblx0XHRcdFBsYXRmb3JtLmdldFJhbmRvbVZhbHVlcyhuYXRpdmVBcnJheSwgZnVuY3Rpb24oZXJyKSB7XG5cdFx0XHRcdGNhbGxiYWNrKGVyciwgQnVmZmVyVXRpbHMudG9Xb3JkQXJyYXkobmF0aXZlQXJyYXkpKVxuXHRcdFx0fSk7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRnZW5lcmF0ZVJhbmRvbSA9IGZ1bmN0aW9uKGJ5dGVzLCBjYWxsYmFjaykge1xuXHRcdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX01BSk9SLCAnQWJseS5DcnlwdG8uZ2VuZXJhdGVSYW5kb20oKScsICdXYXJuaW5nOiB0aGUgYnJvd3NlciB5b3UgYXJlIHVzaW5nIGRvZXMgbm90IHN1cHBvcnQgc2VjdXJlIGNyeXB0b2dyYXBoaWNhbGx5IHNlY3VyZSByYW5kb21uZXNzIGdlbmVyYXRpb247IGZhbGxpbmcgYmFjayB0byBpbnNlY3VyZSBNYXRoLnJhbmRvbSgpJyk7XG5cdFx0XHR2YXIgd29yZHMgPSBieXRlcyAvIDQsIGFycmF5ID0gbmV3IEFycmF5KHdvcmRzKTtcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCB3b3JkczsgaSsrKSB7XG5cdFx0XHRcdC8qIGNyeXB0b2pzIHdvcmRhcnJheXMgdXNlIHNpZ25lZCBpbnRzLiBXaGVuIFdvcmRBcnJheS5jcmVhdGUgaXMgZmVkIGFcblx0XHRcdFx0KiBVaW50MzJBcnJheSB1bnNpZ25lZCBhcmUgY29udmVydGVkIHRvIHNpZ25lZCBhdXRvbWF0aWNhbGx5LCBidXQgd2hlblxuXHRcdFx0XHQqIGZlZCBhIG5vcm1hbCBhcnJheSB0aGV5IGFyZW4ndCwgc28gbmVlZCB0byBkbyBzbyBvdXJzZWx2ZXMgYnlcblx0XHRcdFx0KiBzdWJ0cmFjdGluZyBJTlQzMl9TVVAgKi9cblx0XHRcdFx0YXJyYXlbaV0gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBVSU5UMzJfU1VQKSAtIElOVDMyX1NVUDtcblx0XHRcdH1cblxuXHRcdFx0Y2FsbGJhY2sobnVsbCwgV29yZEFycmF5LmNyZWF0ZShhcnJheSkpO1xuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogSW50ZXJuYWw6IGNhbGN1bGF0ZSB0aGUgcGFkZGVkIGxlbmd0aCBvZiBhIGdpdmVuIHBsYWludGV4dFxuXHQgKiB1c2luZyBQS0NTNS5cblx0ICogQHBhcmFtIHBsYWludGV4dExlbmd0aFxuXHQgKiBAcmV0dXJuXG5cdCAqL1xuXHRmdW5jdGlvbiBnZXRQYWRkZWRMZW5ndGgocGxhaW50ZXh0TGVuZ3RoKSB7XG5cdFx0cmV0dXJuIChwbGFpbnRleHRMZW5ndGggKyBERUZBVUxUX0JMT0NLTEVOR1RIKSAmIC1ERUZBVUxUX0JMT0NLTEVOR1RIO1xuXHR9XG5cblx0LyoqXG5cdCAqIEludGVybmFsOiBjaGVja3MgdGhhdCB0aGUgY2lwaGVyUGFyYW1zIGFyZSBhIHZhbGlkIGNvbWJpbmF0aW9uLiBDdXJyZW50bHlcblx0ICoganVzdCBjaGVja3MgdGhhdCB0aGUgY2FsY3VsYXRlZCBrZXlMZW5ndGggaXMgYSB2YWxpZCBvbmUgZm9yIGFlcy1jYmNcblx0ICovXG5cdGZ1bmN0aW9uIHZhbGlkYXRlQ2lwaGVyUGFyYW1zKHBhcmFtcykge1xuXHRcdGlmKHBhcmFtcy5hbGdvcml0aG0gPT09ICdhZXMnICYmIHBhcmFtcy5tb2RlID09PSAnY2JjJykge1xuXHRcdFx0aWYocGFyYW1zLmtleUxlbmd0aCA9PT0gMTI4IHx8IHBhcmFtcy5rZXlMZW5ndGggPT09IDI1Nikge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGtleSBsZW5ndGggJyArIHBhcmFtcy5rZXlMZW5ndGggKyAnIGZvciBhZXMtY2JjIGVuY3J5cHRpb24uIEVuY3J5cHRpb24ga2V5IG11c3QgYmUgMTI4IG9yIDI1NiBiaXRzICgxNiBvciAzMiBBU0NJSSBjaGFyYWN0ZXJzKScpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIG5vcm1hbGlzZUJhc2U2NChzdHJpbmcpIHtcblx0XHQvKiB1cmwtc2FmZSBiYXNlNjQgc3RyaW5ncyB1c2UgXyBhbmQgLSBpbnN0cmVhZCBvZiAvIGFuZCArICovXG5cdFx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKCdfJywgJy8nKS5yZXBsYWNlKCctJywgJysnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBJbnRlcm5hbDogYSBibG9jayBjb250YWluaW5nIHplcm9zXG5cdCAqL1xuXHR2YXIgZW1wdHlCbG9jayA9IFdvcmRBcnJheS5jcmVhdGUoWzAsMCwwLDBdKTtcblxuXHQvKipcblx0ICogSW50ZXJuYWw6IG9idGFpbiB0aGUgcGtjczUgcGFkZGluZyBzdHJpbmcgZm9yIGEgZ2l2ZW4gcGFkZGVkIGxlbmd0aDtcblx0ICovXG5cdHZhciBwa2NzNVBhZGRpbmcgPSBbXG5cdFx0V29yZEFycmF5LmNyZWF0ZShbMHgxMDEwMTAxMCwweDEwMTAxMDEwLDB4MTAxMDEwMTAsMHgxMDEwMTAxMF0sIDE2KSxcblx0XHRXb3JkQXJyYXkuY3JlYXRlKFsweDAxMDAwMDAwXSwgMSksXG5cdFx0V29yZEFycmF5LmNyZWF0ZShbMHgwMjAyMDAwMF0sIDIpLFxuXHRcdFdvcmRBcnJheS5jcmVhdGUoWzB4MDMwMzAzMDBdLCAzKSxcblx0XHRXb3JkQXJyYXkuY3JlYXRlKFsweDA0MDQwNDA0XSwgNCksXG5cdFx0V29yZEFycmF5LmNyZWF0ZShbMHgwNTA1MDUwNSwweDA1MDAwMDAwXSwgNSksXG5cdFx0V29yZEFycmF5LmNyZWF0ZShbMHgwNjA2MDYwNiwweDA2MDYwMDAwXSwgNiksXG5cdFx0V29yZEFycmF5LmNyZWF0ZShbMHgwNzA3MDcwNywweDA3MDcwNzAwXSwgNyksXG5cdFx0V29yZEFycmF5LmNyZWF0ZShbMHgwODA4MDgwOCwweDA4MDgwODA4XSwgOCksXG5cdFx0V29yZEFycmF5LmNyZWF0ZShbMHgwOTA5MDkwOSwweDA5MDkwOTA5LDB4MDkwMDAwMDBdLCA5KSxcblx0XHRXb3JkQXJyYXkuY3JlYXRlKFsweDBhMGEwYTBhLDB4MGEwYTBhMGEsMHgwYTBhMDAwMF0sIDEwKSxcblx0XHRXb3JkQXJyYXkuY3JlYXRlKFsweDBiMGIwYjBiLDB4MGIwYjBiMGIsMHgwYjBiMGIwMF0sIDExKSxcblx0XHRXb3JkQXJyYXkuY3JlYXRlKFsweDBjMGMwYzBjLDB4MGMwYzBjMGMsMHgwYzBjMGMwY10sIDEyKSxcblx0XHRXb3JkQXJyYXkuY3JlYXRlKFsweDBkMGQwZDBkLDB4MGQwZDBkMGQsMHgwZDBkMGQwZCwweDBkMDAwMDAwXSwgMTMpLFxuXHRcdFdvcmRBcnJheS5jcmVhdGUoWzB4MGUwZTBlMGUsMHgwZTBlMGUwZSwweDBlMGUwZTBlLDB4MGUwZTAwMDBdLCAxNCksXG5cdFx0V29yZEFycmF5LmNyZWF0ZShbMHgwZjBmMGYwZiwweDBmMGYwZjBmLDB4MGYwZjBmMGYsMHgwZjBmMGYwZl0sIDE1KSxcblx0XHRXb3JkQXJyYXkuY3JlYXRlKFsweDEwMTAxMDEwLDB4MTAxMDEwMTAsMHgxMDEwMTAxMCwweDEwMTAxMDEwXSwgMTYpXG5cdF07XG5cblx0LyoqXG5cdCAqIFV0aWxpdHkgY2xhc3NlcyBhbmQgaW50ZXJmYWNlcyBmb3IgbWVzc2FnZSBwYXlsb2FkIGVuY3J5cHRpb24uXG5cdCAqXG5cdCAqIFRoaXMgY2xhc3Mgc3VwcG9ydHMgQUVTL0NCQy9QS0NTNSB3aXRoIGEgZGVmYXVsdCBrZXlsZW5ndGggb2YgMTI4IGJpdHNcblx0ICogYnV0IHN1cHBvcnRpbmcgb3RoZXIga2V5bGVuZ3Rocy4gT3RoZXIgYWxnb3JpdGhtcyBhbmQgY2hhaW5pbmcgbW9kZXMgYXJlXG5cdCAqIG5vdCBzdXBwb3J0ZWQgZGlyZWN0bHksIGJ1dCBzdXBwb3J0YWJsZSBieSBleHRlbmRpbmcvaW1wbGVtZW50aW5nIHRoZSBiYXNlXG5cdCAqIGNsYXNzZXMgYW5kIGludGVyZmFjZXMgaGVyZS5cblx0ICpcblx0ICogU2VjdXJlIHJhbmRvbSBkYXRhIGZvciBjcmVhdGlvbiBvZiBJbml0aWFsaXphdGlvbiBWZWN0b3JzIChJVnMpIGFuZCBrZXlzXG5cdCAqIGlzIG9idGFpbmVkIGZyb20gd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXMgaWYgYXZhaWxhYmxlLCBvciBmcm9tXG5cdCAqIE1hdGgucmFuZG9tKCkgaWYgbm90LiBDbGllbnRzIHdobyBkbyBub3Qgd2FudCB0byBkZXBlbmQgb24gTWF0aC5yYW5kb20oKVxuXHQgKiBzaG91bGQgcG9seWZpbGwgd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXMgd2l0aCBhIGxpYnJhcnkgdGhhdCBzZWVkc1xuXHQgKiBhIFBSTkcgd2l0aCByZWFsIGVudHJvcHkuXG5cdCAqXG5cdCAqIEVhY2ggbWVzc2FnZSBwYXlsb2FkIGlzIGVuY3J5cHRlZCB3aXRoIGFuIElWIGluIENCQyBtb2RlLCBhbmQgdGhlIElWIGlzXG5cdCAqIGNvbmNhdGVuYXRlZCB3aXRoIHRoZSByZXN1bHRpbmcgcmF3IGNpcGhlcnRleHQgdG8gY29uc3RydWN0IHRoZSBcImNpcGhlcnRleHRcIlxuXHQgKiBkYXRhIHBhc3NlZCB0byB0aGUgcmVjaXBpZW50LlxuXHQgKi9cblx0ZnVuY3Rpb24gQ3J5cHRvKCkge31cblxuXHQvKipcblx0ICogQSBjbGFzcyBlbmNhcHN1bGF0aW5nIHRoZSBjbGllbnQtc3BlY2lmaWFibGUgcGFyYW1ldGVycyBmb3Jcblx0ICogdGhlIGNpcGhlci5cblx0ICpcblx0ICogYWxnb3JpdGhtIGlzIHRoZSBuYW1lIG9mIHRoZSBhbGdvcml0aG0gaW4gdGhlIGRlZmF1bHQgc3lzdGVtIHByb3ZpZGVyLFxuXHQgKiBvciB0aGUgbG93ZXItY2FzZWQgdmVyc2lvbiBvZiBpdDsgZWcgXCJhZXNcIiBvciBcIkFFU1wiLlxuXHQgKlxuXHQgKiBDbGllbnRzIGFyZSByZWNvbW1lbmRlZCB0byBub3QgY2FsbCB0aGlzIGRpcmVjdGx5LCBidXQgaW5zdGVhZCB0byB1c2UgdGhlXG5cdCAqIENyeXB0by5nZXREZWZhdWx0UGFyYW1zIGhlbHBlciwgd2hpY2ggd2lsbCBmaWxsIGluIGFueSBmaWVsZHMgbm90IHN1cHBsaWVkXG5cdCAqIHdpdGggZGVmYXVsdCB2YWx1ZXMgYW5kIHZhbGlkYXRpb24gdGhlIHJlc3VsdC5cblx0ICovXG5cdGZ1bmN0aW9uIENpcGhlclBhcmFtcygpIHtcblx0XHR0aGlzLmFsZ29yaXRobSA9IG51bGw7XG5cdFx0dGhpcy5rZXlMZW5ndGggPSBudWxsO1xuXHRcdHRoaXMubW9kZSA9IG51bGw7XG5cdFx0dGhpcy5rZXkgPSBudWxsO1xuXHR9XG5cdENyeXB0by5DaXBoZXJQYXJhbXMgPSBDaXBoZXJQYXJhbXM7XG5cblx0LyoqXG5cdCAqIE9idGFpbiBhIGNvbXBsZXRlIENpcGhlclBhcmFtcyBpbnN0YW5jZSBmcm9tIHRoZSBwcm92aWRlZCBwYXJhbXMsIGZpbGxpbmdcblx0ICogaW4gYW55IG5vdCBwcm92aWRlZCB3aXRoIGRlZmF1bHQgdmFsdWVzLCBjYWxjdWxhdGluZyBhIGtleUxlbmd0aCBmcm9tXG5cdCAqIHRoZSBzdXBwbGllZCBrZXksIGFuZCB2YWxpZGF0aW5nIHRoZSByZXN1bHQuXG5cdCAqIEBwYXJhbSBwYXJhbXMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYXQgYSBtaW5pbXVtIGEgYGtleWAga2V5IHdpdGggdmFsdWUgdGhlXG5cdCAqIGtleSwgYXMgZWl0aGVyIGEgYmluYXJ5IChBcnJheUJ1ZmZlciwgQXJyYXksIFdvcmRBcnJheSkgb3IgYVxuXHQgKiBiYXNlNjQtZW5jb2RlZCBzdHJpbmcuIE1heSBvcHRpb25hbGx5IGFsc28gY29udGFpbjogYWxnb3JpdGhtIChkZWZhdWx0cyB0b1xuXHQgKiBBRVMpLCBtb2RlIChkZWZhdWx0cyB0byAnY2JjJylcblx0ICovXG5cdENyeXB0by5nZXREZWZhdWx0UGFyYW1zID0gZnVuY3Rpb24ocGFyYW1zKSB7XG5cdFx0dmFyIGtleTtcblx0XHQvKiBCYWNrd2FyZCBjb21wYXRpYmlsaXR5ICovXG5cdFx0aWYoKHR5cGVvZihwYXJhbXMpID09PSAnZnVuY3Rpb24nKSB8fCAodHlwZW9mKHBhcmFtcykgPT09ICdzdHJpbmcnKSkge1xuXHRcdFx0TG9nZ2VyLmRlcHJlY2F0ZWQoJ0NyeXB0by5nZXREZWZhdWx0UGFyYW1zKGtleSwgY2FsbGJhY2spJywgJ0NyeXB0by5nZXREZWZhdWx0UGFyYW1zKHtrZXk6IGtleX0pJyk7XG5cdFx0XHRpZih0eXBlb2YocGFyYW1zKSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRDcnlwdG8uZ2VuZXJhdGVSYW5kb21LZXkoZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHRcdFx0cGFyYW1zKG51bGwsIENyeXB0by5nZXREZWZhdWx0UGFyYW1zKHtrZXk6IGtleX0pKTtcblx0XHRcdFx0fSlcblx0XHRcdH0gZWxzZSBpZih0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdGFyZ3VtZW50c1sxXShudWxsLCBDcnlwdG8uZ2V0RGVmYXVsdFBhcmFtcyh7a2V5OiBwYXJhbXN9KSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzIGZvciBDcnlwdG8uZ2V0RGVmYXVsdFBhcmFtcycpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmKCFwYXJhbXMua2V5KSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0NyeXB0by5nZXREZWZhdWx0UGFyYW1zOiBhIGtleSBpcyByZXF1aXJlZCcpO1xuXHRcdH1cblxuXHRcdGlmICh0eXBlb2YocGFyYW1zLmtleSkgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRrZXkgPSBDcnlwdG9KUy5lbmMuQmFzZTY0LnBhcnNlKG5vcm1hbGlzZUJhc2U2NChwYXJhbXMua2V5KSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGtleSA9IEJ1ZmZlclV0aWxzLnRvV29yZEFycmF5KHBhcmFtcy5rZXkpOyAvLyBFeHBlY3Qga2V5IHRvIGJlIGFuIEFycmF5LCBBcnJheUJ1ZmZlciwgb3IgV29yZEFycmF5IGF0IHRoaXMgcG9pbnRcblx0XHR9XG5cblx0XHR2YXIgY2lwaGVyUGFyYW1zID0gbmV3IENpcGhlclBhcmFtcygpO1xuXHRcdGNpcGhlclBhcmFtcy5rZXkgPSBrZXk7XG5cdFx0Y2lwaGVyUGFyYW1zLmFsZ29yaXRobSA9IHBhcmFtcy5hbGdvcml0aG0gfHwgREVGQVVMVF9BTEdPUklUSE07XG5cdFx0Y2lwaGVyUGFyYW1zLmtleUxlbmd0aCA9IGtleS53b3Jkcy5sZW5ndGggKiAoNCAqIDgpO1xuXHRcdGNpcGhlclBhcmFtcy5tb2RlID0gcGFyYW1zLm1vZGUgfHwgREVGQVVMVF9NT0RFO1xuXG5cdFx0aWYocGFyYW1zLmtleUxlbmd0aCAmJiBwYXJhbXMua2V5TGVuZ3RoICE9PSBjaXBoZXJQYXJhbXMua2V5TGVuZ3RoKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0NyeXB0by5nZXREZWZhdWx0UGFyYW1zOiBhIGtleUxlbmd0aCBvZiAnICsgcGFyYW1zLmtleUxlbmd0aCArICcgd2FzIHNwZWNpZmllZCwgYnV0IHRoZSBrZXkgYWN0dWFsbHkgaGFzIGxlbmd0aCAnICsgY2lwaGVyUGFyYW1zLmtleUxlbmd0aCk7XG5cdFx0fVxuXG5cdFx0dmFsaWRhdGVDaXBoZXJQYXJhbXMoY2lwaGVyUGFyYW1zKTtcblx0XHRyZXR1cm4gY2lwaGVyUGFyYW1zO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBHZW5lcmF0ZSBhIHJhbmRvbSBlbmNyeXB0aW9uIGtleSBmcm9tIHRoZSBzdXBwbGllZCBrZXlsZW5ndGggKG9yIHRoZVxuXHQgKiBkZWZhdWx0IGtleUxlbmd0aCBpZiBub25lIHN1cHBsaWVkKSBhcyBhIENyeXB0b0pTIFdvcmRBcnJheVxuXHQgKiBAcGFyYW0ga2V5TGVuZ3RoIChvcHRpb25hbCkgdGhlIHJlcXVpcmVkIGtleUxlbmd0aCBpbiBiaXRzXG5cdCAqIEBwYXJhbSBjYWxsYmFjayAoZXJyLCBrZXkpXG5cdCAqL1xuXHRDcnlwdG8uZ2VuZXJhdGVSYW5kb21LZXkgPSBmdW5jdGlvbihrZXlMZW5ndGgsIGNhbGxiYWNrKSB7XG5cdFx0aWYoYXJndW1lbnRzLmxlbmd0aCA9PSAxICYmIHR5cGVvZihrZXlMZW5ndGgpID09ICdmdW5jdGlvbicpIHtcblx0XHRcdGNhbGxiYWNrID0ga2V5TGVuZ3RoO1xuXHRcdFx0a2V5TGVuZ3RoID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRnZW5lcmF0ZVJhbmRvbSgoa2V5TGVuZ3RoIHx8IERFRkFVTFRfS0VZTEVOR1RIKSAvIDgsIGNhbGxiYWNrKTtcblx0fTtcblxuXHQvKipcblx0ICogSW50ZXJuYWw7IGdldCBhIENoYW5uZWxDaXBoZXIgaW5zdGFuY2UgYmFzZWQgb24gdGhlIGdpdmVuIGNpcGhlclBhcmFtc1xuXHQgKiBAcGFyYW0gcGFyYW1zIGVpdGhlciBhIENpcGhlclBhcmFtcyBpbnN0YW5jZSBvciBzb21lIHN1YnNldCBvZiBpdHNcblx0ICogZmllbGRzIHRoYXQgaW5jbHVkZXMgYSBrZXlcblx0ICovXG5cdENyeXB0by5nZXRDaXBoZXIgPSBmdW5jdGlvbihwYXJhbXMpIHtcblx0XHR2YXIgY2lwaGVyUGFyYW1zID0gKHBhcmFtcyBpbnN0YW5jZW9mIENpcGhlclBhcmFtcykgP1xuXHRcdCAgICAgICAgICAgICAgICAgICBwYXJhbXMgOlxuXHRcdCAgICAgICAgICAgICAgICAgICBDcnlwdG8uZ2V0RGVmYXVsdFBhcmFtcyhwYXJhbXMpO1xuXG5cdFx0cmV0dXJuIHtjaXBoZXJQYXJhbXM6IGNpcGhlclBhcmFtcywgY2lwaGVyOiBuZXcgQ0JDQ2lwaGVyKGNpcGhlclBhcmFtcywgREVGQVVMVF9CTE9DS0xFTkdUSF9XT1JEUywgcGFyYW1zLml2KX07XG5cdH07XG5cblx0ZnVuY3Rpb24gQ0JDQ2lwaGVyKHBhcmFtcywgYmxvY2tMZW5ndGhXb3JkcywgaXYpIHtcblx0XHR0aGlzLmFsZ29yaXRobSA9IHBhcmFtcy5hbGdvcml0aG0gKyAnLScgKyBTdHJpbmcocGFyYW1zLmtleUxlbmd0aCkgKyAnLScgKyBwYXJhbXMubW9kZTtcblx0XHR0aGlzLmNqc0FsZ29yaXRobSA9IHBhcmFtcy5hbGdvcml0aG0udG9VcHBlckNhc2UoKS5yZXBsYWNlKC8tXFxkKyQvLCAnJyk7XG5cdFx0dGhpcy5rZXkgPSBCdWZmZXJVdGlscy50b1dvcmRBcnJheShwYXJhbXMua2V5KTtcblx0XHRpZihpdikge1xuXHRcdFx0dGhpcy5pdiA9IEJ1ZmZlclV0aWxzLnRvV29yZEFycmF5KGl2KS5jbG9uZSgpO1xuXHRcdH1cblx0XHR0aGlzLmJsb2NrTGVuZ3RoV29yZHMgPSBibG9ja0xlbmd0aFdvcmRzO1xuXHR9XG5cblx0Q0JDQ2lwaGVyLnByb3RvdHlwZS5lbmNyeXB0ID0gZnVuY3Rpb24ocGxhaW50ZXh0LCBjYWxsYmFjaykge1xuXHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSUNSTywgJ0NCQ0NpcGhlci5lbmNyeXB0KCknLCAnJyk7XG5cdFx0cGxhaW50ZXh0ID0gQnVmZmVyVXRpbHMudG9Xb3JkQXJyYXkocGxhaW50ZXh0KTtcblx0XHQvL2NvbnNvbGUubG9nKCdlbmNyeXB0OiBwbGFpbnRleHQ6Jyk7XG5cdFx0Ly9jb25zb2xlLmxvZyhDcnlwdG9KUy5lbmMuSGV4LnN0cmluZ2lmeShwbGFpbnRleHQpKTtcblx0XHR2YXIgcGxhaW50ZXh0TGVuZ3RoID0gcGxhaW50ZXh0LnNpZ0J5dGVzLFxuXHRcdFx0cGFkZGVkTGVuZ3RoID0gZ2V0UGFkZGVkTGVuZ3RoKHBsYWludGV4dExlbmd0aCksXG5cdFx0XHRzZWxmID0gdGhpcztcblxuXHRcdHZhciB0aGVuID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRzZWxmLmdldEl2KGZ1bmN0aW9uKGVyciwgaXYpIHtcblx0XHRcdFx0aWYgKGVycikge1xuXHRcdFx0XHRcdGNhbGxiYWNrKGVycik7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBjaXBoZXJPdXQgPSBzZWxmLmVuY3J5cHRDaXBoZXIucHJvY2VzcyhwbGFpbnRleHQuY29uY2F0KHBrY3M1UGFkZGluZ1twYWRkZWRMZW5ndGggLSBwbGFpbnRleHRMZW5ndGhdKSk7XG5cdFx0XHRcdHZhciBjaXBoZXJ0ZXh0ID0gaXYuY29uY2F0KGNpcGhlck91dCk7XG5cdFx0XHRcdC8vY29uc29sZS5sb2coJ2VuY3J5cHQ6IGNpcGhlcnRleHQ6Jyk7XG5cdFx0XHRcdC8vY29uc29sZS5sb2coQ3J5cHRvSlMuZW5jLkhleC5zdHJpbmdpZnkoY2lwaGVydGV4dCkpO1xuXHRcdFx0XHRjYWxsYmFjayhudWxsLCBjaXBoZXJ0ZXh0KTtcblx0XHRcdH0pO1xuXHRcdH07XG5cblx0XHRpZiAoIXRoaXMuZW5jcnlwdENpcGhlcikge1xuXHRcdFx0aWYodGhpcy5pdikge1xuXHRcdFx0XHR0aGlzLmVuY3J5cHRDaXBoZXIgPSBDcnlwdG9KUy5hbGdvW3RoaXMuY2pzQWxnb3JpdGhtXS5jcmVhdGVFbmNyeXB0b3IodGhpcy5rZXksIHsgaXY6IHRoaXMuaXYgfSk7XG5cdFx0XHRcdHRoZW4oKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGdlbmVyYXRlUmFuZG9tKERFRkFVTFRfQkxPQ0tMRU5HVEgsIGZ1bmN0aW9uKGVyciwgaXYpIHtcblx0XHRcdFx0XHRpZiAoZXJyKSB7XG5cdFx0XHRcdFx0XHRjYWxsYmFjayhlcnIpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzZWxmLmVuY3J5cHRDaXBoZXIgPSBDcnlwdG9KUy5hbGdvW3NlbGYuY2pzQWxnb3JpdGhtXS5jcmVhdGVFbmNyeXB0b3Ioc2VsZi5rZXksIHsgaXY6IGl2IH0pO1xuXHRcdFx0XHRcdHNlbGYuaXYgPSBpdjtcblx0XHRcdFx0XHR0aGVuKCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGVuKCk7XG5cdFx0fVxuXHR9O1xuXG5cdENCQ0NpcGhlci5wcm90b3R5cGUuZGVjcnlwdCA9IGZ1bmN0aW9uKGNpcGhlcnRleHQpIHtcblx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlDUk8sICdDQkNDaXBoZXIuZGVjcnlwdCgpJywgJycpO1xuXHRcdGNpcGhlcnRleHQgPSBCdWZmZXJVdGlscy50b1dvcmRBcnJheShjaXBoZXJ0ZXh0KTtcblx0XHQvL2NvbnNvbGUubG9nKCdkZWNyeXB0OiBjaXBoZXJ0ZXh0OicpO1xuXHRcdC8vY29uc29sZS5sb2coQ3J5cHRvSlMuZW5jLkhleC5zdHJpbmdpZnkoY2lwaGVydGV4dCkpO1xuXHRcdHZhciBibG9ja0xlbmd0aFdvcmRzID0gdGhpcy5ibG9ja0xlbmd0aFdvcmRzLFxuXHRcdFx0Y2lwaGVydGV4dFdvcmRzID0gY2lwaGVydGV4dC53b3Jkcyxcblx0XHRcdGl2ID0gV29yZEFycmF5LmNyZWF0ZShjaXBoZXJ0ZXh0V29yZHMuc2xpY2UoMCwgYmxvY2tMZW5ndGhXb3JkcykpLFxuXHRcdFx0Y2lwaGVydGV4dEJvZHkgPSBXb3JkQXJyYXkuY3JlYXRlKGNpcGhlcnRleHRXb3Jkcy5zbGljZShibG9ja0xlbmd0aFdvcmRzKSk7XG5cblx0XHR2YXIgZGVjcnlwdENpcGhlciA9IENyeXB0b0pTLmFsZ29bdGhpcy5janNBbGdvcml0aG1dLmNyZWF0ZURlY3J5cHRvcih0aGlzLmtleSwgeyBpdjogaXYgfSk7XG5cdFx0dmFyIHBsYWludGV4dCA9IGRlY3J5cHRDaXBoZXIucHJvY2VzcyhjaXBoZXJ0ZXh0Qm9keSk7XG5cdFx0dmFyIGVwaWxvZ3VlID0gZGVjcnlwdENpcGhlci5maW5hbGl6ZSgpO1xuXHRcdGRlY3J5cHRDaXBoZXIucmVzZXQoKTtcblx0XHRpZihlcGlsb2d1ZSAmJiBlcGlsb2d1ZS5zaWdCeXRlcykgcGxhaW50ZXh0LmNvbmNhdChlcGlsb2d1ZSk7XG5cdFx0Ly9jb25zb2xlLmxvZygnZGVjcnlwdDogcGxhaW50ZXh0OicpO1xuXHRcdC8vY29uc29sZS5sb2coQ3J5cHRvSlMuZW5jLkhleC5zdHJpbmdpZnkocGxhaW50ZXh0KSk7XG5cdFx0cmV0dXJuIHBsYWludGV4dDtcblx0fTtcblxuXHRDQkNDaXBoZXIucHJvdG90eXBlLmdldEl2ID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0XHRpZih0aGlzLml2KSB7XG5cdFx0XHR2YXIgaXYgPSB0aGlzLml2O1xuXHRcdFx0dGhpcy5pdiA9IG51bGw7XG5cdFx0XHRjYWxsYmFjayhudWxsLCBpdik7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0LyogU2luY2UgdGhlIGl2IGZvciBhIG5ldyBibG9jayBpcyB0aGUgY2lwaGVydGV4dCBvZiB0aGUgbGFzdCwgdGhpc1xuXHRcdCogc2V0cyBhIG5ldyBpdiAoPSBhZXMocmFuZG9tQmxvY2sgWE9SIGxhc3RDaXBoZXJUZXh0KSkgYXMgd2VsbCBhc1xuXHRcdCogcmV0dXJuaW5nIGl0ICovXG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdGdlbmVyYXRlUmFuZG9tKERFRkFVTFRfQkxPQ0tMRU5HVEgsIGZ1bmN0aW9uKGVyciwgcmFuZG9tQmxvY2spIHtcblx0XHRcdGlmIChlcnIpIHtcblx0XHRcdFx0Y2FsbGJhY2soZXJyKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fSBcblx0XHRcdGNhbGxiYWNrKG51bGwsIHNlbGYuZW5jcnlwdENpcGhlci5wcm9jZXNzKHJhbmRvbUJsb2NrKSk7XG5cdFx0fSk7XG5cdH07XG5cblx0cmV0dXJuIENyeXB0bztcbn0pKCk7XG5cbnZhciBXZWJTdG9yYWdlID0gKGZ1bmN0aW9uKCkge1xuXHR2YXIgc2Vzc2lvblN1cHBvcnRlZCxcblx0XHRsb2NhbFN1cHBvcnRlZCxcblx0XHR0ZXN0ID0gJ2FibHlqcy1zdG9yYWdlLXRlc3QnO1xuXG5cdC8qIEV2ZW4ganVzdCBhY2Nlc3NpbmcgdGhlIHNlc3Npb24vbG9jYWxTdG9yYWdlIG9iamVjdCBjYW4gdGhyb3cgYVxuXHQgKiBzZWN1cml0eSBleGNlcHRpb24gaW4gc29tZSBjaXJjdW1zdGFuY2VzIHdpdGggc29tZSBicm93c2Vycy4gSW5cblx0ICogb3RoZXJzLCBjYWxsaW5nIHNldEl0ZW0gd2lsbCB0aHJvdy4gU28gaGF2ZSB0byBjaGVjayBpbiB0aGlzXG5cdCAqIHNvbWV3aGF0IHJvdW5kYWJvdXQgd2F5LiAoSWYgdW5zdXBwb3J0ZWQgb3Igbm8gd2luZG93IG9iamVjdCxcblx0ICogd2lsbCB0aHJvdyBvbiBhY2Nlc3NpbmcgYSBwcm9wZXJ0eSBvZiB1bmRlZmluZWQpICovXG5cdHRyeSB7XG5cdFx0d2luZG93LnNlc3Npb25TdG9yYWdlLnNldEl0ZW0odGVzdCwgdGVzdCk7XG5cdFx0d2luZG93LnNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0odGVzdCk7XG5cdFx0c2Vzc2lvblN1cHBvcnRlZCA9IHRydWU7XG5cdH0gY2F0Y2goZSkge1xuXHRcdHNlc3Npb25TdXBwb3J0ZWQgPSBmYWxzZTtcblx0fVxuXG5cdHRyeSB7XG5cdFx0d2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKHRlc3QsIHRlc3QpO1xuXHRcdHdpbmRvdy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSh0ZXN0KTtcblx0XHRsb2NhbFN1cHBvcnRlZCA9IHRydWU7XG5cdH0gY2F0Y2goZSkge1xuXHRcdGxvY2FsU3VwcG9ydGVkID0gZmFsc2U7XG5cdH1cblxuXHRmdW5jdGlvbiBXZWJTdG9yYWdlKCkge31cblxuXHRmdW5jdGlvbiBzdG9yYWdlSW50ZXJmYWNlKHNlc3Npb24pIHtcblx0XHRyZXR1cm4gc2Vzc2lvbiA/IHdpbmRvdy5zZXNzaW9uU3RvcmFnZSA6IHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXQobmFtZSwgdmFsdWUsIHR0bCwgc2Vzc2lvbikge1xuXHRcdHZhciB3cmFwcGVkVmFsdWUgPSB7dmFsdWU6IHZhbHVlfTtcblx0XHRpZih0dGwpIHtcblx0XHRcdHdyYXBwZWRWYWx1ZS5leHBpcmVzID0gVXRpbHMubm93KCkgKyB0dGw7XG5cdFx0fVxuXHRcdHJldHVybiBzdG9yYWdlSW50ZXJmYWNlKHNlc3Npb24pLnNldEl0ZW0obmFtZSwgSlNPTi5zdHJpbmdpZnkod3JhcHBlZFZhbHVlKSk7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXQobmFtZSwgc2Vzc2lvbikge1xuXHRcdHZhciByYXdJdGVtID0gc3RvcmFnZUludGVyZmFjZShzZXNzaW9uKS5nZXRJdGVtKG5hbWUpO1xuXHRcdGlmKCFyYXdJdGVtKSByZXR1cm4gbnVsbDtcblx0XHR2YXIgd3JhcHBlZFZhbHVlID0gSlNPTi5wYXJzZShyYXdJdGVtKTtcblx0XHRpZih3cmFwcGVkVmFsdWUuZXhwaXJlcyAmJiAod3JhcHBlZFZhbHVlLmV4cGlyZXMgPCBVdGlscy5ub3coKSkpIHtcblx0XHRcdHN0b3JhZ2VJbnRlcmZhY2Uoc2Vzc2lvbikucmVtb3ZlSXRlbShuYW1lKTtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gd3JhcHBlZFZhbHVlLnZhbHVlO1xuXHR9XG5cblx0ZnVuY3Rpb24gcmVtb3ZlKG5hbWUsIHNlc3Npb24pIHtcblx0XHRyZXR1cm4gc3RvcmFnZUludGVyZmFjZShzZXNzaW9uKS5yZW1vdmVJdGVtKG5hbWUpO1xuXHR9XG5cblx0aWYobG9jYWxTdXBwb3J0ZWQpIHtcblx0XHRXZWJTdG9yYWdlLnNldCAgICA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCB0dGwpIHsgcmV0dXJuIHNldChuYW1lLCB2YWx1ZSwgdHRsLCBmYWxzZSk7IH07XG5cdFx0V2ViU3RvcmFnZS5nZXQgICAgPSBmdW5jdGlvbihuYW1lKSB7IHJldHVybiBnZXQobmFtZSwgZmFsc2UpOyB9O1xuXHRcdFdlYlN0b3JhZ2UucmVtb3ZlID0gZnVuY3Rpb24obmFtZSkgeyByZXR1cm4gcmVtb3ZlKG5hbWUsIGZhbHNlKTsgfTtcblx0fVxuXG5cdGlmKHNlc3Npb25TdXBwb3J0ZWQpIHtcblx0XHRXZWJTdG9yYWdlLnNldFNlc3Npb24gICAgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSwgdHRsKSB7IHJldHVybiBzZXQobmFtZSwgdmFsdWUsIHR0bCwgdHJ1ZSk7IH07XG5cdFx0V2ViU3RvcmFnZS5nZXRTZXNzaW9uICAgID0gZnVuY3Rpb24obmFtZSkgeyByZXR1cm4gZ2V0KG5hbWUsIHRydWUpOyB9O1xuXHRcdFdlYlN0b3JhZ2UucmVtb3ZlU2Vzc2lvbiA9IGZ1bmN0aW9uKG5hbWUpIHsgcmV0dXJuIHJlbW92ZShuYW1lLCB0cnVlKTsgfTtcblx0fVxuXG5cdHJldHVybiBXZWJTdG9yYWdlO1xufSkoKTtcblxudmFyIERlZmF1bHRzID0ge1xuXHRpbnRlcm5ldFVwVXJsOiAnaHR0cHM6Ly9pbnRlcm5ldC11cC5hYmx5LXJlYWx0aW1lLmNvbS9pcy10aGUtaW50ZXJuZXQtdXAudHh0Jyxcblx0anNvbnBJbnRlcm5ldFVwVXJsOiAnaHR0cHM6Ly9pbnRlcm5ldC11cC5hYmx5LXJlYWx0aW1lLmNvbS9pcy10aGUtaW50ZXJuZXQtdXAtMC05LmpzJyxcblx0LyogT3JkZXIgbWF0dGVycyBoZXJlOiB0aGUgYmFzZSB0cmFuc3BvcnQgaXMgdGhlIGxlZnRtb3N0IG9uZSBpbiB0aGVcblx0ICogaW50ZXJzZWN0aW9uIG9mIGJhc2VUcmFuc3BvcnRPcmRlciBhbmQgdGhlIHRyYW5zcG9ydHMgY2xpZW50T3B0aW9uIHRoYXQnc1xuXHQgKiBzdXBwb3J0ZWQuICBUaGlzIGlzIG5vdCBxdWl0ZSB0aGUgc2FtZSBhcyB0aGUgcHJlZmVyZW5jZSBvcmRlciAtLSBlLmcuXG5cdCAqIHhocl9wb2xsaW5nIGlzIHByZWZlcnJlZCB0byBqc29ucCwgYnV0IGZvciBicm93c2VycyB0aGF0IHN1cHBvcnQgaXQgd2Ugd2FudFxuXHQgKiB0aGUgYmFzZSB0cmFuc3BvcnQgdG8gYmUgeGhyX3BvbGxpbmcsIG5vdCBqc29ucCAqL1xuXHRkZWZhdWx0VHJhbnNwb3J0czogWyd4aHJfcG9sbGluZycsICd4aHJfc3RyZWFtaW5nJywgJ2pzb25wJywgJ3dlYl9zb2NrZXQnXSxcblx0YmFzZVRyYW5zcG9ydE9yZGVyOiBbJ3hocl9wb2xsaW5nJywgJ3hocl9zdHJlYW1pbmcnLCAnanNvbnAnLCAnd2ViX3NvY2tldCddLFxuXHR0cmFuc3BvcnRQcmVmZXJlbmNlT3JkZXI6IFsnanNvbnAnLCAneGhyX3BvbGxpbmcnLCAneGhyX3N0cmVhbWluZycsICd3ZWJfc29ja2V0J10sXG5cdHVwZ3JhZGVUcmFuc3BvcnRzOiBbJ3hocl9zdHJlYW1pbmcnLCAnd2ViX3NvY2tldCddLFxuXHRtaW5pZmllZDogIShmdW5jdGlvbiBfKCl7fSkubmFtZVxufTtcblxuLyogSWYgdXNpbmcgSUU4LCBkb24ndCBhdHRlbXB0IHRvIHVwZ3JhZGUgZnJvbSB4aHJfcG9sbGluZyB0byB4aHJfc3RyZWFtaW5nIC1cbiogd2hpbGUgaXQgY2FuIGRvIHN0cmVhbWluZywgdGhlIGxvdyBtYXggaHR0cC1jb25uZWN0aW9ucy1wZXItaG9zdCBsaW1pdCBtZWFuc1xuKiB0aGF0IHRoZSBwb2xsaW5nIHRyYW5zcG9ydCBpcyBjcmlwcGxlZCBkdXJpbmcgdGhlIHVwZ3JhZGUgcHJvY2Vzcy4gU28ganVzdFxuKiBsZWF2ZSBpdCBhdCB0aGUgYmFzZSB0cmFuc3BvcnQgKi9cbmlmKFBsYXRmb3JtLm5vVXBncmFkZSkge1xuXHREZWZhdWx0cy51cGdyYWRlVHJhbnNwb3J0cyA9IFtdO1xufVxuXG5cbnZhciBCdWZmZXJVdGlscyA9IChmdW5jdGlvbigpIHtcblx0dmFyIFdvcmRBcnJheSA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXk7XG5cdHZhciBBcnJheUJ1ZmZlciA9IFBsYXRmb3JtLkFycmF5QnVmZmVyO1xuXHR2YXIgYXRvYiA9IFBsYXRmb3JtLmF0b2I7XG5cblx0ZnVuY3Rpb24gaXNXb3JkQXJyYXkob2IpIHsgcmV0dXJuIG9iICE9PSBudWxsICYmIG9iICE9PSB1bmRlZmluZWQgJiYgb2Iuc2lnQnl0ZXMgIT09IHVuZGVmaW5lZDsgfVxuXHRmdW5jdGlvbiBpc0FycmF5QnVmZmVyKG9iKSB7IHJldHVybiBvYiAhPT0gbnVsbCAmJiBvYiAhPT0gdW5kZWZpbmVkICYmIG9iLmNvbnN0cnVjdG9yID09PSBBcnJheUJ1ZmZlcjsgfVxuXG5cdC8vIGh0dHBzOi8vZ2lzdC5naXRodWJ1c2VyY29udGVudC5jb20vam9ubGVpZ2h0b24vOTU4ODQxL3Jhdy9mMjAwZTMwZGZlOTUyMTJjMDE2NWNjZjFhZTAwMGNhNTFlOWRlODAzL2dpc3RmaWxlMS5qc1xuXHRmdW5jdGlvbiBhcnJheUJ1ZmZlclRvQmFzZTY0KEFycmF5QnVmZmVyKSB7XG5cdFx0dmFyIGJhc2U2NCAgICA9ICcnXG5cdFx0dmFyIGVuY29kaW5ncyA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuXG5cdFx0dmFyIGJ5dGVzICAgICAgICAgPSBuZXcgVWludDhBcnJheShBcnJheUJ1ZmZlcilcblx0XHR2YXIgYnl0ZUxlbmd0aCAgICA9IGJ5dGVzLmJ5dGVMZW5ndGhcblx0XHR2YXIgYnl0ZVJlbWFpbmRlciA9IGJ5dGVMZW5ndGggJSAzXG5cdFx0dmFyIG1haW5MZW5ndGggICAgPSBieXRlTGVuZ3RoIC0gYnl0ZVJlbWFpbmRlclxuXG5cdFx0dmFyIGEsIGIsIGMsIGRcblx0XHR2YXIgY2h1bmtcblxuXHRcdC8vIE1haW4gbG9vcCBkZWFscyB3aXRoIGJ5dGVzIGluIGNodW5rcyBvZiAzXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBtYWluTGVuZ3RoOyBpID0gaSArIDMpIHtcblx0XHRcdC8vIENvbWJpbmUgdGhlIHRocmVlIGJ5dGVzIGludG8gYSBzaW5nbGUgaW50ZWdlclxuXHRcdFx0Y2h1bmsgPSAoYnl0ZXNbaV0gPDwgMTYpIHwgKGJ5dGVzW2kgKyAxXSA8PCA4KSB8IGJ5dGVzW2kgKyAyXVxuXG5cdFx0XHQvLyBVc2UgYml0bWFza3MgdG8gZXh0cmFjdCA2LWJpdCBzZWdtZW50cyBmcm9tIHRoZSB0cmlwbGV0XG5cdFx0XHRhID0gKGNodW5rICYgMTY1MTUwNzIpID4+IDE4IC8vIDE2NTE1MDcyID0gKDJeNiAtIDEpIDw8IDE4XG5cdFx0XHRiID0gKGNodW5rICYgMjU4MDQ4KSAgID4+IDEyIC8vIDI1ODA0OCAgID0gKDJeNiAtIDEpIDw8IDEyXG5cdFx0XHRjID0gKGNodW5rICYgNDAzMikgICAgID4+ICA2IC8vIDQwMzIgICAgID0gKDJeNiAtIDEpIDw8IDZcblx0XHRcdGQgPSBjaHVuayAmIDYzICAgICAgICAgICAgICAgLy8gNjMgICAgICAgPSAyXjYgLSAxXG5cblx0XHRcdC8vIENvbnZlcnQgdGhlIHJhdyBiaW5hcnkgc2VnbWVudHMgdG8gdGhlIGFwcHJvcHJpYXRlIEFTQ0lJIGVuY29kaW5nXG5cdFx0XHRiYXNlNjQgKz0gZW5jb2RpbmdzW2FdICsgZW5jb2RpbmdzW2JdICsgZW5jb2RpbmdzW2NdICsgZW5jb2RpbmdzW2RdXG5cdFx0fVxuXG5cdFx0Ly8gRGVhbCB3aXRoIHRoZSByZW1haW5pbmcgYnl0ZXMgYW5kIHBhZGRpbmdcblx0XHRpZiAoYnl0ZVJlbWFpbmRlciA9PSAxKSB7XG5cdFx0XHRjaHVuayA9IGJ5dGVzW21haW5MZW5ndGhdXG5cblx0XHRcdGEgPSAoY2h1bmsgJiAyNTIpID4+IDIgLy8gMjUyID0gKDJeNiAtIDEpIDw8IDJcblxuXHRcdFx0Ly8gU2V0IHRoZSA0IGxlYXN0IHNpZ25pZmljYW50IGJpdHMgdG8gemVyb1xuXHRcdFx0YiA9IChjaHVuayAmIDMpICAgPDwgNCAvLyAzICAgPSAyXjIgLSAxXG5cblx0XHRcdGJhc2U2NCArPSBlbmNvZGluZ3NbYV0gKyBlbmNvZGluZ3NbYl0gKyAnPT0nXG5cdFx0fSBlbHNlIGlmIChieXRlUmVtYWluZGVyID09IDIpIHtcblx0XHRcdGNodW5rID0gKGJ5dGVzW21haW5MZW5ndGhdIDw8IDgpIHwgYnl0ZXNbbWFpbkxlbmd0aCArIDFdXG5cblx0XHRcdGEgPSAoY2h1bmsgJiA2NDUxMikgPj4gMTAgLy8gNjQ1MTIgPSAoMl42IC0gMSkgPDwgMTBcblx0XHRcdGIgPSAoY2h1bmsgJiAxMDA4KSAgPj4gIDQgLy8gMTAwOCAgPSAoMl42IC0gMSkgPDwgNFxuXG5cdFx0XHQvLyBTZXQgdGhlIDIgbGVhc3Qgc2lnbmlmaWNhbnQgYml0cyB0byB6ZXJvXG5cdFx0XHRjID0gKGNodW5rICYgMTUpICAgIDw8ICAyIC8vIDE1ICAgID0gMl40IC0gMVxuXG5cdFx0XHRiYXNlNjQgKz0gZW5jb2RpbmdzW2FdICsgZW5jb2RpbmdzW2JdICsgZW5jb2RpbmdzW2NdICsgJz0nXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGJhc2U2NFxuXHR9XG5cblx0ZnVuY3Rpb24gYmFzZTY0VG9BcnJheUJ1ZmZlcihiYXNlNjQpIHtcblx0XHR2YXIgYmluYXJ5X3N0cmluZyA9ICBhdG9iKGJhc2U2NCk7XG5cdFx0dmFyIGxlbiA9IGJpbmFyeV9zdHJpbmcubGVuZ3RoO1xuXHRcdHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KCBsZW4gKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSAgICAgICAge1xuXHRcdFx0dmFyIGFzY2lpID0gYmluYXJ5X3N0cmluZy5jaGFyQ29kZUF0KGkpO1xuXHRcdFx0Ynl0ZXNbaV0gPSBhc2NpaTtcblx0XHR9XG5cdFx0cmV0dXJuIGJ5dGVzLmJ1ZmZlcjtcblx0fVxuXG5cdGZ1bmN0aW9uIEJ1ZmZlclV0aWxzKCkge31cblxuXHRCdWZmZXJVdGlscy5pc0J1ZmZlciA9IGZ1bmN0aW9uKGJ1ZikgeyByZXR1cm4gaXNBcnJheUJ1ZmZlcihidWYpIHx8IGlzV29yZEFycmF5KGJ1Zik7IH07XG5cblx0QnVmZmVyVXRpbHMudG9BcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKGJ1Zikge1xuXHRcdGlmKCFBcnJheUJ1ZmZlcilcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIkNhbid0IGNvbnZlcnQgdG8gQXJyYXlCdWZmZXI6IEFycmF5QnVmZmVyIG5vdCBzdXBwb3J0ZWRcIik7XG5cblx0XHRpZihpc0FycmF5QnVmZmVyKGJ1ZikpXG5cdFx0XHRyZXR1cm4gYnVmO1xuXG5cdFx0aWYoaXNXb3JkQXJyYXkoYnVmKSkge1xuXHRcdFx0LyogQmFja3BvcnRlZCBmcm9tIHVucmVsZWFzZWQgQ3J5cHRvSlNcblx0XHRcdCogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jcnlwdG8tanMvc291cmNlL2Jyb3dzZS9icmFuY2hlcy8zLngvc3JjL2xpYi10eXBlZGFycmF5cy5qcz9yPTY2MSAqL1xuXHRcdFx0dmFyIGFycmF5QnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ1Zi5zaWdCeXRlcyk7XG5cdFx0XHR2YXIgdWludDhWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGJ1Zi5zaWdCeXRlczsgaSsrKSB7XG5cdFx0XHRcdHVpbnQ4Vmlld1tpXSA9IChidWYud29yZHNbaSA+Pj4gMl0gPj4+ICgyNCAtIChpICUgNCkgKiA4KSkgJiAweGZmO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYXJyYXlCdWZmZXI7XG5cdFx0fTtcblxuXHRcdHRocm93IG5ldyBFcnJvcihcIkJ1ZmZlclV0aWxzLnRvQXJyYXlCdWZmZXIgZXhwZWN0ZWQgYSBidWZmZXJcIik7XG5cdH07XG5cblx0QnVmZmVyVXRpbHMudG9Xb3JkQXJyYXkgPSBmdW5jdGlvbihidWYpIHtcblx0XHRyZXR1cm4gaXNXb3JkQXJyYXkoYnVmKSA/IGJ1ZiA6IFdvcmRBcnJheS5jcmVhdGUoYnVmKTtcblx0fTtcblxuXHRCdWZmZXJVdGlscy5iYXNlNjRFbmNvZGUgPSBmdW5jdGlvbihidWYpIHtcblx0XHRpZihpc0FycmF5QnVmZmVyKGJ1ZikpXG5cdFx0XHRyZXR1cm4gYXJyYXlCdWZmZXJUb0Jhc2U2NChidWYpO1xuXHRcdGlmKGlzV29yZEFycmF5KGJ1ZikpXG5cdFx0XHRyZXR1cm4gQ3J5cHRvSlMuZW5jLkJhc2U2NC5zdHJpbmdpZnkoYnVmKTtcblx0fTtcblxuXHRCdWZmZXJVdGlscy5iYXNlNjREZWNvZGUgPSBmdW5jdGlvbihzdHIpIHtcblx0XHRpZihBcnJheUJ1ZmZlciAmJiBhdG9iKVxuXHRcdFx0cmV0dXJuIGJhc2U2NFRvQXJyYXlCdWZmZXIoc3RyKTtcblx0XHRyZXR1cm4gQ3J5cHRvSlMuZW5jLkJhc2U2NC5wYXJzZShzdHIpO1xuXHR9O1xuXG5cdEJ1ZmZlclV0aWxzLmhleEVuY29kZSA9IGZ1bmN0aW9uKGJ1Zikge1xuXHRcdGlmKGlzQXJyYXlCdWZmZXIoYnVmKSkgYnVmID0gV29yZEFycmF5LmNyZWF0ZShidWYpO1xuXHRcdHJldHVybiBDcnlwdG9KUy5lbmMuSGV4LnN0cmluZ2lmeShidWYpO1xuXHR9O1xuXG5cdEJ1ZmZlclV0aWxzLnV0ZjhFbmNvZGUgPSBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRyZXR1cm4gQ3J5cHRvSlMuZW5jLlV0ZjgucGFyc2Uoc3RyaW5nKTtcblx0fTtcblxuXHRCdWZmZXJVdGlscy51dGY4RGVjb2RlID0gZnVuY3Rpb24oYnVmKSB7XG5cdFx0aWYoaXNBcnJheUJ1ZmZlcihidWYpKVxuXHRcdFx0YnVmID0gQnVmZmVyVXRpbHMudG9Xb3JkQXJyYXkoYnVmKSAvLyBDcnlwdG9KUyBvbmx5IHdvcmtzIHdpdGggV29yZEFycmF5c1xuXHRcdGlmKGlzV29yZEFycmF5KGJ1ZikpXG5cdFx0XHRyZXR1cm4gQ3J5cHRvSlMuZW5jLlV0Zjguc3RyaW5naWZ5KGJ1Zik7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgaW5wdXQgb2YgdXRmOERlY29kZSB0byBiZSBhIGJ1ZmZlciBvciBDcnlwdG9KUyBXb3JkQXJyYXlcIik7XG5cdH07XG5cblx0QnVmZmVyVXRpbHMuYnVmZmVyQ29tcGFyZSA9IGZ1bmN0aW9uKGJ1ZjEsIGJ1ZjIpIHtcblx0XHRpZighYnVmMSkgcmV0dXJuIC0xO1xuXHRcdGlmKCFidWYyKSByZXR1cm4gMTtcblx0XHRidWYxID0gQnVmZmVyVXRpbHMudG9Xb3JkQXJyYXkoYnVmMSk7XG5cdFx0YnVmMiA9IEJ1ZmZlclV0aWxzLnRvV29yZEFycmF5KGJ1ZjIpO1xuXHRcdGJ1ZjEuY2xhbXAoKTsgYnVmMi5jbGFtcCgpO1xuXG5cdFx0dmFyIGNtcCA9IGJ1ZjEuc2lnQnl0ZXMgLSBidWYyLnNpZ0J5dGVzO1xuXHRcdGlmKGNtcCAhPSAwKSByZXR1cm4gY21wO1xuXHRcdGJ1ZjEgPSBidWYxLndvcmRzOyBidWYyID0gYnVmMi53b3Jkcztcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgYnVmMS5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y21wID0gYnVmMVtpXSAtIGJ1ZjJbaV07XG5cdFx0XHRpZihjbXAgIT0gMCkgcmV0dXJuIGNtcDtcblx0XHR9XG5cdFx0cmV0dXJuIDA7XG5cdH07XG5cblx0cmV0dXJuIEJ1ZmZlclV0aWxzO1xufSkoKTtcblxudmFyIEh0dHAgPSAoZnVuY3Rpb24oKSB7XG5cdHZhciBub29wID0gZnVuY3Rpb24oKSB7fTtcblxuXHRmdW5jdGlvbiBIdHRwKCkge31cblxuXHRmdW5jdGlvbiBzaG91bGRGYWxsYmFjayhlcnIpIHtcblx0XHR2YXIgc3RhdHVzQ29kZSA9IGVyci5zdGF0dXNDb2RlO1xuXHRcdC8qIDQwMCArIG5vIGNvZGUgPSBhIGdlbmVyaWMgeGhyIG9uZXJyb3IuIEJyb3dzZXIgZG9lc24ndCBnaXZlIHVzIGVub3VnaFxuXHRcdCAqIGRldGFpbCB0byBrbm93IHdoZXRoZXIgaXQncyBmYWxsYmFjay1maXhhYmxlLCBidXQgaXQgbWF5IGJlIChlZyBpZiBhXG5cdFx0ICogbmV0d29yayBpc3N1ZSksIHNvIHRyeSBqdXN0IGluIGNhc2UgKi9cblx0XHRyZXR1cm4gKHN0YXR1c0NvZGUgPT09IDQwOCAmJiAhZXJyLmNvZGUpIHx8XG5cdFx0XHQoc3RhdHVzQ29kZSA9PT0gNDAwICYmICFlcnIuY29kZSkgICAgICB8fFxuXHRcdFx0KHN0YXR1c0NvZGUgPj0gNTAwICYmIHN0YXR1c0NvZGUgPD0gNTA0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBQZXJmb3JtIGFuIEhUVFAgR0VUIHJlcXVlc3QgZm9yIGEgZ2l2ZW4gcGF0aCBhZ2FpbnN0IHByaW1lIGFuZCBmYWxsYmFjayBBYmx5IGhvc3RzXG5cdCAqIEBwYXJhbSByZXN0XG5cdCAqIEBwYXJhbSBwYXRoIHRoZSBmdWxsIHBhdGggb2YgdGhlIFBPU1QgcmVxdWVzdFxuXHQgKiBAcGFyYW0gaGVhZGVycyBvcHRpb25hbCBoYXNoIG9mIGhlYWRlcnNcblx0ICogQHBhcmFtIHBhcmFtcyBvcHRpb25hbCBoYXNoIG9mIHBhcmFtc1xuXHQgKiBAcGFyYW0gY2FsbGJhY2sgKGVyciwgcmVzcG9uc2UpXG5cdCAqL1xuXHRIdHRwLmdldCA9IGZ1bmN0aW9uKHJlc3QsIHBhdGgsIGhlYWRlcnMsIHBhcmFtcywgY2FsbGJhY2spIHtcblx0XHRjYWxsYmFjayA9IGNhbGxiYWNrIHx8IG5vb3A7XG5cdFx0dmFyIHVyaSA9ICh0eXBlb2YocGF0aCkgPT0gJ2Z1bmN0aW9uJykgPyBwYXRoIDogZnVuY3Rpb24oaG9zdCkgeyByZXR1cm4gcmVzdC5iYXNlVXJpKGhvc3QpICsgcGF0aDsgfTtcblx0XHR2YXIgYmluYXJ5ID0gKGhlYWRlcnMgJiYgaGVhZGVycy5hY2NlcHQgIT0gJ2FwcGxpY2F0aW9uL2pzb24nKTtcblxuXHRcdHZhciBob3N0cywgY29ubmVjdGlvbiA9IHJlc3QuY29ubmVjdGlvbjtcblx0XHRpZihjb25uZWN0aW9uICYmIGNvbm5lY3Rpb24uc3RhdGUgPT0gJ2Nvbm5lY3RlZCcpXG5cdFx0XHRob3N0cyA9IFtjb25uZWN0aW9uLmNvbm5lY3Rpb25NYW5hZ2VyLmhvc3RdO1xuXHRcdGVsc2Vcblx0XHRcdGhvc3RzID0gRGVmYXVsdHMuZ2V0SG9zdHMocmVzdC5vcHRpb25zKTtcblxuXHRcdC8qIGlmIHRoZXJlIGlzIG9ubHkgb25lIGhvc3QgZG8gaXQgKi9cblx0XHRpZihob3N0cy5sZW5ndGggPT0gMSkge1xuXHRcdFx0SHR0cC5nZXRVcmkocmVzdCwgdXJpKGhvc3RzWzBdKSwgaGVhZGVycywgcGFyYW1zLCBjYWxsYmFjayk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Lyogc28gaG9zdCBpcyBhbiBhcnJheSB3aXRoIHByZWZlcnJlZCBob3N0IHBsdXMgYXQgbGVhc3Qgb25lIGZhbGxiYWNrICovXG5cdFx0dmFyIHRyeUFIb3N0ID0gZnVuY3Rpb24oY2FuZGlkYXRlSG9zdHMpIHtcblx0XHRcdEh0dHAuZ2V0VXJpKHJlc3QsIHVyaShjYW5kaWRhdGVIb3N0cy5zaGlmdCgpKSwgaGVhZGVycywgcGFyYW1zLCBmdW5jdGlvbihlcnIpIHtcblx0XHRcdFx0aWYoZXJyICYmIHNob3VsZEZhbGxiYWNrKGVycikgJiYgY2FuZGlkYXRlSG9zdHMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0LyogdXNlIGEgZmFsbGJhY2sgaG9zdCBpZiBhdmFpbGFibGUgKi9cblx0XHRcdFx0XHR0cnlBSG9zdChjYW5kaWRhdGVIb3N0cyk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0dHJ5QUhvc3QoaG9zdHMpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBQZXJmb3JtIGFuIEhUVFAgR0VUIHJlcXVlc3QgZm9yIGEgZ2l2ZW4gcmVzb2x2ZWQgVVJJXG5cdCAqIEBwYXJhbSByZXN0XG5cdCAqIEBwYXJhbSB0aGUgZnVsbCBwYXRoIG9mIHRoZSBQT1NUIHJlcXVlc3Rcblx0ICogQHBhcmFtIGhlYWRlcnMgb3B0aW9uYWwgaGFzaCBvZiBoZWFkZXJzXG5cdCAqIEBwYXJhbSBwYXJhbXMgb3B0aW9uYWwgaGFzaCBvZiBwYXJhbXNcblx0ICogQHBhcmFtIGNhbGxiYWNrIChlcnIsIHJlc3BvbnNlKVxuXHQgKi9cblx0SHR0cC5nZXRVcmkgPSBmdW5jdGlvbihyZXN0LCB1cmksIGhlYWRlcnMsIHBhcmFtcywgY2FsbGJhY2spIHtcblx0XHRIdHRwLlJlcXVlc3QocmVzdCwgdXJpLCBoZWFkZXJzLCBwYXJhbXMsIG51bGwsIGNhbGxiYWNrIHx8IG5vb3ApO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBQZXJmb3JtIGFuIEhUVFAgUE9TVCByZXF1ZXN0XG5cdCAqIEBwYXJhbSByZXN0XG5cdCAqIEBwYXJhbSB0aGUgZnVsbCBwYXRoIG9mIHRoZSBQT1NUIHJlcXVlc3Rcblx0ICogQHBhcmFtIGhlYWRlcnMgb3B0aW9uYWwgaGFzaCBvZiBoZWFkZXJzXG5cdCAqIEBwYXJhbSBib2R5IG9iamVjdCBvciBidWZmZXIgY29udGFpbmluZyByZXF1ZXN0IGJvZHlcblx0ICogQHBhcmFtIHBhcmFtcyBvcHRpb25hbCBoYXNoIG9mIHBhcmFtc1xuXHQgKiBAcGFyYW0gY2FsbGJhY2sgKGVyciwgcmVzcG9uc2UpXG5cdCAqL1xuXHRIdHRwLnBvc3QgPSBmdW5jdGlvbihyZXN0LCBwYXRoLCBoZWFkZXJzLCBib2R5LCBwYXJhbXMsIGNhbGxiYWNrKSB7XG5cdFx0Y2FsbGJhY2sgPSBjYWxsYmFjayB8fCBub29wO1xuXHRcdHZhciB1cmkgPSAodHlwZW9mKHBhdGgpID09ICdmdW5jdGlvbicpID8gcGF0aCA6IGZ1bmN0aW9uKGhvc3QpIHsgcmV0dXJuIHJlc3QuYmFzZVVyaShob3N0KSArIHBhdGg7IH07XG5cdFx0dmFyIGJpbmFyeSA9IChoZWFkZXJzICYmIGhlYWRlcnMuYWNjZXB0ICE9ICdhcHBsaWNhdGlvbi9qc29uJyk7XG5cblx0XHR2YXIgaG9zdHMsIGNvbm5lY3Rpb24gPSByZXN0LmNvbm5lY3Rpb247XG5cdFx0aWYoY29ubmVjdGlvbiAmJiBjb25uZWN0aW9uLnN0YXRlID09ICdjb25uZWN0ZWQnKVxuXHRcdFx0aG9zdHMgPSBbY29ubmVjdGlvbi5jb25uZWN0aW9uTWFuYWdlci5ob3N0XTtcblx0XHRlbHNlXG5cdFx0XHRob3N0cyA9IERlZmF1bHRzLmdldEhvc3RzKHJlc3Qub3B0aW9ucyk7XG5cblx0XHQvKiBpZiB0aGVyZSBpcyBvbmx5IG9uZSBob3N0IGRvIGl0ICovXG5cdFx0aWYoaG9zdHMubGVuZ3RoID09IDEpIHtcblx0XHRcdEh0dHAucG9zdFVyaShyZXN0LCB1cmkoaG9zdHNbMF0pLCBoZWFkZXJzLCBib2R5LCBwYXJhbXMsIGNhbGxiYWNrKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvKiBob3N0cyBpcyBhbiBhcnJheSB3aXRoIHByZWZlcnJlZCBob3N0IHBsdXMgYXQgbGVhc3Qgb25lIGZhbGxiYWNrICovXG5cdFx0dmFyIHRyeUFIb3N0ID0gZnVuY3Rpb24oY2FuZGlkYXRlSG9zdHMpIHtcblx0XHRcdEh0dHAucG9zdFVyaShyZXN0LCB1cmkoY2FuZGlkYXRlSG9zdHMuc2hpZnQoKSksIGhlYWRlcnMsIGJvZHksIHBhcmFtcywgZnVuY3Rpb24oZXJyKSB7XG5cdFx0XHRcdGlmKGVyciAmJiBzaG91bGRGYWxsYmFjayhlcnIpICYmIGNhbmRpZGF0ZUhvc3RzLmxlbmd0aCkge1xuXHRcdFx0XHRcdHRyeUFIb3N0KGNhbmRpZGF0ZUhvc3RzKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FsbGJhY2suYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcblx0XHRcdH0pO1xuXHRcdH07XG5cdFx0dHJ5QUhvc3QoaG9zdHMpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBQZXJmb3JtIGFuIEhUVFAgUE9TVCByZXF1ZXN0IGZvciBhIGdpdmVuIHJlc29sdmVkIFVSSVxuXHQgKiBAcGFyYW0gcmVzdFxuXHQgKiBAcGFyYW0gdGhlIGZ1bGwgcGF0aCBvZiB0aGUgUE9TVCByZXF1ZXN0XG5cdCAqIEBwYXJhbSBoZWFkZXJzIG9wdGlvbmFsIGhhc2ggb2YgaGVhZGVyc1xuXHQgKiBAcGFyYW0gYm9keSBvYmplY3Qgb3IgYnVmZmVyIGNvbnRhaW5pbmcgcmVxdWVzdCBib2R5XG5cdCAqIEBwYXJhbSBwYXJhbXMgb3B0aW9uYWwgaGFzaCBvZiBwYXJhbXNcblx0ICogQHBhcmFtIGNhbGxiYWNrIChlcnIsIHJlc3BvbnNlKVxuXHQgKi9cblx0SHR0cC5wb3N0VXJpID0gZnVuY3Rpb24ocmVzdCwgdXJpLCBoZWFkZXJzLCBib2R5LCBwYXJhbXMsIGNhbGxiYWNrKSB7XG5cdFx0SHR0cC5SZXF1ZXN0KHJlc3QsIHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCBjYWxsYmFjayB8fCBub29wKTtcblx0fTtcblxuXHRIdHRwLnN1cHBvcnRzQXV0aEhlYWRlcnMgPSBmYWxzZTtcblx0SHR0cC5zdXBwb3J0c0xpbmtIZWFkZXJzID0gZmFsc2U7XG5cdHJldHVybiBIdHRwO1xufSkoKTtcblxuLypcbiBDb3B5cmlnaHQgKGMpIDIwMDggRnJlZCBQYWxtZXIgZnJlZC5wYWxtZXJfYXRfZ21haWwuY29tXG5cbiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG4gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XG4gcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXG4gY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuIGNvbmRpdGlvbnM6XG5cbiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcbiBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4gSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXG4gV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4gRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxuIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xudmFyIEJhc2U2NCA9IChmdW5jdGlvbigpIHtcblx0ZnVuY3Rpb24gU3RyaW5nQnVmZmVyKClcblx0e1xuXHRcdHRoaXMuYnVmZmVyID0gW107XG5cdH1cblxuXHRTdHJpbmdCdWZmZXIucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIGFwcGVuZChzdHJpbmcpXG5cdHtcblx0XHR0aGlzLmJ1ZmZlci5wdXNoKHN0cmluZyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0U3RyaW5nQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKClcblx0e1xuXHRcdHJldHVybiB0aGlzLmJ1ZmZlci5qb2luKFwiXCIpO1xuXHR9O1xuXG5cdHZhciBCYXNlNjQgPVxuXHR7XG5cdFx0Y29kZXggOiBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XCIsXG5cblx0XHRlbmNvZGUgOiBmdW5jdGlvbiAoaW5wdXQpXG5cdFx0e1xuXHRcdFx0dmFyIG91dHB1dCA9IG5ldyBTdHJpbmdCdWZmZXIoKTtcblx0XHRcdHZhciBjb2RleCA9IEJhc2U2NC5jb2RleDtcblxuXHRcdFx0dmFyIGVudW1lcmF0b3IgPSBuZXcgVXRmOEVuY29kZUVudW1lcmF0b3IoaW5wdXQpO1xuXHRcdFx0d2hpbGUgKGVudW1lcmF0b3IubW92ZU5leHQoKSlcblx0XHRcdHtcblx0XHRcdFx0dmFyIGNocjEgPSBlbnVtZXJhdG9yLmN1cnJlbnQ7XG5cblx0XHRcdFx0ZW51bWVyYXRvci5tb3ZlTmV4dCgpO1xuXHRcdFx0XHR2YXIgY2hyMiA9IGVudW1lcmF0b3IuY3VycmVudDtcblxuXHRcdFx0XHRlbnVtZXJhdG9yLm1vdmVOZXh0KCk7XG5cdFx0XHRcdHZhciBjaHIzID0gZW51bWVyYXRvci5jdXJyZW50O1xuXG5cdFx0XHRcdHZhciBlbmMxID0gY2hyMSA+PiAyO1xuXHRcdFx0XHR2YXIgZW5jMiA9ICgoY2hyMSAmIDMpIDw8IDQpIHwgKGNocjIgPj4gNCk7XG5cdFx0XHRcdHZhciBlbmMzID0gKChjaHIyICYgMTUpIDw8IDIpIHwgKGNocjMgPj4gNik7XG5cdFx0XHRcdHZhciBlbmM0ID0gY2hyMyAmIDYzO1xuXG5cdFx0XHRcdGlmIChpc05hTihjaHIyKSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGVuYzMgPSBlbmM0ID0gNjQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoaXNOYU4oY2hyMykpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRlbmM0ID0gNjQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRvdXRwdXQuYXBwZW5kKGNvZGV4LmNoYXJBdChlbmMxKSArIGNvZGV4LmNoYXJBdChlbmMyKSArIGNvZGV4LmNoYXJBdChlbmMzKSArIGNvZGV4LmNoYXJBdChlbmM0KSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvdXRwdXQudG9TdHJpbmcoKTtcblx0XHR9LFxuXG5cdFx0ZGVjb2RlIDogZnVuY3Rpb24gKGlucHV0KVxuXHRcdHtcblx0XHRcdHZhciBvdXRwdXQgPSBuZXcgU3RyaW5nQnVmZmVyKCk7XG5cblx0XHRcdHZhciBlbnVtZXJhdG9yID0gbmV3IEJhc2U2NERlY29kZUVudW1lcmF0b3IoaW5wdXQpO1xuXHRcdFx0d2hpbGUgKGVudW1lcmF0b3IubW92ZU5leHQoKSlcblx0XHRcdHtcblx0XHRcdFx0dmFyIGNoYXJDb2RlID0gZW51bWVyYXRvci5jdXJyZW50O1xuXG5cdFx0XHRcdGlmIChjaGFyQ29kZSA8IDEyOClcblx0XHRcdFx0XHRvdXRwdXQuYXBwZW5kKFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpKTtcblx0XHRcdFx0ZWxzZSBpZiAoKGNoYXJDb2RlID4gMTkxKSAmJiAoY2hhckNvZGUgPCAyMjQpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0ZW51bWVyYXRvci5tb3ZlTmV4dCgpO1xuXHRcdFx0XHRcdHZhciBjaGFyQ29kZTIgPSBlbnVtZXJhdG9yLmN1cnJlbnQ7XG5cblx0XHRcdFx0XHRvdXRwdXQuYXBwZW5kKFN0cmluZy5mcm9tQ2hhckNvZGUoKChjaGFyQ29kZSAmIDMxKSA8PCA2KSB8IChjaGFyQ29kZTIgJiA2MykpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRlbnVtZXJhdG9yLm1vdmVOZXh0KCk7XG5cdFx0XHRcdFx0dmFyIGNoYXJDb2RlMiA9IGVudW1lcmF0b3IuY3VycmVudDtcblxuXHRcdFx0XHRcdGVudW1lcmF0b3IubW92ZU5leHQoKTtcblx0XHRcdFx0XHR2YXIgY2hhckNvZGUzID0gZW51bWVyYXRvci5jdXJyZW50O1xuXG5cdFx0XHRcdFx0b3V0cHV0LmFwcGVuZChTdHJpbmcuZnJvbUNoYXJDb2RlKCgoY2hhckNvZGUgJiAxNSkgPDwgMTIpIHwgKChjaGFyQ29kZTIgJiA2MykgPDwgNikgfCAoY2hhckNvZGUzICYgNjMpKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG91dHB1dC50b1N0cmluZygpO1xuXHRcdH1cblx0fTtcblxuXHRmdW5jdGlvbiBVdGY4RW5jb2RlRW51bWVyYXRvcihpbnB1dClcblx0e1xuXHRcdHRoaXMuX2lucHV0ID0gaW5wdXQ7XG5cdFx0dGhpcy5faW5kZXggPSAtMTtcblx0XHR0aGlzLl9idWZmZXIgPSBbXTtcblx0fVxuXG5cdFV0ZjhFbmNvZGVFbnVtZXJhdG9yLnByb3RvdHlwZSA9XG5cdHtcblx0XHRjdXJyZW50OiBOdW1iZXIuTmFOLFxuXG5cdFx0bW92ZU5leHQ6IGZ1bmN0aW9uKClcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5fYnVmZmVyLmxlbmd0aCA+IDApXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuY3VycmVudCA9IHRoaXMuX2J1ZmZlci5zaGlmdCgpO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKHRoaXMuX2luZGV4ID49ICh0aGlzLl9pbnB1dC5sZW5ndGggLSAxKSlcblx0XHRcdHtcblx0XHRcdFx0dGhpcy5jdXJyZW50ID0gTnVtYmVyLk5hTjtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgY2hhckNvZGUgPSB0aGlzLl9pbnB1dC5jaGFyQ29kZUF0KCsrdGhpcy5faW5kZXgpO1xuXG5cdFx0XHRcdC8vIFwiXFxyXFxuXCIgLT4gXCJcXG5cIlxuXHRcdFx0XHQvL1xuXHRcdFx0XHRpZiAoKGNoYXJDb2RlID09IDEzKSAmJiAodGhpcy5faW5wdXQuY2hhckNvZGVBdCh0aGlzLl9pbmRleCArIDEpID09IDEwKSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNoYXJDb2RlID0gMTA7XG5cdFx0XHRcdFx0dGhpcy5faW5kZXggKz0gMjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjaGFyQ29kZSA8IDEyOClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHRoaXMuY3VycmVudCA9IGNoYXJDb2RlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKChjaGFyQ29kZSA+IDEyNykgJiYgKGNoYXJDb2RlIDwgMjA0OCkpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR0aGlzLmN1cnJlbnQgPSAoY2hhckNvZGUgPj4gNikgfCAxOTI7XG5cdFx0XHRcdFx0dGhpcy5fYnVmZmVyLnB1c2goKGNoYXJDb2RlICYgNjMpIHwgMTI4KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR0aGlzLmN1cnJlbnQgPSAoY2hhckNvZGUgPj4gMTIpIHwgMjI0O1xuXHRcdFx0XHRcdHRoaXMuX2J1ZmZlci5wdXNoKCgoY2hhckNvZGUgPj4gNikgJiA2MykgfCAxMjgpO1xuXHRcdFx0XHRcdHRoaXMuX2J1ZmZlci5wdXNoKChjaGFyQ29kZSAmIDYzKSB8IDEyOCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0ZnVuY3Rpb24gQmFzZTY0RGVjb2RlRW51bWVyYXRvcihpbnB1dClcblx0e1xuXHRcdHRoaXMuX2lucHV0ID0gaW5wdXQ7XG5cdFx0dGhpcy5faW5kZXggPSAtMTtcblx0XHR0aGlzLl9idWZmZXIgPSBbXTtcblx0fVxuXG5cdEJhc2U2NERlY29kZUVudW1lcmF0b3IucHJvdG90eXBlID1cblx0e1xuXHRcdGN1cnJlbnQ6IDY0LFxuXG5cdFx0bW92ZU5leHQ6IGZ1bmN0aW9uKClcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5fYnVmZmVyLmxlbmd0aCA+IDApXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuY3VycmVudCA9IHRoaXMuX2J1ZmZlci5zaGlmdCgpO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKHRoaXMuX2luZGV4ID49ICh0aGlzLl9pbnB1dC5sZW5ndGggLSAxKSlcblx0XHRcdHtcblx0XHRcdFx0dGhpcy5jdXJyZW50ID0gNjQ7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdHtcblx0XHRcdFx0dmFyIGVuYzEgPSBCYXNlNjQuY29kZXguaW5kZXhPZih0aGlzLl9pbnB1dC5jaGFyQXQoKyt0aGlzLl9pbmRleCkpO1xuXHRcdFx0XHR2YXIgZW5jMiA9IEJhc2U2NC5jb2RleC5pbmRleE9mKHRoaXMuX2lucHV0LmNoYXJBdCgrK3RoaXMuX2luZGV4KSk7XG5cdFx0XHRcdHZhciBlbmMzID0gQmFzZTY0LmNvZGV4LmluZGV4T2YodGhpcy5faW5wdXQuY2hhckF0KCsrdGhpcy5faW5kZXgpKTtcblx0XHRcdFx0dmFyIGVuYzQgPSBCYXNlNjQuY29kZXguaW5kZXhPZih0aGlzLl9pbnB1dC5jaGFyQXQoKyt0aGlzLl9pbmRleCkpO1xuXG5cdFx0XHRcdHZhciBjaHIxID0gKGVuYzEgPDwgMikgfCAoZW5jMiA+PiA0KTtcblx0XHRcdFx0dmFyIGNocjIgPSAoKGVuYzIgJiAxNSkgPDwgNCkgfCAoZW5jMyA+PiAyKTtcblx0XHRcdFx0dmFyIGNocjMgPSAoKGVuYzMgJiAzKSA8PCA2KSB8IGVuYzQ7XG5cblx0XHRcdFx0dGhpcy5jdXJyZW50ID0gY2hyMTtcblxuXHRcdFx0XHRpZiAoZW5jMyAhPSA2NClcblx0XHRcdFx0XHR0aGlzLl9idWZmZXIucHVzaChjaHIyKTtcblxuXHRcdFx0XHRpZiAoZW5jNCAhPSA2NClcblx0XHRcdFx0XHR0aGlzLl9idWZmZXIucHVzaChjaHIzKTtcblxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIEJhc2U2NDtcbn0pKCk7XG5cbkRlZmF1bHRzLnByb3RvY29sVmVyc2lvbiAgICAgICAgICA9IDE7XG5EZWZhdWx0cy5FTlZJUk9OTUVOVCAgICAgICAgICAgICAgPSAnJztcbkRlZmF1bHRzLlJFU1RfSE9TVCAgICAgICAgICAgICAgICA9ICdyZXN0LmFibHkuaW8nO1xuRGVmYXVsdHMuUkVBTFRJTUVfSE9TVCAgICAgICAgICAgID0gJ3JlYWx0aW1lLmFibHkuaW8nO1xuRGVmYXVsdHMuRkFMTEJBQ0tfSE9TVFMgICAgICAgICAgID0gWydBLmFibHktcmVhbHRpbWUuY29tJywgJ0IuYWJseS1yZWFsdGltZS5jb20nLCAnQy5hYmx5LXJlYWx0aW1lLmNvbScsICdELmFibHktcmVhbHRpbWUuY29tJywgJ0UuYWJseS1yZWFsdGltZS5jb20nXTtcbkRlZmF1bHRzLlBPUlQgICAgICAgICAgICAgICAgICAgICA9IDgwO1xuRGVmYXVsdHMuVExTX1BPUlQgICAgICAgICAgICAgICAgID0gNDQzO1xuRGVmYXVsdHMuVElNRU9VVFMgPSB7XG5cdC8qIERvY3VtZW50ZWQgYXMgb3B0aW9ucyBwYXJhbXM6ICovXG5cdGRpc2Nvbm5lY3RlZFJldHJ5VGltZW91dCAgIDogMTUwMDAsXG5cdHN1c3BlbmRlZFJldHJ5VGltZW91dCAgICAgIDogMzAwMDAsXG5cdGh0dHBSZXF1ZXN0VGltZW91dCAgICAgICAgIDogMTUwMDAsXG5cdGNoYW5uZWxSZXRyeVRpbWVvdXQgICAgICAgIDogMTUwMDAsXG5cdC8qIE5vdCBkb2N1bWVudGVkOiAqL1xuXHRjb25uZWN0aW9uU3RhdGVUdGwgICAgICAgICA6IDEyMDAwMCxcblx0cmVhbHRpbWVSZXF1ZXN0VGltZW91dCAgICAgOiAxMDAwMCxcblx0cmVjdlRpbWVvdXQgICAgICAgICAgICAgICAgOiA5MDAwMCxcblx0cHJlZmVyZW5jZUNvbm5lY3RUaW1lb3V0ICAgOiA2MDAwLFxuXHRwYXJhbGxlbFVwZ3JhZGVEZWxheSAgICAgICA6IDQwMDBcbn07XG5EZWZhdWx0cy5odHRwTWF4UmV0cnlDb3VudCA9IDM7XG5cbkRlZmF1bHRzLnZlcnNpb24gICAgICAgICAgPSAnMS4wLjMnO1xuRGVmYXVsdHMubGlic3RyaW5nICAgICAgICA9IFBsYXRmb3JtLmxpYnZlciArIERlZmF1bHRzLnZlcnNpb247XG5EZWZhdWx0cy5hcGlWZXJzaW9uICAgICAgID0gJzEuMCc7XG5cbkRlZmF1bHRzLmdldEhvc3QgPSBmdW5jdGlvbihvcHRpb25zLCBob3N0LCB3cykge1xuXHRpZih3cylcblx0XHRob3N0ID0gKChob3N0ID09IG9wdGlvbnMucmVzdEhvc3QpICYmIG9wdGlvbnMucmVhbHRpbWVIb3N0KSB8fCBob3N0IHx8IG9wdGlvbnMucmVhbHRpbWVIb3N0O1xuXHRlbHNlXG5cdFx0aG9zdCA9IGhvc3QgfHwgb3B0aW9ucy5yZXN0SG9zdDtcblxuXHRyZXR1cm4gaG9zdDtcbn07XG5cbkRlZmF1bHRzLmdldFBvcnQgPSBmdW5jdGlvbihvcHRpb25zLCB0bHMpIHtcblx0cmV0dXJuICh0bHMgfHwgb3B0aW9ucy50bHMpID8gb3B0aW9ucy50bHNQb3J0IDogb3B0aW9ucy5wb3J0O1xufTtcblxuRGVmYXVsdHMuZ2V0SHR0cFNjaGVtZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0cmV0dXJuIG9wdGlvbnMudGxzID8gJ2h0dHBzOi8vJyA6ICdodHRwOi8vJztcbn07XG5cbkRlZmF1bHRzLmdldEhvc3RzID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXHR2YXIgaG9zdHMgPSBbb3B0aW9ucy5yZXN0SG9zdF0sXG5cdFx0ZmFsbGJhY2tIb3N0cyA9IG9wdGlvbnMuZmFsbGJhY2tIb3N0cyxcblx0XHRodHRwTWF4UmV0cnlDb3VudCA9IHR5cGVvZihvcHRpb25zLmh0dHBNYXhSZXRyeUNvdW50KSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmh0dHBNYXhSZXRyeUNvdW50IDogRGVmYXVsdHMuaHR0cE1heFJldHJ5Q291bnQ7XG5cblx0aWYoZmFsbGJhY2tIb3N0cykge1xuXHRcdGhvc3RzID0gaG9zdHMuY29uY2F0KFV0aWxzLmFyckNob29zZU4oZmFsbGJhY2tIb3N0cywgaHR0cE1heFJldHJ5Q291bnQpKTtcblx0fVxuXHRyZXR1cm4gaG9zdHM7XG59O1xuXG5EZWZhdWx0cy5ub3JtYWxpc2VPcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXHQvKiBEZXByZWNhdGVkIG9wdGlvbnMgKi9cblx0aWYob3B0aW9ucy5ob3N0KSB7XG5cdFx0TG9nZ2VyLmRlcHJlY2F0ZWQoJ2hvc3QnLCAncmVzdEhvc3QnKTtcblx0XHRvcHRpb25zLnJlc3RIb3N0ID0gb3B0aW9ucy5ob3N0O1xuXHR9XG5cdGlmKG9wdGlvbnMud3NIb3N0KSB7XG5cdFx0TG9nZ2VyLmRlcHJlY2F0ZWQoJ3dzSG9zdCcsICdyZWFsdGltZUhvc3QnKTtcblx0XHRvcHRpb25zLnJlYWx0aW1lSG9zdCA9IG9wdGlvbnMud3NIb3N0O1xuXHR9XG5cdGlmKG9wdGlvbnMucXVldWVFdmVudHMpIHtcblx0XHRMb2dnZXIuZGVwcmVjYXRlZCgncXVldWVFdmVudHMnLCAncXVldWVNZXNzYWdlcycpO1xuXHRcdG9wdGlvbnMucXVldWVNZXNzYWdlcyA9IG9wdGlvbnMucXVldWVFdmVudHM7XG5cdH1cblxuXHRpZihvcHRpb25zLnJlY292ZXIgPT09IHRydWUpIHtcblx0XHRMb2dnZXIuZGVwcmVjYXRlZCgne3JlY292ZXI6IHRydWV9JywgJ3tyZWNvdmVyOiBmdW5jdGlvbihsYXN0Q29ubmVjdGlvbkRldGFpbHMsIGNiKSB7IGNiKHRydWUpOyB9fScpO1xuXHRcdG9wdGlvbnMucmVjb3ZlciA9IGZ1bmN0aW9uKGxhc3RDb25uZWN0aW9uRGV0YWlscywgY2IpIHsgY2IodHJ1ZSk7IH07XG5cdH1cblxuXHRpZih0eXBlb2Ygb3B0aW9ucy5yZWNvdmVyID09PSAnZnVuY3Rpb24nICYmIG9wdGlvbnMuY2xvc2VPblVubG9hZCA9PT0gdHJ1ZSkge1xuXHRcdExvZ2dlci5sb2dBY3Rpb24oTE9HX0VSUk9SLCAnRGVmYXVsdHMubm9ybWFsaXNlT3B0aW9ucycsICdjbG9zZU9uVW5sb2FkIHdhcyB0cnVlIGFuZCBhIHNlc3Npb24gcmVjb3ZlcnkgZnVuY3Rpb24gd2FzIHNldCAtIHRoZXNlIGFyZSBtdXR1YWxseSBleGNsdXNpdmUsIHNvIHVuc2V0dGluZyB0aGUgbGF0dGVyJyk7XG5cdFx0b3B0aW9ucy5yZWNvdmVyID0gbnVsbDtcblx0fVxuXG5cdGlmKG9wdGlvbnMudHJhbnNwb3J0cyAmJiBVdGlscy5hcnJJbihvcHRpb25zLnRyYW5zcG9ydHMsICd4aHInKSkge1xuXHRcdExvZ2dlci5kZXByZWNhdGVkKCd0cmFuc3BvcnRzOiBbXCJ4aHJcIl0nLCAndHJhbnNwb3J0czogW1wieGhyX3N0cmVhbWluZ1wiXScpO1xuXHRcdFV0aWxzLmFyckRlbGV0ZVZhbHVlKG9wdGlvbnMudHJhbnNwb3J0cywgJ3hocicpO1xuXHRcdG9wdGlvbnMudHJhbnNwb3J0cy5wdXNoKCd4aHJfc3RyZWFtaW5nJyk7XG5cdH1cblxuXHRpZighKCdxdWV1ZU1lc3NhZ2VzJyBpbiBvcHRpb25zKSlcblx0XHRvcHRpb25zLnF1ZXVlTWVzc2FnZXMgPSB0cnVlO1xuXG5cdHZhciBwcm9kdWN0aW9uID0gZmFsc2U7XG5cdGlmKG9wdGlvbnMucmVzdEhvc3QpIHtcblx0XHRvcHRpb25zLnJlYWx0aW1lSG9zdCA9IG9wdGlvbnMucmVhbHRpbWVIb3N0IHx8IG9wdGlvbnMucmVzdEhvc3Q7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIGVudmlyb25tZW50ID0gKG9wdGlvbnMuZW52aXJvbm1lbnQgJiYgU3RyaW5nKG9wdGlvbnMuZW52aXJvbm1lbnQpLnRvTG93ZXJDYXNlKCkpIHx8IERlZmF1bHRzLkVOVklST05NRU5UO1xuXHRcdHByb2R1Y3Rpb24gPSAhZW52aXJvbm1lbnQgfHwgKGVudmlyb25tZW50ID09PSAncHJvZHVjdGlvbicpO1xuXHRcdG9wdGlvbnMucmVzdEhvc3QgPSBwcm9kdWN0aW9uID8gRGVmYXVsdHMuUkVTVF9IT1NUIDogZW52aXJvbm1lbnQgKyAnLScgKyBEZWZhdWx0cy5SRVNUX0hPU1Q7XG5cdFx0b3B0aW9ucy5yZWFsdGltZUhvc3QgPSBwcm9kdWN0aW9uID8gRGVmYXVsdHMuUkVBTFRJTUVfSE9TVCA6IGVudmlyb25tZW50ICsgJy0nICsgRGVmYXVsdHMuUkVBTFRJTUVfSE9TVDtcblx0fVxuXHRvcHRpb25zLmZhbGxiYWNrSG9zdHMgPSAocHJvZHVjdGlvbiB8fCBvcHRpb25zLmZhbGxiYWNrSG9zdHNVc2VEZWZhdWx0KSA/IERlZmF1bHRzLkZBTExCQUNLX0hPU1RTIDogb3B0aW9ucy5mYWxsYmFja0hvc3RzO1xuXHRvcHRpb25zLnBvcnQgPSBvcHRpb25zLnBvcnQgfHwgRGVmYXVsdHMuUE9SVDtcblx0b3B0aW9ucy50bHNQb3J0ID0gb3B0aW9ucy50bHNQb3J0IHx8IERlZmF1bHRzLlRMU19QT1JUO1xuXHRpZighKCd0bHMnIGluIG9wdGlvbnMpKSBvcHRpb25zLnRscyA9IHRydWU7XG5cblx0LyogQWxsb3cgdmFsdWVzIHBhc3NlZCBpbiBvcHRpb25zIHRvIG92ZXJyaWRlIGRlZmF1bHQgdGltZW91dHMgKi9cblx0b3B0aW9ucy50aW1lb3V0cyA9IHt9O1xuXHRmb3IodmFyIHByb3AgaW4gRGVmYXVsdHMuVElNRU9VVFMpIHtcblx0XHRvcHRpb25zLnRpbWVvdXRzW3Byb3BdID0gb3B0aW9uc1twcm9wXSB8fCBEZWZhdWx0cy5USU1FT1VUU1twcm9wXTtcblx0fTtcblxuXHRpZigndXNlQmluYXJ5UHJvdG9jb2wnIGluIG9wdGlvbnMpIHtcblx0XHRvcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID0gUGxhdGZvcm0uc3VwcG9ydHNCaW5hcnkgJiYgb3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbDtcblx0fSBlbHNlIHtcblx0XHRvcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID0gUGxhdGZvcm0ucHJlZmVyQmluYXJ5O1xuXHR9XG5cblx0cmV0dXJuIG9wdGlvbnM7XG59O1xuXG52YXIgRXZlbnRFbWl0dGVyID0gKGZ1bmN0aW9uKCkge1xuXG5cdC8qIHB1YmxpYyBjb25zdHJ1Y3RvciAqL1xuXHRmdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG5cdFx0dGhpcy5hbnkgPSBbXTtcblx0XHR0aGlzLmV2ZW50cyA9IHt9O1xuXHRcdHRoaXMuYW55T25jZSA9IFtdO1xuXHRcdHRoaXMuZXZlbnRzT25jZSA9IHt9O1xuXHR9XG5cblx0LyogQ2FsbCB0aGUgbGlzdGVuZXIsIGNhdGNoIGFueSBleGNlcHRpb25zIGFuZCBsb2csIGJ1dCBjb250aW51ZSBvcGVyYXRpb24qL1xuXHRmdW5jdGlvbiBjYWxsTGlzdGVuZXIoZXZlbnRUaGlzLCBsaXN0ZW5lciwgYXJncykge1xuXHRcdHRyeSB7XG5cdFx0XHRsaXN0ZW5lci5hcHBseShldmVudFRoaXMsIGFyZ3MpO1xuXHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX0VSUk9SLCAnRXZlbnRFbWl0dGVyLmVtaXQoKScsICdVbmV4cGVjdGVkIGxpc3RlbmVyIGV4Y2VwdGlvbjogJyArIGUgKyAnOyBzdGFjayA9ICcgKyBlLnN0YWNrKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlIGxpc3RlbmVycyB0aGF0IG1hdGNoIGxpc3RlbmVyXG5cdCAqIEBwYXJhbSB0YXJnZXRMaXN0ZW5lcnMgaXMgYW4gYXJyYXkgb2YgbGlzdGVuZXIgYXJyYXlzIG9yIGV2ZW50IG9iamVjdHMgd2l0aCBhcnJheXMgb2YgbGlzdGVuZXJzXG5cdCAqIEBwYXJhbSBsaXN0ZW5lciB0aGUgbGlzdGVuZXIgY2FsbGJhY2sgdG8gcmVtb3ZlXG5cdCAqIEBwYXJhbSBldmVudEZpbHRlciAob3B0aW9uYWwpIGV2ZW50IG5hbWUgaW5zdHJ1Y3RpbmcgdGhlIGZ1bmN0aW9uIHRvIG9ubHkgcmVtb3ZlIGxpc3RlbmVycyBmb3IgdGhlIHNwZWNpZmllZCBldmVudFxuXHQgKi9cblx0ZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodGFyZ2V0TGlzdGVuZXJzLCBsaXN0ZW5lciwgZXZlbnRGaWx0ZXIpIHtcblx0XHR2YXIgbGlzdGVuZXJzLCBpZHgsIGV2ZW50TmFtZSwgdGFyZ2V0TGlzdGVuZXJzSW5kZXg7XG5cblx0XHRmb3IgKHRhcmdldExpc3RlbmVyc0luZGV4ID0gMDsgdGFyZ2V0TGlzdGVuZXJzSW5kZXggPCB0YXJnZXRMaXN0ZW5lcnMubGVuZ3RoOyB0YXJnZXRMaXN0ZW5lcnNJbmRleCsrKSB7XG5cdFx0XHRsaXN0ZW5lcnMgPSB0YXJnZXRMaXN0ZW5lcnNbdGFyZ2V0TGlzdGVuZXJzSW5kZXhdO1xuXHRcdFx0aWYgKGV2ZW50RmlsdGVyKSB7IGxpc3RlbmVycyA9IGxpc3RlbmVyc1tldmVudEZpbHRlcl07IH1cblxuXHRcdFx0aWYgKFV0aWxzLmlzQXJyYXkobGlzdGVuZXJzKSkge1xuXHRcdFx0XHR3aGlsZSAoKGlkeCA9IFV0aWxzLmFyckluZGV4T2YobGlzdGVuZXJzLCBsaXN0ZW5lcikpICE9PSAtMSkge1xuXHRcdFx0XHRcdGxpc3RlbmVycy5zcGxpY2UoaWR4LCAxKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvKiBJZiBldmVudHMgb2JqZWN0IGhhcyBhbiBldmVudCBuYW1lIGtleSB3aXRoIG5vIGxpc3RlbmVycyB0aGVuXG5cdFx0XHRcdCAgIHJlbW92ZSB0aGUga2V5IHRvIHN0b3AgdGhlIGxpc3QgZ3Jvd2luZyBpbmRlZmluaXRlbHkgKi9cblx0XHRcdFx0aWYgKGV2ZW50RmlsdGVyICYmIChsaXN0ZW5lcnMubGVuZ3RoID09PSAwKSkge1xuXHRcdFx0XHRcdGRlbGV0ZSB0YXJnZXRMaXN0ZW5lcnNbdGFyZ2V0TGlzdGVuZXJzSW5kZXhdW2V2ZW50RmlsdGVyXTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChVdGlscy5pc09iamVjdChsaXN0ZW5lcnMpKSB7XG5cdFx0XHRcdC8qIGV2ZW50cyAqL1xuXHRcdFx0XHRmb3IgKGV2ZW50TmFtZSBpbiBsaXN0ZW5lcnMpIHtcblx0XHRcdFx0XHRpZiAobGlzdGVuZXJzLmhhc093blByb3BlcnR5KGV2ZW50TmFtZSkgJiYgVXRpbHMuaXNBcnJheShsaXN0ZW5lcnNbZXZlbnROYW1lXSkpIHtcblx0XHRcdFx0XHRcdHJlbW92ZUxpc3RlbmVyKFtsaXN0ZW5lcnNdLCBsaXN0ZW5lciwgZXZlbnROYW1lKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQWRkIGFuIGV2ZW50IGxpc3RlbmVyXG5cdCAqIEBwYXJhbSBldmVudCAob3B0aW9uYWwpIHRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBsaXN0ZW4gdG9cblx0ICogICAgICAgIGlmIG5vdCBzdXBwbGllZCwgYWxsIGV2ZW50cyB0cmlnZ2VyIGEgY2FsbCB0byB0aGUgbGlzdGVuZXJcblx0ICogQHBhcmFtIGxpc3RlbmVyIHRoZSBsaXN0ZW5lciB0byBiZSBjYWxsZWRcblx0ICovXG5cdEV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbihldmVudCwgbGlzdGVuZXIpIHtcblx0XHRpZihhcmd1bWVudHMubGVuZ3RoID09IDEgJiYgdHlwZW9mKGV2ZW50KSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHR0aGlzLmFueS5wdXNoKGV2ZW50KTtcblx0XHR9IGVsc2UgaWYoVXRpbHMuaXNFbXB0eUFyZyhldmVudCkpIHtcblx0XHRcdHRoaXMuYW55LnB1c2gobGlzdGVuZXIpO1xuXHRcdH0gZWxzZSBpZihVdGlscy5pc0FycmF5KGV2ZW50KSkge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0VXRpbHMuYXJyRm9yRWFjaChldmVudCwgZnVuY3Rpb24oZXYpIHtcblx0XHRcdFx0c2VsZi5vbihldiwgbGlzdGVuZXIpO1xuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBsaXN0ZW5lcnMgPSAodGhpcy5ldmVudHNbZXZlbnRdIHx8ICh0aGlzLmV2ZW50c1tldmVudF0gPSBbXSkpO1xuXHRcdFx0bGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogUmVtb3ZlIG9uZSBvciBtb3JlIGV2ZW50IGxpc3RlbmVyc1xuXHQgKiBAcGFyYW0gZXZlbnQgKG9wdGlvbmFsKSB0aGUgbmFtZSBvZiB0aGUgZXZlbnQgd2hvc2UgbGlzdGVuZXJcblx0ICogICAgICAgIGlzIHRvIGJlIHJlbW92ZWQuIElmIG5vdCBzdXBwbGllZCwgdGhlIGxpc3RlbmVyIGlzXG5cdCAqICAgICAgICB0cmVhdGVkIGFzIGFuICdhbnknIGxpc3RlbmVyXG5cdCAqIEBwYXJhbSBsaXN0ZW5lciAob3B0aW9uYWwpIHRoZSBsaXN0ZW5lciB0byByZW1vdmUuIElmIG5vdFxuXHQgKiAgICAgICAgc3VwcGxpZWQsIGFsbCBsaXN0ZW5lcnMgYXJlIHJlbW92ZWQuXG5cdCAqL1xuXHRFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uKGV2ZW50LCBsaXN0ZW5lcikge1xuXHRcdGlmKGFyZ3VtZW50cy5sZW5ndGggPT0gMCB8fCAoVXRpbHMuaXNFbXB0eUFyZyhldmVudCkgJiYgVXRpbHMuaXNFbXB0eUFyZyhsaXN0ZW5lcikpKSB7XG5cdFx0XHR0aGlzLmFueSA9IFtdO1xuXHRcdFx0dGhpcy5ldmVudHMgPSB7fTtcblx0XHRcdHRoaXMuYW55T25jZSA9IFtdO1xuXHRcdFx0dGhpcy5ldmVudHNPbmNlID0ge307XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkge1xuXHRcdFx0aWYodHlwZW9mKGV2ZW50KSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdC8qIHdlIHRha2UgdGhpcyB0byBiZSB0aGUgbGlzdGVuZXIgYW5kIHRyZWF0IHRoZSBldmVudCBhcyBcImFueVwiIC4uICovXG5cdFx0XHRcdGxpc3RlbmVyID0gZXZlbnQ7XG5cdFx0XHRcdGV2ZW50ID0gbnVsbDtcblx0XHRcdH1cblx0XHRcdC8qIC4uLiBvciB3ZSB0YWtlIGV2ZW50IHRvIGJlIHRoZSBhY3R1YWwgZXZlbnQgbmFtZSBhbmQgbGlzdGVuZXIgdG8gYmUgYWxsICovXG5cdFx0fVxuXG5cdFx0aWYobGlzdGVuZXIgJiYgVXRpbHMuaXNFbXB0eUFyZyhldmVudCkpIHtcblx0XHRcdHJlbW92ZUxpc3RlbmVyKFt0aGlzLmFueSwgdGhpcy5ldmVudHMsIHRoaXMuYW55T25jZSwgdGhpcy5ldmVudHNPbmNlXSwgbGlzdGVuZXIpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmKFV0aWxzLmlzQXJyYXkoZXZlbnQpKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRVdGlscy5hcnJGb3JFYWNoKGV2ZW50LCBmdW5jdGlvbihldikge1xuXHRcdFx0XHRzZWxmLm9mZihldiwgbGlzdGVuZXIpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0LyogXCJub3JtYWxcIiBjYXNlIHdoZXJlIGV2ZW50IGlzIGFuIGFjdHVhbCBldmVudCAqL1xuXHRcdGlmKGxpc3RlbmVyKSB7XG5cdFx0XHRyZW1vdmVMaXN0ZW5lcihbdGhpcy5ldmVudHMsIHRoaXMuZXZlbnRzT25jZV0sIGxpc3RlbmVyLCBldmVudCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRlbGV0ZSB0aGlzLmV2ZW50c1tldmVudF07XG5cdFx0XHRkZWxldGUgdGhpcy5ldmVudHNPbmNlW2V2ZW50XTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEdldCB0aGUgYXJyYXkgb2YgbGlzdGVuZXJzIGZvciBhIGdpdmVuIGV2ZW50OyBleGNsdWRlcyBvbmNlIGV2ZW50c1xuXHQgKiBAcGFyYW0gZXZlbnQgKG9wdGlvbmFsKSB0aGUgbmFtZSBvZiB0aGUgZXZlbnQsIG9yIG5vbmUgZm9yICdhbnknXG5cdCAqIEByZXR1cm4gYXJyYXkgb2YgZXZlbnRzLCBvciBudWxsIGlmIG5vbmVcblx0ICovXG5cdEV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRpZihldmVudCkge1xuXHRcdFx0dmFyIGxpc3RlbmVycyA9ICh0aGlzLmV2ZW50c1tldmVudF0gfHwgW10pO1xuXHRcdFx0aWYodGhpcy5ldmVudHNPbmNlW2V2ZW50XSlcblx0XHRcdFx0QXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkobGlzdGVuZXJzLCB0aGlzLmV2ZW50c09uY2VbZXZlbnRdKTtcblx0XHRcdHJldHVybiBsaXN0ZW5lcnMubGVuZ3RoID8gbGlzdGVuZXJzIDogbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuYW55Lmxlbmd0aCA/IHRoaXMuYW55IDogbnVsbDtcblx0fTtcblxuXHQvKipcblx0ICogRW1pdCBhbiBldmVudFxuXHQgKiBAcGFyYW0gZXZlbnQgdGhlIGV2ZW50IG5hbWVcblx0ICogQHBhcmFtIGFyZ3MgdGhlIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBsaXN0ZW5lclxuXHQgKi9cblx0RXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oZXZlbnQgIC8qICwgYXJncy4uLiAqLykge1xuXHRcdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblx0XHR2YXIgZXZlbnRUaGlzID0ge2V2ZW50OmV2ZW50fTtcblx0XHR2YXIgbGlzdGVuZXJzID0gW107XG5cblx0XHRpZih0aGlzLmFueU9uY2UubGVuZ3RoKSB7XG5cdFx0XHRBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShsaXN0ZW5lcnMsIHRoaXMuYW55T25jZSk7XG5cdFx0XHR0aGlzLmFueU9uY2UgPSBbXTtcblx0XHR9XG5cdFx0aWYodGhpcy5hbnkubGVuZ3RoKSB7XG5cdFx0XHRBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShsaXN0ZW5lcnMsIHRoaXMuYW55KTtcblx0XHR9XG5cdFx0dmFyIGV2ZW50c09uY2VMaXN0ZW5lcnMgPSB0aGlzLmV2ZW50c09uY2VbZXZlbnRdO1xuXHRcdGlmKGV2ZW50c09uY2VMaXN0ZW5lcnMpIHtcblx0XHRcdEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGxpc3RlbmVycywgZXZlbnRzT25jZUxpc3RlbmVycyk7XG5cdFx0XHRkZWxldGUgdGhpcy5ldmVudHNPbmNlW2V2ZW50XTtcblx0XHR9XG5cdFx0dmFyIGV2ZW50c0xpc3RlbmVycyA9IHRoaXMuZXZlbnRzW2V2ZW50XTtcblx0XHRpZihldmVudHNMaXN0ZW5lcnMpIHtcblx0XHRcdEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGxpc3RlbmVycywgZXZlbnRzTGlzdGVuZXJzKTtcblx0XHR9XG5cblx0XHRVdGlscy5hcnJGb3JFYWNoKGxpc3RlbmVycywgZnVuY3Rpb24obGlzdGVuZXIpIHtcblx0XHRcdGNhbGxMaXN0ZW5lcihldmVudFRoaXMsIGxpc3RlbmVyLCBhcmdzKTtcblx0XHR9KTtcblx0fTtcblxuXHQvKipcblx0ICogTGlzdGVuIGZvciBhIHNpbmdsZSBvY2N1cnJlbmNlIG9mIGFuIGV2ZW50XG5cdCAqIEBwYXJhbSBldmVudCB0aGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gbGlzdGVuIHRvXG5cdCAqIEBwYXJhbSBsaXN0ZW5lciB0aGUgbGlzdGVuZXIgdG8gYmUgY2FsbGVkXG5cdCAqL1xuXHRFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihldmVudCwgbGlzdGVuZXIpIHtcblx0XHRpZihhcmd1bWVudHMubGVuZ3RoID09IDEgJiYgdHlwZW9mKGV2ZW50KSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHR0aGlzLmFueU9uY2UucHVzaChldmVudCk7XG5cdFx0fSBlbHNlIGlmKFV0aWxzLmlzRW1wdHlBcmcoZXZlbnQpKSB7XG5cdFx0XHR0aGlzLmFueU9uY2UucHVzaChsaXN0ZW5lcik7XG5cdFx0fSBlbHNlIGlmKFV0aWxzLmlzQXJyYXkoZXZlbnQpKXtcblx0XHRcdHRocm93KFwiQXJyYXlzIG9mIGV2ZW50cyBjYW4gb25seSBiZSB1c2VkIHdpdGggb24oKSwgbm90IG9uY2UoKVwiKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGxpc3RlbmVycyA9ICh0aGlzLmV2ZW50c09uY2VbZXZlbnRdIHx8ICh0aGlzLmV2ZW50c09uY2VbZXZlbnRdID0gW10pKTtcblx0XHRcdGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFByaXZhdGUgQVBJXG5cdCAqXG5cdCAqIExpc3RlbiBmb3IgYSBzaW5nbGUgb2NjdXJyZW5jZSBvZiBhIHN0YXRlIGV2ZW50IGFuZCBmaXJlIGltbWVkaWF0ZWx5IGlmIGN1cnJlbnRTdGF0ZSBtYXRjaGVzIHRhcmdldFN0YXRlXG5cdCAqIEBwYXJhbSB0YXJnZXRTdGF0ZSB0aGUgbmFtZSBvZiB0aGUgc3RhdGUgZXZlbnQgdG8gbGlzdGVuIHRvXG5cdCAqIEBwYXJhbSBjdXJyZW50U3RhdGUgdGhlIG5hbWUgb2YgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhpcyBvYmplY3Rcblx0ICogQHBhcmFtIGxpc3RlbmVyIHRoZSBsaXN0ZW5lciB0byBiZSBjYWxsZWRcblx0ICovXG5cdEV2ZW50RW1pdHRlci5wcm90b3R5cGUud2hlblN0YXRlID0gZnVuY3Rpb24odGFyZ2V0U3RhdGUsIGN1cnJlbnRTdGF0ZSwgbGlzdGVuZXIgLyogLi4ubGlzdGVuZXJBcmdzICovKSB7XG5cdFx0dmFyIGV2ZW50VGhpcyA9IHtldmVudDp0YXJnZXRTdGF0ZX0sXG5cdFx0XHRcdGxpc3RlbmVyQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMyk7XG5cblx0XHRpZigodHlwZW9mKHRhcmdldFN0YXRlKSAhPT0gJ3N0cmluZycpIHx8ICh0eXBlb2YoY3VycmVudFN0YXRlKSAhPT0gJ3N0cmluZycpKVxuXHRcdFx0dGhyb3coXCJ3aGVuU3RhdGUgcmVxdWlyZXMgYSB2YWxpZCBldmVudCBTdHJpbmcgYXJndW1lbnRcIik7XG5cdFx0aWYgKHR5cGVvZihsaXN0ZW5lcikgIT09ICdmdW5jdGlvbicpXG5cdFx0XHR0aHJvdyhcIndoZW5TdGF0ZSByZXF1aXJlcyBhIHZhbGlkIGxpc3RlbmVyIGFyZ3VtZW50XCIpO1xuXG5cdFx0aWYodGFyZ2V0U3RhdGUgPT09IGN1cnJlbnRTdGF0ZSkge1xuXHRcdFx0Y2FsbExpc3RlbmVyKGV2ZW50VGhpcywgbGlzdGVuZXIsIGxpc3RlbmVyQXJncyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMub25jZSh0YXJnZXRTdGF0ZSwgbGlzdGVuZXIpO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBFdmVudEVtaXR0ZXI7XG59KSgpO1xuXG52YXIgTG9nZ2VyID0gKGZ1bmN0aW9uKCkge1xuXHR2YXIgY29uc29sZUxvZ2dlcjtcblxuXHQvKiBDYW4ndCBqdXN0IGNoZWNrIGZvciBjb25zb2xlICYmIGNvbnNvbGUubG9nOyBmYWlscyBpbiBJRSA8PTkgKi9cblx0aWYoKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSAvKiBub2RlICovIHx8XG5cdFx0ICh3aW5kb3cuY29uc29sZSAmJiB3aW5kb3cuY29uc29sZS5sb2cgJiYgKHR5cGVvZiB3aW5kb3cuY29uc29sZS5sb2cuYXBwbHkgPT09ICdmdW5jdGlvbicpKSAvKiBzZW5zaWJsZSBicm93c2VycyAqLykge1xuXHRcdGNvbnNvbGVMb2dnZXIgPSBmdW5jdGlvbigpIHsgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTsgfTtcblx0fSBlbHNlIGlmKHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5jb25zb2xlLmxvZykge1xuXHRcdC8qIElFIDw9IDkgd2l0aCB0aGUgY29uc29sZSBvcGVuIC0tIGNvbnNvbGUubG9nIGRvZXMgbm90XG5cdFx0ICogaW5oZXJpdCBmcm9tIEZ1bmN0aW9uLCBzbyBoYXMgbm8gYXBwbHkgbWV0aG9kICovXG5cdFx0Y29uc29sZUxvZ2dlciA9IGZ1bmN0aW9uKCkgeyBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlLmxvZywgY29uc29sZSwgYXJndW1lbnRzKTsgfTtcblx0fSBlbHNlIHtcblx0XHQvKiBJRSA8PSA5IHdoZW4gZGV2IHRvb2xzIGFyZSBjbG9zZWQgLSB3aW5kb3cuY29uc29sZSBub3QgZXZlbiBkZWZpbmVkICovXG5cdFx0Y29uc29sZUxvZ2dlciA9IGZ1bmN0aW9uKCkge307XG5cdH1cblxuXHR2YXIgTE9HX05PTkUgID0gMCxcblx0TE9HX0VSUk9SID0gMSxcblx0TE9HX01BSk9SID0gMixcblx0TE9HX01JTk9SID0gMyxcblx0TE9HX01JQ1JPID0gNDtcblxuXHR2YXIgTE9HX0RFRkFVTFQgPSBMT0dfRVJST1IsXG5cdExPR19ERUJVRyAgID0gTE9HX01JQ1JPO1xuXG5cdHZhciBsb2dMZXZlbCA9IExPR19ERUZBVUxUO1xuXHR2YXIgbG9nSGFuZGxlciA9IGNvbnNvbGVMb2dnZXI7XG5cblx0LyogcHVibGljIGNvbnN0cnVjdG9yICovXG5cdGZ1bmN0aW9uIExvZ2dlcihhcmdzKSB7fVxuXG5cdC8qIHB1YmxpYyBjb25zdGFudHMgKi9cblx0TG9nZ2VyLkxPR19OT05FICAgID0gTE9HX05PTkUsXG5cdExvZ2dlci5MT0dfRVJST1IgICA9IExPR19FUlJPUixcblx0TG9nZ2VyLkxPR19NQUpPUiAgID0gTE9HX01BSk9SLFxuXHRMb2dnZXIuTE9HX01JTk9SICAgPSBMT0dfTUlOT1IsXG5cdExvZ2dlci5MT0dfTUlDUk8gICA9IExPR19NSUNSTztcblxuXHRMb2dnZXIuTE9HX0RFRkFVTFQgPSBMT0dfREVGQVVMVCxcblx0TG9nZ2VyLkxPR19ERUJVRyAgID0gTE9HX0RFQlVHO1xuXG5cdC8qIHB1YmxpYyBzdGF0aWMgZnVuY3Rpb25zICovXG5cdExvZ2dlci5sb2dBY3Rpb24gPSBmdW5jdGlvbihsZXZlbCwgYWN0aW9uLCBtZXNzYWdlKSB7XG5cdFx0aWYgKExvZ2dlci5zaG91bGRMb2cobGV2ZWwpKSB7XG5cdFx0XHRsb2dIYW5kbGVyKCdBYmx5OiAnICsgYWN0aW9uICsgJzogJyArIG1lc3NhZ2UpO1xuXHRcdH1cblx0fTtcblxuXHRMb2dnZXIuZGVwcmVjYXRlZCA9IGZ1bmN0aW9uKG9yaWdpbmFsLCByZXBsYWNlbWVudCkge1xuXHRcdGlmIChMb2dnZXIuc2hvdWxkTG9nKExPR19FUlJPUikpIHtcblx0XHRcdGxvZ0hhbmRsZXIoXCJBYmx5OiBEZXByZWNhdGlvbiB3YXJuaW5nIC0gJ1wiICsgb3JpZ2luYWwgKyBcIicgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGZyb20gYSBmdXR1cmUgdmVyc2lvbi4gUGxlYXNlIHVzZSAnXCIgKyByZXBsYWNlbWVudCArIFwiJyBpbnN0ZWFkLlwiKTtcblx0XHR9XG5cdH1cblxuXHQvKiBXaGVyZSBhIGxvZ2dpbmcgb3BlcmF0aW9uIGlzIGV4cGVuc2l2ZSwgc3VjaCBhcyBzZXJpYWxpc2F0aW9uIG9mIGRhdGEsIHVzZSBzaG91bGRMb2cgd2lsbCBwcmV2ZW50XG5cdCAgIHRoZSBvYmplY3QgYmVpbmcgc2VyaWFsaXNlZCBpZiB0aGUgbG9nIGxldmVsIHdpbGwgbm90IG91dHB1dCB0aGUgbWVzc2FnZSAqL1xuXHRMb2dnZXIuc2hvdWxkTG9nID0gZnVuY3Rpb24obGV2ZWwpIHtcblx0XHRyZXR1cm4gbGV2ZWwgPD0gbG9nTGV2ZWw7XG5cdH07XG5cblx0TG9nZ2VyLnNldExvZyA9IGZ1bmN0aW9uKGxldmVsLCBoYW5kbGVyKSB7XG5cdFx0aWYobGV2ZWwgIT09IHVuZGVmaW5lZCkgbG9nTGV2ZWwgPSBsZXZlbDtcblx0XHRpZihoYW5kbGVyICE9PSB1bmRlZmluZWQpIGxvZ0hhbmRsZXIgPSBoYW5kbGVyO1xuXHR9O1xuXG5cdHJldHVybiBMb2dnZXI7XG59KSgpO1xuXG52YXIgVXRpbHMgPSAoZnVuY3Rpb24oKSB7XG5cdGZ1bmN0aW9uIFV0aWxzKCkge31cblxuXHQvKlxuXHQgKiBBZGQgYSBzZXQgb2YgcHJvcGVydGllcyB0byBhIHRhcmdldCBvYmplY3Rcblx0ICogdGFyZ2V0OiB0aGUgdGFyZ2V0IG9iamVjdFxuXHQgKiBwcm9wczogIGFuIG9iamVjdCB3aG9zZSBlbnVtZXJhYmxlIHByb3BlcnRpZXMgYXJlXG5cdCAqICAgICAgICAgYWRkZWQsIGJ5IHJlZmVyZW5jZSBvbmx5XG5cdCAqL1xuXHRVdGlscy5taXhpbiA9IGZ1bmN0aW9uKHRhcmdldCwgc3JjKSB7XG5cdFx0aWYoc3JjKSB7XG5cdFx0XHR2YXIgaGFzT3duUHJvcGVydHkgPSBzcmMuaGFzT3duUHJvcGVydHk7XG5cdFx0XHRmb3IodmFyIGtleSBpbiBzcmMpIHtcblx0XHRcdFx0aWYoIWhhc093blByb3BlcnR5IHx8IGhhc093blByb3BlcnR5LmNhbGwoc3JjLCBrZXkpKSB7XG5cdFx0XHRcdFx0dGFyZ2V0W2tleV0gPSBzcmNba2V5XTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXHR9O1xuXG5cdC8qXG5cdCAqIEFkZCBhIHNldCBvZiBwcm9wZXJ0aWVzIHRvIGEgdGFyZ2V0IG9iamVjdFxuXHQgKiB0YXJnZXQ6IHRoZSB0YXJnZXQgb2JqZWN0XG5cdCAqIHByb3BzOiAgYW4gb2JqZWN0IHdob3NlIGVudW1lcmFibGUgcHJvcGVydGllcyBhcmVcblx0ICogICAgICAgICBhZGRlZCwgYnkgcmVmZXJlbmNlIG9ubHlcblx0ICovXG5cdFV0aWxzLmNvcHkgPSBmdW5jdGlvbihzcmMpIHtcblx0XHRyZXR1cm4gVXRpbHMubWl4aW4oe30sIHNyYyk7XG5cdH07XG5cblx0Lypcblx0ICogRGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IGEgZ2l2ZW4gb2JqZWN0IGlzXG5cdCAqIGFuIGFycmF5LlxuXHQgKi9cblx0VXRpbHMuaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24ob2IpIHtcblx0XHRyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iKSA9PSAnW29iamVjdCBBcnJheV0nO1xuXHR9O1xuXG5cdC8qXG5cdCAqIEVuc3VyZXMgdGhhdCBhbiBBcnJheSBvYmplY3QgaXMgYWx3YXlzIHJldHVybmVkXG5cdCAqIHJldHVybmluZyB0aGUgb3JpZ2luYWwgQXJyYXkgb2Ygb2JqIGlzIGFuIEFycmF5XG5cdCAqIGVsc2Ugd3JhcHBpbmcgdGhlIG9iaiBpbiBhIHNpbmdsZSBlbGVtZW50IEFycmF5XG5cdCAqL1xuXHRVdGlscy5lbnN1cmVBcnJheSA9IGZ1bmN0aW9uKG9iaikge1xuXHRcdGlmKFV0aWxzLmlzRW1wdHlBcmcob2JqKSkge1xuXHRcdFx0cmV0dXJuIFtdO1xuXHRcdH1cblx0XHRpZihVdGlscy5pc0FycmF5KG9iaikpIHtcblx0XHRcdHJldHVybiBvYmo7XG5cdFx0fVxuXHRcdHJldHVybiBbb2JqXTtcblx0fVxuXG5cdC8qIC4uLk9yIGFuIE9iamVjdCAoaW4gdGhlIG5hcnJvdyBzZW5zZSkgKi9cblx0VXRpbHMuaXNPYmplY3QgPSBmdW5jdGlvbihvYikge1xuXHRcdHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2IpID09ICdbb2JqZWN0IE9iamVjdF0nO1xuXHR9O1xuXG5cdC8qXG5cdCAqIERldGVybWluZSB3aGV0aGVyIG9yIG5vdCBhbiBvYmplY3QgY29udGFpbnNcblx0ICogYW55IGVudW1lcmFibGUgcHJvcGVydGllcy5cblx0ICogb2I6IHRoZSBvYmplY3Rcblx0ICovXG5cdFV0aWxzLmlzRW1wdHkgPSBmdW5jdGlvbihvYikge1xuXHRcdGZvcih2YXIgcHJvcCBpbiBvYilcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXHRVdGlscy5pc09ubHlQcm9wSW4gPSBmdW5jdGlvbihvYiwgcHJvcGVydHkpIHtcblx0XHRmb3IodmFyIHByb3AgaW4gb2IpIHtcblx0XHRcdGlmKHByb3AgIT09IHByb3BlcnR5KSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblx0Lypcblx0ICogRGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IGFuIGFyZ3VtZW50IHRvIGFuIG92ZXJsb2FkZWQgZnVuY3Rpb24gaXNcblx0ICogdW5kZWZpbmVkIChtaXNzaW5nKSBvciBudWxsLlxuXHQgKiBUaGlzIG1ldGhvZCBpcyB1c2VmdWwgd2hlbiBjb25zdHJ1Y3RpbmcgZnVuY3Rpb25zIHN1Y2ggYXMgKFdlYklETCB0ZXJtaW5vbG9neSk6XG5cdCAqICAgb2ZmKFtUcmVhdFVuZGVmaW5lZEFzPU51bGxdIERPTVN0cmluZz8gZXZlbnQpXG5cdCAqIGFzIHlvdSBjYW4gdGhlbiBjb25maXJtIHRoZSBhcmd1bWVudCB1c2luZzpcblx0ICogICBVdGlscy5pc0VtcHR5QXJnKGV2ZW50KVxuXHQgKi9cblxuXHRVdGlscy5pc0VtcHR5QXJnID0gZnVuY3Rpb24oYXJnKSB7XG5cdFx0cmV0dXJuIGFyZyA9PT0gbnVsbCB8fCBhcmcgPT09IHVuZGVmaW5lZDtcblx0fVxuXG5cdC8qXG5cdCAqIFBlcmZvcm0gYSBzaW1wbGUgc2hhbGxvdyBjbG9uZSBvZiBhbiBvYmplY3QuXG5cdCAqIFJlc3VsdCBpcyBhbiBvYmplY3QgaXJyZXNwZWN0aXZlIG9mIHdoZXRoZXJcblx0ICogdGhlIGlucHV0IGlzIGFuIG9iamVjdCBvciBhcnJheS4gQWxsXG5cdCAqIGVudW1lcmFibGUgcHJvcGVydGllcyBhcmUgY29waWVkLlxuXHQgKiBvYjogdGhlIG9iamVjdFxuXHQgKi9cblx0VXRpbHMuc2hhbGxvd0Nsb25lID0gZnVuY3Rpb24ob2IpIHtcblx0XHR2YXIgcmVzdWx0ID0gbmV3IE9iamVjdCgpO1xuXHRcdGZvcih2YXIgcHJvcCBpbiBvYilcblx0XHRcdHJlc3VsdFtwcm9wXSA9IG9iW3Byb3BdO1xuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0Lypcblx0ICogQ2xvbmUgYW4gb2JqZWN0IGJ5IGNyZWF0aW5nIGEgbmV3IG9iamVjdCB3aXRoIHRoZVxuXHQgKiBnaXZlbiBvYmplY3QgYXMgaXRzIHByb3RvdHlwZS4gT3B0aW9uYWxseVxuXHQgKiBhIHNldCBvZiBhZGRpdGlvbmFsIG93biBwcm9wZXJ0aWVzIGNhbiBiZVxuXHQgKiBzdXBwbGllZCB0byBiZSBhZGRlZCB0byB0aGUgbmV3bHkgY3JlYXRlZCBjbG9uZS5cblx0ICogb2I6ICAgICAgICAgICAgdGhlIG9iamVjdCB0byBiZSBjbG9uZWRcblx0ICogb3duUHJvcGVydGllczogb3B0aW9uYWwgb2JqZWN0IHdpdGggYWRkaXRpb25hbFxuXHQgKiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzIHRvIGFkZFxuXHQgKi9cblx0VXRpbHMucHJvdG90eXBpY2FsQ2xvbmUgPSBmdW5jdGlvbihvYiwgb3duUHJvcGVydGllcykge1xuXHRcdGZ1bmN0aW9uIEYoKSB7fVxuXHRcdEYucHJvdG90eXBlID0gb2I7XG5cdFx0dmFyIHJlc3VsdCA9IG5ldyBGKCk7XG5cdFx0aWYob3duUHJvcGVydGllcylcblx0XHRcdFV0aWxzLm1peGluKHJlc3VsdCwgb3duUHJvcGVydGllcyk7XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHQvKlxuXHQgKiBEZWNsYXJlIGEgY29uc3RydWN0b3IgdG8gcmVwcmVzZW50IGEgc3ViY2xhc3Ncblx0ICogb2YgYW5vdGhlciBjb25zdHJ1Y3RvclxuXHQgKiBJZiBwbGF0Zm9ybSBoYXMgYSBidWlsdC1pbiB2ZXJzaW9uIHdlIHVzZSB0aGF0IGZyb20gUGxhdGZvcm0sIGVsc2Ugd2Vcblx0ICogZGVmaW5lIGhlcmUgKHNvIGNhbiBtYWtlIHVzZSBvZiBvdGhlciBVdGlscyBmbnMpXG5cdCAqIFNlZSBub2RlLmpzIHV0aWwuaW5oZXJpdHNcblx0ICovXG5cdFV0aWxzLmluaGVyaXRzID0gUGxhdGZvcm0uaW5oZXJpdHMgfHwgZnVuY3Rpb24oY3Rvciwgc3VwZXJDdG9yKSB7XG5cdFx0Y3Rvci5zdXBlcl8gPSBzdXBlckN0b3I7XG5cdFx0Y3Rvci5wcm90b3R5cGUgPSBVdGlscy5wcm90b3R5cGljYWxDbG9uZShzdXBlckN0b3IucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiBjdG9yIH0pO1xuXHR9O1xuXG5cdC8qXG5cdCAqIERldGVybWluZSB3aGV0aGVyIG9yIG5vdCBhbiBvYmplY3QgaGFzIGFuIGVudW1lcmFibGVcblx0ICogcHJvcGVydHkgd2hvc2UgdmFsdWUgZXF1YWxzIGEgZ2l2ZW4gdmFsdWUuXG5cdCAqIG9iOiAgdGhlIG9iamVjdFxuXHQgKiB2YWw6IHRoZSB2YWx1ZSB0byBmaW5kXG5cdCAqL1xuXHRVdGlscy5jb250YWluc1ZhbHVlID0gZnVuY3Rpb24ob2IsIHZhbCkge1xuXHRcdGZvcih2YXIgaSBpbiBvYikge1xuXHRcdFx0aWYob2JbaV0gPT0gdmFsKVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xuXG5cdFV0aWxzLmludGVyc2VjdCA9IGZ1bmN0aW9uKGFyciwgb2IpIHsgcmV0dXJuIFV0aWxzLmlzQXJyYXkob2IpID8gVXRpbHMuYXJySW50ZXJzZWN0KGFyciwgb2IpIDogVXRpbHMuYXJySW50ZXJzZWN0T2IoYXJyLCBvYik7IH07XG5cblx0VXRpbHMuYXJySW50ZXJzZWN0ID0gZnVuY3Rpb24oYXJyMSwgYXJyMikge1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgYXJyMS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIG1lbWJlciA9IGFycjFbaV07XG5cdFx0XHRpZihVdGlscy5hcnJJbmRleE9mKGFycjIsIG1lbWJlcikgIT0gLTEpXG5cdFx0XHRcdHJlc3VsdC5wdXNoKG1lbWJlcik7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0VXRpbHMuYXJySW50ZXJzZWN0T2IgPSBmdW5jdGlvbihhcnIsIG9iKSB7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBtZW1iZXIgPSBhcnJbaV07XG5cdFx0XHRpZihtZW1iZXIgaW4gb2IpXG5cdFx0XHRcdHJlc3VsdC5wdXNoKG1lbWJlcik7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0VXRpbHMuYXJyU3VidHJhY3QgPSBmdW5jdGlvbihhcnIxLCBhcnIyKSB7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBhcnIxLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgZWxlbWVudCA9IGFycjFbaV07XG5cdFx0XHRpZihVdGlscy5hcnJJbmRleE9mKGFycjIsIGVsZW1lbnQpID09IC0xKVxuXHRcdFx0XHRyZXN1bHQucHVzaChlbGVtZW50KTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRVdGlscy5hcnJJbmRleE9mID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2Zcblx0XHQ/IGZ1bmN0aW9uKGFyciwgZWxlbSwgZnJvbUluZGV4KSB7XG5cdFx0XHRyZXR1cm4gYXJyLmluZGV4T2YoZWxlbSwgIGZyb21JbmRleCk7XG5cdFx0fVxuXHRcdDogZnVuY3Rpb24oYXJyLCBlbGVtLCBmcm9tSW5kZXgpIHtcblx0XHRcdGZyb21JbmRleCA9IGZyb21JbmRleCB8fCAwO1xuXHRcdFx0dmFyIGxlbiA9IGFyci5sZW5ndGg7XG5cdFx0XHRmb3IoO2Zyb21JbmRleCA8IGxlbjsgZnJvbUluZGV4KyspIHtcblx0XHRcdFx0aWYoYXJyW2Zyb21JbmRleF0gPT09IGVsZW0pIHtcblx0XHRcdFx0XHRyZXR1cm4gZnJvbUluZGV4O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gLTE7XG5cdFx0fTtcblxuXHRVdGlscy5hcnJJbiA9IGZ1bmN0aW9uKGFyciwgdmFsKSB7XG5cdFx0cmV0dXJuIFV0aWxzLmFyckluZGV4T2YoYXJyLCB2YWwpICE9PSAtMTtcblx0fTtcblxuXHRVdGlscy5hcnJEZWxldGVWYWx1ZSA9IGZ1bmN0aW9uKGFyciwgdmFsKSB7XG5cdFx0dmFyIGlkeCA9IFV0aWxzLmFyckluZGV4T2YoYXJyLCB2YWwpO1xuXHRcdHZhciByZXMgPSAoaWR4ICE9IC0xKTtcblx0XHRpZihyZXMpXG5cdFx0XHRhcnIuc3BsaWNlKGlkeCwgMSk7XG5cdFx0cmV0dXJuIHJlcztcblx0fTtcblxuXHRVdGlscy5hcnJXaXRob3V0VmFsdWUgPSBmdW5jdGlvbihhcnIsIHZhbCkge1xuXHRcdHZhciBuZXdBcnIgPSBhcnIuc2xpY2UoKTtcblx0XHRVdGlscy5hcnJEZWxldGVWYWx1ZShuZXdBcnIsIHZhbCk7XG5cdFx0cmV0dXJuIG5ld0Fycjtcblx0fTtcblxuXHQvKlxuXHQgKiBDb25zdHJ1Y3QgYW4gYXJyYXkgb2YgdGhlIGtleXMgb2YgdGhlIGVudW1lcmFibGVcblx0ICogcHJvcGVydGllcyBvZiBhIGdpdmVuIG9iamVjdCwgb3B0aW9uYWxseSBsaW1pdGVkXG5cdCAqIHRvIG9ubHkgdGhlIG93biBwcm9wZXJ0aWVzLlxuXHQgKiBvYjogICAgICB0aGUgb2JqZWN0XG5cdCAqIG93bk9ubHk6IGJvb2xlYW4sIGdldCBvd24gcHJvcGVydGllcyBvbmx5XG5cdCAqL1xuXHRVdGlscy5rZXlzQXJyYXkgPSBmdW5jdGlvbihvYiwgb3duT25seSkge1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHRmb3IodmFyIHByb3AgaW4gb2IpIHtcblx0XHRcdGlmKG93bk9ubHkgJiYgIW9iLmhhc093blByb3BlcnR5KHByb3ApKSBjb250aW51ZTtcblx0XHRcdHJlc3VsdC5wdXNoKHByb3ApO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdC8qXG5cdCAqIENvbnN0cnVjdCBhbiBhcnJheSBvZiB0aGUgdmFsdWVzIG9mIHRoZSBlbnVtZXJhYmxlXG5cdCAqIHByb3BlcnRpZXMgb2YgYSBnaXZlbiBvYmplY3QsIG9wdGlvbmFsbHkgbGltaXRlZFxuXHQgKiB0byBvbmx5IHRoZSBvd24gcHJvcGVydGllcy5cblx0ICogb2I6ICAgICAgdGhlIG9iamVjdFxuXHQgKiBvd25Pbmx5OiBib29sZWFuLCBnZXQgb3duIHByb3BlcnRpZXMgb25seVxuXHQgKi9cblx0VXRpbHMudmFsdWVzQXJyYXkgPSBmdW5jdGlvbihvYiwgb3duT25seSkge1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHRmb3IodmFyIHByb3AgaW4gb2IpIHtcblx0XHRcdGlmKG93bk9ubHkgJiYgIW9iLmhhc093blByb3BlcnR5KHByb3ApKSBjb250aW51ZTtcblx0XHRcdHJlc3VsdC5wdXNoKG9iW3Byb3BdKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRVdGlscy5hcnJGb3JFYWNoID0gQXJyYXkucHJvdG90eXBlLmZvckVhY2ggP1xuXHRcdGZ1bmN0aW9uKGFyciwgZm4pIHtcblx0XHRcdGFyci5mb3JFYWNoKGZuKTtcblx0XHR9IDpcblx0XHRmdW5jdGlvbihhcnIsIGZuKSB7XG5cdFx0XHR2YXIgbGVuID0gYXJyLmxlbmd0aDtcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRmbihhcnJbaV0sIGksIGFycik7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHQvKiBVc2VmdWwgd2hlbiB0aGUgZnVuY3Rpb24gbWF5IG11dGF0ZSB0aGUgYXJyYXkgKi9cblx0VXRpbHMuc2FmZUFyckZvckVhY2ggPSBmdW5jdGlvbihhcnIsIGZuKSB7XG5cdFx0cmV0dXJuIFV0aWxzLmFyckZvckVhY2goYXJyLnNsaWNlKCksIGZuKTtcblx0fTtcblxuXHRVdGlscy5hcnJNYXAgPSBBcnJheS5wcm90b3R5cGUubWFwID9cblx0XHRmdW5jdGlvbihhcnIsIGZuKSB7XG5cdFx0XHRyZXR1cm4gYXJyLm1hcChmbik7XG5cdFx0fSA6XG5cdFx0ZnVuY3Rpb24oYXJyLCBmbilcdHtcblx0XHRcdHZhciByZXN1bHQgPSBbXSxcblx0XHRcdFx0bGVuID0gYXJyLmxlbmd0aDtcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRyZXN1bHQucHVzaChmbihhcnJbaV0sIGksIGFycikpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9O1xuXG5cdFV0aWxzLmFyckZpbHRlciA9IEFycmF5LnByb3RvdHlwZS5maWx0ZXIgP1xuXHRcdGZ1bmN0aW9uKGFyciwgZm4pIHtcblx0XHRcdHJldHVybiBhcnIuZmlsdGVyKGZuKTtcblx0XHR9IDpcblx0XHRmdW5jdGlvbihhcnIsIGZuKVx0e1xuXHRcdFx0dmFyIHJlc3VsdCA9IFtdLFxuXHRcdFx0XHRsZW4gPSBhcnIubGVuZ3RoO1xuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdGlmKGZuKGFycltpXSkpIHtcblx0XHRcdFx0XHRyZXN1bHQucHVzaChhcnJbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH07XG5cblx0VXRpbHMuYXJyRXZlcnkgPSBBcnJheS5wcm90b3R5cGUuZXZlcnkgP1xuXHRcdGZ1bmN0aW9uKGFyciwgZm4pIHtcblx0XHRcdHJldHVybiBhcnIuZXZlcnkoZm4pO1xuXHRcdH0gOiBmdW5jdGlvbihhcnIsIGZuKSB7XG5cdFx0XHR2YXIgbGVuID0gYXJyLmxlbmd0aDtcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRpZighZm4oYXJyW2ldLCBpLCBhcnIpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fTtcblxuXHRVdGlscy5uZXh0VGljayA9IFBsYXRmb3JtLm5leHRUaWNrO1xuXG5cdHZhciBjb250ZW50VHlwZXMgPSB7XG5cdFx0anNvbjogICAnYXBwbGljYXRpb24vanNvbicsXG5cdFx0anNvbnA6ICAnYXBwbGljYXRpb24vamF2YXNjcmlwdCcsXG5cdFx0eG1sOiAgICAnYXBwbGljYXRpb24veG1sJyxcblx0XHRodG1sOiAgICd0ZXh0L2h0bWwnLFxuXHRcdG1zZ3BhY2s6ICdhcHBsaWNhdGlvbi94LW1zZ3BhY2snXG5cdH07XG5cblx0VXRpbHMuZGVmYXVsdEdldEhlYWRlcnMgPSBmdW5jdGlvbihmb3JtYXQpIHtcblx0XHRmb3JtYXQgPSBmb3JtYXQgfHwgJ2pzb24nO1xuXHRcdHZhciBhY2NlcHQgPSAoZm9ybWF0ID09PSAnanNvbicpID8gY29udGVudFR5cGVzLmpzb24gOiBjb250ZW50VHlwZXNbZm9ybWF0XSArICcsJyArIGNvbnRlbnRUeXBlcy5qc29uO1xuXHRcdHJldHVybiB7XG5cdFx0XHRhY2NlcHQ6IGFjY2VwdCxcblx0XHRcdCdYLUFibHktVmVyc2lvbic6IERlZmF1bHRzLmFwaVZlcnNpb24sXG5cdFx0XHQnWC1BYmx5LUxpYic6IERlZmF1bHRzLmxpYnN0cmluZ1xuXHRcdH07XG5cdH07XG5cblx0VXRpbHMuZGVmYXVsdFBvc3RIZWFkZXJzID0gZnVuY3Rpb24oZm9ybWF0KSB7XG5cdFx0Zm9ybWF0ID0gZm9ybWF0IHx8ICdqc29uJztcblx0XHR2YXIgYWNjZXB0ID0gKGZvcm1hdCA9PT0gJ2pzb24nKSA/IGNvbnRlbnRUeXBlcy5qc29uIDogY29udGVudFR5cGVzW2Zvcm1hdF0gKyAnLCcgKyBjb250ZW50VHlwZXMuanNvbixcblx0XHRcdGNvbnRlbnRUeXBlID0gKGZvcm1hdCA9PT0gJ2pzb24nKSA/IGNvbnRlbnRUeXBlcy5qc29uIDogY29udGVudFR5cGVzW2Zvcm1hdF07XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0YWNjZXB0OiBhY2NlcHQsXG5cdFx0XHQnY29udGVudC10eXBlJzogY29udGVudFR5cGUsXG5cdFx0XHQnWC1BYmx5LVZlcnNpb24nOiBEZWZhdWx0cy5hcGlWZXJzaW9uLFxuXHRcdFx0J1gtQWJseS1MaWInOiBEZWZhdWx0cy5saWJzdHJpbmdcblx0XHR9O1xuXHR9O1xuXG5cdFV0aWxzLmFyclBvcFJhbmRvbUVsZW1lbnQgPSBmdW5jdGlvbihhcnIpIHtcblx0XHRyZXR1cm4gYXJyLnNwbGljZShNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBhcnIubGVuZ3RoKSwgMSlbMF07XG5cdH07XG5cblx0VXRpbHMudG9RdWVyeVN0cmluZyA9IGZ1bmN0aW9uKHBhcmFtcykge1xuXHRcdHZhciBwYXJ0cyA9IFtdO1xuXHRcdGlmKHBhcmFtcykge1xuXHRcdFx0Zm9yKHZhciBrZXkgaW4gcGFyYW1zKVxuXHRcdFx0XHRwYXJ0cy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtc1trZXldKSk7XG5cdFx0fVxuXHRcdHJldHVybiBwYXJ0cy5sZW5ndGggPyAnPycgKyBwYXJ0cy5qb2luKCcmJykgOiAnJztcblx0fTtcblxuXHRVdGlscy5wYXJzZVF1ZXJ5U3RyaW5nID0gZnVuY3Rpb24ocXVlcnkpIHtcblx0XHR2YXIgbWF0Y2gsXG5cdFx0XHRzZWFyY2ggPSAvKFtePyY9XSspPT8oW14mXSopL2csXG5cdFx0XHRyZXN1bHQgPSB7fTtcblxuXHRcdHdoaWxlIChtYXRjaCA9IHNlYXJjaC5leGVjKHF1ZXJ5KSlcblx0XHRcdHJlc3VsdFtkZWNvZGVVUklDb21wb25lbnQobWF0Y2hbMV0pXSA9IGRlY29kZVVSSUNvbXBvbmVudChtYXRjaFsyXSk7XG5cbiBcdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRVdGlscy5ub3cgPSBEYXRlLm5vdyB8fCBmdW5jdGlvbigpIHtcblx0XHQvKiBJRSA4ICovXG5cdFx0cmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXHR9O1xuXG5cdFV0aWxzLmluc3BlY3QgPSBQbGF0Zm9ybS5pbnNwZWN0O1xuXG5cdFV0aWxzLmluc3BlY3RFcnJvciA9IGZ1bmN0aW9uKHgpIHtcblx0XHRyZXR1cm4gKHggJiYgKHguY29uc3RydWN0b3IubmFtZSA9PSAnRXJyb3JJbmZvJyB8fCB4LmNvbnN0cnVjdG9yLm5hbWUgPT0gJ0Vycm9yJykpID9cblx0XHRcdHgudG9TdHJpbmcoKSA6XG5cdFx0XHRVdGlscy5pbnNwZWN0KHgpO1xuXHR9O1xuXG5cdFV0aWxzLnJhbmRTdHIgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gU3RyaW5nKE1hdGgucmFuZG9tKCkpLnN1YnN0cigyKTtcblx0fTtcblxuXHQvKiBQaWNrIG4gZWxlbWVudHMgYXQgcmFuZG9tIHdpdGhvdXQgcmVwbGFjZW1lbnQgZnJvbSBhbiBhcnJheSAqL1xuXHRVdGlscy5hcnJDaG9vc2VOID0gZnVuY3Rpb24oYXJyLCBuKSB7XG5cdFx0dmFyIG51bUl0ZW1zID0gTWF0aC5taW4obiwgYXJyLmxlbmd0aCksXG5cdFx0XHRtdXRhYmxlQXJyID0gYXJyLnNsaWNlKCksXG5cdFx0XHRyZXN1bHQgPSBbXTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbnVtSXRlbXM7IGkrKykge1xuXHRcdFx0cmVzdWx0LnB1c2goVXRpbHMuYXJyUG9wUmFuZG9tRWxlbWVudChtdXRhYmxlQXJyKSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0VXRpbHMudHJpbSA9IFN0cmluZy5wcm90b3R5cGUudHJpbSA/IGZ1bmN0aW9uKHN0cikge1xuXHRcdHJldHVybiBzdHIudHJpbSgpO1xuXHR9IDogZnVuY3Rpb24oc3RyKSB7XG5cdFx0cmV0dXJuIHN0ci5yZXBsYWNlKC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZywgJycpO1xuXHR9O1xuXG5cdHJldHVybiBVdGlscztcbn0pKCk7XG5cbnZhciBNdWx0aWNhc3RlciA9IChmdW5jdGlvbigpIHtcblxuXHRmdW5jdGlvbiBNdWx0aWNhc3RlcihtZW1iZXJzKSB7XG5cdFx0bWVtYmVycyA9IG1lbWJlcnMgfHwgW107XG5cblx0XHR2YXIgaGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IG1lbWJlcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dmFyIG1lbWJlciA9IG1lbWJlcnNbaV07XG5cdFx0XHRcdGlmKG1lbWJlcikge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRtZW1iZXIuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcblx0XHRcdFx0XHR9IGNhdGNoKGUpe1xuXHRcdFx0XHRcdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX0VSUk9SLCAnTXVsdGljYXN0ZXIgbXVsdGlwbGUgY2FsbGJhY2sgaGFuZGxlcicsICdVbmV4cGVjdGVkIGV4Y2VwdGlvbjogJyArIGUgKyAnOyBzdGFjayA9ICcgKyBlLnN0YWNrKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0aGFuZGxlci5wdXNoID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShtZW1iZXJzLCBhcmd1bWVudHMpO1xuXHRcdH07XG5cdFx0cmV0dXJuIGhhbmRsZXI7XG5cdH1cblxuXHRyZXR1cm4gTXVsdGljYXN0ZXI7XG59KSgpO1xuXG52YXIgRXJyb3JJbmZvID0gKGZ1bmN0aW9uKCkge1xuXG5cdGZ1bmN0aW9uIEVycm9ySW5mbyhtZXNzYWdlLCBjb2RlLCBzdGF0dXNDb2RlKSB7XG5cdFx0dGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcblx0XHR0aGlzLmNvZGUgPSBjb2RlO1xuXHRcdHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG5cdH1cblxuXHRFcnJvckluZm8ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlc3VsdCA9ICdbJyArIHRoaXMuY29uc3RydWN0b3IubmFtZTtcblx0XHRpZih0aGlzLm1lc3NhZ2UpIHJlc3VsdCArPSAnOiAnICsgdGhpcy5tZXNzYWdlO1xuXHRcdGlmKHRoaXMuc3RhdHVzQ29kZSkgcmVzdWx0ICs9ICc7IHN0YXR1c0NvZGU9JyArIHRoaXMuc3RhdHVzQ29kZTtcblx0XHRpZih0aGlzLmNvZGUpIHJlc3VsdCArPSAnOyBjb2RlPScgKyB0aGlzLmNvZGU7XG5cdFx0cmVzdWx0ICs9ICddJztcblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdEVycm9ySW5mby5mcm9tVmFsdWVzID0gZnVuY3Rpb24odmFsdWVzKSB7XG5cdFx0dmFyIHJlc3VsdCA9IFV0aWxzLm1peGluKG5ldyBFcnJvckluZm8oKSwgdmFsdWVzKTtcblx0XHRpZiAodmFsdWVzIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0XHRcdC8qIEVycm9yLm1lc3NhZ2UgaXMgbm90IGVudW1lcmFibGUsIHNvIG1peGluIGxvc2VzIHRoZSBtZXNzYWdlICovXG5cdFx0XHRyZXN1bHQubWVzc2FnZSA9IHZhbHVlcy5tZXNzYWdlO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdHJldHVybiBFcnJvckluZm87XG59KSgpO1xuXG52YXIgTWVzc2FnZSA9IChmdW5jdGlvbigpIHtcblx0dmFyIG1zZ3BhY2sgPSBQbGF0Zm9ybS5tc2dwYWNrO1xuXG5cdGZ1bmN0aW9uIE1lc3NhZ2UoKSB7XG5cdFx0dGhpcy5uYW1lID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuaWQgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy50aW1lc3RhbXAgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5jbGllbnRJZCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLmNvbm5lY3Rpb25JZCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLmNvbm5lY3Rpb25LZXkgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5kYXRhID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuZW5jb2RpbmcgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5leHRyYXMgPSB1bmRlZmluZWQ7XG5cdH1cblxuXHQvKipcblx0ICogT3ZlcmxvYWQgdG9KU09OKCkgdG8gaW50ZXJjZXB0IEpTT04uc3RyaW5naWZ5KClcblx0ICogQHJldHVybiB7Kn1cblx0ICovXG5cdE1lc3NhZ2UucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByZXN1bHQgPSB7XG5cdFx0XHRuYW1lOiB0aGlzLm5hbWUsXG5cdFx0XHRjbGllbnRJZDogdGhpcy5jbGllbnRJZCxcblx0XHRcdGNvbm5lY3Rpb25JZDogdGhpcy5jb25uZWN0aW9uSWQsXG5cdFx0XHRjb25uZWN0aW9uS2V5OiB0aGlzLmNvbm5lY3Rpb25LZXksXG5cdFx0XHRlbmNvZGluZzogdGhpcy5lbmNvZGluZyxcblx0XHRcdGV4dHJhczogdGhpcy5leHRyYXNcblx0XHR9O1xuXG5cdFx0LyogZW5jb2RlIGRhdGEgdG8gYmFzZTY0IGlmIHByZXNlbnQgYW5kIHdlJ3JlIHJldHVybmluZyByZWFsIEpTT047XG5cdFx0ICogYWx0aG91Z2ggbXNncGFjayBjYWxscyB0b0pTT04oKSwgd2Uga25vdyBpdCBpcyBhIHN0cmluZ2lmeSgpXG5cdFx0ICogY2FsbCBpZiBpdCBoYXMgYSBub24tZW1wdHkgYXJndW1lbnRzIGxpc3QgKi9cblx0XHR2YXIgZGF0YSA9IHRoaXMuZGF0YTtcblx0XHRpZihkYXRhICYmIEJ1ZmZlclV0aWxzLmlzQnVmZmVyKGRhdGEpKSB7XG5cdFx0XHRpZihhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHQvKiBzdHJpbmdpZnkgY2FsbCAqL1xuXHRcdFx0XHR2YXIgZW5jb2RpbmcgPSB0aGlzLmVuY29kaW5nO1xuXHRcdFx0XHRyZXN1bHQuZW5jb2RpbmcgPSBlbmNvZGluZyA/IChlbmNvZGluZyArICcvYmFzZTY0JykgOiAnYmFzZTY0Jztcblx0XHRcdFx0ZGF0YSA9IEJ1ZmZlclV0aWxzLmJhc2U2NEVuY29kZShkYXRhKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8qIENhbGxlZCBieSBtc2dwYWNrLiBOZWVkIHRvIGZlZWQgaXQgYW4gQXJyYXlCdWZmZXIsIG1zZ3BhY2sgZG9lc24ndFxuXHRcdFx0XHQqIHVuZGVyc3RhbmQgV29yZEFycmF5cyAqL1xuXHRcdFx0XHRkYXRhID0gQnVmZmVyVXRpbHMudG9BcnJheUJ1ZmZlcihkYXRhKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmVzdWx0LmRhdGEgPSBkYXRhO1xuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0TWVzc2FnZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmVzdWx0ID0gJ1tNZXNzYWdlJztcblx0XHRpZih0aGlzLm5hbWUpXG5cdFx0XHRyZXN1bHQgKz0gJzsgbmFtZT0nICsgdGhpcy5uYW1lO1xuXHRcdGlmKHRoaXMuaWQpXG5cdFx0XHRyZXN1bHQgKz0gJzsgaWQ9JyArIHRoaXMuaWQ7XG5cdFx0aWYodGhpcy50aW1lc3RhbXApXG5cdFx0XHRyZXN1bHQgKz0gJzsgdGltZXN0YW1wPScgKyB0aGlzLnRpbWVzdGFtcDtcblx0XHRpZih0aGlzLmNsaWVudElkKVxuXHRcdFx0cmVzdWx0ICs9ICc7IGNsaWVudElkPScgKyB0aGlzLmNsaWVudElkO1xuXHRcdGlmKHRoaXMuY29ubmVjdGlvbklkKVxuXHRcdFx0cmVzdWx0ICs9ICc7IGNvbm5lY3Rpb25JZD0nICsgdGhpcy5jb25uZWN0aW9uSWQ7XG5cdFx0aWYodGhpcy5lbmNvZGluZylcblx0XHRcdHJlc3VsdCArPSAnOyBlbmNvZGluZz0nICsgdGhpcy5lbmNvZGluZztcblx0XHRpZih0aGlzLmV4dHJhcylcblx0XHRcdHJlc3VsdCArPSAnOyBleHRyYXMgPScgKyBKU09OLnN0cmluZ2lmeSh0aGlzLmV4dHJhcyk7XG5cdFx0aWYodGhpcy5kYXRhKSB7XG5cdFx0XHRpZiAodHlwZW9mKGRhdGEpID09ICdzdHJpbmcnKVxuXHRcdFx0XHRyZXN1bHQgKz0gJzsgZGF0YT0nICsgdGhpcy5kYXRhO1xuXHRcdFx0ZWxzZSBpZiAoQnVmZmVyVXRpbHMuaXNCdWZmZXIodGhpcy5kYXRhKSlcblx0XHRcdFx0cmVzdWx0ICs9ICc7IGRhdGEgKGJ1ZmZlcik9JyArIEJ1ZmZlclV0aWxzLmJhc2U2NEVuY29kZSh0aGlzLmRhdGEpO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRyZXN1bHQgKz0gJzsgZGF0YSAoanNvbik9JyArIEpTT04uc3RyaW5naWZ5KHRoaXMuZGF0YSk7XG5cdFx0fVxuXHRcdHJlc3VsdCArPSAnXSc7XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRNZXNzYWdlLmVuY3J5cHQgPSBmdW5jdGlvbihtc2csIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cdFx0dmFyIGRhdGEgPSBtc2cuZGF0YSxcblx0XHRcdGVuY29kaW5nID0gbXNnLmVuY29kaW5nLFxuXHRcdFx0Y2lwaGVyID0gb3B0aW9ucy5jaGFubmVsQ2lwaGVyO1xuXG5cdFx0ZW5jb2RpbmcgPSBlbmNvZGluZyA/IChlbmNvZGluZyArICcvJykgOiAnJztcblx0XHRpZighQnVmZmVyVXRpbHMuaXNCdWZmZXIoZGF0YSkpIHtcblx0XHRcdGRhdGEgPSBCdWZmZXJVdGlscy51dGY4RW5jb2RlKFN0cmluZyhkYXRhKSk7XG5cdFx0XHRlbmNvZGluZyA9IGVuY29kaW5nICsgJ3V0Zi04Lyc7XG5cdFx0fVxuXHRcdGNpcGhlci5lbmNyeXB0KGRhdGEsIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuXHRcdFx0aWYgKGVycikge1xuXHRcdFx0XHRjYWxsYmFjayhlcnIpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRtc2cuZGF0YSA9IGRhdGE7XG5cdFx0XHRtc2cuZW5jb2RpbmcgPSBlbmNvZGluZyArICdjaXBoZXIrJyArIGNpcGhlci5hbGdvcml0aG07XG5cdFx0XHRjYWxsYmFjayhudWxsLCBtc2cpO1xuXHRcdH0pO1xuXHR9O1xuXG5cdE1lc3NhZ2UuZW5jb2RlID0gZnVuY3Rpb24obXNnLCBvcHRpb25zLCBjYWxsYmFjaykge1xuXHRcdHZhciBkYXRhID0gbXNnLmRhdGEsIGVuY29kaW5nLFxuXHRcdFx0bmF0aXZlRGF0YVR5cGUgPSB0eXBlb2YoZGF0YSkgPT0gJ3N0cmluZycgfHwgQnVmZmVyVXRpbHMuaXNCdWZmZXIoZGF0YSkgfHwgZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB1bmRlZmluZWQ7XG5cblx0XHRpZiAoIW5hdGl2ZURhdGFUeXBlKSB7XG5cdFx0XHRpZiAoVXRpbHMuaXNPYmplY3QoZGF0YSkgfHwgVXRpbHMuaXNBcnJheShkYXRhKSkge1xuXHRcdFx0XHRtc2cuZGF0YSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuXHRcdFx0XHRtc2cuZW5jb2RpbmcgPSAoZW5jb2RpbmcgPSBtc2cuZW5jb2RpbmcpID8gKGVuY29kaW5nICsgJy9qc29uJykgOiAnanNvbic7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3JJbmZvKCdEYXRhIHR5cGUgaXMgdW5zdXBwb3J0ZWQnLCA0MDAxMywgNDAwKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZihvcHRpb25zICE9IG51bGwgJiYgb3B0aW9ucy5jaXBoZXIpIHtcblx0XHRcdE1lc3NhZ2UuZW5jcnlwdChtc2csIG9wdGlvbnMsIGNhbGxiYWNrKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2FsbGJhY2sobnVsbCwgbXNnKTtcblx0XHR9XG5cdH07XG5cblx0TWVzc2FnZS5lbmNvZGVBcnJheSA9IGZ1bmN0aW9uKG1lc3NhZ2VzLCBvcHRpb25zLCBjYWxsYmFjaykge1xuXHRcdHZhciBwcm9jZXNzZWQgPSAwO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdE1lc3NhZ2UuZW5jb2RlKG1lc3NhZ2VzW2ldLCBvcHRpb25zLCBmdW5jdGlvbihlcnIsIG1zZykge1xuXHRcdFx0XHRpZiAoZXJyKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soZXJyKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0cHJvY2Vzc2VkKys7XG5cdFx0XHRcdGlmIChwcm9jZXNzZWQgPT0gbWVzc2FnZXMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2sobnVsbCwgbWVzc2FnZXMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdH07XG5cblx0TWVzc2FnZS50b1JlcXVlc3RCb2R5ID0gZnVuY3Rpb24obWVzc2FnZXMsIG9wdGlvbnMsIGZvcm1hdCwgY2FsbGJhY2spIHtcblx0XHRNZXNzYWdlLmVuY29kZUFycmF5KG1lc3NhZ2VzLCBvcHRpb25zLCBmdW5jdGlvbihlcnIpIHtcblx0XHRcdGlmIChlcnIpIHtcblx0XHRcdFx0Y2FsbGJhY2soZXJyKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Y2FsbGJhY2sobnVsbCwgKGZvcm1hdCA9PSAnbXNncGFjaycpID8gbXNncGFjay5lbmNvZGUobWVzc2FnZXMsIHRydWUpOiBKU09OLnN0cmluZ2lmeShtZXNzYWdlcykpO1xuXHRcdH0pO1xuXHR9O1xuXG5cdE1lc3NhZ2UuZGVjb2RlID0gZnVuY3Rpb24obWVzc2FnZSwgb3B0aW9ucykge1xuXHRcdHZhciBlbmNvZGluZyA9IG1lc3NhZ2UuZW5jb2Rpbmc7XG5cdFx0aWYoZW5jb2RpbmcpIHtcblx0XHRcdHZhciB4Zm9ybXMgPSBlbmNvZGluZy5zcGxpdCgnLycpLFxuXHRcdFx0XHRpLCBqID0geGZvcm1zLmxlbmd0aCxcblx0XHRcdFx0ZGF0YSA9IG1lc3NhZ2UuZGF0YTtcblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0d2hpbGUoKGkgPSBqKSA+IDApIHtcblx0XHRcdFx0XHR2YXIgbWF0Y2ggPSB4Zm9ybXNbLS1qXS5tYXRjaCgvKFtcXC1cXHddKykoXFwrKFtcXHdcXC1dKykpPy8pO1xuXHRcdFx0XHRcdGlmKCFtYXRjaCkgYnJlYWs7XG5cdFx0XHRcdFx0dmFyIHhmb3JtID0gbWF0Y2hbMV07XG5cdFx0XHRcdFx0c3dpdGNoKHhmb3JtKSB7XG5cdFx0XHRcdFx0XHRjYXNlICdiYXNlNjQnOlxuXHRcdFx0XHRcdFx0XHRkYXRhID0gQnVmZmVyVXRpbHMuYmFzZTY0RGVjb2RlKFN0cmluZyhkYXRhKSk7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0Y2FzZSAndXRmLTgnOlxuXHRcdFx0XHRcdFx0XHRkYXRhID0gQnVmZmVyVXRpbHMudXRmOERlY29kZShkYXRhKTtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHRjYXNlICdqc29uJzpcblx0XHRcdFx0XHRcdFx0ZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0Y2FzZSAnY2lwaGVyJzpcblx0XHRcdFx0XHRcdFx0aWYob3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMuY2lwaGVyKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHhmb3JtQWxnb3JpdGhtID0gbWF0Y2hbM10sIGNpcGhlciA9IG9wdGlvbnMuY2hhbm5lbENpcGhlcjtcblx0XHRcdFx0XHRcdFx0XHQvKiBkb24ndCBhdHRlbXB0IHRvIGRlY3J5cHQgdW5sZXNzIHRoZSBjaXBoZXIgcGFyYW1zIGFyZSBjb21wYXRpYmxlICovXG5cdFx0XHRcdFx0XHRcdFx0aWYoeGZvcm1BbGdvcml0aG0gIT0gY2lwaGVyLmFsZ29yaXRobSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZGVjcnlwdCBtZXNzYWdlIHdpdGggZ2l2ZW4gY2lwaGVyOyBpbmNvbXBhdGlibGUgY2lwaGVyIHBhcmFtcycpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRkYXRhID0gY2lwaGVyLmRlY3J5cHQoZGF0YSk7XG5cdFx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZGVjcnlwdCBtZXNzYWdlOyBub3QgYW4gZW5jcnlwdGVkIGNoYW5uZWwnKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBlbmNvZGluZ1wiKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3JJbmZvKCdFcnJvciBwcm9jZXNzaW5nIHRoZSAnICsgeGZvcm0gKyAnIGVuY29kaW5nLCBkZWNvZGVyIHJldHVybmVkIOKAmCcgKyBlLm1lc3NhZ2UgKyAn4oCZJywgNDAwMTMsIDQwMCk7XG5cdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRtZXNzYWdlLmVuY29kaW5nID0gKGkgPD0gMCkgPyBudWxsIDogeGZvcm1zLnNsaWNlKDAsIGkpLmpvaW4oJy8nKTtcblx0XHRcdFx0bWVzc2FnZS5kYXRhID0gZGF0YTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0TWVzc2FnZS5mcm9tUmVzcG9uc2VCb2R5ID0gZnVuY3Rpb24oYm9keSwgb3B0aW9ucywgZm9ybWF0KSB7XG5cdFx0aWYoZm9ybWF0KVxuXHRcdFx0Ym9keSA9IChmb3JtYXQgPT0gJ21zZ3BhY2snKSA/IG1zZ3BhY2suZGVjb2RlKGJvZHkpIDogSlNPTi5wYXJzZShTdHJpbmcoYm9keSkpO1xuXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IGJvZHkubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBtc2cgPSBib2R5W2ldID0gTWVzc2FnZS5mcm9tVmFsdWVzKGJvZHlbaV0pO1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0TWVzc2FnZS5kZWNvZGUobXNnLCBvcHRpb25zKTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX0VSUk9SLCAnTWVzc2FnZS5mcm9tUmVzcG9uc2VCb2R5KCknLCBlLnRvU3RyaW5nKCkpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gYm9keTtcblx0fTtcblxuXHRNZXNzYWdlLmZyb21WYWx1ZXMgPSBmdW5jdGlvbih2YWx1ZXMpIHtcblx0XHRyZXR1cm4gVXRpbHMubWl4aW4obmV3IE1lc3NhZ2UoKSwgdmFsdWVzKTtcblx0fTtcblxuXHRNZXNzYWdlLmZyb21WYWx1ZXNBcnJheSA9IGZ1bmN0aW9uKHZhbHVlcykge1xuXHRcdHZhciBjb3VudCA9IHZhbHVlcy5sZW5ndGgsIHJlc3VsdCA9IG5ldyBBcnJheShjb3VudCk7XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHJlc3VsdFtpXSA9IE1lc3NhZ2UuZnJvbVZhbHVlcyh2YWx1ZXNbaV0pO1xuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0TWVzc2FnZS5mcm9tRW5jb2RlZCA9IGZ1bmN0aW9uKGVuY29kZWQsIG9wdGlvbnMpIHtcblx0XHR2YXIgbXNnID0gTWVzc2FnZS5mcm9tVmFsdWVzKGVuY29kZWQpO1xuXHRcdC8qIGlmIGRlY29kaW5nIGZhaWxzIGF0IGFueSBwb2ludCwgY2F0Y2ggYW5kIHJldHVybiB0aGUgbWVzc2FnZSBkZWNvZGVkIHRvXG5cdFx0ICogdGhlIGZ1bGxlc3QgZXh0ZW50IHBvc3NpYmxlICovXG5cdFx0dHJ5IHtcblx0XHRcdE1lc3NhZ2UuZGVjb2RlKG1zZywgb3B0aW9ucyk7XG5cdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfRVJST1IsICdNZXNzYWdlLmZyb21FbmNvZGVkKCknLCBlLnRvU3RyaW5nKCkpO1xuXHRcdH1cblx0XHRyZXR1cm4gbXNnO1xuXHR9O1xuXG5cdE1lc3NhZ2UuZnJvbUVuY29kZWRBcnJheSA9IGZ1bmN0aW9uKGVuY29kZWRBcnJheSwgb3B0aW9ucykge1xuXHRcdHJldHVybiBVdGlscy5hcnJNYXAoZW5jb2RlZEFycmF5LCBmdW5jdGlvbihlbmNvZGVkKSB7XG5cdFx0XHRyZXR1cm4gTWVzc2FnZS5mcm9tRW5jb2RlZChlbmNvZGVkLCBvcHRpb25zKTtcblx0XHR9KTtcblx0fTtcblxuXHRyZXR1cm4gTWVzc2FnZTtcbn0pKCk7XG5cbnZhciBQcmVzZW5jZU1lc3NhZ2UgPSAoZnVuY3Rpb24oKSB7XG5cdHZhciBtc2dwYWNrID0gUGxhdGZvcm0ubXNncGFjaztcblxuXHRmdW5jdGlvbiB0b0FjdGlvblZhbHVlKGFjdGlvblN0cmluZykge1xuXHRcdHJldHVybiBVdGlscy5hcnJJbmRleE9mKFByZXNlbmNlTWVzc2FnZS5BY3Rpb25zLCBhY3Rpb25TdHJpbmcpXG5cdH1cblxuXHRmdW5jdGlvbiBQcmVzZW5jZU1lc3NhZ2UoKSB7XG5cdFx0dGhpcy5hY3Rpb24gPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5pZCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLnRpbWVzdGFtcCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLmNsaWVudElkID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuY29ubmVjdGlvbklkID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLmVuY29kaW5nID0gdW5kZWZpbmVkO1xuXHR9XG5cblx0UHJlc2VuY2VNZXNzYWdlLkFjdGlvbnMgPSBbXG5cdFx0J2Fic2VudCcsXG5cdFx0J3ByZXNlbnQnLFxuXHRcdCdlbnRlcicsXG5cdFx0J2xlYXZlJyxcblx0XHQndXBkYXRlJ1xuXHRdO1xuXG5cdC8qIFJldHVybnMgd2hldGhlciB0aGlzIHByZXNlbmNlTWVzc2FnZSBpcyBzeW50aGVzaXplZCwgaS5lLiB3YXMgbm90IGFjdHVhbGx5XG5cdCAqIHNlbnQgYnkgdGhlIGNvbm5lY3Rpb24gKHVzdWFsbHkgbWVhbnMgYSBsZWF2ZSBldmVudCBzZW50IDE1cyBhZnRlciBhXG5cdCAqIGRpc2Nvbm5lY3Rpb24pLiBUaGlzIGlzIHVzZWZ1bCBiZWNhdXNlIHN5bnRoZXNpemVkIG1lc3NhZ2VzIGNhbm5vdCBiZVxuXHQgKiBjb21wYXJlZCBmb3IgbmV3bmVzcyBieSBpZCBsZXhpY29ncmFwaGljYWxseSAtIFJUUDJiMVxuXHQgKi9cblx0UHJlc2VuY2VNZXNzYWdlLnByb3RvdHlwZS5pc1N5bnRoZXNpemVkID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuaWQuc3Vic3RyaW5nKHRoaXMuY29ubmVjdGlvbklkLmxlbmd0aCwgMCkgIT09IHRoaXMuY29ubmVjdGlvbklkO1xuXHR9O1xuXG5cdC8qIFJUUDJiMiAqL1xuXHRQcmVzZW5jZU1lc3NhZ2UucHJvdG90eXBlLnBhcnNlSWQgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgcGFydHMgPSB0aGlzLmlkLnNwbGl0KCc6Jyk7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGNvbm5lY3Rpb25JZDogcGFydHNbMF0sXG5cdFx0XHRtc2dTZXJpYWw6IHBhcnNlSW50KHBhcnRzWzFdLCAxMCksXG5cdFx0XHRpbmRleDogcGFyc2VJbnQocGFydHNbMl0sIDEwKVxuXHRcdH07XG5cdH07XG5cblx0LyoqXG5cdCAqIE92ZXJsb2FkIHRvSlNPTigpIHRvIGludGVyY2VwdCBKU09OLnN0cmluZ2lmeSgpXG5cdCAqIEByZXR1cm4geyp9XG5cdCAqL1xuXHRQcmVzZW5jZU1lc3NhZ2UucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByZXN1bHQgPSB7XG5cdFx0XHRjbGllbnRJZDogdGhpcy5jbGllbnRJZCxcblx0XHRcdC8qIENvbnZlcnQgcHJlc2VuY2UgYWN0aW9uIGJhY2sgdG8gYW4gaW50IGZvciBzZW5kaW5nIHRvIEFibHkgKi9cblx0XHRcdGFjdGlvbjogdG9BY3Rpb25WYWx1ZSh0aGlzLmFjdGlvbiksXG5cdFx0XHRlbmNvZGluZzogdGhpcy5lbmNvZGluZ1xuXHRcdH07XG5cblx0XHQvKiBlbmNvZGUgZGF0YSB0byBiYXNlNjQgaWYgcHJlc2VudCBhbmQgd2UncmUgcmV0dXJuaW5nIHJlYWwgSlNPTjtcblx0XHQgKiBhbHRob3VnaCBtc2dwYWNrIGNhbGxzIHRvSlNPTigpLCB3ZSBrbm93IGl0IGlzIGEgc3RyaW5naWZ5KClcblx0XHQgKiBjYWxsIGlmIGl0IGhhcyBhIG5vbi1lbXB0eSBhcmd1bWVudHMgbGlzdCAqL1xuXHRcdHZhciBkYXRhID0gdGhpcy5kYXRhO1xuXHRcdGlmKGRhdGEgJiYgQnVmZmVyVXRpbHMuaXNCdWZmZXIoZGF0YSkpIHtcblx0XHRcdGlmKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdC8qIHN0cmluZ2lmeSBjYWxsICovXG5cdFx0XHRcdHZhciBlbmNvZGluZyA9IHRoaXMuZW5jb2Rpbmc7XG5cdFx0XHRcdHJlc3VsdC5lbmNvZGluZyA9IGVuY29kaW5nID8gKGVuY29kaW5nICsgJy9iYXNlNjQnKSA6ICdiYXNlNjQnO1xuXHRcdFx0XHRkYXRhID0gQnVmZmVyVXRpbHMuYmFzZTY0RW5jb2RlKGRhdGEpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0LyogQ2FsbGVkIGJ5IG1zZ3BhY2suIE5lZWQgdG8gZmVlZCBpdCBhbiBBcnJheUJ1ZmZlciwgbXNncGFjayBkb2Vzbid0XG5cdFx0XHRcdCogdW5kZXJzdGFuZCBXb3JkQXJyYXlzICovXG5cdFx0XHRcdGRhdGEgPSBCdWZmZXJVdGlscy50b0FycmF5QnVmZmVyKGRhdGEpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXN1bHQuZGF0YSA9IGRhdGE7XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRQcmVzZW5jZU1lc3NhZ2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlc3VsdCA9ICdbUHJlc2VuY2VNZXNzYWdlJztcblx0XHRyZXN1bHQgKz0gJzsgYWN0aW9uPScgKyB0aGlzLmFjdGlvbjtcblx0XHRpZih0aGlzLmlkKVxuXHRcdFx0cmVzdWx0ICs9ICc7IGlkPScgKyB0aGlzLmlkO1xuXHRcdGlmKHRoaXMudGltZXN0YW1wKVxuXHRcdFx0cmVzdWx0ICs9ICc7IHRpbWVzdGFtcD0nICsgdGhpcy50aW1lc3RhbXA7XG5cdFx0aWYodGhpcy5jbGllbnRJZClcblx0XHRcdHJlc3VsdCArPSAnOyBjbGllbnRJZD0nICsgdGhpcy5jbGllbnRJZDtcblx0XHRpZih0aGlzLmNvbm5lY3Rpb25JZClcblx0XHRcdHJlc3VsdCArPSAnOyBjb25uZWN0aW9uSWQ9JyArIHRoaXMuY29ubmVjdGlvbklkO1xuXHRcdGlmKHRoaXMuZW5jb2RpbmcpXG5cdFx0XHRyZXN1bHQgKz0gJzsgZW5jb2Rpbmc9JyArIHRoaXMuZW5jb2Rpbmc7XG5cdFx0aWYodGhpcy5kYXRhKSB7XG5cdFx0XHRpZiAodHlwZW9mKHRoaXMuZGF0YSkgPT0gJ3N0cmluZycpXG5cdFx0XHRcdHJlc3VsdCArPSAnOyBkYXRhPScgKyB0aGlzLmRhdGE7XG5cdFx0XHRlbHNlIGlmIChCdWZmZXJVdGlscy5pc0J1ZmZlcih0aGlzLmRhdGEpKVxuXHRcdFx0XHRyZXN1bHQgKz0gJzsgZGF0YSAoYnVmZmVyKT0nICsgQnVmZmVyVXRpbHMuYmFzZTY0RW5jb2RlKHRoaXMuZGF0YSk7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdHJlc3VsdCArPSAnOyBkYXRhIChqc29uKT0nICsgSlNPTi5zdHJpbmdpZnkodGhpcy5kYXRhKTtcblx0XHR9XG5cdFx0cmVzdWx0ICs9ICddJztcblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXHRQcmVzZW5jZU1lc3NhZ2UuZW5jb2RlID0gTWVzc2FnZS5lbmNvZGU7XG5cdFByZXNlbmNlTWVzc2FnZS5kZWNvZGUgPSBNZXNzYWdlLmRlY29kZTtcblxuXHRQcmVzZW5jZU1lc3NhZ2UuZnJvbVJlc3BvbnNlQm9keSA9IGZ1bmN0aW9uKGJvZHksIG9wdGlvbnMsIGZvcm1hdCkge1xuXHRcdGlmKGZvcm1hdClcblx0XHRcdGJvZHkgPSAoZm9ybWF0ID09ICdtc2dwYWNrJykgPyBtc2dwYWNrLmRlY29kZShib2R5KSA6IEpTT04ucGFyc2UoU3RyaW5nKGJvZHkpKTtcblxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBib2R5Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgbXNnID0gYm9keVtpXSA9IFByZXNlbmNlTWVzc2FnZS5mcm9tVmFsdWVzKGJvZHlbaV0sIHRydWUpO1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0UHJlc2VuY2VNZXNzYWdlLmRlY29kZShtc2csIG9wdGlvbnMpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfRVJST1IsICdQcmVzZW5jZU1lc3NhZ2UuZnJvbVJlc3BvbnNlQm9keSgpJywgZS50b1N0cmluZygpKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGJvZHk7XG5cdH07XG5cblx0LyogQ3JlYXRlcyBhIFByZXNlbmNlTWVzc2FnZSBmcm9tIHNwZWNpZmllZCB2YWx1ZXMsIHdpdGggYSBzdHJpbmcgcHJlc2VuY2UgYWN0aW9uICovXG5cdFByZXNlbmNlTWVzc2FnZS5mcm9tVmFsdWVzID0gZnVuY3Rpb24odmFsdWVzLCBzdHJpbmdpZnlBY3Rpb24pIHtcblx0XHRpZihzdHJpbmdpZnlBY3Rpb24pIHtcblx0XHRcdHZhbHVlcy5hY3Rpb24gPSBQcmVzZW5jZU1lc3NhZ2UuQWN0aW9uc1t2YWx1ZXMuYWN0aW9uXVxuXHRcdH1cblx0XHRyZXR1cm4gVXRpbHMubWl4aW4obmV3IFByZXNlbmNlTWVzc2FnZSgpLCB2YWx1ZXMpO1xuXHR9O1xuXG5cdFByZXNlbmNlTWVzc2FnZS5mcm9tVmFsdWVzQXJyYXkgPSBmdW5jdGlvbih2YWx1ZXMpIHtcblx0XHR2YXIgY291bnQgPSB2YWx1ZXMubGVuZ3RoLCByZXN1bHQgPSBuZXcgQXJyYXkoY291bnQpO1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSByZXN1bHRbaV0gPSBQcmVzZW5jZU1lc3NhZ2UuZnJvbVZhbHVlcyh2YWx1ZXNbaV0pO1xuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0UHJlc2VuY2VNZXNzYWdlLmZyb21FbmNvZGVkID0gZnVuY3Rpb24oZW5jb2RlZCwgb3B0aW9ucykge1xuXHRcdHZhciBtc2cgPSBQcmVzZW5jZU1lc3NhZ2UuZnJvbVZhbHVlcyhlbmNvZGVkLCB0cnVlKTtcblx0XHQvKiBpZiBkZWNvZGluZyBmYWlscyBhdCBhbnkgcG9pbnQsIGNhdGNoIGFuZCByZXR1cm4gdGhlIG1lc3NhZ2UgZGVjb2RlZCB0b1xuXHRcdCAqIHRoZSBmdWxsZXN0IGV4dGVudCBwb3NzaWJsZSAqL1xuXHRcdHRyeSB7XG5cdFx0XHRQcmVzZW5jZU1lc3NhZ2UuZGVjb2RlKG1zZywgb3B0aW9ucyk7XG5cdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfRVJST1IsICdQcmVzZW5jZU1lc3NhZ2UuZnJvbUVuY29kZWQoKScsIGUudG9TdHJpbmcoKSk7XG5cdFx0fVxuXHRcdHJldHVybiBtc2c7XG5cdH07XG5cblx0UHJlc2VuY2VNZXNzYWdlLmZyb21FbmNvZGVkQXJyYXkgPSBmdW5jdGlvbihlbmNvZGVkQXJyYXksIG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gVXRpbHMuYXJyTWFwKGVuY29kZWRBcnJheSwgZnVuY3Rpb24oZW5jb2RlZCkge1xuXHRcdFx0cmV0dXJuIFByZXNlbmNlTWVzc2FnZS5mcm9tRW5jb2RlZChlbmNvZGVkLCBvcHRpb25zKTtcblx0XHR9KTtcblx0fTtcblxuXHRyZXR1cm4gUHJlc2VuY2VNZXNzYWdlO1xufSkoKTtcblxudmFyIFByb3RvY29sTWVzc2FnZSA9IChmdW5jdGlvbigpIHtcblx0dmFyIG1zZ3BhY2sgPSBQbGF0Zm9ybS5tc2dwYWNrO1xuXG5cdGZ1bmN0aW9uIFByb3RvY29sTWVzc2FnZSgpIHtcblx0XHR0aGlzLmFjdGlvbiA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLmZsYWdzID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuaWQgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy50aW1lc3RhbXAgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5jb3VudCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLmVycm9yID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuY29ubmVjdGlvbklkID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuY29ubmVjdGlvbktleSA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLmNvbm5lY3Rpb25TZXJpYWwgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5jaGFubmVsID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuY2hhbm5lbFNlcmlhbCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLm1zZ1NlcmlhbCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLm1lc3NhZ2VzID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMucHJlc2VuY2UgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5hdXRoID0gdW5kZWZpbmVkO1xuXHR9XG5cblx0UHJvdG9jb2xNZXNzYWdlLkFjdGlvbiA9IHtcblx0XHQnSEVBUlRCRUFUJyA6IDAsXG5cdFx0J0FDSycgOiAxLFxuXHRcdCdOQUNLJyA6IDIsXG5cdFx0J0NPTk5FQ1QnIDogMyxcblx0XHQnQ09OTkVDVEVEJyA6IDQsXG5cdFx0J0RJU0NPTk5FQ1QnIDogNSxcblx0XHQnRElTQ09OTkVDVEVEJyA6IDYsXG5cdFx0J0NMT1NFJyA6IDcsXG5cdFx0J0NMT1NFRCcgOiA4LFxuXHRcdCdFUlJPUicgOiA5LFxuXHRcdCdBVFRBQ0gnIDogMTAsXG5cdFx0J0FUVEFDSEVEJyA6IDExLFxuXHRcdCdERVRBQ0gnIDogMTIsXG5cdFx0J0RFVEFDSEVEJyA6IDEzLFxuXHRcdCdQUkVTRU5DRScgOiAxNCxcblx0XHQnTUVTU0FHRScgOiAxNSxcblx0XHQnU1lOQycgOiAxNixcblx0XHQnQVVUSCcgOiAxN1xuXHR9O1xuXG5cdFByb3RvY29sTWVzc2FnZS5BY3Rpb25OYW1lID0gW107XG5cdFV0aWxzLmFyckZvckVhY2goVXRpbHMua2V5c0FycmF5KFByb3RvY29sTWVzc2FnZS5BY3Rpb24sIHRydWUpLCBmdW5jdGlvbihuYW1lKSB7XG5cdFx0UHJvdG9jb2xNZXNzYWdlLkFjdGlvbk5hbWVbUHJvdG9jb2xNZXNzYWdlLkFjdGlvbltuYW1lXV0gPSBuYW1lO1xuXHR9KTtcblxuXHR2YXIgZmxhZ3MgPSB7XG5cdFx0LyogQ2hhbm5lbCBhdHRhY2ggc3RhdGUgZmxhZ3MgKi9cblx0XHQnSEFTX1BSRVNFTkNFJzogICAgICAgMSA8PCAwLFxuXHRcdCdIQVNfQkFDS0xPRyc6ICAgICAgICAxIDw8IDEsXG5cdFx0J1JFU1VNRUQnOiAgICAgICAgICAgIDEgPDwgMixcblx0XHQnSEFTX0xPQ0FMX1BSRVNFTkNFJzogMSA8PCAzLFxuXHRcdCdUUkFOU0lFTlQnOiAgICAgICAgICAxIDw8IDQsXG5cdFx0LyogQ2hhbm5lbCBtb2RlIGZsYWdzICovXG5cdFx0J1BSRVNFTkNFJzogICAgICAgICAgIDEgPDwgMTYsXG5cdFx0J1BVQkxJU0gnOiAgICAgICAgICAgIDEgPDwgMTcsXG5cdFx0J1NVQlNDUklCRSc6ICAgICAgICAgIDEgPDwgMTgsXG5cdFx0J1BSRVNFTkNFX1NVQlNDUklCRSc6IDEgPDwgMTlcblx0fTtcblx0dmFyIGZsYWdOYW1lcyA9IFV0aWxzLmtleXNBcnJheShmbGFncyk7XG5cdGZsYWdzLk1PREVfQUxMID0gZmxhZ3MuUFJFU0VOQ0UgfCBmbGFncy5QVUJMSVNIIHwgZmxhZ3MuU1VCU0NSSUJFIHwgZmxhZ3MuUFJFU0VOQ0VfU1VCU0NSSUJFO1xuXG5cdFByb3RvY29sTWVzc2FnZS5wcm90b3R5cGUuaGFzRmxhZyA9IGZ1bmN0aW9uKGZsYWcpIHtcblx0XHRyZXR1cm4gKCh0aGlzLmZsYWdzICYgZmxhZ3NbZmxhZ10pID4gMCk7XG5cdH07XG5cblx0UHJvdG9jb2xNZXNzYWdlLnByb3RvdHlwZS5zZXRGbGFnID0gZnVuY3Rpb24oZmxhZykge1xuXHRcdHJldHVybiB0aGlzLmZsYWdzID0gdGhpcy5mbGFncyB8IGZsYWdzW2ZsYWddO1xuXHR9O1xuXG5cdFByb3RvY29sTWVzc2FnZS5wcm90b3R5cGUuZ2V0TW9kZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmZsYWdzICYmICh0aGlzLmZsYWdzICYgZmxhZ3MuTU9ERV9BTEwpO1xuXHR9O1xuXG5cdFByb3RvY29sTWVzc2FnZS5zZXJpYWxpemUgPSBmdW5jdGlvbihtc2csIGZvcm1hdCkge1xuXHRcdHJldHVybiAoZm9ybWF0ID09ICdtc2dwYWNrJykgPyBtc2dwYWNrLmVuY29kZShtc2csIHRydWUpOiBKU09OLnN0cmluZ2lmeShtc2cpO1xuXHR9O1xuXG5cdFByb3RvY29sTWVzc2FnZS5kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uKHNlcmlhbGl6ZWQsIGZvcm1hdCkge1xuXHRcdHZhciBkZXNlcmlhbGl6ZWQgPSAoZm9ybWF0ID09ICdtc2dwYWNrJykgPyBtc2dwYWNrLmRlY29kZShzZXJpYWxpemVkKSA6IEpTT04ucGFyc2UoU3RyaW5nKHNlcmlhbGl6ZWQpKTtcblx0XHRyZXR1cm4gUHJvdG9jb2xNZXNzYWdlLmZyb21EZXNlcmlhbGl6ZWQoZGVzZXJpYWxpemVkKTtcblx0fTtcblxuXHRQcm90b2NvbE1lc3NhZ2UuZnJvbURlc2VyaWFsaXplZCA9IGZ1bmN0aW9uKGRlc2VyaWFsaXplZCkge1xuXHRcdHZhciBlcnJvciA9IGRlc2VyaWFsaXplZC5lcnJvcjtcblx0XHRpZihlcnJvcikgZGVzZXJpYWxpemVkLmVycm9yID0gRXJyb3JJbmZvLmZyb21WYWx1ZXMoZXJyb3IpO1xuXHRcdHZhciBtZXNzYWdlcyA9IGRlc2VyaWFsaXplZC5tZXNzYWdlcztcblx0XHRpZihtZXNzYWdlcykgZm9yKHZhciBpID0gMDsgaSA8IG1lc3NhZ2VzLmxlbmd0aDsgaSsrKSBtZXNzYWdlc1tpXSA9IE1lc3NhZ2UuZnJvbVZhbHVlcyhtZXNzYWdlc1tpXSk7XG5cdFx0dmFyIHByZXNlbmNlID0gZGVzZXJpYWxpemVkLnByZXNlbmNlO1xuXHRcdGlmKHByZXNlbmNlKSBmb3IodmFyIGkgPSAwOyBpIDwgcHJlc2VuY2UubGVuZ3RoOyBpKyspIHByZXNlbmNlW2ldID0gUHJlc2VuY2VNZXNzYWdlLmZyb21WYWx1ZXMocHJlc2VuY2VbaV0sIHRydWUpO1xuXHRcdHJldHVybiBVdGlscy5taXhpbihuZXcgUHJvdG9jb2xNZXNzYWdlKCksIGRlc2VyaWFsaXplZCk7XG5cdH07XG5cblx0UHJvdG9jb2xNZXNzYWdlLmZyb21WYWx1ZXMgPSBmdW5jdGlvbih2YWx1ZXMpIHtcblx0XHRyZXR1cm4gVXRpbHMubWl4aW4obmV3IFByb3RvY29sTWVzc2FnZSgpLCB2YWx1ZXMpO1xuXHR9O1xuXG5cdGZ1bmN0aW9uIHRvU3RyaW5nQXJyYXkoYXJyYXkpIHtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0aWYgKGFycmF5KSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHJlc3VsdC5wdXNoKGFycmF5W2ldLnRvU3RyaW5nKCkpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gJ1sgJyArIHJlc3VsdC5qb2luKCcsICcpICsgJyBdJztcblx0fVxuXG5cdHZhciBzaW1wbGVBdHRyaWJ1dGVzID0gJ2lkIGNoYW5uZWwgY2hhbm5lbFNlcmlhbCBjb25uZWN0aW9uSWQgY29ubmVjdGlvbktleSBjb25uZWN0aW9uU2VyaWFsIGNvdW50IG1zZ1NlcmlhbCB0aW1lc3RhbXAnLnNwbGl0KCcgJyk7XG5cblx0UHJvdG9jb2xNZXNzYWdlLnN0cmluZ2lmeSA9IGZ1bmN0aW9uKG1zZykge1xuXHRcdHZhciByZXN1bHQgPSAnW1Byb3RvY29sTWVzc2FnZSc7XG5cdFx0aWYobXNnLmFjdGlvbiAhPT0gdW5kZWZpbmVkKVxuXHRcdFx0cmVzdWx0ICs9ICc7IGFjdGlvbj0nICsgUHJvdG9jb2xNZXNzYWdlLkFjdGlvbk5hbWVbbXNnLmFjdGlvbl0gfHwgbXNnLmFjdGlvbjtcblxuXHRcdHZhciBhdHRyaWJ1dGU7XG5cdFx0Zm9yICh2YXIgYXR0cmliSW5kZXggPSAwOyBhdHRyaWJJbmRleCA8IHNpbXBsZUF0dHJpYnV0ZXMubGVuZ3RoOyBhdHRyaWJJbmRleCsrKSB7XG5cdFx0XHRhdHRyaWJ1dGUgPSBzaW1wbGVBdHRyaWJ1dGVzW2F0dHJpYkluZGV4XTtcblx0XHRcdGlmKG1zZ1thdHRyaWJ1dGVdICE9PSB1bmRlZmluZWQpXG5cdFx0XHRcdHJlc3VsdCArPSAnOyAnICsgYXR0cmlidXRlICsgJz0nICsgbXNnW2F0dHJpYnV0ZV07XG5cdFx0fVxuXG5cdFx0aWYobXNnLm1lc3NhZ2VzKVxuXHRcdFx0cmVzdWx0ICs9ICc7IG1lc3NhZ2VzPScgKyB0b1N0cmluZ0FycmF5KE1lc3NhZ2UuZnJvbVZhbHVlc0FycmF5KG1zZy5tZXNzYWdlcykpO1xuXHRcdGlmKG1zZy5wcmVzZW5jZSlcblx0XHRcdHJlc3VsdCArPSAnOyBwcmVzZW5jZT0nICsgdG9TdHJpbmdBcnJheShQcmVzZW5jZU1lc3NhZ2UuZnJvbVZhbHVlc0FycmF5KG1zZy5wcmVzZW5jZSkpO1xuXHRcdGlmKG1zZy5lcnJvcilcblx0XHRcdHJlc3VsdCArPSAnOyBlcnJvcj0nICsgRXJyb3JJbmZvLmZyb21WYWx1ZXMobXNnLmVycm9yKS50b1N0cmluZygpO1xuXHRcdGlmKG1zZy5hdXRoICYmIG1zZy5hdXRoLmFjY2Vzc1Rva2VuKVxuXHRcdFx0cmVzdWx0ICs9ICc7IHRva2VuPScgKyBtc2cuYXV0aC5hY2Nlc3NUb2tlbjtcblx0XHRpZihtc2cuZmxhZ3MpXG5cdFx0XHRyZXN1bHQgKz0gJzsgZmxhZ3M9JyArIFV0aWxzLmFyckZpbHRlcihmbGFnTmFtZXMsIGZ1bmN0aW9uKGZsYWcpIHtcblx0XHRcdFx0cmV0dXJuIG1zZy5oYXNGbGFnKGZsYWcpO1xuXHRcdFx0fSkuam9pbignLCcpO1xuXG5cdFx0cmVzdWx0ICs9ICddJztcblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdHJldHVybiBQcm90b2NvbE1lc3NhZ2U7XG59KSgpO1xuXG52YXIgU3RhdHMgPSAoZnVuY3Rpb24oKSB7XG5cblx0ZnVuY3Rpb24gTWVzc2FnZUNvdW50KHZhbHVlcykge1xuXHRcdHRoaXMuY291bnQgPSAodmFsdWVzICYmIHZhbHVlcy5jb3VudCkgfHwgMDtcblx0XHR0aGlzLmRhdGEgPSAodmFsdWVzICYmIHZhbHVlcy5kYXRhKSB8fCAwO1xuXHRcdHRoaXMuZmFpbGVkID0gKHZhbHVlcyAmJiB2YWx1ZXMuZmFpbGVkKSB8fCAwO1xuXHRcdHRoaXMucmVmdXNlZCA9ICh2YWx1ZXMgJiYgdmFsdWVzLnJlZnVzZWQpIHx8IDA7XG5cdH1cblxuXHRmdW5jdGlvbiBSZXNvdXJjZUNvdW50KHZhbHVlcykge1xuXHRcdHRoaXMucGVhayA9ICh2YWx1ZXMgJiYgdmFsdWVzLnBlYWspIHx8IDA7XG5cdFx0dGhpcy5taW4gPSAodmFsdWVzICYmIHZhbHVlcy5taW4pIHx8IDA7XG5cdFx0dGhpcy5tZWFuID0gKHZhbHVlcyAmJiB2YWx1ZXMubWVhbikgfHwgMDtcblx0XHR0aGlzLm9wZW5lZCA9ICh2YWx1ZXMgJiYgdmFsdWVzLm9wZW5lZCkgfHwgMDtcblx0XHR0aGlzLnJlZnVzZWQgPSAodmFsdWVzICYmIHZhbHVlcy5yZWZ1c2VkKSB8fCAwO1xuXHR9XG5cblx0ZnVuY3Rpb24gUmVxdWVzdENvdW50KHZhbHVlcykge1xuXHRcdHRoaXMuc3VjY2VlZGVkID0gKHZhbHVlcyAmJiB2YWx1ZXMuc3VjY2VlZGVkKSB8fCAwO1xuXHRcdHRoaXMuZmFpbGVkID0gKHZhbHVlcyAmJiB2YWx1ZXMuZmFpbGVkKSB8fCAwO1xuXHRcdHRoaXMucmVmdXNlZCA9ICh2YWx1ZXMgJiYgdmFsdWVzLnJlZnVzZWQpIHx8IDA7XG5cdH1cblxuXHRmdW5jdGlvbiBDb25uZWN0aW9uVHlwZXModmFsdWVzKSB7XG5cdFx0dGhpcy5wbGFpbiA9IG5ldyBSZXNvdXJjZUNvdW50KHZhbHVlcyAmJiB2YWx1ZXMucGxhaW4pO1xuXHRcdHRoaXMudGxzID0gbmV3IFJlc291cmNlQ291bnQodmFsdWVzICYmIHZhbHVlcy50bHMpO1xuXHRcdHRoaXMuYWxsID0gbmV3IFJlc291cmNlQ291bnQodmFsdWVzICYmIHZhbHVlcy5hbGwpO1xuXHR9XG5cblx0ZnVuY3Rpb24gTWVzc2FnZVR5cGVzKHZhbHVlcykge1xuXHRcdHRoaXMubWVzc2FnZXMgPSBuZXcgTWVzc2FnZUNvdW50KHZhbHVlcyAmJiB2YWx1ZXMubWVzc2FnZXMpO1xuXHRcdHRoaXMucHJlc2VuY2UgPSBuZXcgTWVzc2FnZUNvdW50KHZhbHVlcyAmJiB2YWx1ZXMucHJlc2VuY2UpO1xuXHRcdHRoaXMuYWxsID0gbmV3IE1lc3NhZ2VDb3VudCh2YWx1ZXMgJiYgdmFsdWVzLmFsbCk7XG5cdH1cblxuXHRmdW5jdGlvbiBNZXNzYWdlVHJhZmZpYyh2YWx1ZXMpIHtcblx0XHR0aGlzLnJlYWx0aW1lID0gbmV3IE1lc3NhZ2VUeXBlcyh2YWx1ZXMgJiYgdmFsdWVzLnJlYWx0aW1lKTtcblx0XHR0aGlzLnJlc3QgPSBuZXcgTWVzc2FnZVR5cGVzKHZhbHVlcyAmJiB2YWx1ZXMucmVzdCk7XG5cdFx0dGhpcy53ZWJob29rID0gbmV3IE1lc3NhZ2VUeXBlcyh2YWx1ZXMgJiYgdmFsdWVzLndlYmhvb2spO1xuXHRcdHRoaXMucHVzaCA9IG5ldyBNZXNzYWdlVHlwZXModmFsdWVzICYmIHZhbHVlcy5wdXNoKTtcblx0XHR0aGlzLnNoYXJlZFF1ZXVlID0gbmV3IE1lc3NhZ2VUeXBlcyh2YWx1ZXMgJiYgdmFsdWVzLnNoYXJlZFF1ZXVlKTtcblx0XHR0aGlzLmV4dGVybmFsUXVldWUgPSBuZXcgTWVzc2FnZVR5cGVzKHZhbHVlcyAmJiB2YWx1ZXMuZXh0ZXJuYWxRdWV1ZSk7XG5cdFx0dGhpcy5hbGwgPSBuZXcgTWVzc2FnZVR5cGVzKHZhbHVlcyAmJiB2YWx1ZXMuYWxsKTtcblx0fVxuXG5cdGZ1bmN0aW9uIFN0YXRzKHZhbHVlcykge1xuXHRcdHRoaXMuYWxsICAgICAgICAgICA9IG5ldyBNZXNzYWdlVHlwZXModmFsdWVzICYmIHZhbHVlcy5hbGwpO1xuXHRcdHRoaXMuaW5ib3VuZCAgICAgICA9IG5ldyBNZXNzYWdlVHJhZmZpYyh2YWx1ZXMgJiYgdmFsdWVzLmluYm91bmQpO1xuXHRcdHRoaXMub3V0Ym91bmQgICAgICA9IG5ldyBNZXNzYWdlVHJhZmZpYyh2YWx1ZXMgJiYgdmFsdWVzLm91dGJvdW5kKTtcblx0XHR0aGlzLnBlcnNpc3RlZCAgICAgPSBuZXcgTWVzc2FnZVR5cGVzKHZhbHVlcyAmJiB2YWx1ZXMucGVyc2lzdGVkKTtcblx0XHR0aGlzLmNvbm5lY3Rpb25zICAgPSBuZXcgQ29ubmVjdGlvblR5cGVzKHZhbHVlcyAmJiB2YWx1ZXMuY29ubmVjdGlvbnMpO1xuXHRcdHRoaXMuY2hhbm5lbHMgICAgICA9IG5ldyBSZXNvdXJjZUNvdW50KHZhbHVlcyAmJiB2YWx1ZXMuY2hhbm5lbHMpO1xuXHRcdHRoaXMuYXBpUmVxdWVzdHMgICA9IG5ldyBSZXF1ZXN0Q291bnQodmFsdWVzICYmIHZhbHVlcy5hcGlSZXF1ZXN0cyk7XG5cdFx0dGhpcy50b2tlblJlcXVlc3RzID0gbmV3IFJlcXVlc3RDb3VudCh2YWx1ZXMgJiYgdmFsdWVzLnRva2VuUmVxdWVzdHMpO1xuXHRcdHRoaXMuaW5Qcm9ncmVzcyAgICA9ICh2YWx1ZXMgJiYgdmFsdWVzLmluUHJvZ3Jlc3MpIHx8IHVuZGVmaW5lZDtcblx0XHR0aGlzLnVuaXQgICAgICAgICAgPSAodmFsdWVzICYmIHZhbHVlcy51bml0KSB8fCB1bmRlZmluZWQ7XG5cdFx0dGhpcy5pbnRlcnZhbElkICAgID0gKHZhbHVlcyAmJiB2YWx1ZXMuaW50ZXJ2YWxJZCkgfHwgdW5kZWZpbmVkO1xuXHR9XG5cblx0U3RhdHMuZnJvbVZhbHVlcyA9IGZ1bmN0aW9uKHZhbHVlcykge1xuXHRcdHJldHVybiBuZXcgU3RhdHModmFsdWVzKTtcblx0fTtcblxuXHRyZXR1cm4gU3RhdHM7XG59KSgpO1xuXG52YXIgQ29ubmVjdGlvbkVycm9yID0ge1xuXHRkaXNjb25uZWN0ZWQ6IEVycm9ySW5mby5mcm9tVmFsdWVzKHtcblx0XHRzdGF0dXNDb2RlOiA0MDAsXG5cdFx0Y29kZTogODAwMDMsXG5cdFx0bWVzc2FnZTogJ0Nvbm5lY3Rpb24gdG8gc2VydmVyIHRlbXBvcmFyaWx5IHVuYXZhaWxhYmxlJ1xuXHR9KSxcblx0c3VzcGVuZGVkOiBFcnJvckluZm8uZnJvbVZhbHVlcyh7XG5cdFx0c3RhdHVzQ29kZTogNDAwLFxuXHRcdGNvZGU6IDgwMDAyLFxuXHRcdG1lc3NhZ2U6ICdDb25uZWN0aW9uIHRvIHNlcnZlciB1bmF2YWlsYWJsZSdcblx0fSksXG5cdGZhaWxlZDogRXJyb3JJbmZvLmZyb21WYWx1ZXMoe1xuXHRcdHN0YXR1c0NvZGU6IDQwMCxcblx0XHRjb2RlOiA4MDAwMCxcblx0XHRtZXNzYWdlOiAnQ29ubmVjdGlvbiBmYWlsZWQgb3IgZGlzY29ubmVjdGVkIGJ5IHNlcnZlcidcblx0fSksXG5cdGNsb3Npbmc6IEVycm9ySW5mby5mcm9tVmFsdWVzKHtcblx0XHRzdGF0dXNDb2RlOiA0MDAsXG5cdFx0Y29kZTogODAwMTcsXG5cdFx0bWVzc2FnZTogJ0Nvbm5lY3Rpb24gY2xvc2luZydcblx0fSksXG5cdGNsb3NlZDogRXJyb3JJbmZvLmZyb21WYWx1ZXMoe1xuXHRcdHN0YXR1c0NvZGU6IDQwMCxcblx0XHRjb2RlOiA4MDAxNyxcblx0XHRtZXNzYWdlOiAnQ29ubmVjdGlvbiBjbG9zZWQnXG5cdH0pLFxuXHR1bmtub3duQ29ubmVjdGlvbkVycjogRXJyb3JJbmZvLmZyb21WYWx1ZXMoe1xuXHRcdHN0YXR1c0NvZGU6IDUwMCxcblx0XHRjb2RlOiA1MDAwMixcblx0XHRtZXNzYWdlOiAnSW50ZXJuYWwgY29ubmVjdGlvbiBlcnJvcidcblx0fSksXG5cdHVua25vd25DaGFubmVsRXJyOiBFcnJvckluZm8uZnJvbVZhbHVlcyh7XG5cdFx0c3RhdHVzQ29kZTogNTAwLFxuXHRcdGNvZGU6IDUwMDAxLFxuXHRcdG1lc3NhZ2U6ICdJbnRlcm5hbCBjaGFubmVsIGVycm9yJ1xuXHR9KVxufTtcblxudmFyIE1lc3NhZ2VRdWV1ZSA9IChmdW5jdGlvbigpIHtcblx0ZnVuY3Rpb24gTWVzc2FnZVF1ZXVlKCkge1xuXHRcdEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXHRcdHRoaXMubWVzc2FnZXMgPSBbXTtcblx0fVxuXHRVdGlscy5pbmhlcml0cyhNZXNzYWdlUXVldWUsIEV2ZW50RW1pdHRlcik7XG5cblx0TWVzc2FnZVF1ZXVlLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1lc3NhZ2VzLmxlbmd0aDtcblx0fTtcblxuXHRNZXNzYWdlUXVldWUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihtZXNzYWdlKSB7XG5cdFx0dGhpcy5tZXNzYWdlcy5wdXNoKG1lc3NhZ2UpO1xuXHR9O1xuXG5cdE1lc3NhZ2VRdWV1ZS5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tZXNzYWdlcy5zaGlmdCgpO1xuXHR9O1xuXG5cdE1lc3NhZ2VRdWV1ZS5wcm90b3R5cGUubGFzdCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1lc3NhZ2VzW3RoaXMubWVzc2FnZXMubGVuZ3RoIC0gMV07XG5cdH07XG5cblx0TWVzc2FnZVF1ZXVlLnByb3RvdHlwZS5jb3B5QWxsID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWVzc2FnZXMuc2xpY2UoKTtcblx0fTtcblxuXHRNZXNzYWdlUXVldWUucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uKG1lc3NhZ2VzKSB7XG5cdFx0dGhpcy5tZXNzYWdlcy5wdXNoLmFwcGx5KHRoaXMubWVzc2FnZXMsIG1lc3NhZ2VzKTtcblx0fTtcblxuXHRNZXNzYWdlUXVldWUucHJvdG90eXBlLnByZXBlbmQgPSBmdW5jdGlvbihtZXNzYWdlcykge1xuXHRcdHRoaXMubWVzc2FnZXMudW5zaGlmdC5hcHBseSh0aGlzLm1lc3NhZ2VzLCBtZXNzYWdlcyk7XG5cdH07XG5cblx0TWVzc2FnZVF1ZXVlLnByb3RvdHlwZS5jb21wbGV0ZU1lc3NhZ2VzID0gZnVuY3Rpb24oc2VyaWFsLCBjb3VudCwgZXJyKSB7XG5cdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX01JQ1JPLCAnTWVzc2FnZVF1ZXVlLmNvbXBsZXRlTWVzc2FnZXMoKScsICdzZXJpYWwgPSAnICsgc2VyaWFsICsgJzsgY291bnQgPSAnICsgY291bnQpO1xuXHRcdGVyciA9IGVyciB8fCBudWxsO1xuXHRcdHZhciBtZXNzYWdlcyA9IHRoaXMubWVzc2FnZXM7XG5cdFx0dmFyIGZpcnN0ID0gbWVzc2FnZXNbMF07XG5cdFx0aWYoZmlyc3QpIHtcblx0XHRcdHZhciBzdGFydFNlcmlhbCA9IGZpcnN0Lm1lc3NhZ2UubXNnU2VyaWFsO1xuXHRcdFx0dmFyIGVuZFNlcmlhbCA9IHNlcmlhbCArIGNvdW50OyAvKiB0aGUgc2VyaWFsIG9mIHRoZSBmaXJzdCBtZXNzYWdlIHRoYXQgaXMgKm5vdCogdGhlIHN1YmplY3Qgb2YgdGhpcyBjYWxsICovXG5cdFx0XHRpZihlbmRTZXJpYWwgPiBzdGFydFNlcmlhbCkge1xuXHRcdFx0XHR2YXIgY29tcGxldGVNZXNzYWdlcyA9IG1lc3NhZ2VzLnNwbGljZSgwLCAoZW5kU2VyaWFsIC0gc3RhcnRTZXJpYWwpKTtcblx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGNvbXBsZXRlTWVzc2FnZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRjb21wbGV0ZU1lc3NhZ2VzW2ldLmNhbGxiYWNrKGVycik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmKG1lc3NhZ2VzLmxlbmd0aCA9PSAwKVxuXHRcdFx0XHR0aGlzLmVtaXQoJ2lkbGUnKTtcblx0XHR9XG5cdH07XG5cblx0TWVzc2FnZVF1ZXVlLnByb3RvdHlwZS5jb21wbGV0ZUFsbE1lc3NhZ2VzID0gZnVuY3Rpb24oZXJyKSB7XG5cdFx0dGhpcy5jb21wbGV0ZU1lc3NhZ2VzKDAsIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8IE51bWJlci5NQVhfVkFMVUUsIGVycik7XG5cdH07XG5cblx0TWVzc2FnZVF1ZXVlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuXHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSUNSTywgJ01lc3NhZ2VRdWV1ZS5jbGVhcigpJywgJ2NsZWFyaW5nICcgKyB0aGlzLm1lc3NhZ2VzLmxlbmd0aCArICcgbWVzc2FnZXMnKTtcblx0XHR0aGlzLm1lc3NhZ2VzID0gW107XG5cdFx0dGhpcy5lbWl0KCdpZGxlJyk7XG5cdH07XG5cblx0cmV0dXJuIE1lc3NhZ2VRdWV1ZTtcbn0pKCk7XG5cbnZhciBQcm90b2NvbCA9IChmdW5jdGlvbigpIHtcblx0dmFyIGFjdGlvbnMgPSBQcm90b2NvbE1lc3NhZ2UuQWN0aW9uO1xuXG5cdGZ1bmN0aW9uIFByb3RvY29sKHRyYW5zcG9ydCkge1xuXHRcdEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXHRcdHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuXHRcdHRoaXMubWVzc2FnZVF1ZXVlID0gbmV3IE1lc3NhZ2VRdWV1ZSgpO1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHR0cmFuc3BvcnQub24oJ2FjaycsIGZ1bmN0aW9uKHNlcmlhbCwgY291bnQpIHsgc2VsZi5vbkFjayhzZXJpYWwsIGNvdW50KTsgfSk7XG5cdFx0dHJhbnNwb3J0Lm9uKCduYWNrJywgZnVuY3Rpb24oc2VyaWFsLCBjb3VudCwgZXJyKSB7IHNlbGYub25OYWNrKHNlcmlhbCwgY291bnQsIGVycik7IH0pO1xuXHR9XG5cdFV0aWxzLmluaGVyaXRzKFByb3RvY29sLCBFdmVudEVtaXR0ZXIpO1xuXG5cdFByb3RvY29sLnByb3RvdHlwZS5vbkFjayA9IGZ1bmN0aW9uKHNlcmlhbCwgY291bnQpIHtcblx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlDUk8sICdQcm90b2NvbC5vbkFjaygpJywgJ3NlcmlhbCA9ICcgKyBzZXJpYWwgKyAnOyBjb3VudCA9ICcgKyBjb3VudCk7XG5cdFx0dGhpcy5tZXNzYWdlUXVldWUuY29tcGxldGVNZXNzYWdlcyhzZXJpYWwsIGNvdW50KTtcblx0fTtcblxuXHRQcm90b2NvbC5wcm90b3R5cGUub25OYWNrID0gZnVuY3Rpb24oc2VyaWFsLCBjb3VudCwgZXJyKSB7XG5cdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX0VSUk9SLCAnUHJvdG9jb2wub25OYWNrKCknLCAnc2VyaWFsID0gJyArIHNlcmlhbCArICc7IGNvdW50ID0gJyArIGNvdW50ICsgJzsgZXJyID0gJyArIFV0aWxzLmluc3BlY3RFcnJvcihlcnIpKTtcblx0XHRpZighZXJyKSB7XG5cdFx0XHRlcnIgPSBuZXcgRXJyb3JJbmZvKCdVbmFibGUgdG8gc2VuZCBtZXNzYWdlOyBjaGFubmVsIG5vdCByZXNwb25kaW5nJywgNTAwMDEsIDUwMCk7XG5cdFx0fVxuXHRcdHRoaXMubWVzc2FnZVF1ZXVlLmNvbXBsZXRlTWVzc2FnZXMoc2VyaWFsLCBjb3VudCwgZXJyKTtcblx0fTtcblxuXHRQcm90b2NvbC5wcm90b3R5cGUub25jZUlkbGUgPSBmdW5jdGlvbihsaXN0ZW5lcikge1xuXHRcdHZhciBtZXNzYWdlUXVldWUgPSB0aGlzLm1lc3NhZ2VRdWV1ZTtcblx0XHRpZihtZXNzYWdlUXVldWUuY291bnQoKSA9PT0gMCkge1xuXHRcdFx0bGlzdGVuZXIoKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0bWVzc2FnZVF1ZXVlLm9uY2UoJ2lkbGUnLCBsaXN0ZW5lcik7XG5cdH07XG5cblx0UHJvdG9jb2wucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihwZW5kaW5nTWVzc2FnZSkge1xuXHRcdGlmKHBlbmRpbmdNZXNzYWdlLmFja1JlcXVpcmVkKSB7XG5cdFx0XHR0aGlzLm1lc3NhZ2VRdWV1ZS5wdXNoKHBlbmRpbmdNZXNzYWdlKTtcblx0XHR9XG5cdFx0aWYgKExvZ2dlci5zaG91bGRMb2coTG9nZ2VyLkxPR19NSUNSTykpIHtcblx0XHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSUNSTywgJ1Byb3RvY29sLnNlbmQoKScsICdzZW5kaW5nIG1zZzsgJyArIFByb3RvY29sTWVzc2FnZS5zdHJpbmdpZnkocGVuZGluZ01lc3NhZ2UubWVzc2FnZSkpO1xuXHRcdH1cblx0XHRwZW5kaW5nTWVzc2FnZS5zZW5kQXR0ZW1wdGVkID0gdHJ1ZTtcblx0XHR0aGlzLnRyYW5zcG9ydC5zZW5kKHBlbmRpbmdNZXNzYWdlLm1lc3NhZ2UpO1xuXHR9O1xuXG5cdFByb3RvY29sLnByb3RvdHlwZS5nZXRUcmFuc3BvcnQgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy50cmFuc3BvcnQ7XG5cdH07XG5cblx0UHJvdG9jb2wucHJvdG90eXBlLmdldFBlbmRpbmdNZXNzYWdlcyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1lc3NhZ2VRdWV1ZS5jb3B5QWxsKCk7XG5cdH07XG5cblx0UHJvdG9jb2wucHJvdG90eXBlLmNsZWFyUGVuZGluZ01lc3NhZ2VzID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWVzc2FnZVF1ZXVlLmNsZWFyKCk7XG5cdH07XG5cblx0UHJvdG9jb2wucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0cmFuc3BvcnQgPSB0aGlzLnRyYW5zcG9ydDtcblx0XHR0aGlzLm9uY2VJZGxlKGZ1bmN0aW9uKCkge1xuXHRcdFx0dHJhbnNwb3J0LmRpc2Nvbm5lY3QoKTtcblx0XHR9KTtcblx0fTtcblxuXHRmdW5jdGlvbiBQZW5kaW5nTWVzc2FnZShtZXNzYWdlLCBjYWxsYmFjaykge1xuXHRcdHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG5cdFx0dGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuXHRcdHRoaXMubWVyZ2VkID0gZmFsc2U7XG5cdFx0dmFyIGFjdGlvbiA9IG1lc3NhZ2UuYWN0aW9uO1xuXHRcdHRoaXMuc2VuZEF0dGVtcHRlZCA9IGZhbHNlO1xuXHRcdHRoaXMuYWNrUmVxdWlyZWQgPSAoYWN0aW9uID09IGFjdGlvbnMuTUVTU0FHRSB8fCBhY3Rpb24gPT0gYWN0aW9ucy5QUkVTRU5DRSk7XG5cdH1cblx0UHJvdG9jb2wuUGVuZGluZ01lc3NhZ2UgPSBQZW5kaW5nTWVzc2FnZTtcblxuXHRyZXR1cm4gUHJvdG9jb2w7XG59KSgpO1xuXG52YXIgQ29ubmVjdGlvbk1hbmFnZXIgPSAoZnVuY3Rpb24oKSB7XG5cdHZhciBoYXZlV2ViU3RvcmFnZSA9ICEhKHR5cGVvZihXZWJTdG9yYWdlKSAhPT0gJ3VuZGVmaW5lZCcgJiYgV2ViU3RvcmFnZS5nZXQpO1xuXHR2YXIgaGF2ZVNlc3Npb25TdG9yYWdlID0gISEodHlwZW9mKFdlYlN0b3JhZ2UpICE9PSAndW5kZWZpbmVkJyAmJiBXZWJTdG9yYWdlLmdldFNlc3Npb24pO1xuXHR2YXIgYWN0aW9ucyA9IFByb3RvY29sTWVzc2FnZS5BY3Rpb247XG5cdHZhciBQZW5kaW5nTWVzc2FnZSA9IFByb3RvY29sLlBlbmRpbmdNZXNzYWdlO1xuXHR2YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XG5cdHZhciB0cmFuc3BvcnRQcmVmZXJlbmNlT3JkZXIgPSBEZWZhdWx0cy50cmFuc3BvcnRQcmVmZXJlbmNlT3JkZXI7XG5cdHZhciBvcHRpbWFsVHJhbnNwb3J0ID0gdHJhbnNwb3J0UHJlZmVyZW5jZU9yZGVyW3RyYW5zcG9ydFByZWZlcmVuY2VPcmRlci5sZW5ndGggLSAxXTtcblx0dmFyIHRyYW5zcG9ydFByZWZlcmVuY2VOYW1lID0gJ2FibHktdHJhbnNwb3J0LXByZWZlcmVuY2UnO1xuXG5cdHZhciBzZXNzaW9uUmVjb3ZlcnlOYW1lID0gJ2FibHktY29ubmVjdGlvbi1yZWNvdmVyeSc7XG5cdGZ1bmN0aW9uIGdldFNlc3Npb25SZWNvdmVyRGF0YSgpIHtcblx0XHRyZXR1cm4gaGF2ZVNlc3Npb25TdG9yYWdlICYmIFdlYlN0b3JhZ2UuZ2V0U2Vzc2lvbihzZXNzaW9uUmVjb3ZlcnlOYW1lKTtcblx0fVxuXHRmdW5jdGlvbiBzZXRTZXNzaW9uUmVjb3ZlckRhdGEodmFsdWUpIHtcblx0XHRyZXR1cm4gaGF2ZVNlc3Npb25TdG9yYWdlICYmIFdlYlN0b3JhZ2Uuc2V0U2Vzc2lvbihzZXNzaW9uUmVjb3ZlcnlOYW1lLCB2YWx1ZSk7XG5cdH1cblx0ZnVuY3Rpb24gY2xlYXJTZXNzaW9uUmVjb3ZlckRhdGEoKSB7XG5cdFx0cmV0dXJuIGhhdmVTZXNzaW9uU3RvcmFnZSAmJiBXZWJTdG9yYWdlLnJlbW92ZVNlc3Npb24oc2Vzc2lvblJlY292ZXJ5TmFtZSk7XG5cdH1cblxuXHRmdW5jdGlvbiBiZXR0ZXJUcmFuc3BvcnRUaGFuKGEsIGIpIHtcblx0XHRyZXR1cm4gVXRpbHMuYXJySW5kZXhPZih0cmFuc3BvcnRQcmVmZXJlbmNlT3JkZXIsIGEuc2hvcnROYW1lKSA+XG5cdFx0ICAgVXRpbHMuYXJySW5kZXhPZih0cmFuc3BvcnRQcmVmZXJlbmNlT3JkZXIsIGIuc2hvcnROYW1lKTtcblx0fVxuXG5cdGZ1bmN0aW9uIFRyYW5zcG9ydFBhcmFtcyhvcHRpb25zLCBob3N0LCBtb2RlLCBjb25uZWN0aW9uS2V5LCBjb25uZWN0aW9uU2VyaWFsKSB7XG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0XHR0aGlzLmhvc3QgPSBob3N0O1xuXHRcdHRoaXMubW9kZSA9IG1vZGU7XG5cdFx0dGhpcy5jb25uZWN0aW9uS2V5ID0gY29ubmVjdGlvbktleTtcblx0XHR0aGlzLmNvbm5lY3Rpb25TZXJpYWwgPSBjb25uZWN0aW9uU2VyaWFsO1xuXHRcdHRoaXMuZm9ybWF0ID0gb3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/ICdtc2dwYWNrJyA6ICdqc29uJztcblx0fVxuXG5cdFRyYW5zcG9ydFBhcmFtcy5wcm90b3R5cGUuZ2V0Q29ubmVjdFBhcmFtcyA9IGZ1bmN0aW9uKGF1dGhQYXJhbXMpIHtcblx0XHR2YXIgcGFyYW1zID0gYXV0aFBhcmFtcyA/IFV0aWxzLmNvcHkoYXV0aFBhcmFtcykgOiB7fTtcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblx0XHRzd2l0Y2godGhpcy5tb2RlKSB7XG5cdFx0XHRjYXNlICd1cGdyYWRlJzpcblx0XHRcdFx0cGFyYW1zLnVwZ3JhZGUgPSB0aGlzLmNvbm5lY3Rpb25LZXk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAncmVzdW1lJzpcblx0XHRcdFx0cGFyYW1zLnJlc3VtZSA9IHRoaXMuY29ubmVjdGlvbktleTtcblx0XHRcdFx0aWYodGhpcy5jb25uZWN0aW9uU2VyaWFsICE9PSB1bmRlZmluZWQpXG5cdFx0XHRcdFx0cGFyYW1zLmNvbm5lY3Rpb25fc2VyaWFsID0gdGhpcy5jb25uZWN0aW9uU2VyaWFsO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3JlY292ZXInOlxuXHRcdFx0XHR2YXIgbWF0Y2ggPSBvcHRpb25zLnJlY292ZXIuc3BsaXQoJzonKTtcblx0XHRcdFx0aWYobWF0Y2gpIHtcblx0XHRcdFx0XHRwYXJhbXMucmVjb3ZlciA9IG1hdGNoWzBdO1xuXHRcdFx0XHRcdHBhcmFtcy5jb25uZWN0aW9uX3NlcmlhbCA9IG1hdGNoWzFdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHR9XG5cdFx0aWYob3B0aW9ucy5jbGllbnRJZCAhPT0gdW5kZWZpbmVkKVxuXHRcdFx0cGFyYW1zLmNsaWVudElkID0gb3B0aW9ucy5jbGllbnRJZDtcblx0XHRpZihvcHRpb25zLmVjaG9NZXNzYWdlcyA9PT0gZmFsc2UpXG5cdFx0XHRwYXJhbXMuZWNobyA9ICdmYWxzZSc7XG5cdFx0aWYodGhpcy5mb3JtYXQgIT09IHVuZGVmaW5lZClcblx0XHRcdHBhcmFtcy5mb3JtYXQgPSB0aGlzLmZvcm1hdDtcblx0XHRpZih0aGlzLnN0cmVhbSAhPT0gdW5kZWZpbmVkKVxuXHRcdFx0cGFyYW1zLnN0cmVhbSA9IHRoaXMuc3RyZWFtO1xuXHRcdGlmKHRoaXMuaGVhcnRiZWF0cyAhPT0gdW5kZWZpbmVkKVxuXHRcdFx0cGFyYW1zLmhlYXJ0YmVhdHMgPSB0aGlzLmhlYXJ0YmVhdHM7XG5cdFx0aWYob3B0aW9ucy50cmFuc3BvcnRQYXJhbXMgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0VXRpbHMubWl4aW4ocGFyYW1zLCBvcHRpb25zLnRyYW5zcG9ydFBhcmFtcyk7XG5cdFx0fVxuXHRcdHBhcmFtcy52ID0gRGVmYXVsdHMuYXBpVmVyc2lvbjtcblx0XHRwYXJhbXMubGliID0gRGVmYXVsdHMubGlic3RyaW5nO1xuXHRcdHJldHVybiBwYXJhbXM7XG5cdH07XG5cblx0LyogcHVibGljIGNvbnN0cnVjdG9yICovXG5cdGZ1bmN0aW9uIENvbm5lY3Rpb25NYW5hZ2VyKHJlYWx0aW1lLCBvcHRpb25zKSB7XG5cdFx0RXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cdFx0dGhpcy5yZWFsdGltZSA9IHJlYWx0aW1lO1xuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0dmFyIHRpbWVvdXRzID0gb3B0aW9ucy50aW1lb3V0cztcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0LyogY29ubmVjdGluZ1RpbWVvdXQ6IGxlYXZlIHByZWZlcmVuY2VDb25uZWN0VGltZW91dCAofjZzKSB0byB0cnkgdGhlXG5cdFx0ICogcHJlZmVyZW5jZSB0cmFuc3BvcnQsIHRoZW4gcmVhbHRpbWVSZXF1ZXN0VGltZW91dCAofjEwcykgdG8gZXN0YWJsaXNoXG5cdFx0ICogdGhlIGJhc2UgdHJhbnNwb3J0IGluIGNhc2UgdGhhdCBmYWlscyAqL1xuXHRcdHZhciBjb25uZWN0aW5nVGltZW91dCA9IHRpbWVvdXRzLnByZWZlcmVuY2VDb25uZWN0VGltZW91dCArIHRpbWVvdXRzLnJlYWx0aW1lUmVxdWVzdFRpbWVvdXQ7XG5cdFx0dGhpcy5zdGF0ZXMgPSB7XG5cdFx0XHRpbml0aWFsaXplZDogICB7c3RhdGU6ICdpbml0aWFsaXplZCcsICAgdGVybWluYWw6IGZhbHNlLCBxdWV1ZUV2ZW50czogdHJ1ZSwgIHNlbmRFdmVudHM6IGZhbHNlLCBmYWlsU3RhdGU6ICdkaXNjb25uZWN0ZWQnfSxcblx0XHRcdGNvbm5lY3Rpbmc6ICAgIHtzdGF0ZTogJ2Nvbm5lY3RpbmcnLCAgICB0ZXJtaW5hbDogZmFsc2UsIHF1ZXVlRXZlbnRzOiB0cnVlLCAgc2VuZEV2ZW50czogZmFsc2UsIHJldHJ5RGVsYXk6IGNvbm5lY3RpbmdUaW1lb3V0LCBmYWlsU3RhdGU6ICdkaXNjb25uZWN0ZWQnfSxcblx0XHRcdGNvbm5lY3RlZDogICAgIHtzdGF0ZTogJ2Nvbm5lY3RlZCcsICAgICB0ZXJtaW5hbDogZmFsc2UsIHF1ZXVlRXZlbnRzOiBmYWxzZSwgc2VuZEV2ZW50czogdHJ1ZSwgIGZhaWxTdGF0ZTogJ2Rpc2Nvbm5lY3RlZCd9LFxuXHRcdFx0c3luY2hyb25pemluZzoge3N0YXRlOiAnY29ubmVjdGVkJywgICAgIHRlcm1pbmFsOiBmYWxzZSwgcXVldWVFdmVudHM6IHRydWUsICBzZW5kRXZlbnRzOiBmYWxzZSwgZm9yY2VRdWV1ZUV2ZW50czogdHJ1ZSwgZmFpbFN0YXRlOiAnZGlzY29ubmVjdGVkJ30sXG5cdFx0XHRkaXNjb25uZWN0ZWQ6ICB7c3RhdGU6ICdkaXNjb25uZWN0ZWQnLCAgdGVybWluYWw6IGZhbHNlLCBxdWV1ZUV2ZW50czogdHJ1ZSwgIHNlbmRFdmVudHM6IGZhbHNlLCByZXRyeURlbGF5OiB0aW1lb3V0cy5kaXNjb25uZWN0ZWRSZXRyeVRpbWVvdXQsIGZhaWxTdGF0ZTogJ2Rpc2Nvbm5lY3RlZCd9LFxuXHRcdFx0c3VzcGVuZGVkOiAgICAge3N0YXRlOiAnc3VzcGVuZGVkJywgICAgIHRlcm1pbmFsOiBmYWxzZSwgcXVldWVFdmVudHM6IGZhbHNlLCBzZW5kRXZlbnRzOiBmYWxzZSwgcmV0cnlEZWxheTogdGltZW91dHMuc3VzcGVuZGVkUmV0cnlUaW1lb3V0LCBmYWlsU3RhdGU6ICdzdXNwZW5kZWQnfSxcblx0XHRcdGNsb3Npbmc6ICAgICAgIHtzdGF0ZTogJ2Nsb3NpbmcnLCAgICAgICB0ZXJtaW5hbDogZmFsc2UsIHF1ZXVlRXZlbnRzOiBmYWxzZSwgc2VuZEV2ZW50czogZmFsc2UsIHJldHJ5RGVsYXk6IHRpbWVvdXRzLnJlYWx0aW1lUmVxdWVzdFRpbWVvdXQsIGZhaWxTdGF0ZTogJ2Nsb3NlZCd9LFxuXHRcdFx0Y2xvc2VkOiAgICAgICAge3N0YXRlOiAnY2xvc2VkJywgICAgICAgIHRlcm1pbmFsOiB0cnVlLCAgcXVldWVFdmVudHM6IGZhbHNlLCBzZW5kRXZlbnRzOiBmYWxzZSwgZmFpbFN0YXRlOiAnY2xvc2VkJ30sXG5cdFx0XHRmYWlsZWQ6ICAgICAgICB7c3RhdGU6ICdmYWlsZWQnLCAgICAgICAgdGVybWluYWw6IHRydWUsICBxdWV1ZUV2ZW50czogZmFsc2UsIHNlbmRFdmVudHM6IGZhbHNlLCBmYWlsU3RhdGU6ICdmYWlsZWQnfVxuXHRcdH07XG5cdFx0dGhpcy5zdGF0ZSA9IHRoaXMuc3RhdGVzLmluaXRpYWxpemVkO1xuXHRcdHRoaXMuZXJyb3JSZWFzb24gPSBudWxsO1xuXG5cdFx0dGhpcy5xdWV1ZWRNZXNzYWdlcyA9IG5ldyBNZXNzYWdlUXVldWUoKTtcblx0XHR0aGlzLm1zZ1NlcmlhbCA9IDA7XG5cdFx0dGhpcy5jb25uZWN0aW9uSWQgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5jb25uZWN0aW9uS2V5ID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuY29ubmVjdGlvblNlcmlhbCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLmNvbm5lY3Rpb25TdGF0ZVR0bCA9IHRpbWVvdXRzLmNvbm5lY3Rpb25TdGF0ZVR0bDtcblx0XHR0aGlzLm1heElkbGVJbnRlcnZhbCA9IG51bGw7XG5cblx0XHR0aGlzLnRyYW5zcG9ydHMgPSBVdGlscy5pbnRlcnNlY3QoKG9wdGlvbnMudHJhbnNwb3J0cyB8fCBEZWZhdWx0cy5kZWZhdWx0VHJhbnNwb3J0cyksIENvbm5lY3Rpb25NYW5hZ2VyLnN1cHBvcnRlZFRyYW5zcG9ydHMpO1xuXHRcdC8qIGJhc2VUcmFuc3BvcnRzIHNlbGVjdHMgdGhlIGxlZnRtb3N0IHRyYW5zcG9ydCBpbiB0aGUgRGVmYXVsdHMuYmFzZVRyYW5zcG9ydE9yZGVyIGxpc3Rcblx0XHQqIHRoYXQncyBib3RoIHJlcXVlc3RlZCBhbmQgc3VwcG9ydGVkLiBOb3JtYWxseSB0aGlzIHdpbGwgYmUgeGhyX3BvbGxpbmc7XG5cdFx0KiBpZiB4aHIgaXNuJ3Qgc3VwcG9ydGVkIGl0IHdpbGwgYmUganNvbnAuIElmIHRoZSB1c2VyIGhhcyBmb3JjZWQgYVxuXHRcdCogdHJhbnNwb3J0LCBpdCdsbCBqdXN0IGJlIHRoYXQgb25lLiAqL1xuXHRcdHRoaXMuYmFzZVRyYW5zcG9ydCA9IFV0aWxzLmludGVyc2VjdChEZWZhdWx0cy5iYXNlVHJhbnNwb3J0T3JkZXIsIHRoaXMudHJhbnNwb3J0cylbMF07XG5cdFx0dGhpcy51cGdyYWRlVHJhbnNwb3J0cyA9IFV0aWxzLmludGVyc2VjdCh0aGlzLnRyYW5zcG9ydHMsIERlZmF1bHRzLnVwZ3JhZGVUcmFuc3BvcnRzKTtcblx0XHQvKiBNYXAgb2YgaG9zdHMgdG8gYW4gYXJyYXkgb2YgdHJhbnNwb3J0cyB0byBub3QgYmUgdHJpZWQgZm9yIHRoYXQgaG9zdCAqL1xuXHRcdHRoaXMudHJhbnNwb3J0SG9zdEJsYWNrbGlzdCA9IHt9O1xuXHRcdHRoaXMudHJhbnNwb3J0UHJlZmVyZW5jZSA9IG51bGw7XG5cblx0XHR0aGlzLmh0dHBIb3N0cyA9IERlZmF1bHRzLmdldEhvc3RzKG9wdGlvbnMpO1xuXHRcdHRoaXMuYWN0aXZlUHJvdG9jb2wgPSBudWxsO1xuXHRcdHRoaXMucHJvcG9zZWRUcmFuc3BvcnRzID0gW107XG5cdFx0dGhpcy5wZW5kaW5nVHJhbnNwb3J0cyA9IFtdO1xuXHRcdHRoaXMuaG9zdCA9IG51bGw7XG5cdFx0dGhpcy5sYXN0QXV0b1JlY29ubmVjdEF0dGVtcHQgPSBudWxsO1xuXHRcdHRoaXMubGFzdEFjdGl2aXR5ID0gbnVsbDtcblxuXHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSU5PUiwgJ1JlYWx0aW1lLkNvbm5lY3Rpb25NYW5hZ2VyKCknLCAnc3RhcnRlZCcpO1xuXHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSUNSTywgJ1JlYWx0aW1lLkNvbm5lY3Rpb25NYW5hZ2VyKCknLCAncmVxdWVzdGVkIHRyYW5zcG9ydHMgPSBbJyArIChvcHRpb25zLnRyYW5zcG9ydHMgfHwgRGVmYXVsdHMuZGVmYXVsdFRyYW5zcG9ydHMpICsgJ10nKTtcblx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlDUk8sICdSZWFsdGltZS5Db25uZWN0aW9uTWFuYWdlcigpJywgJ2F2YWlsYWJsZSB0cmFuc3BvcnRzID0gWycgKyB0aGlzLnRyYW5zcG9ydHMgKyAnXScpO1xuXHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSUNSTywgJ1JlYWx0aW1lLkNvbm5lY3Rpb25NYW5hZ2VyKCknLCAnaHR0cCBob3N0cyA9IFsnICsgdGhpcy5odHRwSG9zdHMgKyAnXScpO1xuXG5cdFx0aWYoIXRoaXMudHJhbnNwb3J0cy5sZW5ndGgpIHtcblx0XHRcdHZhciBtc2cgPSAnbm8gcmVxdWVzdGVkIHRyYW5zcG9ydHMgYXZhaWxhYmxlJztcblx0XHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19FUlJPUiwgJ3JlYWx0aW1lLkNvbm5lY3Rpb25NYW5hZ2VyKCknLCBtc2cpO1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKG1zZyk7XG5cdFx0fVxuXG5cdFx0dmFyIGFkZEV2ZW50TGlzdGVuZXIgPSBQbGF0Zm9ybS5hZGRFdmVudExpc3RlbmVyO1xuXHRcdGlmKGFkZEV2ZW50TGlzdGVuZXIpIHtcblx0XHRcdC8qIGludGVyY2VwdCBjbG9zZSBldmVudCBpbiBicm93c2VyIHRvIHBlcnNpc3QgY29ubmVjdGlvbiBpZCBpZiByZXF1ZXN0ZWQgKi9cblx0XHRcdGlmKGhhdmVTZXNzaW9uU3RvcmFnZSAmJiB0eXBlb2Ygb3B0aW9ucy5yZWNvdmVyID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdC8qIFVzdWFsbHkgY2FuJ3QgdXNlIGJpbmQgYXMgbm90IHN1cHBvcnRlZCBpbiBJRTgsIGJ1dCBJRSBkb2Vzbid0IHN1cHBvcnQgc2Vzc2lvblN0b3JhZ2UsIHNvLi4uICovXG5cdFx0XHRcdGFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIHRoaXMucGVyc2lzdENvbm5lY3Rpb24uYmluZCh0aGlzKSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmKG9wdGlvbnMuY2xvc2VPblVubG9hZCA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRhZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCBmdW5jdGlvbigpIHsgc2VsZi5yZXF1ZXN0U3RhdGUoe3N0YXRlOiAnY2xvc2luZyd9KTsgfSk7XG5cdFx0XHR9XG5cblx0XHRcdC8qIExpc3RlbiBmb3Igb25saW5lIGFuZCBvZmZsaW5lIGV2ZW50cyAqL1xuXHRcdFx0YWRkRXZlbnRMaXN0ZW5lcignb25saW5lJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmKHNlbGYuc3RhdGUgPT0gc2VsZi5zdGF0ZXMuZGlzY29ubmVjdGVkIHx8IHNlbGYuc3RhdGUgPT0gc2VsZi5zdGF0ZXMuc3VzcGVuZGVkKSB7XG5cdFx0XHRcdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIgY2F1Z2h0IGJyb3dzZXIg4oCYb25saW5l4oCZIGV2ZW50JywgJ3JlYXR0ZW1wdGluZyBjb25uZWN0aW9uJyk7XG5cdFx0XHRcdFx0c2VsZi5yZXF1ZXN0U3RhdGUoe3N0YXRlOiAnY29ubmVjdGluZyd9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRhZGRFdmVudExpc3RlbmVyKCdvZmZsaW5lJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmKHNlbGYuc3RhdGUgPT0gc2VsZi5zdGF0ZXMuY29ubmVjdGVkKSB7XG5cdFx0XHRcdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIgY2F1Z2h0IGJyb3dzZXIg4oCYb2ZmbGluZeKAmSBldmVudCcsICdkaXNjb25uZWN0aW5nIGFjdGl2ZSB0cmFuc3BvcnQnKTtcblx0XHRcdFx0XHQvLyBOb3Qgc3VmZmljaWVudCB0byBqdXN0IGdvIHRvIHRoZSAnZGlzY29ubmVjdGVkJyBzdGF0ZSwgd2FudCB0b1xuXHRcdFx0XHRcdC8vIGZvcmNlIGFsbCB0cmFuc3BvcnRzIHRvIHJlYXR0ZW1wdCB0aGUgY29ubmVjdGlvbi4gV2lsbCBpbW1lZGlhdGVseVxuXHRcdFx0XHRcdC8vIHJldHJ5LlxuXHRcdFx0XHRcdHNlbGYuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cdFV0aWxzLmluaGVyaXRzKENvbm5lY3Rpb25NYW5hZ2VyLCBFdmVudEVtaXR0ZXIpO1xuXG5cdC8qKioqKioqKioqKioqKioqKioqKipcblx0ICogdHJhbnNwb3J0IG1hbmFnZW1lbnRcblx0ICoqKioqKioqKioqKioqKioqKioqKi9cblxuXHRDb25uZWN0aW9uTWFuYWdlci5zdXBwb3J0ZWRUcmFuc3BvcnRzID0ge307XG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmdldFRyYW5zcG9ydFBhcmFtcyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXG5cdFx0ZnVuY3Rpb24gZGVjaWRlTW9kZShtb2RlQ2IpIHtcblx0XHRcdGlmKHNlbGYuY29ubmVjdGlvbktleSkge1xuXHRcdFx0XHRtb2RlQ2IoJ3Jlc3VtZScpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmKHR5cGVvZiBzZWxmLm9wdGlvbnMucmVjb3ZlciA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0bW9kZUNiKCdyZWNvdmVyJyk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHJlY292ZXJGbiA9IHNlbGYub3B0aW9ucy5yZWNvdmVyLFxuXHRcdFx0XHRsYXN0U2Vzc2lvbkRhdGEgPSBnZXRTZXNzaW9uUmVjb3ZlckRhdGEoKTtcblx0XHRcdGlmKGxhc3RTZXNzaW9uRGF0YSAmJiB0eXBlb2YocmVjb3ZlckZuKSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5nZXRUcmFuc3BvcnRQYXJhbXMoKScsICdDYWxsaW5nIGNsaWVudE9wdGlvbnMtcHJvdmlkZWQgcmVjb3ZlciBmdW5jdGlvbiB3aXRoIGxhc3Qgc2Vzc2lvbiBkYXRhJyk7XG5cdFx0XHRcdHJlY292ZXJGbihsYXN0U2Vzc2lvbkRhdGEsIGZ1bmN0aW9uKHNob3VsZFJlY292ZXIpIHtcblx0XHRcdFx0XHRpZihzaG91bGRSZWNvdmVyKSB7XG5cdFx0XHRcdFx0XHRzZWxmLm9wdGlvbnMucmVjb3ZlciA9IGxhc3RTZXNzaW9uRGF0YS5yZWNvdmVyeUtleTtcblx0XHRcdFx0XHRcdG1vZGVDYigncmVjb3ZlcicpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRtb2RlQ2IoJ2NsZWFuJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0bW9kZUNiKCdjbGVhbicpO1xuXHRcdH1cblxuXHRcdGRlY2lkZU1vZGUoZnVuY3Rpb24obW9kZSkge1xuXHRcdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuZ2V0VHJhbnNwb3J0UGFyYW1zKCknLCAnVHJhbnNwb3J0IHJlY292ZXJ5IG1vZGUgPSAnICsgbW9kZSArIChtb2RlID09ICdjbGVhbicgPyAnJyA6ICc7IGNvbm5lY3Rpb25LZXkgPSAnICsgc2VsZi5jb25uZWN0aW9uS2V5ICsgJzsgY29ubmVjdGlvblNlcmlhbCA9ICcgKyBzZWxmLmNvbm5lY3Rpb25TZXJpYWwpKTtcblx0XHRcdGNhbGxiYWNrKG5ldyBUcmFuc3BvcnRQYXJhbXMoc2VsZi5vcHRpb25zLCBudWxsLCBtb2RlLCBzZWxmLmNvbm5lY3Rpb25LZXksIHNlbGYuY29ubmVjdGlvblNlcmlhbCkpO1xuXHRcdH0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBdHRlbXB0IHRvIGNvbm5lY3QgdXNpbmcgYSBnaXZlbiB0cmFuc3BvcnRcblx0ICogQHBhcmFtIHRyYW5zcG9ydFBhcmFtc1xuXHQgKiBAcGFyYW0gY2FuZGlkYXRlLCB0aGUgdHJhbnNwb3J0IHRvIHRyeVxuXHQgKiBAcGFyYW0gY2FsbGJhY2tcblx0ICovXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS50cnlBVHJhbnNwb3J0ID0gZnVuY3Rpb24odHJhbnNwb3J0UGFyYW1zLCBjYW5kaWRhdGUsIGNhbGxiYWNrKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzLCBob3N0ID0gdHJhbnNwb3J0UGFyYW1zLmhvc3Q7XG5cdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIudHJ5QVRyYW5zcG9ydCgpJywgJ3RyeWluZyAnICsgY2FuZGlkYXRlKTtcblx0XHRpZigoaG9zdCBpbiB0aGlzLnRyYW5zcG9ydEhvc3RCbGFja2xpc3QpICYmIFV0aWxzLmFyckluKHRoaXMudHJhbnNwb3J0SG9zdEJsYWNrbGlzdFtob3N0XSwgY2FuZGlkYXRlKSkge1xuXHRcdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIudHJ5QVRyYW5zcG9ydCgpJywgY2FuZGlkYXRlICsgJyB0cmFuc3BvcnQgaXMgYmxhY2tsaXN0ZWQgZm9yIGhvc3QgJyArIHRyYW5zcG9ydFBhcmFtcy5ob3N0KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0KENvbm5lY3Rpb25NYW5hZ2VyLnN1cHBvcnRlZFRyYW5zcG9ydHNbY2FuZGlkYXRlXSkudHJ5Q29ubmVjdCh0aGlzLCB0aGlzLnJlYWx0aW1lLmF1dGgsIHRyYW5zcG9ydFBhcmFtcywgZnVuY3Rpb24od3JhcHBlZEVyciwgdHJhbnNwb3J0KSB7XG5cdFx0XHR2YXIgc3RhdGUgPSBzZWxmLnN0YXRlO1xuXHRcdFx0aWYoc3RhdGUgPT0gc2VsZi5zdGF0ZXMuY2xvc2luZyB8fCBzdGF0ZSA9PSBzZWxmLnN0YXRlcy5jbG9zZWQgfHwgc3RhdGUgPT0gc2VsZi5zdGF0ZXMuZmFpbGVkKSB7XG5cdFx0XHRcdGlmKHRyYW5zcG9ydCkge1xuXHRcdFx0XHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnRyeUFUcmFuc3BvcnQoKScsICdjb25uZWN0aW9uICcgKyBzdGF0ZS5zdGF0ZSArICcgd2hpbGUgd2Ugd2VyZSBhdHRlbXB0aW5nIHRoZSB0cmFuc3BvcnQ7IGNsb3NpbmcgJyArIHRyYW5zcG9ydCk7XG5cdFx0XHRcdFx0dHJhbnNwb3J0LmNsb3NlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FsbGJhY2sodHJ1ZSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYod3JhcHBlZEVycikge1xuXHRcdFx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci50cnlBVHJhbnNwb3J0KCknLCAndHJhbnNwb3J0ICcgKyBjYW5kaWRhdGUgKyAnICcgKyB3cmFwcGVkRXJyLmV2ZW50ICsgJywgZXJyOiAnICsgd3JhcHBlZEVyci5lcnJvci50b1N0cmluZygpKTtcblxuXHRcdFx0XHQvKiBDb21ldCB0cmFuc3BvcnQgb25jb25uZWN0IHRva2VuIGVycm9ycyBjYW4gYmUgZGVhbHQgd2l0aCBoZXJlLlxuXHRcdFx0XHQqIFdlYnNvY2tldCBvbmVzIG9ubHkgaGFwcGVuIGFmdGVyIHRoZSB0cmFuc3BvcnQgY2xhaW1zIHRvIGJlIHZpYWJsZSxcblx0XHRcdFx0KiBzbyBhcmUgZGVhbHQgd2l0aCBhcyBub24tb25jb25uZWN0IHRva2VuIGVycm9ycyAqL1xuXHRcdFx0XHRpZihBdXRoLmlzVG9rZW5FcnIod3JhcHBlZEVyci5lcnJvcikpIHtcblx0XHRcdFx0XHQvKiByZS1nZXQgYSB0b2tlbiBhbmQgdHJ5IGFnYWluICovXG5cdFx0XHRcdFx0c2VsZi5yZWFsdGltZS5hdXRoLl9mb3JjZU5ld1Rva2VuKG51bGwsIG51bGwsIGZ1bmN0aW9uKGVycikge1xuXHRcdFx0XHRcdFx0aWYoZXJyKSB7XG5cdFx0XHRcdFx0XHRcdHNlbGYuYWN0T25FcnJvckZyb21BdXRob3JpemUoZXJyKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0c2VsZi50cnlBVHJhbnNwb3J0KHRyYW5zcG9ydFBhcmFtcywgY2FuZGlkYXRlLCBjYWxsYmFjayk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0gZWxzZSBpZih3cmFwcGVkRXJyLmV2ZW50ID09PSAnZmFpbGVkJykge1xuXHRcdFx0XHRcdC8qIEVycm9yIHRoYXQncyBmYXRhbCB0byB0aGUgY29ubmVjdGlvbiAqL1xuXHRcdFx0XHRcdHNlbGYubm90aWZ5U3RhdGUoe3N0YXRlOiAnZmFpbGVkJywgZXJyb3I6IHdyYXBwZWRFcnIuZXJyb3J9KTtcblx0XHRcdFx0XHRjYWxsYmFjayh0cnVlKTtcblx0XHRcdFx0fSBlbHNlIGlmKHdyYXBwZWRFcnIuZXZlbnQgPT09ICdkaXNjb25uZWN0ZWQnKSB7XG5cdFx0XHRcdFx0LyogRXJyb3Igd2l0aCB0aGF0IHRyYW5zcG9ydCBvbmx5ICovXG5cdFx0XHRcdFx0Y2FsbGJhY2soZmFsc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuY2hvb3NlVHJhbnNwb3J0Rm9ySG9zdCgpJywgJ3ZpYWJsZSB0cmFuc3BvcnQgJyArIGNhbmRpZGF0ZSArICc7IHNldHRpbmcgcGVuZGluZycpO1xuXHRcdFx0c2VsZi5zZXRUcmFuc3BvcnRQZW5kaW5nKHRyYW5zcG9ydCwgdHJhbnNwb3J0UGFyYW1zKTtcblx0XHRcdGNhbGxiYWNrKG51bGwsIHRyYW5zcG9ydCk7XG5cdFx0fSk7XG5cdH07XG5cblxuXHQvKipcblx0ICogQ2FsbGVkIHdoZW4gYSB0cmFuc3BvcnQgaXMgaW5kaWNhdGVkIHRvIGJlIHZpYWJsZSwgYW5kIHRoZSBjb25uZWN0aW9ubWFuYWdlclxuXHQgKiBleHBlY3RzIHRvIGFjdGl2YXRlIHRoaXMgdHJhbnNwb3J0IGFzIHNvb24gYXMgaXQgaXMgY29ubmVjdGVkLlxuXHQgKiBAcGFyYW0gaG9zdFxuXHQgKiBAcGFyYW0gdHJhbnNwb3J0UGFyYW1zXG5cdCAqL1xuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuc2V0VHJhbnNwb3J0UGVuZGluZyA9IGZ1bmN0aW9uKHRyYW5zcG9ydCwgdHJhbnNwb3J0UGFyYW1zKSB7XG5cdFx0dmFyIG1vZGUgPSB0cmFuc3BvcnRQYXJhbXMubW9kZTtcblx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5zZXRUcmFuc3BvcnRQZW5kaW5nKCknLCAndHJhbnNwb3J0ID0gJyArIHRyYW5zcG9ydCArICc7IG1vZGUgPSAnICsgbW9kZSk7XG5cblx0XHRVdGlscy5hcnJEZWxldGVWYWx1ZSh0aGlzLnByb3Bvc2VkVHJhbnNwb3J0cywgdHJhbnNwb3J0KTtcblx0XHR0aGlzLnBlbmRpbmdUcmFuc3BvcnRzLnB1c2godHJhbnNwb3J0KTtcblxuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHR0cmFuc3BvcnQub25jZSgnY29ubmVjdGVkJywgZnVuY3Rpb24oZXJyb3IsIGNvbm5lY3Rpb25LZXksIGNvbm5lY3Rpb25TZXJpYWwsIGNvbm5lY3Rpb25JZCwgY29ubmVjdGlvbkRldGFpbHMpIHtcblx0XHRcdGlmKG1vZGUgPT0gJ3VwZ3JhZGUnICYmIHNlbGYuYWN0aXZlUHJvdG9jb2wpIHtcblx0XHRcdFx0LyogIGlmIHdzIGFuZCB4aHJzIGFyZSBjb25uZWN0aW5nIGluIHBhcmFsbGVsLCBkZWxheSB4aHJzIGFjdGl2YXRpb24gdG8gbGV0IHdzIGdvIGFoZWFkICovXG5cdFx0XHRcdGlmKHRyYW5zcG9ydC5zaG9ydE5hbWUgIT09IG9wdGltYWxUcmFuc3BvcnQgJiYgVXRpbHMuYXJySW4oc2VsZi5nZXRVcGdyYWRlUG9zc2liaWxpdGllcygpLCBvcHRpbWFsVHJhbnNwb3J0KSkge1xuXHRcdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRzZWxmLnNjaGVkdWxlVHJhbnNwb3J0QWN0aXZhdGlvbihlcnJvciwgdHJhbnNwb3J0LCBjb25uZWN0aW9uS2V5LCBjb25uZWN0aW9uU2VyaWFsLCBjb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzKTtcblx0XHRcdFx0XHR9LCBzZWxmLm9wdGlvbnMudGltZW91dHMucGFyYWxsZWxVcGdyYWRlRGVsYXkpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHNlbGYuc2NoZWR1bGVUcmFuc3BvcnRBY3RpdmF0aW9uKGVycm9yLCB0cmFuc3BvcnQsIGNvbm5lY3Rpb25LZXksIGNvbm5lY3Rpb25TZXJpYWwsIGNvbm5lY3Rpb25JZCwgY29ubmVjdGlvbkRldGFpbHMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZWxmLmFjdGl2YXRlVHJhbnNwb3J0KGVycm9yLCB0cmFuc3BvcnQsIGNvbm5lY3Rpb25LZXksIGNvbm5lY3Rpb25TZXJpYWwsIGNvbm5lY3Rpb25JZCwgY29ubmVjdGlvbkRldGFpbHMpO1xuXG5cdFx0XHRcdC8qIGFsbG93IGNvbm5lY3RJbXBsIHRvIHN0YXJ0IHRoZSB1cGdyYWRlIHByb2Nlc3MgaWYgbmVlZGVkLCBidXQgYWxsb3dcblx0XHRcdFx0ICogb3RoZXIgZXZlbnQgaGFuZGxlcnMsIGluY2x1ZGluZyBhY3RpdmF0aW5nIHRoZSB0cmFuc3BvcnQsIHRvIHJ1biBmaXJzdCAqL1xuXHRcdFx0XHRVdGlscy5uZXh0VGljayhmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRzZWxmLmNvbm5lY3RJbXBsKHRyYW5zcG9ydFBhcmFtcyk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRpZihtb2RlID09PSAncmVjb3ZlcicgJiYgc2VsZi5vcHRpb25zLnJlY292ZXIpIHtcblx0XHRcdFx0LyogQWZ0ZXIgYSBzdWNjZXNzZnVsIHJlY292ZXJ5LCB3ZSB1bnBlcnNpc3QsIGFzIGEgcmVjb3Zlcnkga2V5IGNhbm5vdFxuXHRcdFx0XHQqIGJlIHVzZWQgbW9yZSB0aGFuIG9uY2UgKi9cblx0XHRcdFx0c2VsZi5vcHRpb25zLnJlY292ZXIgPSBudWxsO1xuXHRcdFx0XHRzZWxmLnVucGVyc2lzdENvbm5lY3Rpb24oKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHRyYW5zcG9ydC5vbihbJ2Rpc2Nvbm5lY3RlZCcsICdjbG9zZWQnLCAnZmFpbGVkJ10sIGZ1bmN0aW9uKGVycm9yKSB7XG5cdFx0XHRzZWxmLmRlYWN0aXZhdGVUcmFuc3BvcnQodHJhbnNwb3J0LCB0aGlzLmV2ZW50LCBlcnJvcik7XG5cdFx0fSk7XG5cblx0XHR0aGlzLmVtaXQoJ3RyYW5zcG9ydC5wZW5kaW5nJywgdHJhbnNwb3J0KTtcblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIHdoZW4gYW4gdXBncmFkZSB0cmFuc3BvcnQgaXMgY29ubmVjdGVkLFxuXHQgKiB0byBzY2hlZHVsZSB0aGUgYWN0aXZhdGlvbiBvZiB0aGF0IHRyYW5zcG9ydC5cblx0ICogQHBhcmFtIHRyYW5zcG9ydCwgdGhlIHRyYW5zcG9ydCBpbnN0YW5jZVxuXHQgKiBAcGFyYW0gY29ubmVjdGlvbktleVxuXHQgKi9cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnNjaGVkdWxlVHJhbnNwb3J0QWN0aXZhdGlvbiA9IGZ1bmN0aW9uKGVycm9yLCB0cmFuc3BvcnQsIGNvbm5lY3Rpb25LZXksIGNvbm5lY3Rpb25TZXJpYWwsIGNvbm5lY3Rpb25JZCwgY29ubmVjdGlvbkRldGFpbHMpIHtcblx0XHR2YXIgc2VsZiA9IHRoaXMsXG5cdFx0XHRjdXJyZW50VHJhbnNwb3J0ID0gdGhpcy5hY3RpdmVQcm90b2NvbCAmJiB0aGlzLmFjdGl2ZVByb3RvY29sLmdldFRyYW5zcG9ydCgpLFxuXHRcdFx0YWJhbmRvbiA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0cmFuc3BvcnQuZGlzY29ubmVjdCgpO1xuXHRcdFx0XHRVdGlscy5hcnJEZWxldGVWYWx1ZShzZWxmLnBlbmRpbmdUcmFuc3BvcnRzLCB0cmFuc3BvcnQpO1xuXHRcdFx0fTtcblxuXHRcdGlmKHRoaXMuc3RhdGUgIT09IHRoaXMuc3RhdGVzLmNvbm5lY3RlZCAmJiB0aGlzLnN0YXRlICE9PSB0aGlzLnN0YXRlcy5jb25uZWN0aW5nKSB7XG5cdFx0XHQvKiBUaGlzIGlzIG1vc3QgbGlrZWx5IHRvIGhhcHBlbiBmb3IgdGhlIGRlbGF5ZWQgeGhycywgd2hlbiB4aHJzIGFuZCB3cyBhcmUgc2NoZWR1bGVkIGluIHBhcmFsbGVsKi9cblx0XHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNjaGVkdWxlVHJhbnNwb3J0QWN0aXZhdGlvbigpJywgJ0N1cnJlbnQgY29ubmVjdGlvbiBzdGF0ZSAoJyArIHRoaXMuc3RhdGUuc3RhdGUgKyAodGhpcy5zdGF0ZSA9PT0gdGhpcy5zdGF0ZXMuc3luY2hyb25pemluZyA/ICcsIGJ1dCB3aXRoIGFuIHVwZ3JhZGUgYWxyZWFkeSBpbiBwcm9ncmVzcycgOiAnJykgKyAnKSBpcyBub3QgdmFsaWQgdG8gdXBncmFkZSBpbjsgYWJhbmRvbmluZyB1cGdyYWRlIHRvICcgKyB0cmFuc3BvcnQuc2hvcnROYW1lKTtcblx0XHRcdGFiYW5kb24oKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZihjdXJyZW50VHJhbnNwb3J0ICYmICFiZXR0ZXJUcmFuc3BvcnRUaGFuKHRyYW5zcG9ydCwgY3VycmVudFRyYW5zcG9ydCkpIHtcblx0XHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNjaGVkdWxlVHJhbnNwb3J0QWN0aXZhdGlvbigpJywgJ1Byb3Bvc2VkIHRyYW5zcG9ydCAnICsgdHJhbnNwb3J0LnNob3J0TmFtZSArICcgaXMgbm8gYmV0dGVyIHRoYW4gY3VycmVudCBhY3RpdmUgdHJhbnNwb3J0ICcgKyBjdXJyZW50VHJhbnNwb3J0LnNob3J0TmFtZSArICcgLSBhYmFuZG9uaW5nIHVwZ3JhZGUnKTtcblx0XHRcdGFiYW5kb24oKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5zY2hlZHVsZVRyYW5zcG9ydEFjdGl2YXRpb24oKScsICdTY2hlZHVsaW5nIHRyYW5zcG9ydCB1cGdyYWRlOyB0cmFuc3BvcnQgPSAnICsgdHJhbnNwb3J0KTtcblxuXHRcdHRoaXMucmVhbHRpbWUuY2hhbm5lbHMub25jZU5vcGVuZGluZyhmdW5jdGlvbihlcnIpIHtcblx0XHRcdHZhciBvbGRQcm90b2NvbDtcblx0XHRcdGlmKGVycikge1xuXHRcdFx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfRVJST1IsICdDb25uZWN0aW9uTWFuYWdlci5zY2hlZHVsZVRyYW5zcG9ydEFjdGl2YXRpb24oKScsICdVbmFibGUgdG8gYWN0aXZhdGUgdHJhbnNwb3J0OyB0cmFuc3BvcnQgPSAnICsgdHJhbnNwb3J0ICsgJzsgZXJyID0gJyArIGVycik7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYoIXRyYW5zcG9ydC5pc0Nvbm5lY3RlZCkge1xuXHRcdFx0XHQvKiBUaGlzIGlzIG9ubHkgcG9zc2libGUgaWYgdGhlIHhociBzdHJlYW1pbmcgdHJhbnNwb3J0IHdhcyBkaXNjb25uZWN0ZWQgZHVyaW5nIHRoZSBwYXJhbGxlbFVwZ3JhZGVEZWxheSAqL1xuXHRcdFx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5zY2hlZHVsZVRyYW5zcG9ydEFjdGl2YXRpb24oKScsICdQcm9wb3NlZCB0cmFuc3BvcnQgJyArIHRyYW5zcG9ydC5zaG9ydE5hbWUgKyAnaXMgbm8gbG9uZ2VyIGNvbm5lY3RlZDsgYWJhbmRvbmluZyB1cGdyYWRlJyk7XG5cdFx0XHRcdGFiYW5kb24oKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZihzZWxmLnN0YXRlID09PSBzZWxmLnN0YXRlcy5jb25uZWN0ZWQpIHtcblx0XHRcdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2NoZWR1bGVUcmFuc3BvcnRBY3RpdmF0aW9uKCknLCAnQ3VycmVudGx5IGNvbm5lY3RlZCwgc28gdGVtcG9yYXJpbHkgcGF1c2luZyBldmVudHMgdW50aWwgdGhlIHVwZ3JhZGUgaXMgY29tcGxldGUnKTtcblx0XHRcdFx0c2VsZi5zdGF0ZSA9IHNlbGYuc3RhdGVzLnN5bmNocm9uaXppbmc7XG5cdFx0XHRcdG9sZFByb3RvY29sID0gc2VsZi5hY3RpdmVQcm90b2NvbDtcblx0XHRcdH0gZWxzZSBpZihzZWxmLnN0YXRlICE9PSBzZWxmLnN0YXRlcy5jb25uZWN0aW5nKSB7XG5cdFx0XHRcdC8qIE5vdGU6IHVwZ3JhZGluZyBmcm9tIHRoZSBjb25uZWN0aW5nIHN0YXRlIGlzIHZhbGlkIGlmIHRoZSBvbGQgYWN0aXZlXG5cdFx0XHRcdCogdHJhbnNwb3J0IHdhcyBkZWFjdGl2YXRlZCBhZnRlciB0aGUgdXBncmFkZSB0cmFuc3BvcnQgZmlyc3QgY29ubmVjdGVkO1xuXHRcdFx0XHQqIHNlZSBsb2dpYyBpbiBkZWFjdGl2YXRlVHJhbnNwb3J0ICovXG5cdFx0XHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNjaGVkdWxlVHJhbnNwb3J0QWN0aXZhdGlvbigpJywgJ0N1cnJlbnQgY29ubmVjdGlvbiBzdGF0ZSAoJyArIHNlbGYuc3RhdGUuc3RhdGUgKyAoc2VsZi5zdGF0ZSA9PT0gc2VsZi5zdGF0ZXMuc3luY2hyb25pemluZyA/ICcsIGJ1dCB3aXRoIGFuIHVwZ3JhZGUgYWxyZWFkeSBpbiBwcm9ncmVzcycgOiAnJykgKyAnKSBpcyBub3QgdmFsaWQgdG8gdXBncmFkZSBpbjsgYWJhbmRvbmluZyB1cGdyYWRlIHRvICcgKyB0cmFuc3BvcnQuc2hvcnROYW1lKTtcblx0XHRcdFx0YWJhbmRvbigpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8qIElmIHRoZSBjb25uZWN0aW9uSWQgaGFzIGNoYW5nZWQsIHRoZSB1cGdyYWRlIGhhc24ndCB3b3JrZWQuIEJ1dCBhc1xuXHRcdFx0KiBpdCdzIHN0aWxsIGFuIHVwZ3JhZGUsIHJlYWx0aW1lIHN0aWxsIGV4cGVjdHMgYSBzeW5jIC0gaXQganVzdCBuZWVkcyB0b1xuXHRcdFx0KiBiZSBhIHN5bmMgd2l0aCB0aGUgbmV3IGNvbm5lY3Rpb25TZXJpYWwgKHdoaWNoIHdpbGwgYmUgLTEpLiAoQW5kIGl0XG5cdFx0XHQqIG5lZWRzIHRvIGJlIHNldCBpbiB0aGUgbGlicmFyeSwgd2hpY2ggaXMgZG9uZSBieSBhY3RpdmF0ZVRyYW5zcG9ydCkuICovXG5cdFx0XHR2YXIgY29ubmVjdGlvblJlc2V0ID0gY29ubmVjdGlvbklkICE9PSBzZWxmLmNvbm5lY3Rpb25JZCxcblx0XHRcdFx0bmV3Q29ubmVjdGlvblNlcmlhbCA9IGNvbm5lY3Rpb25SZXNldCA/IGNvbm5lY3Rpb25TZXJpYWwgOiBzZWxmLmNvbm5lY3Rpb25TZXJpYWw7XG5cblx0XHRcdGlmKGNvbm5lY3Rpb25SZXNldCkge1xuXHRcdFx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfRVJST1IsICdDb25uZWN0aW9uTWFuYWdlci5zY2hlZHVsZVRyYW5zcG9ydEFjdGl2YXRpb24oKScsICdVcGdyYWRlIHJlc3VsdGVkIGluIG5ldyBjb25uZWN0aW9uSWQ7IHJlc2V0dGluZyBsaWJyYXJ5IGNvbm5lY3Rpb25TZXJpYWwgZnJvbSAnICsgc2VsZi5jb25uZWN0aW9uU2VyaWFsICsgJyB0byAnICsgbmV3Q29ubmVjdGlvblNlcmlhbCArICc7IHVwZ3JhZGUgZXJyb3Igd2FzICcgKyBlcnJvcik7XG5cdFx0XHR9XG5cblx0XHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNjaGVkdWxlVHJhbnNwb3J0QWN0aXZhdGlvbigpJywgJ1N5bmNpbmcgdHJhbnNwb3J0OyB0cmFuc3BvcnQgPSAnICsgdHJhbnNwb3J0KTtcblx0XHRcdHNlbGYuc3luYyh0cmFuc3BvcnQsIGZ1bmN0aW9uKHN5bmNFcnIsIG5ld0Nvbm5lY3Rpb25TZXJpYWwsIGNvbm5lY3Rpb25JZCkge1xuXHRcdFx0XHQvKiBJZiB0aGVyZSdzIGJlZW4gc29tZSBwcm9ibGVtIHdpdGggc3luY2luZyAoYW5kIHRoZSBjb25uZWN0aW9uIGhhc24ndFxuXHRcdFx0XHQgKiBjbG9zZWQgb3Igc29tZXRoaW5nIGluIHRoZSBtZWFudGltZSksIHdlIGhhdmUgYSBwcm9ibGVtIC0tIHdlIGNhbid0XG5cdFx0XHRcdCAqIGp1c3QgZmFsbCBiYWNrIG9uIHRoZSBvbGQgdHJhbnNwb3J0LCBhcyB3ZSBkb24ndCBrbm93IHdoZXRoZXJcblx0XHRcdFx0ICogcmVhbHRpbWUgZ290IHRoZSBzeW5jIC0tIGlmIGl0IGRpZCwgdGhlIG9sZCB0cmFuc3BvcnQgaXMgbm8gbG9uZ2VyXG5cdFx0XHRcdCAqIHZhbGlkLiBUbyBiZSBzYWZlLCB3ZSBkaXNjb25uZWN0IGJvdGggYW5kIHN0YXJ0IGFnYWluIGZyb20gc2NyYXRjaC4gKi9cblx0XHRcdFx0aWYoc3luY0Vycikge1xuXHRcdFx0XHRcdGlmKHNlbGYuc3RhdGUgPT09IHNlbGYuc3RhdGVzLnN5bmNocm9uaXppbmcpIHtcblx0XHRcdFx0XHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19FUlJPUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNjaGVkdWxlVHJhbnNwb3J0QWN0aXZhdGlvbigpJywgJ1VuZXhwZWN0ZWQgZXJyb3IgYXR0ZW1wdGluZyB0byBzeW5jIHRyYW5zcG9ydDsgdHJhbnNwb3J0ID0gJyArIHRyYW5zcG9ydCArICc7IGVyciA9ICcgKyBzeW5jRXJyKTtcblx0XHRcdFx0XHRcdHNlbGYuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBmaW5pc2hVcGdyYWRlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2NoZWR1bGVUcmFuc3BvcnRBY3RpdmF0aW9uKCknLCAnQWN0aXZhdGluZyB0cmFuc3BvcnQ7IHRyYW5zcG9ydCA9ICcgKyB0cmFuc3BvcnQpO1xuXHRcdFx0XHRcdHNlbGYuYWN0aXZhdGVUcmFuc3BvcnQoZXJyb3IsIHRyYW5zcG9ydCwgY29ubmVjdGlvbktleSwgbmV3Q29ubmVjdGlvblNlcmlhbCwgY29ubmVjdGlvbklkLCBjb25uZWN0aW9uRGV0YWlscyk7XG5cdFx0XHRcdFx0LyogUmVzdG9yZSBwcmUtc3luYyBzdGF0ZS4gSWYgc3RhdGUgaGFzIGNoYW5nZWQgaW4gdGhlIG1lYW50aW1lLFxuXHRcdFx0XHRcdCAqIGRvbid0IHRvdWNoIGl0IC0tIHNpbmNlIHRoZSB3ZWJzb2NrZXQgdHJhbnNwb3J0IHdhaXRzIGEgdGljayBiZWZvcmVcblx0XHRcdFx0XHQgKiBkaXNwb3NpbmcgaXRzZWxmLCBpdCdzIHBvc3NpYmxlIGZvciBpdCB0byBoYXZlIGhhcHBpbHkgc3luY2VkXG5cdFx0XHRcdFx0ICogd2l0aG91dCBlcnIgd2hpbGUsIHVua25vd24gdG8gaXQsIHRoZSBjb25uZWN0aW9uIGhhcyBjbG9zZWQgaW4gdGhlXG5cdFx0XHRcdFx0ICogbWVhbnRpbWUgYW5kIHRoZSB3cyB0cmFuc3BvcnQgaXMgc2NoZWR1bGVkIGZvciBkZWF0aCAqL1xuXHRcdFx0XHRcdGlmKHNlbGYuc3RhdGUgPT09IHNlbGYuc3RhdGVzLnN5bmNocm9uaXppbmcpIHtcblx0XHRcdFx0XHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNjaGVkdWxlVHJhbnNwb3J0QWN0aXZhdGlvbigpJywgJ1ByZS11cGdyYWRlIHByb3RvY29sIGlkbGUsIHNlbmRpbmcgcXVldWVkIG1lc3NhZ2VzIG9uIHVwZ3JhZGVkIHRyYW5zcG9ydDsgdHJhbnNwb3J0ID0gJyArIHRyYW5zcG9ydCk7XG5cdFx0XHRcdFx0XHRzZWxmLnN0YXRlID0gc2VsZi5zdGF0ZXMuY29ubmVjdGVkO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5zY2hlZHVsZVRyYW5zcG9ydEFjdGl2YXRpb24oKScsICdQcmUtdXBncmFkZSBwcm90b2NvbCBpZGxlLCBidXQgc3RhdGUgaXMgbm93ICcgKyBzZWxmLnN0YXRlLnN0YXRlICsgJywgc28gbGVhdmluZyB1bmNoYW5nZWQnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYoc2VsZi5zdGF0ZS5zZW5kRXZlbnRzKSB7XG5cdFx0XHRcdFx0XHRzZWxmLnNlbmRRdWV1ZWRNZXNzYWdlcygpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblxuXHRcdFx0XHQvKiBXYWl0IHVudGlsIHN5bmMgaXMgZG9uZSBhbmQgb2xkIHRyYW5zcG9ydCBpcyBpZGxlIGJlZm9yZSBhY3RpdmF0aW5nIG5ldyB0cmFuc3BvcnQuIFRoaXNcblx0XHRcdFx0ICogZ3VhcmFudGVlcyB0aGF0IG1lc3NhZ2VzIGFycml2ZSBhdCByZWFsdGltZSBpbiB0aGUgc2FtZSBvcmRlciB0aGV5IGFyZSBzZW50LlxuXHRcdFx0XHQgKlxuXHRcdFx0XHQgKiBJZiBhIG1lc3NhZ2UgdGltZXMgb3V0IG9uIHRoZSBvbGQgdHJhbnNwb3J0LCBzaW5jZSBpdCdzIHN0aWxsIHRoZSBhY3RpdmUgdHJhbnNwb3J0IHRoZVxuXHRcdFx0XHQgKiBtZXNzYWdlIHdpbGwgYmUgcmVxdWV1ZWQuIGRlYWN0aXZhdGVUcmFuc3BvcnQgd2lsbCBzZWUgdGhlIHBlbmRpbmcgdHJhbnNwb3J0IGFuZCBub3RpZnlcblx0XHRcdFx0ICogdGhlIGBjb25uZWN0aW5nYCBzdGF0ZSB3aXRob3V0IHN0YXJ0aW5nIGEgbmV3IGNvbm5lY3Rpb24sIHNvIHRoZSBuZXcgdHJhbnNwb3J0IGNhbiB0YWtlXG5cdFx0XHRcdCAqIG92ZXIgb25jZSBkZWFjdGl2YXRlVHJhbnNwb3J0IGNsZWFycyB0aGUgb2xkIHByb3RvY29sJ3MgcXVldWUuXG5cdFx0XHRcdCAqXG5cdFx0XHRcdCAqIElmIHRoZXJlIGlzIG5vIG9sZCBwcm90b2NvbCwgdGhhdCBtZWFudCB0aGF0IHdlIHdlcmVuJ3QgaW4gdGhlIGNvbm5lY3RlZCBzdGF0ZSBhdCB0aGVcblx0XHRcdFx0ICogYmVnaW5uaW5nIG9mIHRoZSBzeW5jIC0gbGlrZWx5IHRoZSBiYXNlIHRyYW5zcG9ydCBkaWVkIGp1c3QgYmVmb3JlIHRoZSBzeW5jLiBTbyBjYW4ganVzdFxuXHRcdFx0XHQgKiBmaW5pc2ggdGhlIHVwZ3JhZGUuIElmIHdlJ3JlIGFjdHVhbGx5IGluIGNsb3NpbmcvZmFpbGVkIHJhdGhlciB0aGFuIGNvbm5lY3RpbmcsIHRoYXQnc1xuXHRcdFx0XHQgKiBmaW5lLCBhY3RpdmF0ZXRyYW5zcG9ydCB3aWxsIGRlYWwgd2l0aCB0aGF0LiAqL1xuXHRcdFx0XHRpZihvbGRQcm90b2NvbCkge1xuXHRcdFx0XHQgLyogTW9zdCBvZiB0aGUgdGltZSB0aGlzIHdpbGwgYmUgYWxyZWFkeSB0cnVlOiB0aGUgbmV3LXRyYW5zcG9ydCBzeW5jIHdpbGwgaGF2ZSBnaXZlblxuXHRcdFx0XHQgKiBlbm91Z2ggdGltZSBmb3IgaW4tZmxpZ2h0IG1lc3NhZ2VzIG9uIHRoZSBvbGQgdHJhbnNwb3J0IHRvIGNvbXBsZXRlLiAqL1xuXHRcdFx0XHRcdG9sZFByb3RvY29sLm9uY2VJZGxlKGZpbmlzaFVwZ3JhZGUpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGZpbmlzaFVwZ3JhZGUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCB3aGVuIGEgdHJhbnNwb3J0IGlzIGNvbm5lY3RlZCwgYW5kIHRoZSBjb25uZWN0aW9ubWFuYWdlciBkZWNpZGVzIHRoYXRcblx0ICogaXQgd2lsbCBub3cgYmUgdGhlIGFjdGl2ZSB0cmFuc3BvcnQuIFJldHVybnMgd2hldGhlciBvciBub3QgaXQgYWN0aXZhdGVkXG5cdCAqIHRoZSB0cmFuc3BvcnQgKGlmIHRoZSBjb25uZWN0aW9uIGlzIGNsb3NpbmcvY2xvc2VkIGl0IHdpbGwgY2hvb3NlIG5vdCB0bykuXG5cdCAqIEBwYXJhbSB0cmFuc3BvcnQgdGhlIHRyYW5zcG9ydCBpbnN0YW5jZVxuXHQgKiBAcGFyYW0gY29ubmVjdGlvbktleSB0aGUga2V5IG9mIHRoZSBuZXcgYWN0aXZlIGNvbm5lY3Rpb25cblx0ICogQHBhcmFtIGNvbm5lY3Rpb25TZXJpYWwgdGhlIGN1cnJlbnQgY29ubmVjdGlvblNlcmlhbFxuXHQgKiBAcGFyYW0gY29ubmVjdGlvbklkIHRoZSBpZCBvZiB0aGUgbmV3IGFjdGl2ZSBjb25uZWN0aW9uXG5cdCAqL1xuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuYWN0aXZhdGVUcmFuc3BvcnQgPSBmdW5jdGlvbihlcnJvciwgdHJhbnNwb3J0LCBjb25uZWN0aW9uS2V5LCBjb25uZWN0aW9uU2VyaWFsLCBjb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzKSB7XG5cdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKScsICd0cmFuc3BvcnQgPSAnICsgdHJhbnNwb3J0KTtcblx0XHRpZihlcnJvcikge1xuXHRcdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX0VSUk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKScsICdlcnJvciA9ICcgKyBlcnJvcik7XG5cdFx0fVxuXHRcdGlmKGNvbm5lY3Rpb25LZXkpXG5cdFx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpJywgJ2Nvbm5lY3Rpb25LZXkgPSAgJyArIGNvbm5lY3Rpb25LZXkpO1xuXHRcdGlmKGNvbm5lY3Rpb25TZXJpYWwgIT09IHVuZGVmaW5lZClcblx0XHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2YXRlVHJhbnNwb3J0KCknLCAnY29ubmVjdGlvblNlcmlhbCA9ICAnICsgY29ubmVjdGlvblNlcmlhbCk7XG5cdFx0aWYoY29ubmVjdGlvbklkKVxuXHRcdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKScsICdjb25uZWN0aW9uSWQgPSAgJyArIGNvbm5lY3Rpb25JZCk7XG5cdFx0aWYoY29ubmVjdGlvbkRldGFpbHMpXG5cdFx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpJywgJ2Nvbm5lY3Rpb25EZXRhaWxzID0gICcgKyBKU09OLnN0cmluZ2lmeShjb25uZWN0aW9uRGV0YWlscykpO1xuXG5cdFx0dGhpcy5wZXJzaXN0VHJhbnNwb3J0UHJlZmVyZW5jZSh0cmFuc3BvcnQpO1xuXG5cdFx0LyogaWYgdGhlIGNvbm5lY3Rpb25tYW5hZ2VyIG1vdmVkIHRvIHRoZSBjbG9zaW5nL2Nsb3NlZCBzdGF0ZSBiZWZvcmUgdGhpc1xuXHRcdCAqIGNvbm5lY3Rpb24gZXZlbnQsIHRoZW4gd2Ugd29uJ3QgYWN0aXZhdGUgdGhpcyB0cmFuc3BvcnQgKi9cblx0XHR2YXIgZXhpc3RpbmdTdGF0ZSA9IHRoaXMuc3RhdGUsXG5cdFx0XHRjb25uZWN0ZWRTdGF0ZSA9IHRoaXMuc3RhdGVzLmNvbm5lY3RlZC5zdGF0ZTtcblx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpJywgJ2N1cnJlbnQgc3RhdGUgPSAnICsgZXhpc3RpbmdTdGF0ZS5zdGF0ZSk7XG5cdFx0aWYoZXhpc3RpbmdTdGF0ZS5zdGF0ZSA9PSB0aGlzLnN0YXRlcy5jbG9zaW5nLnN0YXRlIHx8IGV4aXN0aW5nU3RhdGUuc3RhdGUgPT0gdGhpcy5zdGF0ZXMuY2xvc2VkLnN0YXRlIHx8IGV4aXN0aW5nU3RhdGUuc3RhdGUgPT0gdGhpcy5zdGF0ZXMuZmFpbGVkLnN0YXRlKSB7XG5cdFx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpJywgJ0Rpc2Nvbm5lY3RpbmcgdHJhbnNwb3J0IGFuZCBhYmFuZG9uaW5nJyk7XG5cdFx0XHR0cmFuc3BvcnQuZGlzY29ubmVjdCgpO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8qIHJlbW92ZSB0aGlzIHRyYW5zcG9ydCBmcm9tIHBlbmRpbmcgdHJhbnNwb3J0cyAqL1xuXHRcdFV0aWxzLmFyckRlbGV0ZVZhbHVlKHRoaXMucGVuZGluZ1RyYW5zcG9ydHMsIHRyYW5zcG9ydCk7XG5cblx0XHQvKiBpZiB0aGUgdHJhbnNwb3J0IGlzIG5vdCBjb25uZWN0ZWQgKGVnIGJlY2F1c2UgaXQgZmFpbGVkIGR1cmluZyBhXG5cdFx0ICogc2NoZWR1bGVUcmFuc3BvcnRBY3RpdmF0aW9uI29uY2VOb1BlbmRpbmcgd2FpdCkgdGhlbiBkb24ndCBhY3RpdmF0ZSBpdCAqL1xuXHRcdGlmKCF0cmFuc3BvcnQuaXNDb25uZWN0ZWQpIHtcblx0XHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2YXRlVHJhbnNwb3J0KCknLCAnRGVjbGluaW5nIHRvIGFjdGl2YXRlIHRyYW5zcG9ydCAnICsgdHJhbnNwb3J0ICsgJyBzaW5jZSBpdCBhcHBlYXJzIHRvIG5vIGxvbmdlciBiZSBjb25uZWN0ZWQnKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvKiB0aGUgZ2l2ZW4gdHJhbnNwb3J0IGlzIGNvbm5lY3RlZDsgdGhpcyB3aWxsIGltbWVkaWF0ZWx5XG5cdFx0ICogdGFrZSBvdmVyIGFzIHRoZSBhY3RpdmUgdHJhbnNwb3J0ICovXG5cdFx0dmFyIGV4aXN0aW5nQWN0aXZlUHJvdG9jb2wgPSB0aGlzLmFjdGl2ZVByb3RvY29sO1xuXHRcdHRoaXMuYWN0aXZlUHJvdG9jb2wgPSBuZXcgUHJvdG9jb2wodHJhbnNwb3J0KTtcblx0XHR0aGlzLmhvc3QgPSB0cmFuc3BvcnQucGFyYW1zLmhvc3Q7XG5cdFx0aWYoY29ubmVjdGlvbktleSAmJiB0aGlzLmNvbm5lY3Rpb25LZXkgIT0gY29ubmVjdGlvbktleSkgIHtcblx0XHRcdHRoaXMuc2V0Q29ubmVjdGlvbihjb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25LZXksIGNvbm5lY3Rpb25TZXJpYWwpO1xuXHRcdH1cblxuXHRcdC8qIFJlYnJvYWRjYXN0IGFueSBuZXcgY29ubmVjdGlvbkRldGFpbHMgZnJvbSB0aGUgYWN0aXZlIHRyYW5zcG9ydCwgd2hpY2hcblx0XHQgKiBjYW4gY29tZSBhdCBhbnkgdGltZSAoZWcgZm9sbG93aW5nIGEgcmVhdXRoKSwgYW5kIGVtaXQgYW4gUlROMjQgVVBEQVRFXG5cdFx0ICogZXZlbnQuIChMaXN0ZW5lciBhZGRlZCBvbiBuZXh0VGljayBiZWNhdXNlIHdlJ3JlIGluIGEgdHJhbnNwb3J0Lm9uKCdjb25uZWN0ZWQnKVxuXHRcdCAqIGNhbGxiYWNrIGF0IHRoZSBtb21lbnQ7IGlmIHdlIGFkZCBpdCBub3cgd2UnbGwgYmUgYWRkaW5nIGl0IHRvIHRoZSBlbmRcblx0XHQgKiBvZiB0aGUgbGlzdGVuZXJzIGFycmF5IGFuZCBpdCdsbCBiZSBjYWxsZWQgaW1tZWRpYXRlbHkpICovXG5cdFx0dGhpcy5vbkNvbm5lY3Rpb25EZXRhaWxzVXBkYXRlKGNvbm5lY3Rpb25EZXRhaWxzLCB0cmFuc3BvcnQpO1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRVdGlscy5uZXh0VGljayhmdW5jdGlvbigpIHtcblx0XHRcdHRyYW5zcG9ydC5vbignY29ubmVjdGVkJywgZnVuY3Rpb24oY29ubmVjdGVkRXJyLCBfY29ubmVjdGlvbktleSwgX2Nvbm5lY3Rpb25TZXJpYWwsIF9jb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzKSB7XG5cdFx0XHRcdHNlbGYub25Db25uZWN0aW9uRGV0YWlsc1VwZGF0ZShjb25uZWN0aW9uRGV0YWlscywgdHJhbnNwb3J0KTtcblx0XHRcdFx0c2VsZi5lbWl0KCd1cGRhdGUnLCBuZXcgQ29ubmVjdGlvblN0YXRlQ2hhbmdlKGNvbm5lY3RlZFN0YXRlLCBjb25uZWN0ZWRTdGF0ZSwgbnVsbCwgY29ubmVjdGVkRXJyKSk7XG5cdFx0XHR9KTtcblx0XHR9KVxuXG5cdFx0LyogSWYgcHJldmlvdXNseSBub3QgY29ubmVjdGVkLCBub3RpZnkgdGhlIHN0YXRlIGNoYW5nZSAoaW5jbHVkaW5nIGFueVxuXHRcdCAqIGVycm9yKS4gKi9cblx0XHRpZihleGlzdGluZ1N0YXRlLnN0YXRlID09PSB0aGlzLnN0YXRlcy5jb25uZWN0ZWQuc3RhdGUpIHtcblx0XHRcdGlmKGVycm9yKSB7XG5cdFx0XHRcdC8qIGlmIHVwZ3JhZGluZyB3aXRob3V0IGVycm9yLCBsZWF2ZSBhbnkgZXhpc3RpbmcgZXJyb3JSZWFzb24gYWxvbmUgKi9cblx0XHRcdFx0dGhpcy5lcnJvclJlYXNvbiA9IHRoaXMucmVhbHRpbWUuY29ubmVjdGlvbi5lcnJvclJlYXNvbiA9IGVycm9yO1xuXHRcdFx0XHQvKiBPbmx5IGJvdGhlciBlbWl0dGluZyBhbiB1cGdyYWRlIGlmIHRoZXJlJ3MgYW4gZXJyb3I7IG90aGVyd2lzZSBpdCdzXG5cdFx0XHRcdCAqIGp1c3QgYSB0cmFuc3BvcnQgdXBncmFkZSwgc28gYXV0aCBkZXRhaWxzIHdvbid0IGhhdmUgY2hhbmdlZCAqL1xuXHRcdFx0XHR0aGlzLmVtaXQoJ3VwZGF0ZScsIG5ldyBDb25uZWN0aW9uU3RhdGVDaGFuZ2UoY29ubmVjdGVkU3RhdGUsIGNvbm5lY3RlZFN0YXRlLCBudWxsLCBlcnJvcikpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLm5vdGlmeVN0YXRlKHtzdGF0ZTogJ2Nvbm5lY3RlZCcsIGVycm9yOiBlcnJvcn0pO1xuXHRcdFx0dGhpcy5lcnJvclJlYXNvbiA9IHRoaXMucmVhbHRpbWUuY29ubmVjdGlvbi5lcnJvclJlYXNvbiA9IGVycm9yIHx8IG51bGw7XG5cdFx0fVxuXG5cdFx0LyogU2VuZCBhZnRlciB0aGUgY29ubmVjdGlvbiBzdGF0ZSB1cGRhdGUsIGFzIENoYW5uZWxzIGhvb2tzIGludG8gdGhpcyB0b1xuXHRcdCAqIHJlc2VuZCBhdHRhY2hlcyBvbiBhIG5ldyB0cmFuc3BvcnQgaWYgbmVjZXNzYXJ5ICovXG5cdFx0dGhpcy5lbWl0KCd0cmFuc3BvcnQuYWN0aXZlJywgdHJhbnNwb3J0LCBjb25uZWN0aW9uS2V5LCB0cmFuc3BvcnQucGFyYW1zKTtcblxuXHRcdC8qIEdyYWNlZnVsbHkgdGVybWluYXRlIGV4aXN0aW5nIHByb3RvY29sICovXG5cdFx0aWYoZXhpc3RpbmdBY3RpdmVQcm90b2NvbCkge1xuXHRcdFx0aWYoZXhpc3RpbmdBY3RpdmVQcm90b2NvbC5tZXNzYWdlUXVldWUuY291bnQoKSA+IDApIHtcblx0XHRcdFx0LyogV2UgY291bGQganVzdCByZXF1ZXVlIHBlbmRpbmcgbWVzc2FnZXMgb24gdGhlIG5ldyB0cmFuc3BvcnQsIGJ1dFxuXHRcdFx0XHQgKiBhY3R1YWxseSB0aGlzIHNob3VsZCBuZXZlciBoYXBwZW46IHRyYW5zcG9ydHMgc2hvdWxkIG9ubHkgdGFrZSBvdmVyXG5cdFx0XHRcdCAqIGZyb20gb3RoZXIgYWN0aXZlIHRyYW5zcG9ydHMgd2hlbiB1cGdyYWRpbmcsIGFuZCB1cGdyYWRpbmcgd2FpdHMgZm9yXG5cdFx0XHRcdCAqIHRoZSBvbGQgdHJhbnNwb3J0IHRvIGJlIGlkbGUuIFNvIGxvZyBhbiBlcnJvci4gKi9cblx0XHRcdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX0VSUk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKScsICdQcmV2aW91cyBhY3RpdmUgcHJvdG9jb2wgKGZvciB0cmFuc3BvcnQgJyArIGV4aXN0aW5nQWN0aXZlUHJvdG9jb2wudHJhbnNwb3J0LnNob3J0TmFtZSArICcsIG5ldyBvbmUgaXMgJyArIHRyYW5zcG9ydC5zaG9ydE5hbWUgKyAnKSBmaW5pc2hpbmcgd2l0aCAnICsgZXhpc3RpbmdBY3RpdmVQcm90b2NvbC5tZXNzYWdlUXVldWUuY291bnQoKSArICcgbWVzc2FnZXMgc3RpbGwgcGVuZGluZycpO1xuXHRcdFx0fVxuXHRcdFx0ZXhpc3RpbmdBY3RpdmVQcm90b2NvbC5maW5pc2goKTtcblx0XHR9XG5cblx0XHQvKiBUZXJtaW5hdGUgYW55IG90aGVyIHBlbmRpbmcgdHJhbnNwb3J0KHMpLCBhbmRcblx0XHQgKiBhYm9ydCBhbnkgbm90LXlldC1wZW5kaW5nIHRyYW5zcG9ydCBhdHRlbXB0cyAqL1xuXHRcdFV0aWxzLnNhZmVBcnJGb3JFYWNoKHRoaXMucGVuZGluZ1RyYW5zcG9ydHMsIGZ1bmN0aW9uKHRyYW5zcG9ydCkge1xuXHRcdFx0dHJhbnNwb3J0LmRpc2Nvbm5lY3QoKTtcblx0XHR9KTtcblx0XHRVdGlscy5zYWZlQXJyRm9yRWFjaCh0aGlzLnByb3Bvc2VkVHJhbnNwb3J0cywgZnVuY3Rpb24odHJhbnNwb3J0KSB7XG5cdFx0XHR0cmFuc3BvcnQuZGlzcG9zZSgpO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCB3aGVuIGEgdHJhbnNwb3J0IGlzIG5vIGxvbmdlciB0aGUgYWN0aXZlIHRyYW5zcG9ydC4gVGhpcyBjYW4gb2NjdXJcblx0ICogaW4gYW55IHRyYW5zcG9ydCBjb25uZWN0aW9uIHN0YXRlLlxuXHQgKiBAcGFyYW0gdHJhbnNwb3J0XG5cdCAqL1xuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuZGVhY3RpdmF0ZVRyYW5zcG9ydCA9IGZ1bmN0aW9uKHRyYW5zcG9ydCwgc3RhdGUsIGVycm9yKSB7XG5cdFx0dmFyIGN1cnJlbnRQcm90b2NvbCA9IHRoaXMuYWN0aXZlUHJvdG9jb2wsXG5cdFx0XHR3YXNBY3RpdmUgPSBjdXJyZW50UHJvdG9jb2wgJiYgY3VycmVudFByb3RvY29sLmdldFRyYW5zcG9ydCgpID09PSB0cmFuc3BvcnQsXG5cdFx0XHR3YXNQZW5kaW5nID0gVXRpbHMuYXJyRGVsZXRlVmFsdWUodGhpcy5wZW5kaW5nVHJhbnNwb3J0cywgdHJhbnNwb3J0KSxcblx0XHRcdHdhc1Byb3Bvc2VkID0gVXRpbHMuYXJyRGVsZXRlVmFsdWUodGhpcy5wcm9wb3NlZFRyYW5zcG9ydHMsIHRyYW5zcG9ydCksXG5cdFx0XHRub1RyYW5zcG9ydHNTY2hlZHVsZWRGb3JBY3RpdmF0aW9uID0gdGhpcy5ub1RyYW5zcG9ydHNTY2hlZHVsZWRGb3JBY3RpdmF0aW9uKCk7XG5cblx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5kZWFjdGl2YXRlVHJhbnNwb3J0KCknLCAndHJhbnNwb3J0ID0gJyArIHRyYW5zcG9ydCk7XG5cdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuZGVhY3RpdmF0ZVRyYW5zcG9ydCgpJywgJ3N0YXRlID0gJyArIHN0YXRlICsgKHdhc0FjdGl2ZSA/ICc7IHdhcyBhY3RpdmUnIDogd2FzUGVuZGluZyA/ICc7IHdhcyBwZW5kaW5nJyA6IHdhc1Byb3Bvc2VkID8gJzsgd2FzIHByb3Bvc2VkJyA6ICcnKSArIChub1RyYW5zcG9ydHNTY2hlZHVsZWRGb3JBY3RpdmF0aW9uID8gJycgOiAnOyBhbm90aGVyIHRyYW5zcG9ydCBpcyBzY2hlZHVsZWQgZm9yIGFjdGl2YXRpb24nKSk7XG5cdFx0aWYoZXJyb3IgJiYgZXJyb3IubWVzc2FnZSlcblx0XHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmRlYWN0aXZhdGVUcmFuc3BvcnQoKScsICdyZWFzb24gPSAgJyArIGVycm9yLm1lc3NhZ2UpO1xuXG5cdFx0aWYod2FzQWN0aXZlKSB7XG5cdFx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5kZWFjdGl2YXRlVHJhbnNwb3J0KCknLCAnR2V0dGluZywgY2xlYXJpbmcsIGFuZCByZXF1ZXVpbmcgJyArIHRoaXMuYWN0aXZlUHJvdG9jb2wubWVzc2FnZVF1ZXVlLmNvdW50KCkgKyAnIHBlbmRpbmcgbWVzc2FnZXMnKTtcblx0XHRcdHRoaXMucXVldWVQZW5kaW5nTWVzc2FnZXMoY3VycmVudFByb3RvY29sLmdldFBlbmRpbmdNZXNzYWdlcygpKTtcblx0XHRcdC8qIENsZWFyIGFueSBtZXNzYWdlcyB3ZSByZXF1ZXVlIHRvIGFsbG93IHRoZSBwcm90b2NvbCB0byBiZWNvbWUgaWRsZS5cblx0XHRcdCAqIEluIGNhc2Ugb2YgYW4gdXBncmFkZSwgdGhpcyB3aWxsIHRyaWdnZXIgYW4gaW1tZWRpYXRlIGFjdGl2YXRpb24gb2Zcblx0XHRcdCAqIHRoZSB1cGdyYWRlIHRyYW5zcG9ydCwgc28gZGVsYXkgYSB0aWNrIHNvIHRoaXMgdHJhbnNwb3J0IGNhbiBmaW5pc2hcblx0XHRcdCAqIGRlYWN0aXZhdGluZyAqL1xuXHRcdFx0VXRpbHMubmV4dFRpY2soZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGN1cnJlbnRQcm90b2NvbC5jbGVhclBlbmRpbmdNZXNzYWdlcygpO1xuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLmFjdGl2ZVByb3RvY29sID0gdGhpcy5ob3N0ID0gbnVsbDtcblx0XHR9XG5cblx0XHR0aGlzLmVtaXQoJ3RyYW5zcG9ydC5pbmFjdGl2ZScsIHRyYW5zcG9ydCk7XG5cblx0XHQvKiB0aGlzIHRyYW5zcG9ydCBzdGF0ZSBjaGFuZ2UgaXMgYSBzdGF0ZSBjaGFuZ2UgZm9yIHRoZSBjb25uZWN0aW9ubWFuYWdlciBpZlxuXHRcdCAqIC0gdGhlIHRyYW5zcG9ydCB3YXMgdGhlIGFjdGl2ZSB0cmFuc3BvcnQgYW5kIHRoZXJlIGFyZSBubyB0cmFuc3BvcnRzXG5cdFx0ICogICB3aGljaCBhcmUgY29ubmVjdGVkIGFuZCBzY2hlZHVsZWQgZm9yIGFjdGl2YXRpb24sIGp1c3Qgd2FpdGluZyBmb3IgdGhlXG5cdFx0ICogICBhY3RpdmUgdHJhbnNwb3J0IHRvIGZpbmlzaCB3aGF0IGl0cyBkb2luZzsgb3Jcblx0XHQgKiAtIHRoZSB0cmFuc3BvcnQgd2FzIHRoZSBhY3RpdmUgdHJhbnNwb3J0IGFuZCB0aGUgZXJyb3Igd2FzIGZhdGFsIChzb1xuXHRcdCAqICAgdW5oZWFsYWJsZSBieSBhbm90aGVyIHRyYW5zcG9ydCk7IG9yXG5cdFx0ICogLSB0aGVyZSBpcyBubyBhY3RpdmUgdHJhbnNwb3J0LCBhbmQgdGhpcyBpcyB0aGUgbGFzdCByZW1haW5pbmdcblx0XHQgKiAgIHBlbmRpbmcgdHJhbnNwb3J0IChzbyB3ZSB3ZXJlIGluIHRoZSBjb25uZWN0aW5nIHN0YXRlKVxuXHRcdCAqL1xuXHRcdGlmKCh3YXNBY3RpdmUgJiYgbm9UcmFuc3BvcnRzU2NoZWR1bGVkRm9yQWN0aXZhdGlvbikgfHxcblx0XHRcdCh3YXNBY3RpdmUgJiYgKHN0YXRlID09PSAnZmFpbGVkJykgfHwgKHN0YXRlID09PSAnY2xvc2VkJykpIHx8XG5cdFx0XHQoY3VycmVudFByb3RvY29sID09PSBudWxsICYmIHdhc1BlbmRpbmcgJiYgdGhpcy5wZW5kaW5nVHJhbnNwb3J0cy5sZW5ndGggPT09IDApKSB7XG5cdFx0XHQvKiBUT0RPIHJlbW92ZSBiZWxvdyBsaW5lIG9uY2UgcmVhbHRpbWUgc2VuZHMgdG9rZW4gZXJyb3JzIGFzIERJU0NPTk5FQ1RFRHMgKi9cblx0XHRcdGlmKHN0YXRlID09PSAnZmFpbGVkJyAmJiBBdXRoLmlzVG9rZW5FcnIoZXJyb3IpKSB7IHN0YXRlID0gJ2Rpc2Nvbm5lY3RlZCcgfVxuXHRcdFx0dGhpcy5ub3RpZnlTdGF0ZSh7c3RhdGU6IHN0YXRlLCBlcnJvcjogZXJyb3J9KTtcblx0XHR9IGVsc2UgaWYod2FzQWN0aXZlICYmIChzdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RlZCcpKSB7XG5cdFx0XHQvKiBJZiB3ZSB3ZXJlIGFjdGl2ZSBidXQgdGhlcmUgaXMgYW5vdGhlciB0cmFuc3BvcnQgc2NoZWR1bGVkIGZvclxuXHRcdFx0KiBhY3RpdmF0aW9uLCBnbyBpbnRvIHRvIHRoZSBjb25uZWN0aW5nIHN0YXRlIHVudGlsIHRoYXQgdHJhbnNwb3J0XG5cdFx0XHQqIGFjdGl2YXRlcyBhbmQgc2V0cyB1cyBiYWNrIHRvIGNvbm5lY3RlZC4gKG1hbnVhbGx5IHN0YXJ0aW5nIHRoZVxuXHRcdFx0KiB0cmFuc2l0aW9uIHRpbWVycyBpbiBjYXNlIHRoYXQgbmV2ZXIgaGFwcGVucykgKi9cblx0XHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmRlYWN0aXZhdGVUcmFuc3BvcnQoKScsICd3YXNBY3RpdmUgYnV0IGFub3RoZXIgdHJhbnNwb3J0IGlzIGNvbm5lY3RlZCBhbmQgc2NoZWR1bGVkIGZvciBhY3RpdmF0aW9uLCBzbyBnb2luZyBpbnRvIHRoZSBjb25uZWN0aW5nIHN0YXRlIHVudGlsIGl0IGFjdGl2YXRlcycpO1xuXHRcdFx0dGhpcy5zdGFydFN1c3BlbmRUaW1lcigpO1xuXHRcdFx0dGhpcy5zdGFydFRyYW5zaXRpb25UaW1lcih0aGlzLnN0YXRlcy5jb25uZWN0aW5nKTtcblx0XHRcdHRoaXMubm90aWZ5U3RhdGUoe3N0YXRlOiAnY29ubmVjdGluZycsIGVycm9yOiBlcnJvcn0pO1xuXHRcdH1cblx0fTtcblxuXHQvKiBIZWxwZXIgdGhhdCByZXR1cm5zIHRydWUgaWYgdGhlcmUgYXJlIG5vIHRyYW5zcG9ydHMgd2hpY2ggYXJlIHBlbmRpbmcsXG5cdCogaGF2ZSBiZWVuIGNvbm5lY3RlZCwgYW5kIGFyZSBqdXN0IHdhaXRpbmcgZm9yIG9uY2VOb1BlbmRpbmcgdG8gZmlyZSBiZWZvcmVcblx0KiBiZWluZyBhY3RpdmF0ZWQgKi9cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLm5vVHJhbnNwb3J0c1NjaGVkdWxlZEZvckFjdGl2YXRpb24gPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gVXRpbHMuaXNFbXB0eSh0aGlzLnBlbmRpbmdUcmFuc3BvcnRzKSB8fFxuXHRcdFx0dGhpcy5wZW5kaW5nVHJhbnNwb3J0cy5ldmVyeShmdW5jdGlvbih0cmFuc3BvcnQpIHtcblx0XHRcdFx0cmV0dXJuICF0cmFuc3BvcnQuaXNDb25uZWN0ZWQ7XG5cdFx0XHR9KTtcblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIHdoZW4gYWN0aXZhdGluZyBhIG5ldyB0cmFuc3BvcnQsIHRvIGVuc3VyZSBtZXNzYWdlIGRlbGl2ZXJ5XG5cdCAqIG9uIHRoZSBuZXcgdHJhbnNwb3J0IHN5bmNocm9uaXNlcyB3aXRoIHRoZSBtZXNzYWdlcyBhbHJlYWR5IHJlY2VpdmVkXG5cdCAqL1xuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuc3luYyA9IGZ1bmN0aW9uKHRyYW5zcG9ydCwgY2FsbGJhY2spIHtcblx0XHR2YXIgdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdFx0dHJhbnNwb3J0Lm9mZignc3luYycpO1xuXHRcdFx0Y2FsbGJhY2sobmV3IEVycm9ySW5mbygnVGltZW91dCB3YWl0aW5nIGZvciBzeW5jIHJlc3BvbnNlJywgNTAwMDAsIDUwMCkpO1xuXHRcdH0sIHRoaXMub3B0aW9ucy50aW1lb3V0cy5yZWFsdGltZVJlcXVlc3RUaW1lb3V0KTtcblxuXHRcdC8qIHNlbmQgc3luYyByZXF1ZXN0ICovXG5cdFx0dmFyIHN5bmNNZXNzYWdlID0gUHJvdG9jb2xNZXNzYWdlLmZyb21WYWx1ZXMoe1xuXHRcdFx0YWN0aW9uOiBhY3Rpb25zLlNZTkMsXG5cdFx0XHRjb25uZWN0aW9uS2V5OiB0aGlzLmNvbm5lY3Rpb25LZXksXG5cdFx0XHRjb25uZWN0aW9uU2VyaWFsOiB0aGlzLmNvbm5lY3Rpb25TZXJpYWxcblx0XHR9KTtcblxuXHRcdHRyYW5zcG9ydC5zZW5kKHN5bmNNZXNzYWdlKTtcblxuXHRcdHRyYW5zcG9ydC5vbmNlKCdzeW5jJywgZnVuY3Rpb24oY29ubmVjdGlvblNlcmlhbCwgY29ubmVjdGlvbklkKSB7XG5cdFx0XHRjbGVhclRpbWVvdXQodGltZW91dCk7XG5cdFx0XHRjYWxsYmFjayhudWxsLCBjb25uZWN0aW9uU2VyaWFsLCBjb25uZWN0aW9uSWQpO1xuXHRcdH0pO1xuXHR9O1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zZXRDb25uZWN0aW9uID0gZnVuY3Rpb24oY29ubmVjdGlvbklkLCBjb25uZWN0aW9uS2V5LCBjb25uZWN0aW9uU2VyaWFsKSB7XG5cdFx0LyogaWYgY29ubmVjdGlvbktleSBjaGFuZ2VzIGJ1dCBjb25uZWN0aW9uSWQgc3RheXMgdGhlIHNhbWUsIHRoZW4ganVzdCBhXG5cdFx0ICogdHJhbnNwb3J0IGNoYW5nZSBvbiB0aGUgc2FtZSBjb25uZWN0aW9uLiBJZiBjb25uZWN0aW9uSWQgY2hhbmdlcywgd2UncmVcblx0XHQgKiBvbiBhIG5ldyBjb25uZWN0aW9uLCB3aXRoIGltcGxpY2F0aW9ucyBmb3IgbXNnU2VyaWFsIGFuZCBjaGFubmVsIHN0YXRlICovXG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdGNvbm5lY3Rpb25TZXJpYWwgPSAoY29ubmVjdGlvblNlcmlhbCA9PT0gdW5kZWZpbmVkKSA/IC0xIDogY29ubmVjdGlvblNlcmlhbDtcblx0XHQvKiBOb3RlIHRoYXQgdGhpcyBpcyBhbHNvIHJ1biBvbiBjbGVhbiBjb25uZWN0aW9uczsgdGhlIG1zZ1NlcmlhbCBpcyBhXG5cdFx0ICogbm9vcCwgYnV0IHRoZSBjaGFubmVsIHJlYXR0YWNoIGlzIG5lZWRlZCBmb3IgY2hhbm5lbHMgdGhhdCB3ZXJlXG5cdFx0ICogcHJldmlvdXNseSBpbiB0aGUgYXR0YWNoZWQgc3RhdGUgZXZlbiB0aG91Z2ggdGhlIGNvbm5lY3Rpb24gbW9kZSB3YXNcblx0XHQgKiAnY2xlYW4nIGR1ZSB0byBhIGZyZXNobmVzcyBjaGVjayAtIHNlZSBodHRwczovL2dpdGh1Yi5jb20vYWJseS9hYmx5LWpzL2lzc3Vlcy8zOTQgKi9cblx0XHRpZih0aGlzLmNvbm5lY3Rpb25JZCAhPT0gY29ubmVjdGlvbklkKSAge1xuXHRcdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2V0Q29ubmVjdGlvbigpJywgJ05ldyBjb25uZWN0aW9uSWQ7IHJlc2V0dGluZyBtc2dTZXJpYWwgYW5kIHJlYXR0YWNoaW5nIGFueSBhdHRhY2hlZCBjaGFubmVscycpO1xuXHRcdFx0dGhpcy5tc2dTZXJpYWwgPSAwO1xuXHRcdFx0LyogV2FpdCB0aWxsIG5leHQgdGljayBiZWZvcmUgcmVhdHRhY2hpbmcgY2hhbm5lbHMsIHNvIHRoYXQgY29ubmVjdGlvblxuXHRcdFx0ICogc3RhdGUgd2lsbCBiZSB1cGRhdGVkIGFuZCBzbyB0aGF0IGl0IHdpbGwgYmUgYXBwbGllZCBhZnRlclxuXHRcdFx0ICogQ2hhbm5lbHMjb25UcmFuc3BvcnRVcGRhdGUsIGVsc2UgY2hhbm5lbHMgd2lsbCBub3QgaGF2ZSBhbiBBVFRBQ0hFRFxuXHRcdFx0ICogc2VudCB0d2ljZSAob25jZSBmcm9tIHRoaXMgYW5kIG9uY2UgZnJvbSB0aGF0KS4gKi9cblx0XHRcdFV0aWxzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZWxmLnJlYWx0aW1lLmNoYW5uZWxzLnJlYXR0YWNoKCk7XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0LyogZG9uJ3QgYWxsb3cgdGhlIGNvbm5lY3Rpb25TZXJpYWwgaW4gdGhlIENPTk5FQ1RFRCB0byBsb3dlciB0aGUgc3RvcmVkXG5cdFx0XHQgKiBjb25uZWN0aW9uU2VyaWFsLCBiZWNhdXNlIG1lc3NhZ2VzIGNhbiBhcnJpdmUgb24gdGhlIHVwZ3JhZGUgdHJhbnNwb3J0XG5cdFx0XHQgKiAodmFsaWRseSBpbmNyZW1lbnRpbmcgdGhlIHN0b3JlZCBjb25uZWN0aW9uU2VyaWFsKSBhZnRlciBpdCdzIGJlZW5cblx0XHRcdCAqIHN5bmNlZCBidXQgYmVmb3JlIGl0IGdldHMgYWN0aXZhdGVkICovXG5cdFx0XHRjb25uZWN0aW9uU2VyaWFsID0gKHRoaXMuY29ubmVjdGlvblNlcmlhbCA9PT0gdW5kZWZpbmVkKSA/IGNvbm5lY3Rpb25TZXJpYWwgOiBNYXRoLm1heChjb25uZWN0aW9uU2VyaWFsLCB0aGlzLmNvbm5lY3Rpb25TZXJpYWwpO1xuXHRcdH1cblx0XHR0aGlzLnJlYWx0aW1lLmNvbm5lY3Rpb24uaWQgPSB0aGlzLmNvbm5lY3Rpb25JZCA9IGNvbm5lY3Rpb25JZDtcblx0XHR0aGlzLnJlYWx0aW1lLmNvbm5lY3Rpb24ua2V5ID0gdGhpcy5jb25uZWN0aW9uS2V5ID0gY29ubmVjdGlvbktleTtcblx0XHR0aGlzLnJlYWx0aW1lLmNvbm5lY3Rpb24uc2VyaWFsID0gdGhpcy5jb25uZWN0aW9uU2VyaWFsID0gY29ubmVjdGlvblNlcmlhbDtcblx0XHR0aGlzLnJlYWx0aW1lLmNvbm5lY3Rpb24ucmVjb3ZlcnlLZXkgPSBjb25uZWN0aW9uS2V5ICsgJzonICsgdGhpcy5jb25uZWN0aW9uU2VyaWFsO1xuXHR9O1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jbGVhckNvbm5lY3Rpb24gPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnJlYWx0aW1lLmNvbm5lY3Rpb24uaWQgPSB0aGlzLmNvbm5lY3Rpb25JZCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLnJlYWx0aW1lLmNvbm5lY3Rpb24ua2V5ID0gdGhpcy5jb25uZWN0aW9uS2V5ID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMucmVhbHRpbWUuY29ubmVjdGlvbi5zZXJpYWwgPSB0aGlzLmNvbm5lY3Rpb25TZXJpYWwgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5yZWFsdGltZS5jb25uZWN0aW9uLnJlY292ZXJ5S2V5ID0gbnVsbDtcblx0XHR0aGlzLm1zZ1NlcmlhbCA9IDA7XG5cdFx0dGhpcy51bnBlcnNpc3RDb25uZWN0aW9uKCk7XG5cdH07XG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNoZWNrQ29ubmVjdGlvblN0YXRlRnJlc2huZXNzID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYoIXRoaXMubGFzdEFjdGl2aXR5IHx8ICF0aGlzLmNvbm5lY3Rpb25JZCkgeyByZXR1cm47IH1cblxuXHRcdHZhciBzaW5jZUxhc3QgPSBVdGlscy5ub3coKSAtIHRoaXMubGFzdEFjdGl2aXR5O1xuXHRcdGlmKHNpbmNlTGFzdCA+IHRoaXMuY29ubmVjdGlvblN0YXRlVHRsICsgdGhpcy5tYXhJZGxlSW50ZXJ2YWwpIHtcblx0XHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmNoZWNrQ29ubmVjdGlvblN0YXRlRnJlc2huZXNzKCknLCAnTGFzdCBrbm93biBhY3Rpdml0eSBmcm9tIHJlYWx0aW1lIHdhcyAnICsgc2luY2VMYXN0ICsgJ21zIGFnbzsgZGlzY2FyZGluZyBjb25uZWN0aW9uIHN0YXRlJyk7XG5cdFx0XHR0aGlzLmNsZWFyQ29ubmVjdGlvbigpO1xuXHRcdFx0dGhpcy5zdGF0ZXMuY29ubmVjdGluZy5mYWlsU3RhdGUgPSAnc3VzcGVuZGVkJztcblx0XHRcdHRoaXMuc3RhdGVzLmNvbm5lY3RpbmcucXVldWVFdmVudHMgPSBmYWxzZTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCB3aGVuIHRoZSBjb25uZWN0aW9ubWFuYWdlciB3YW50cyB0byBwZXJzaXN0IHRyYW5zcG9ydFxuXHQgKiBzdGF0ZSBmb3IgbGF0ZXIgcmVjb3ZlcnkuIE9ubHkgYXBwbGljYWJsZSBpbiB0aGUgYnJvd3NlciBjb250ZXh0LlxuXHQgKi9cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnBlcnNpc3RDb25uZWN0aW9uID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYoaGF2ZVNlc3Npb25TdG9yYWdlICYmIHRoaXMuY29ubmVjdGlvbktleSAmJiB0aGlzLmNvbm5lY3Rpb25TZXJpYWwgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0c2V0U2Vzc2lvblJlY292ZXJEYXRhKHtcblx0XHRcdFx0cmVjb3ZlcnlLZXk6IHRoaXMuY29ubmVjdGlvbktleSArICc6JyArIHRoaXMuY29ubmVjdGlvblNlcmlhbCxcblx0XHRcdFx0ZGlzY29ubmVjdGVkQXQ6IFV0aWxzLm5vdygpLFxuXHRcdFx0XHRsb2NhdGlvbjogd2luZG93LmxvY2F0aW9uLFxuXHRcdFx0XHRjbGllbnRJZDogdGhpcy5yZWFsdGltZS5hdXRoLmNsaWVudElkXG5cdFx0XHR9LCB0aGlzLmNvbm5lY3Rpb25TdGF0ZVR0bCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgd2hlbiB0aGUgY29ubmVjdGlvbm1hbmFnZXIgd2FudHMgdG8gcGVyc2lzdCB0cmFuc3BvcnRcblx0ICogc3RhdGUgZm9yIGxhdGVyIHJlY292ZXJ5LiBPbmx5IGFwcGxpY2FibGUgaW4gdGhlIGJyb3dzZXIgY29udGV4dC5cblx0ICovXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS51bnBlcnNpc3RDb25uZWN0aW9uID0gZnVuY3Rpb24oKSB7XG5cdFx0Y2xlYXJTZXNzaW9uUmVjb3ZlckRhdGEoKTtcblx0fTtcblxuXHQvKioqKioqKioqKioqKioqKioqKioqXG5cdCAqIHN0YXRlIG1hbmFnZW1lbnRcblx0ICoqKioqKioqKioqKioqKioqKioqKi9cblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuZ2V0U3RhdGVFcnJvciA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBDb25uZWN0aW9uRXJyb3JbdGhpcy5zdGF0ZS5zdGF0ZV07XG5cdH07XG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmFjdGl2ZVN0YXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuc3RhdGUucXVldWVFdmVudHMgfHwgdGhpcy5zdGF0ZS5zZW5kRXZlbnRzO1xuXHR9O1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5lbmFjdFN0YXRlQ2hhbmdlID0gZnVuY3Rpb24oc3RhdGVDaGFuZ2UpIHtcblx0XHR2YXIgbG9nTGV2ZWwgPSBzdGF0ZUNoYW5nZS5jdXJyZW50ID09PSAnZmFpbGVkJyA/IExvZ2dlci5MT0dfRVJST1IgOiBMb2dnZXIuTE9HX01BSk9SO1xuXHRcdExvZ2dlci5sb2dBY3Rpb24obG9nTGV2ZWwsICdDb25uZWN0aW9uIHN0YXRlJywgc3RhdGVDaGFuZ2UuY3VycmVudCArIChzdGF0ZUNoYW5nZS5yZWFzb24gPyAoJzsgcmVhc29uOiAnICsgc3RhdGVDaGFuZ2UucmVhc29uLm1lc3NhZ2UgKyAnLCBjb2RlOiAnICsgc3RhdGVDaGFuZ2UucmVhc29uLmNvZGUpIDogJycpKTtcblx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5lbmFjdFN0YXRlQ2hhbmdlJywgJ3NldHRpbmcgbmV3IHN0YXRlOiAnICsgc3RhdGVDaGFuZ2UuY3VycmVudCArICc7IHJlYXNvbiA9ICcgKyAoc3RhdGVDaGFuZ2UucmVhc29uICYmIHN0YXRlQ2hhbmdlLnJlYXNvbi5tZXNzYWdlKSk7XG5cdFx0dmFyIG5ld1N0YXRlID0gdGhpcy5zdGF0ZSA9IHRoaXMuc3RhdGVzW3N0YXRlQ2hhbmdlLmN1cnJlbnRdO1xuXHRcdGlmKHN0YXRlQ2hhbmdlLnJlYXNvbikge1xuXHRcdFx0dGhpcy5lcnJvclJlYXNvbiA9IHN0YXRlQ2hhbmdlLnJlYXNvbjtcblx0XHRcdHRoaXMucmVhbHRpbWUuY29ubmVjdGlvbi5lcnJvclJlYXNvbiA9IHN0YXRlQ2hhbmdlLnJlYXNvbjtcblx0XHR9XG5cdFx0aWYobmV3U3RhdGUudGVybWluYWwgfHwgbmV3U3RhdGUuc3RhdGUgPT09ICdzdXNwZW5kZWQnKSB7XG5cdFx0XHQvKiBzdXNwZW5kZWQgaXMgbm9udGVybWluYWwsIGJ1dCBvbmNlIGluIHRoZSBzdXNwZW5kZWQgc3RhdGUsIHJlYWx0aW1lXG5cdFx0XHQgKiB3aWxsIGhhdmUgZGlzY2FyZGVkIG91ciBjb25uZWN0aW9uIHN0YXRlLCBzbyBmdXRoZXIgY29ubmVjdGlvblxuXHRcdFx0ICogYXR0ZW1wdHMgc2hvdWxkIHN0YXJ0IGZyb20gc2NyYXRjaCAqL1xuXHRcdFx0dGhpcy5jbGVhckNvbm5lY3Rpb24oKTtcblx0XHR9XG5cdFx0dGhpcy5lbWl0KCdjb25uZWN0aW9uc3RhdGUnLCBzdGF0ZUNoYW5nZSk7XG5cdH07XG5cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0ICogQ29ubmVjdGlvbk1hbmFnZXIgY29ubmVjdGlvbiBsaWZlY3ljbGVcblx0ICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnN0YXJ0VHJhbnNpdGlvblRpbWVyID0gZnVuY3Rpb24odHJhbnNpdGlvblN0YXRlKSB7XG5cdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuc3RhcnRUcmFuc2l0aW9uVGltZXIoKScsICd0cmFuc2l0aW9uU3RhdGU6ICcgKyB0cmFuc2l0aW9uU3RhdGUuc3RhdGUpO1xuXG5cdFx0aWYodGhpcy50cmFuc2l0aW9uVGltZXIpIHtcblx0XHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnN0YXJ0VHJhbnNpdGlvblRpbWVyKCknLCAnY2xlYXJpbmcgYWxyZWFkeS1ydW5uaW5nIHRpbWVyJyk7XG5cdFx0XHRjbGVhclRpbWVvdXQodGhpcy50cmFuc2l0aW9uVGltZXIpO1xuXHRcdH1cblxuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHR0aGlzLnRyYW5zaXRpb25UaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRpZihzZWxmLnRyYW5zaXRpb25UaW1lcikge1xuXHRcdFx0XHRzZWxmLnRyYW5zaXRpb25UaW1lciA9IG51bGw7XG5cdFx0XHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyICcgKyB0cmFuc2l0aW9uU3RhdGUuc3RhdGUgKyAnIHRpbWVyIGV4cGlyZWQnLCAncmVxdWVzdGluZyBuZXcgc3RhdGU6ICcgKyB0cmFuc2l0aW9uU3RhdGUuZmFpbFN0YXRlKTtcblx0XHRcdFx0c2VsZi5ub3RpZnlTdGF0ZSh7c3RhdGU6IHRyYW5zaXRpb25TdGF0ZS5mYWlsU3RhdGV9KTtcblx0XHRcdH1cblx0XHR9LCB0cmFuc2l0aW9uU3RhdGUucmV0cnlEZWxheSk7XG5cdH07XG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNhbmNlbFRyYW5zaXRpb25UaW1lciA9IGZ1bmN0aW9uKCkge1xuXHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmNhbmNlbFRyYW5zaXRpb25UaW1lcigpJywgJycpO1xuXHRcdGlmKHRoaXMudHJhbnNpdGlvblRpbWVyKSB7XG5cdFx0XHRjbGVhclRpbWVvdXQodGhpcy50cmFuc2l0aW9uVGltZXIpO1xuXHRcdFx0dGhpcy50cmFuc2l0aW9uVGltZXIgPSBudWxsO1xuXHRcdH1cblx0fTtcblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuc3RhcnRTdXNwZW5kVGltZXIgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0aWYodGhpcy5zdXNwZW5kVGltZXIpXG5cdFx0XHRyZXR1cm47XG5cdFx0dGhpcy5zdXNwZW5kVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYoc2VsZi5zdXNwZW5kVGltZXIpIHtcblx0XHRcdFx0c2VsZi5zdXNwZW5kVGltZXIgPSBudWxsO1xuXHRcdFx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlciBzdXNwZW5kIHRpbWVyIGV4cGlyZWQnLCAncmVxdWVzdGluZyBuZXcgc3RhdGU6IHN1c3BlbmRlZCcpO1xuXHRcdFx0XHRzZWxmLnN0YXRlcy5jb25uZWN0aW5nLmZhaWxTdGF0ZSA9ICdzdXNwZW5kZWQnO1xuXHRcdFx0XHRzZWxmLnN0YXRlcy5jb25uZWN0aW5nLnF1ZXVlRXZlbnRzID0gZmFsc2U7XG5cdFx0XHRcdHNlbGYubm90aWZ5U3RhdGUoe3N0YXRlOiAnc3VzcGVuZGVkJ30pO1xuXHRcdFx0fVxuXHRcdH0sIHRoaXMuY29ubmVjdGlvblN0YXRlVHRsKTtcblx0fTtcblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY2hlY2tTdXNwZW5kVGltZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuXHRcdGlmKHN0YXRlICE9PSAnZGlzY29ubmVjdGVkJyAmJiBzdGF0ZSAhPT0gJ3N1c3BlbmRlZCcgJiYgc3RhdGUgIT09ICdjb25uZWN0aW5nJylcblx0XHRcdHRoaXMuY2FuY2VsU3VzcGVuZFRpbWVyKCk7XG5cdH07XG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNhbmNlbFN1c3BlbmRUaW1lciA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuc3RhdGVzLmNvbm5lY3RpbmcuZmFpbFN0YXRlID0gJ2Rpc2Nvbm5lY3RlZCc7XG5cdFx0dGhpcy5zdGF0ZXMuY29ubmVjdGluZy5xdWV1ZUV2ZW50cyA9IHRydWU7XG5cdFx0aWYodGhpcy5zdXNwZW5kVGltZXIpIHtcblx0XHRcdGNsZWFyVGltZW91dCh0aGlzLnN1c3BlbmRUaW1lcik7XG5cdFx0XHR0aGlzLnN1c3BlbmRUaW1lciA9IG51bGw7XG5cdFx0fVxuXHR9O1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zdGFydFJldHJ5VGltZXIgPSBmdW5jdGlvbihpbnRlcnZhbCkge1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHR0aGlzLnJldHJ5VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIgcmV0cnkgdGltZXIgZXhwaXJlZCcsICdyZXRyeWluZycpO1xuXHRcdFx0c2VsZi5yZXRyeVRpbWVyID0gbnVsbDtcblx0XHRcdHNlbGYucmVxdWVzdFN0YXRlKHtzdGF0ZTogJ2Nvbm5lY3RpbmcnfSk7XG5cdFx0fSwgaW50ZXJ2YWwpO1xuXHR9O1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jYW5jZWxSZXRyeVRpbWVyID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYodGhpcy5yZXRyeVRpbWVyKSB7XG5cdFx0XHRjbGVhclRpbWVvdXQodGhpcy5yZXRyeVRpbWVyKTtcblx0XHRcdHRoaXMucmV0cnlUaW1lciA9IG51bGw7XG5cdFx0fVxuXHR9O1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5ub3RpZnlTdGF0ZSA9IGZ1bmN0aW9uKGluZGljYXRlZCkge1xuXHRcdHZhciBzdGF0ZSA9IGluZGljYXRlZC5zdGF0ZSxcblx0XHRcdHNlbGYgPSB0aGlzO1xuXG5cdFx0LyogV2UgcmV0cnkgaW1tZWRpYXRlbHkgaWY6XG5cdFx0ICogLSBzb21ldGhpbmcgZGlzY29ubmVjdHMgdXMgd2hpbGUgd2UncmUgY29ubmVjdGVkLCBvclxuXHRcdCAqIC0gYSB2aWFibGUgKGJ1dCBub3QgeWV0IGFjdGl2ZSkgdHJhbnNwb3J0IGZhaWxzIGR1ZSB0byBhIHRva2VuIGVycm9yIChzb1xuXHRcdCAqICAgdGhpcy5lcnJvclJlYXNvbiB3aWxsIGJlIHNldCwgYW5kIHN0YXJ0Q29ubmVjdCB3aWxsIGRvIGEgZm9yY2VkIGF1dGhvcml6ZSkgKi9cblx0XHR2YXIgcmV0cnlJbW1lZGlhdGVseSA9IChzdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RlZCcgJiZcblx0XHRcdCh0aGlzLnN0YXRlID09PSB0aGlzLnN0YXRlcy5jb25uZWN0ZWQgICAgIHx8XG5cdFx0XHQgdGhpcy5zdGF0ZSA9PT0gdGhpcy5zdGF0ZXMuc3luY2hyb25pemluZyB8fFxuXHRcdFx0XHQodGhpcy5zdGF0ZSA9PT0gdGhpcy5zdGF0ZXMuY29ubmVjdGluZyAgJiZcblx0XHRcdFx0XHRpbmRpY2F0ZWQuZXJyb3IgJiYgQXV0aC5pc1Rva2VuRXJyKGluZGljYXRlZC5lcnJvcikpKSk7XG5cblx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5ub3RpZnlTdGF0ZSgpJywgJ25ldyBzdGF0ZTogJyArIHN0YXRlICsgKHJldHJ5SW1tZWRpYXRlbHkgPyAnOyB3aWxsIHJldHJ5IGNvbm5lY3Rpb24gaW1tZWRpYXRlbHknIDogJycpKTtcblx0XHQvKiBkbyBub3RoaW5nIGlmIHdlJ3JlIGFscmVhZHkgaW4gdGhlIGluZGljYXRlZCBzdGF0ZSAqL1xuXHRcdGlmKHN0YXRlID09IHRoaXMuc3RhdGUuc3RhdGUpXG5cdFx0XHRyZXR1cm47XG5cblx0XHQvKiBraWxsIHRpbWVycyAocG9zc2libHkgZXhjZXB0aW5nIHN1c3BlbmQgdGltZXIgZGVwZW5kaW5nIG9uIHRoZSBub3RpZmllZFxuXHRcdCogc3RhdGUpLCBhcyB0aGVzZSBhcmUgc3VwZXJzZWRlZCBieSB0aGlzIG5vdGlmaWNhdGlvbiAqL1xuXHRcdHRoaXMuY2FuY2VsVHJhbnNpdGlvblRpbWVyKCk7XG5cdFx0dGhpcy5jYW5jZWxSZXRyeVRpbWVyKCk7XG5cdFx0dGhpcy5jaGVja1N1c3BlbmRUaW1lcihpbmRpY2F0ZWQuc3RhdGUpO1xuXG5cdFx0LyogZG8gbm90aGluZyBpZiB3ZSdyZSB1bmFibGUgdG8gbW92ZSBmcm9tIHRoZSBjdXJyZW50IHN0YXRlICovXG5cdFx0aWYodGhpcy5zdGF0ZS50ZXJtaW5hbClcblx0XHRcdHJldHVybjtcblxuXHRcdC8qIHByb2Nlc3MgbmV3IHN0YXRlICovXG5cdFx0dmFyIG5ld1N0YXRlID0gdGhpcy5zdGF0ZXNbaW5kaWNhdGVkLnN0YXRlXSxcblx0XHRcdGNoYW5nZSA9IG5ldyBDb25uZWN0aW9uU3RhdGVDaGFuZ2UodGhpcy5zdGF0ZS5zdGF0ZSwgbmV3U3RhdGUuc3RhdGUsIG5ld1N0YXRlLnJldHJ5RGVsYXksIChpbmRpY2F0ZWQuZXJyb3IgfHwgQ29ubmVjdGlvbkVycm9yW25ld1N0YXRlLnN0YXRlXSkpO1xuXG5cdFx0aWYocmV0cnlJbW1lZGlhdGVseSkge1xuXHRcdFx0dmFyIGF1dG9SZWNvbm5lY3QgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYoc2VsZi5zdGF0ZSA9PT0gc2VsZi5zdGF0ZXMuZGlzY29ubmVjdGVkKSB7XG5cdFx0XHRcdFx0c2VsZi5sYXN0QXV0b1JlY29ubmVjdEF0dGVtcHQgPSBVdGlscy5ub3coKTtcblx0XHRcdFx0XHRzZWxmLnJlcXVlc3RTdGF0ZSh7c3RhdGU6ICdjb25uZWN0aW5nJ30pO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0dmFyIHNpbmNlTGFzdCA9IHRoaXMubGFzdEF1dG9SZWNvbm5lY3RBdHRlbXB0ICYmIChVdGlscy5ub3coKSAtIHRoaXMubGFzdEF1dG9SZWNvbm5lY3RBdHRlbXB0ICsgMSk7XG5cdFx0XHRpZihzaW5jZUxhc3QgJiYgKHNpbmNlTGFzdCA8IDEwMDApKSB7XG5cdFx0XHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLm5vdGlmeVN0YXRlKCknLCAnTGFzdCByZWNvbm5lY3QgYXR0ZW1wdCB3YXMgb25seSAnICsgc2luY2VMYXN0ICsgJ21zIGFnbywgd2FpdGluZyBhbm90aGVyICcgKyAoMTAwMCAtIHNpbmNlTGFzdCkgKyAnbXMgYmVmb3JlIHRyeWluZyBhZ2FpbicpO1xuXHRcdFx0XHRzZXRUaW1lb3V0KGF1dG9SZWNvbm5lY3QsIDEwMDAgLSBzaW5jZUxhc3QpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0VXRpbHMubmV4dFRpY2soYXV0b1JlY29ubmVjdCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmKHN0YXRlID09PSAnZGlzY29ubmVjdGVkJyB8fCBzdGF0ZSA9PT0gJ3N1c3BlbmRlZCcpIHtcblx0XHRcdHRoaXMuc3RhcnRSZXRyeVRpbWVyKG5ld1N0YXRlLnJldHJ5RGVsYXkpO1xuXHRcdH1cblxuXHRcdCAvKiBJZiBnb2luZyBpbnRvIGRpc2Nvbm5lY3Qvc3VzcGVuZGVkIChhbmQgbm90IHJldHJ5aW5nIGltbWVkaWF0ZWx5KSwgb3IgYVxuXHRcdFx0KiB0ZXJtaW5hbCBzdGF0ZSwgZW5zdXJlIHRoZXJlIGFyZSBubyBvcnBoYW5lZCB0cmFuc3BvcnRzIGhhbmdpbmcgYXJvdW5kLiAqL1xuXHRcdGlmKChzdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RlZCcgJiYgIXJldHJ5SW1tZWRpYXRlbHkpIHx8XG5cdFx0XHQgKHN0YXRlID09PSAnc3VzcGVuZGVkJykgfHxcblx0XHRcdCBuZXdTdGF0ZS50ZXJtaW5hbCkge1xuXHRcdFx0XHQgLyogV2FpdCB0aWxsIHRoZSBuZXh0IHRpY2sgc28gdGhlIGNvbm5lY3Rpb24gc3RhdGUgY2hhbmdlIGlzIGVuYWN0ZWQsXG5cdFx0XHRcdCAqIHNvIGFib3J0aW5nIHRyYW5zcG9ydHMgZG9lc24ndCB0cmlnZ2VyIHJlZHVuZGFudCBzdGF0ZSBjaGFuZ2VzICovXG5cdFx0XHRcdCBVdGlscy5uZXh0VGljayhmdW5jdGlvbigpIHtcblx0XHRcdFx0XHQgc2VsZi5kaXNjb25uZWN0QWxsVHJhbnNwb3J0cygpO1xuXHRcdFx0XHQgfSk7XG5cdFx0IH1cblxuXHRcdGlmKHN0YXRlID09ICdjb25uZWN0ZWQnICYmICF0aGlzLmFjdGl2ZVByb3RvY29sKSB7XG5cdFx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfRVJST1IsICdDb25uZWN0aW9uTWFuYWdlci5ub3RpZnlTdGF0ZSgpJywgJ0Jyb2tlbiBpbnZhcmlhbnQ6IGF0dGVtcHRlZCB0byBnbyBpbnRvIGNvbm5lY3RlZCBzdGF0ZSwgYnV0IHRoZXJlIGlzIG5vIGFjdGl2ZSBwcm90b2NvbCcpO1xuXHRcdH1cblxuXHRcdC8qIGltcGxlbWVudCB0aGUgY2hhbmdlIGFuZCBub3RpZnkgKi9cblx0XHR0aGlzLmVuYWN0U3RhdGVDaGFuZ2UoY2hhbmdlKTtcblx0XHRpZih0aGlzLnN0YXRlLnNlbmRFdmVudHMpIHtcblx0XHRcdHRoaXMuc2VuZFF1ZXVlZE1lc3NhZ2VzKCk7XG5cdFx0fSBlbHNlIGlmKCF0aGlzLnN0YXRlLnF1ZXVlRXZlbnRzKSB7XG5cdFx0XHR0aGlzLnJlYWx0aW1lLmNoYW5uZWxzLnByb3BvZ2F0ZUNvbm5lY3Rpb25JbnRlcnJ1cHRpb24oc3RhdGUsIGNoYW5nZS5yZWFzb24pO1xuXHRcdFx0dGhpcy5mYWlsUXVldWVkTWVzc2FnZXMoY2hhbmdlLnJlYXNvbik7IC8vIFJUTjdjXG5cdFx0fVxuXHR9O1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5yZXF1ZXN0U3RhdGUgPSBmdW5jdGlvbihyZXF1ZXN0KSB7XG5cdFx0dmFyIHN0YXRlID0gcmVxdWVzdC5zdGF0ZSwgc2VsZiA9IHRoaXM7XG5cdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIucmVxdWVzdFN0YXRlKCknLCAncmVxdWVzdGVkIHN0YXRlOiAnICsgc3RhdGUgKyAnOyBjdXJyZW50IHN0YXRlOiAnICsgdGhpcy5zdGF0ZS5zdGF0ZSk7XG5cdFx0aWYoc3RhdGUgPT0gdGhpcy5zdGF0ZS5zdGF0ZSlcblx0XHRcdHJldHVybjsgLyogc2lsZW50bHkgZG8gbm90aGluZyAqL1xuXG5cdFx0Lyoga2lsbCBydW5uaW5nIHRpbWVycywgYXMgdGhpcyByZXF1ZXN0IHN1cGVyc2VkZXMgdGhlbSAqL1xuXHRcdHRoaXMuY2FuY2VsVHJhbnNpdGlvblRpbWVyKCk7XG5cdFx0dGhpcy5jYW5jZWxSZXRyeVRpbWVyKCk7XG5cdFx0LyogZm9yIHN1c3BlbmQgdGltZXIgY2hlY2sgcmF0aGVyIHRoYW4gY2FuY2VsIC0tIGVnIHJlcXVlc3RpbmcgYSBjb25uZWN0aW5nXG5cdFx0KiBzdGF0ZSBzaG91bGQgbm90IHJlc2V0IHRoZSBzdXNwZW5kIHRpbWVyICovXG5cdFx0dGhpcy5jaGVja1N1c3BlbmRUaW1lcihzdGF0ZSk7XG5cblx0XHRpZihzdGF0ZSA9PSAnY29ubmVjdGluZycgJiYgdGhpcy5zdGF0ZS5zdGF0ZSA9PSAnY29ubmVjdGVkJykgcmV0dXJuO1xuXHRcdGlmKHN0YXRlID09ICdjbG9zaW5nJyAmJiB0aGlzLnN0YXRlLnN0YXRlID09ICdjbG9zZWQnKSByZXR1cm47XG5cblx0XHR2YXIgbmV3U3RhdGUgPSB0aGlzLnN0YXRlc1tzdGF0ZV0sXG5cdFx0XHRjaGFuZ2UgPSBuZXcgQ29ubmVjdGlvblN0YXRlQ2hhbmdlKHRoaXMuc3RhdGUuc3RhdGUsIG5ld1N0YXRlLnN0YXRlLCBudWxsLCAocmVxdWVzdC5lcnJvciB8fCBDb25uZWN0aW9uRXJyb3JbbmV3U3RhdGUuc3RhdGVdKSk7XG5cblx0XHR0aGlzLmVuYWN0U3RhdGVDaGFuZ2UoY2hhbmdlKTtcblxuXHRcdGlmKHN0YXRlID09ICdjb25uZWN0aW5nJykge1xuXHRcdFx0VXRpbHMubmV4dFRpY2soZnVuY3Rpb24oKSB7IHNlbGYuc3RhcnRDb25uZWN0KCk7IH0pO1xuXHRcdH1cblx0XHRpZihzdGF0ZSA9PSAnY2xvc2luZycpIHtcblx0XHRcdHRoaXMuY2xvc2VJbXBsKCk7XG5cdFx0fVxuXHR9O1xuXG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnN0YXJ0Q29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmKHRoaXMuc3RhdGUgIT09IHRoaXMuc3RhdGVzLmNvbm5lY3RpbmcpIHtcblx0XHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnN0YXJ0Q29ubmVjdCgpJywgJ011c3QgYmUgaW4gY29ubmVjdGluZyBzdGF0ZSB0byBjb25uZWN0LCBidXQgd2FzICcgKyB0aGlzLnN0YXRlLnN0YXRlKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgYXV0aCA9IHRoaXMucmVhbHRpbWUuYXV0aCxcblx0XHRcdHNlbGYgPSB0aGlzO1xuXG5cdFx0dmFyIGNvbm5lY3QgPSBmdW5jdGlvbigpIHtcblx0XHRcdHNlbGYuY2hlY2tDb25uZWN0aW9uU3RhdGVGcmVzaG5lc3MoKTtcblx0XHRcdHNlbGYuZ2V0VHJhbnNwb3J0UGFyYW1zKGZ1bmN0aW9uKHRyYW5zcG9ydFBhcmFtcykge1xuXHRcdFx0XHRzZWxmLmNvbm5lY3RJbXBsKHRyYW5zcG9ydFBhcmFtcyk7XG5cdFx0XHR9KTtcblx0XHR9O1xuXG5cdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuc3RhcnRDb25uZWN0KCknLCAnc3RhcnRpbmcgY29ubmVjdGlvbicpO1xuXHRcdHRoaXMuc3RhcnRTdXNwZW5kVGltZXIoKTtcblx0XHR0aGlzLnN0YXJ0VHJhbnNpdGlvblRpbWVyKHRoaXMuc3RhdGVzLmNvbm5lY3RpbmcpO1xuXG5cdFx0aWYoYXV0aC5tZXRob2QgPT09ICdiYXNpYycpIHtcblx0XHRcdGNvbm5lY3QoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGF1dGhDYiA9IGZ1bmN0aW9uKGVycikge1xuXHRcdFx0XHRpZihlcnIpIHtcblx0XHRcdFx0XHRzZWxmLmFjdE9uRXJyb3JGcm9tQXV0aG9yaXplKGVycik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29ubmVjdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0aWYodGhpcy5lcnJvclJlYXNvbiAmJiBBdXRoLmlzVG9rZW5FcnIodGhpcy5lcnJvclJlYXNvbikpIHtcblx0XHRcdFx0LyogRm9yY2UgYSByZWZldGNoIG9mIGEgbmV3IHRva2VuICovXG5cdFx0XHRcdGF1dGguX2ZvcmNlTmV3VG9rZW4obnVsbCwgbnVsbCwgYXV0aENiKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGF1dGguX2Vuc3VyZVZhbGlkQXV0aENyZWRlbnRpYWxzKGF1dGhDYik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cblx0LyoqXG5cdCAqIFRoZXJlIGFyZSB0aHJlZSBzdGFnZXMgaW4gY29ubmVjdGluZzpcblx0ICogLSBwcmVmZXJlbmNlOiBpZiB0aGVyZSBpcyBhIGNhY2hlZCB0cmFuc3BvcnQgcHJlZmVyZW5jZSwgd2UgdHJ5IHRvIGNvbm5lY3Rcblx0ICogICBvbiB0aGF0LiBJZiB0aGF0IGZhaWxzIG9yIHRpbWVzIG91dCB3ZSBhYm9ydCB0aGUgYXR0ZW1wdCwgcmVtb3ZlIHRoZVxuXHQgKiAgIHByZWZlcmVuY2UgYW5kIGZhbGwgYmFjayB0byBiYXNlLiBJZiBpdCBzdWNjZWVkcywgd2UgdHJ5IHVwZ3JhZGluZyBpdCBpZlxuXHQgKiAgIG5lZWRlZCAod2lsbCBvbmx5IGJlIGluIHRoZSBjYXNlIHdoZXJlIHRoZSBwcmVmZXJlbmNlIGlzIHhocnMgYW5kIHRoZVxuXHQgKiAgIGJyb3dzZXIgc3VwcG9ydHMgd3MpLlxuXHQgKiAtIGJhc2U6IHdlIHRyeSB0byBjb25uZWN0IHdpdGggdGhlIGJlc3QgdHJhbnNwb3J0IHRoYXQgd2UgdGhpbmsgd2lsbFxuXHQgKiAgIG5ldmVyIGZhaWwgZm9yIHRoaXMgYnJvd3NlciAodXN1YWxseSB0aGlzIGlzIHhocl9wb2xsaW5nOyBmb3IgdmVyeSBvbGRcblx0ICogICBicm93c2VycyB3aWxsIGJlIGpzb25wLCBmb3Igbm9kZSB3aWxsIGJlIGNvbWV0KS4gSWYgaXQgZG9lc24ndCB3b3JrLCB3ZVxuXHQgKiAgIHRyeSBmYWxsYmFjayBob3N0cy5cblx0ICogLSB1cGdyYWRlOiBnaXZlbiBhIGNvbm5lY3RlZCB0cmFuc3BvcnQsIHdlIHNlZSBpZiB0aGVyZSBhcmUgYW55IGJldHRlclxuXHQgKiAgIG9uZXMsIGFuZCBpZiBzbywgdHJ5IHRvIHVwZ3JhZGUgdG8gdGhlbS5cblx0ICpcblx0ICogY29ubmVjdEltcGwgd29ya3Mgb3V0IHdoYXQgc3RhZ2UgeW91J3JlIGF0ICh3aGljaCBpcyBwdXJlbHkgYSBmdW5jdGlvbiBvZlxuXHQgKiB0aGUgY3VycmVudCBjb25uZWN0aW9uIHN0YXRlIGFuZCB3aGV0aGVyIHRoZXJlIGFyZSBhbnkgc3RvcmVkIHByZWZlcmVuY2VzKSxcblx0ICogYW5kIGRpc3BhdGNoZXMgYWNjb3JkaW5nbHkuIEFmdGVyIGEgdHJhbnNwb3J0IGhhcyBiZWVuIHNldCBwZW5kaW5nLFxuXHQgKiB0cnlBVHJhbnNwb3J0IGNhbGxzIGNvbm5lY3RJbXBsIHRvIHNlZSBpZiB0aGVyZSdzIGFub3RoZXIgc3RhZ2UgdG8gYmUgZG9uZS5cblx0ICogKi9cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNvbm5lY3RJbXBsID0gZnVuY3Rpb24odHJhbnNwb3J0UGFyYW1zKSB7XG5cdFx0dmFyIHN0YXRlID0gdGhpcy5zdGF0ZS5zdGF0ZTtcblxuXHRcdGlmKHN0YXRlICE9PSB0aGlzLnN0YXRlcy5jb25uZWN0aW5nLnN0YXRlICYmIHN0YXRlICE9PSB0aGlzLnN0YXRlcy5jb25uZWN0ZWQuc3RhdGUpIHtcblx0XHRcdC8qIE9ubHkga2VlcCB0cnlpbmcgYXMgbG9uZyBhcyBpbiB0aGUgJ2Nvbm5lY3RpbmcnIHN0YXRlIChvciAnY29ubmVjdGVkJ1xuXHRcdFx0ICogZm9yIHVwZ3JhZGluZykuIEFueSBvcGVyYXRpb24gY2FuIHB1dCB1cyBpbnRvICdkaXNjb25uZWN0ZWQnIHRvIGNhbmNlbFxuXHRcdFx0ICogY29ubmVjdGlvbiBhdHRlbXB0cyBhbmQgd2FpdCBiZWZvcmUgcmV0cnlpbmcsIG9yICdmYWlsZWQnIHRvIGZhaWwuICovXG5cdFx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5jb25uZWN0SW1wbCgpJywgJ011c3QgYmUgaW4gY29ubmVjdGluZyBzdGF0ZSB0byBjb25uZWN0IChvciBjb25uZWN0ZWQgdG8gdXBncmFkZSksIGJ1dCB3YXMgJyArIHN0YXRlKTtcblx0XHR9IGVsc2UgaWYodGhpcy5wZW5kaW5nVHJhbnNwb3J0cy5sZW5ndGgpIHtcblx0XHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3RJbXBsKCknLCAnVHJhbnNwb3J0cyAnICsgdGhpcy5wZW5kaW5nVHJhbnNwb3J0c1swXS50b1N0cmluZygpICsgJyBjdXJyZW50bHkgcGVuZGluZzsgdGFraW5nIG5vIGFjdGlvbicpO1xuXHRcdH0gZWxzZSBpZihzdGF0ZSA9PSB0aGlzLnN0YXRlcy5jb25uZWN0ZWQuc3RhdGUpIHtcblx0XHRcdHRoaXMudXBncmFkZUlmTmVlZGVkKHRyYW5zcG9ydFBhcmFtcyk7XG5cdFx0fSBlbHNlIGlmKHRoaXMudHJhbnNwb3J0cy5sZW5ndGggPiAxICYmIHRoaXMuZ2V0VHJhbnNwb3J0UHJlZmVyZW5jZSgpKSB7XG5cdFx0XHR0aGlzLmNvbm5lY3RQcmVmZXJlbmNlKHRyYW5zcG9ydFBhcmFtcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuY29ubmVjdEJhc2UodHJhbnNwb3J0UGFyYW1zKTtcblx0XHR9XG5cdH07XG5cblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY29ubmVjdFByZWZlcmVuY2UgPSBmdW5jdGlvbih0cmFuc3BvcnRQYXJhbXMpIHtcblx0XHR2YXIgcHJlZmVyZW5jZSA9IHRoaXMuZ2V0VHJhbnNwb3J0UHJlZmVyZW5jZSgpLFxuXHRcdFx0c2VsZiA9IHRoaXMsXG5cdFx0XHRwcmVmZXJlbmNlVGltZW91dEV4cGlyZWQgPSBmYWxzZTtcblxuXHRcdGlmKCFVdGlscy5hcnJJbih0aGlzLnRyYW5zcG9ydHMsIHByZWZlcmVuY2UpKSB7XG5cdFx0XHR0aGlzLnVucGVyc2lzdFRyYW5zcG9ydFByZWZlcmVuY2UoKTtcblx0XHRcdHRoaXMuY29ubmVjdEltcGwodHJhbnNwb3J0UGFyYW1zKTtcblx0XHR9XG5cblx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5jb25uZWN0UHJlZmVyZW5jZSgpJywgJ1RyeWluZyB0byBjb25uZWN0IHdpdGggc3RvcmVkIHRyYW5zcG9ydCBwcmVmZXJlbmNlICcgKyBwcmVmZXJlbmNlKTtcblxuXHRcdHZhciBwcmVmZXJlbmNlVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRwcmVmZXJlbmNlVGltZW91dEV4cGlyZWQgPSB0cnVlO1xuXHRcdFx0aWYoIShzZWxmLnN0YXRlLnN0YXRlID09PSBzZWxmLnN0YXRlcy5jb25uZWN0ZWQuc3RhdGUpKSB7XG5cdFx0XHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3RQcmVmZXJlbmNlKCknLCAnU2hvcnRjaXJjdWl0IGNvbm5lY3Rpb24gYXR0ZW1wdCB3aXRoICcgKyBwcmVmZXJlbmNlICsgJyBmYWlsZWQ7IGNsZWFyaW5nIHByZWZlcmVuY2UgYW5kIHRyeWluZyBmcm9tIHNjcmF0Y2gnKTtcblx0XHRcdFx0LyogQWJvcnQgYWxsIGNvbm5lY3Rpb24gYXR0ZW1wdHMuIChUaGlzIGFsc28gZGlzY29ubmVjdHMgdGhlIGFjdGl2ZVxuXHRcdFx0XHQgKiBwcm90b2NvbCwgYnV0IG5vbmUgZXhpc3RzIGlmIHdlJ3JlIG5vdCBpbiB0aGUgY29ubmVjdGVkIHN0YXRlKSAqL1xuXHRcdFx0XHRzZWxmLmRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzKCk7XG5cdFx0XHRcdC8qIEJlIHF1aXRlIGFncmVzc2l2ZSBhYm91dCBjbGVhcmluZyB0aGUgc3RvcmVkIHByZWZlcmVuY2UgaWYgZXZlciBpdCBkb2Vzbid0IHdvcmsgKi9cblx0XHRcdFx0c2VsZi51bnBlcnNpc3RUcmFuc3BvcnRQcmVmZXJlbmNlKCk7XG5cdFx0XHR9XG5cdFx0XHRzZWxmLmNvbm5lY3RJbXBsKHRyYW5zcG9ydFBhcmFtcyk7XG5cdFx0fSwgdGhpcy5vcHRpb25zLnRpbWVvdXRzLnByZWZlcmVuY2VDb25uZWN0VGltZW91dCk7XG5cblx0XHQvKiBGb3IgY29ubmVjdFByZWZlcmVuY2UsIGp1c3QgdXNlIHRoZSBtYWluIGhvc3QuIElmIGhvc3QgZmFsbGJhY2sgaXMgbmVlZGVkLCBkbyBpdCBpbiBjb25uZWN0QmFzZS5cblx0XHQgKiBUaGUgd3N0cmFuc3BvcnQgaXQgd2lsbCBzdWJzdGl0dXRlIHRoZSBodHRwaG9zdCBmb3IgYW4gYXBwcm9wcmlhdGUgd3Nob3N0ICovXG5cdFx0dHJhbnNwb3J0UGFyYW1zLmhvc3QgPSBzZWxmLmh0dHBIb3N0c1swXTtcblx0XHRzZWxmLnRyeUFUcmFuc3BvcnQodHJhbnNwb3J0UGFyYW1zLCBwcmVmZXJlbmNlLCBmdW5jdGlvbihmYXRhbCwgdHJhbnNwb3J0KSB7XG5cdFx0XHRjbGVhclRpbWVvdXQocHJlZmVyZW5jZVRpbWVvdXQpO1xuXHRcdFx0aWYocHJlZmVyZW5jZVRpbWVvdXRFeHBpcmVkICYmIHRyYW5zcG9ydCkge1xuXHRcdFx0XHQvKiBWaWFibGUsIGJ1dCB0b28gbGF0ZSAtIGNvbm5lY3RJbXBsKCkgd2lsbCBhbHJlYWR5IGJlIHRyeWluZ1xuXHRcdFx0XHQqIGNvbm5lY3RCYXNlLCBhbmQgd2Ugd2VyZW4ndCBpbiB1cGdyYWRlIG1vZGUuIEp1c3QgcmVtb3ZlIHRoZVxuXHRcdFx0XHQqIG9uY29ubmVjdGVkIGxpc3RlbmVyIGFuZCBnZXQgcmlkIG9mIGl0ICovXG5cdFx0XHRcdHRyYW5zcG9ydC5vZmYoKTtcblx0XHRcdFx0dHJhbnNwb3J0LmRpc2Nvbm5lY3QoKTtcblx0XHRcdFx0VXRpbHMuYXJyRGVsZXRlVmFsdWUodGhpcy5wZW5kaW5nVHJhbnNwb3J0cywgdHJhbnNwb3J0KTtcblx0XHRcdH0gZWxzZSBpZighdHJhbnNwb3J0ICYmICFmYXRhbCkge1xuXHRcdFx0XHQvKiBQcmVmZXJlbmNlIGZhaWxlZCBpbiBhIHRyYW5zcG9ydC1zcGVjaWZpYyB3YXkuIFRyeSBtb3JlICovXG5cdFx0XHRcdHNlbGYudW5wZXJzaXN0VHJhbnNwb3J0UHJlZmVyZW5jZSgpO1xuXHRcdFx0XHRzZWxmLmNvbm5lY3RJbXBsKHRyYW5zcG9ydFBhcmFtcyk7XG5cdFx0XHR9XG5cdFx0XHQvKiBJZiBzdWNlZWRlZCwgb3IgZmFpbGVkIGZhdGFsbHksIG5vdGhpbmcgdG8gZG8gKi9cblx0XHR9KTtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBUcnkgdG8gZXN0YWJsaXNoIGEgdHJhbnNwb3J0IG9uIHRoZSBiYXNlIHRyYW5zcG9ydCAodGhlIGJlc3QgdHJhbnNwb3J0XG5cdCAqIHN1Y2ggdGhhdCBpZiBpdCBkb2Vzbid0IHdvcmssIG5vdGhpbmcgd2lsbCB3b3JrKSBhcyBkZXRlcm1pbmVkIHRocm91Z2hcblx0ICogc3RhdGljIGZlYXR1cmUgZGV0ZWN0aW9uLCBjaGVja2luZyBmb3IgbmV0d29yayBjb25uZWN0aXZpdHkgYW5kIHRyeWluZ1xuXHQgKiBmYWxsYmFjayBob3N0cyBpZiBhcHBsaWNhYmxlLlxuXHQgKiBAcGFyYW0gdHJhbnNwb3J0UGFyYW1zXG5cdCAqL1xuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY29ubmVjdEJhc2UgPSBmdW5jdGlvbih0cmFuc3BvcnRQYXJhbXMpIHtcblx0XHR2YXIgc2VsZiA9IHRoaXMsXG5cdFx0XHRnaXZlVXAgPSBmdW5jdGlvbihlcnIpIHtcblx0XHRcdFx0c2VsZi5ub3RpZnlTdGF0ZSh7c3RhdGU6IHNlbGYuc3RhdGVzLmNvbm5lY3RpbmcuZmFpbFN0YXRlLCBlcnJvcjogZXJyfSk7XG5cdFx0XHR9LFxuXHRcdFx0Y2FuZGlkYXRlSG9zdHMgPSB0aGlzLmh0dHBIb3N0cy5zbGljZSgpLFxuXHRcdFx0aG9zdEF0dGVtcHRDYiA9IGZ1bmN0aW9uKGZhdGFsLCB0cmFuc3BvcnQpIHtcblx0XHRcdFx0aWYoIXRyYW5zcG9ydCAmJiAhZmF0YWwpIHtcblx0XHRcdFx0XHR0cnlGYWxsYmFja0hvc3RzKCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5jb25uZWN0QmFzZSgpJywgJ1RyeWluZyB0byBjb25uZWN0IHdpdGggYmFzZSB0cmFuc3BvcnQgJyArIHRoaXMuYmFzZVRyYW5zcG9ydCk7XG5cblx0XHQvKiBmaXJzdCB0cnkgdG8gZXN0YWJsaXNoIGEgY29ubmVjdGlvbiB3aXRoIHRoZSBwcmlvcml0eSBob3N0IHdpdGggaHR0cCB0cmFuc3BvcnQgKi9cblx0XHR2YXIgaG9zdCA9IGNhbmRpZGF0ZUhvc3RzLnNoaWZ0KCk7XG5cdFx0aWYoIWhvc3QpIHtcblx0XHRcdGdpdmVVcChuZXcgRXJyb3JJbmZvKCdVbmFibGUgdG8gY29ubmVjdCAobm8gYXZhaWxhYmxlIGhvc3QpJywgODAwMDAsIDQwNCkpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0cmFuc3BvcnRQYXJhbXMuaG9zdCA9IGhvc3Q7XG5cblx0XHQvKiB0aGlzIGlzIHdoYXQgd2UnbGwgYmUgZG9pbmcgaWYgdGhlIGF0dGVtcHQgZm9yIHRoZSBtYWluIGhvc3QgZmFpbHMgKi9cblx0XHRmdW5jdGlvbiB0cnlGYWxsYmFja0hvc3RzKCkge1xuXHRcdFx0LyogaWYgdGhlcmUgYXJlbid0IGFueSBmYWxsYmFjayBob3N0cywgZmFpbCAqL1xuXHRcdFx0aWYoIWNhbmRpZGF0ZUhvc3RzLmxlbmd0aCkge1xuXHRcdFx0XHRnaXZlVXAobmV3IEVycm9ySW5mbygnVW5hYmxlIHRvIGNvbm5lY3QgKGFuZCBubyBtb3JlIGZhbGxiYWNrIGhvc3RzIHRvIHRyeSknLCA4MDAwMCwgNDA0KSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdC8qIGJlZm9yZSB0cnlpbmcgYW55IGZhbGxiYWNrIChvciBhbnkgcmVtYWluaW5nIGZhbGxiYWNrKSB3ZSBkZWNpZGUgaWZcblx0XHRcdCAqIHRoZXJlIGlzIGEgcHJvYmxlbSB3aXRoIHRoZSBhYmx5IGhvc3QsIG9yIHRoZXJlIGlzIGEgZ2VuZXJhbCBjb25uZWN0aXZpdHlcblx0XHRcdCAqIHByb2JsZW0gKi9cblx0XHRcdEh0dHAuY2hlY2tDb25uZWN0aXZpdHkoZnVuY3Rpb24oZXJyLCBjb25uZWN0aXZpdHkpIHtcblx0XHRcdFx0Lyogd2Uga25vdyBlcnIgd29uJ3QgaGFwcGVuIGJ1dCBoYW5kbGUgaXQgaGVyZSBhbnl3YXkgKi9cblx0XHRcdFx0aWYoZXJyKSB7XG5cdFx0XHRcdFx0Z2l2ZVVwKGVycik7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKCFjb25uZWN0aXZpdHkpIHtcblx0XHRcdFx0XHQvKiB0aGUgaW50ZXJuZXQgaXNuJ3QgcmVhY2hhYmxlLCBzbyBkb24ndCB0cnkgdGhlIGZhbGxiYWNrIGhvc3RzICovXG5cdFx0XHRcdFx0Z2l2ZVVwKG5ldyBFcnJvckluZm8oJ1VuYWJsZSB0byBjb25uZWN0IChuZXR3b3JrIHVucmVhY2hhYmxlKScsIDgwMDAwLCA0MDQpKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0LyogdGhlIG5ldHdvcmsgaXMgdGhlcmUsIHNvIHRoZXJlJ3MgYSBwcm9ibGVtIHdpdGggdGhlIG1haW4gaG9zdCwgb3Jcblx0XHRcdFx0ICogaXRzIGRucy4gVHJ5IHRoZSBmYWxsYmFjayBob3N0cy4gV2UgY291bGQgdHJ5IHRoZW0gc2ltdWx0YW5lb3VzbHkgYnV0XG5cdFx0XHRcdCAqIHRoYXQgd291bGQgcG90ZW50aWFsbHkgY2F1c2UgYSBodWdlIHNwaWtlIGluIGxvYWQgb24gdGhlIGxvYWQgYmFsYW5jZXIgKi9cblx0XHRcdFx0dHJhbnNwb3J0UGFyYW1zLmhvc3QgPSBVdGlscy5hcnJQb3BSYW5kb21FbGVtZW50KGNhbmRpZGF0ZUhvc3RzKTtcblx0XHRcdFx0c2VsZi50cnlBVHJhbnNwb3J0KHRyYW5zcG9ydFBhcmFtcywgc2VsZi5iYXNlVHJhbnNwb3J0LCBob3N0QXR0ZW1wdENiKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHRoaXMudHJ5QVRyYW5zcG9ydCh0cmFuc3BvcnRQYXJhbXMsIHRoaXMuYmFzZVRyYW5zcG9ydCwgaG9zdEF0dGVtcHRDYik7XG5cdH07XG5cblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuZ2V0VXBncmFkZVBvc3NpYmlsaXRpZXMgPSBmdW5jdGlvbigpIHtcblx0XHQvKiByZXR1cm5zIHRoZSBzdWJzZXQgb2YgdXBncmFkZVRyYW5zcG9ydHMgdG8gdGhlIHJpZ2h0IG9mIHRoZSBjdXJyZW50XG5cdFx0ICogdHJhbnNwb3J0IGluIHVwZ3JhZGVUcmFuc3BvcnRzIChpZiBpdCdzIGluIHRoZXJlIC0gaWYgbm90LCBjdXJyZW50UG9zaXRpb25cblx0XHQgKiB3aWxsIGJlIC0xLCBzbyByZXR1cm4gdXBncmFkZVRyYW5zcG9ydHMuc2xpY2UoMCkgPT0gdXBncmFkZVRyYW5zcG9ydHMgKi9cblx0XHR2YXIgY3VycmVudCA9IHRoaXMuYWN0aXZlUHJvdG9jb2wuZ2V0VHJhbnNwb3J0KCkuc2hvcnROYW1lO1xuXHRcdHZhciBjdXJyZW50UG9zaXRpb24gPSBVdGlscy5hcnJJbmRleE9mKHRoaXMudXBncmFkZVRyYW5zcG9ydHMsIGN1cnJlbnQpO1xuXHRcdHJldHVybiB0aGlzLnVwZ3JhZGVUcmFuc3BvcnRzLnNsaWNlKGN1cnJlbnRQb3NpdGlvbiArIDEpO1xuXHR9O1xuXG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnVwZ3JhZGVJZk5lZWRlZCA9IGZ1bmN0aW9uKHRyYW5zcG9ydFBhcmFtcykge1xuXHRcdHZhciB1cGdyYWRlUG9zc2liaWxpdGllcyA9IHRoaXMuZ2V0VXBncmFkZVBvc3NpYmlsaXRpZXMoKSxcblx0XHRcdHNlbGYgPSB0aGlzO1xuXHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnVwZ3JhZGVJZk5lZWRlZCgpJywgJ3VwZ3JhZGUgcG9zc2liaWxpdGllczogJyArIFV0aWxzLmluc3BlY3QodXBncmFkZVBvc3NpYmlsaXRpZXMpKTtcblxuXHRcdGlmKCF1cGdyYWRlUG9zc2liaWxpdGllcy5sZW5ndGgpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRVdGlscy5hcnJGb3JFYWNoKHVwZ3JhZGVQb3NzaWJpbGl0aWVzLCBmdW5jdGlvbih1cGdyYWRlVHJhbnNwb3J0KSB7XG5cdFx0XHQvKiBOb3RlOiB0aGUgdHJhbnNwb3J0IG1heSBtdXRhdGUgdGhlIHBhcmFtcywgc28gZ2l2ZSBlYWNoIHRyYW5zcG9ydCBhIGZyZXNoIG9uZSAqL1xuXHRcdFx0dmFyIHVwZ3JhZGVUcmFuc3BvcnRQYXJhbXMgPSBuZXcgVHJhbnNwb3J0UGFyYW1zKHNlbGYub3B0aW9ucywgdHJhbnNwb3J0UGFyYW1zLmhvc3QsICd1cGdyYWRlJywgc2VsZi5jb25uZWN0aW9uS2V5KTtcblx0XHRcdHNlbGYudHJ5QVRyYW5zcG9ydCh1cGdyYWRlVHJhbnNwb3J0UGFyYW1zLCB1cGdyYWRlVHJhbnNwb3J0LCBub29wKTtcblx0XHR9KTtcblx0fTtcblxuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jbG9zZUltcGwgPSBmdW5jdGlvbigpIHtcblx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5jbG9zZUltcGwoKScsICdjbG9zaW5nIGNvbm5lY3Rpb24nKTtcblx0XHR0aGlzLmNhbmNlbFN1c3BlbmRUaW1lcigpO1xuXHRcdHRoaXMuc3RhcnRUcmFuc2l0aW9uVGltZXIodGhpcy5zdGF0ZXMuY2xvc2luZyk7XG5cblx0XHRVdGlscy5zYWZlQXJyRm9yRWFjaCh0aGlzLnBlbmRpbmdUcmFuc3BvcnRzLCBmdW5jdGlvbih0cmFuc3BvcnQpIHtcblx0XHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmNsb3NlSW1wbCgpJywgJ0Nsb3NpbmcgcGVuZGluZyB0cmFuc3BvcnQ6ICcgKyB0cmFuc3BvcnQpO1xuXHRcdFx0aWYodHJhbnNwb3J0KSB0cmFuc3BvcnQuY2xvc2UoKTtcblx0XHR9KTtcblxuXHRcdFV0aWxzLnNhZmVBcnJGb3JFYWNoKHRoaXMucHJvcG9zZWRUcmFuc3BvcnRzLCBmdW5jdGlvbih0cmFuc3BvcnQpIHtcblx0XHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmNsb3NlSW1wbCgpJywgJ0Rpc3Bvc2luZyBvZiBwcm9wb3NlZCB0cmFuc3BvcnQ6ICcgKyB0cmFuc3BvcnQpO1xuXHRcdFx0aWYodHJhbnNwb3J0KSB0cmFuc3BvcnQuZGlzcG9zZSgpO1xuXHRcdH0pO1xuXG5cdFx0aWYodGhpcy5hY3RpdmVQcm90b2NvbCkge1xuXHRcdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuY2xvc2VJbXBsKCknLCAnQ2xvc2luZyBhY3RpdmUgdHJhbnNwb3J0OiAnICsgdGhpcy5hY3RpdmVQcm90b2NvbC5nZXRUcmFuc3BvcnQoKSk7XG5cdFx0XHR0aGlzLmFjdGl2ZVByb3RvY29sLmdldFRyYW5zcG9ydCgpLmNsb3NlKCk7XG5cdFx0fVxuXG5cdFx0LyogSWYgdGhlcmUgd2FzIGFuIGFjdGl2ZSB0cmFuc3BvcnQsIHRoaXMgd2lsbCBwcm9iYWJseSBiZVxuXHRcdCAqIHByZWVtcHRlZCBieSB0aGUgbm90aWZ5U3RhdGUgY2FsbCBpbiBkZWFjdGl2YXRlVHJhbnNwb3J0ICovXG5cdFx0dGhpcy5ub3RpZnlTdGF0ZSh7c3RhdGU6ICdjbG9zZWQnfSk7XG5cdH07XG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLm9uQXV0aFVwZGF0ZWQgPSBmdW5jdGlvbih0b2tlbkRldGFpbHMsIGNhbGxiYWNrKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHN3aXRjaCh0aGlzLnN0YXRlLnN0YXRlKSB7XG5cdFx0XHRjYXNlICdjb25uZWN0ZWQnOlxuXHRcdFx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5vbkF1dGhVcGRhdGVkKCknLCAnU2VuZGluZyBBVVRIIG1lc3NhZ2Ugb24gYWN0aXZlIHRyYW5zcG9ydCcpO1xuXHRcdFx0XHQvKiBJZiB0aGVyZSBhcmUgYW55IHByb3Bvc2VkL3BlbmRpbmcgdHJhbnNwb3J0cyAoZWcgYW4gdXBncmFkZSB0aGF0XG5cdFx0XHRcdCAqIGlzbid0IHlldCBzY2hlZHVsZWQgZm9yIGFjdGl2YXRpb24pIHRoYXQgaGFzbid0IHlldCBzdGFydGVkIHN5bmNpbmcsXG5cdFx0XHRcdCAqIGp1c3QgdG8gZ2V0IHJpZCBvZiB0aGVtICYgcmVzdGFydCB0aGUgdXBncmFkZSB3aXRoIHRoZSBuZXcgdG9rZW4sIHRvXG5cdFx0XHRcdCAqIGF2b2lkIGEgcmFjZSBjb25kaXRpb24uIChJZiBpdCBoYXMgc3RhcnRlZCBzeW5jaW5nLCB0aGUgQVVUSCB3aWxsIGJlXG5cdFx0XHRcdCAqIHF1ZXVlZCB1bnRpbCB0aGUgdXBncmFkZSBpcyBjb21wbGV0ZSwgc28gZXZlcnl0aGluZydzIGZpbmUpICovXG5cdFx0XHRcdGlmKCh0aGlzLnBlbmRpbmdUcmFuc3BvcnRzLmxlbmd0aCB8fCB0aGlzLnByb3Bvc2VkVHJhbnNwb3J0cy5sZW5ndGgpICYmXG5cdFx0XHRcdFx0c2VsZi5zdGF0ZSAhPT0gc2VsZi5zdGF0ZXMuc3luY2hyb25pemluZykge1xuXHRcdFx0XHRcdHRoaXMuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMoLyogZXhjZXB0QWN0aXZlOiAqL3RydWUpO1xuXHRcdFx0XHRcdHZhciB0cmFuc3BvcnRQYXJhbXMgPSB0aGlzLmFjdGl2ZVByb3RvY29sLmdldFRyYW5zcG9ydCgpLnBhcmFtcztcblx0XHRcdFx0XHRVdGlscy5uZXh0VGljayhmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGlmKHNlbGYuc3RhdGUuc3RhdGUgPT09ICdjb25uZWN0ZWQnKSB7XG5cdFx0XHRcdFx0XHRcdHNlbGYudXBncmFkZUlmTmVlZGVkKHRyYW5zcG9ydFBhcmFtcyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvKiBEbyBhbnkgdHJhbnNwb3J0LXNwZWNpZmljIG5ldy10b2tlbiBhY3Rpb24gKi9cblx0XHRcdFx0dGhpcy5hY3RpdmVQcm90b2NvbC5nZXRUcmFuc3BvcnQoKS5vbkF1dGhVcGRhdGVkKHRva2VuRGV0YWlscyk7XG5cblx0XHRcdFx0dmFyIGF1dGhNc2cgPSBQcm90b2NvbE1lc3NhZ2UuZnJvbVZhbHVlcyh7XG5cdFx0XHRcdFx0YWN0aW9uOiBhY3Rpb25zLkFVVEgsXG5cdFx0XHRcdFx0YXV0aDoge1xuXHRcdFx0XHRcdFx0YWNjZXNzVG9rZW46IHRva2VuRGV0YWlscy50b2tlblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHRcdHRoaXMuc2VuZChhdXRoTXNnKTtcblxuXHRcdFx0XHQvKiBUaGUgYW5zd2VyIHdpbGwgY29tZSBiYWNrIGFzIGVpdGhlciBhIGNvbm5lY3Rpb25kZXRhaWxzIGV2ZW50XG5cdFx0XHRcdCAqIChyZWFsdGltZSBzZW5kcyBhIENPTk5FQ1RFRCB0byBhc2tub3dsZWRnZSB0aGUgcmVhdXRoKSBvciBhXG5cdFx0XHRcdCAqIHN0YXRlY2hhbmdlIHRvIGZhaWxlZCAqL1xuXHRcdFx0XHR2YXIgc3VjY2Vzc0xpc3RlbmVyID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0c2VsZi5vZmYoZmFpbHVyZUxpc3RlbmVyKTtcblx0XHRcdFx0XHRjYWxsYmFjayhudWxsLCB0b2tlbkRldGFpbHMpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHR2YXIgZmFpbHVyZUxpc3RlbmVyID0gZnVuY3Rpb24oc3RhdGVDaGFuZ2UpIHtcblx0XHRcdFx0XHRpZihzdGF0ZUNoYW5nZS5jdXJyZW50ID09PSAnZmFpbGVkJykge1xuXHRcdFx0XHRcdFx0c2VsZi5vZmYoc3VjY2Vzc0xpc3RlbmVyKTtcblx0XHRcdFx0XHRcdHNlbGYub2ZmKGZhaWx1cmVMaXN0ZW5lcik7XG5cdFx0XHRcdFx0XHRjYWxsYmFjayhzdGF0ZUNoYW5nZS5yZWFzb24gfHwgc2VsZi5nZXRTdGF0ZUVycm9yKCkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdFx0dGhpcy5vbmNlKCdjb25uZWN0aW9uZGV0YWlscycsIHN1Y2Nlc3NMaXN0ZW5lcik7XG5cdFx0XHRcdHRoaXMub24oJ2Nvbm5lY3Rpb25zdGF0ZScsIGZhaWx1cmVMaXN0ZW5lcik7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdjb25uZWN0aW5nJzpcblx0XHRcdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIub25BdXRoVXBkYXRlZCgpJyxcblx0XHRcdFx0XHQnQWJvcnRpbmcgY3VycmVudCBjb25uZWN0aW9uIGF0dGVtcHRzIGluIG9yZGVyIHRvIHN0YXJ0IGFnYWluIHdpdGggdGhlIG5ldyBhdXRoIGRldGFpbHMnKTtcblx0XHRcdFx0dGhpcy5kaXNjb25uZWN0QWxsVHJhbnNwb3J0cygpO1xuXHRcdFx0XHQvKiBmYWxsdGhyb3VnaCB0byBhZGQgc3RhdGVjaGFuZ2UgbGlzdGVuZXIgKi9cblxuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIub25BdXRoVXBkYXRlZCgpJyxcblx0XHRcdFx0XHQnQ29ubmVjdGlvbiBzdGF0ZSBpcyAnICsgdGhpcy5zdGF0ZS5zdGF0ZSArICc7IHdhaXRpbmcgdW50aWwgZWl0aGVyIGNvbm5lY3RlZCBvciBmYWlsZWQnKTtcblx0XHRcdFx0dmFyIGxpc3RlbmVyID0gZnVuY3Rpb24oc3RhdGVDaGFuZ2UpIHtcblx0XHRcdFx0XHRzd2l0Y2goc3RhdGVDaGFuZ2UuY3VycmVudCkge1xuXHRcdFx0XHRcdFx0Y2FzZSAnY29ubmVjdGVkJzpcblx0XHRcdFx0XHRcdFx0c2VsZi5vZmYobGlzdGVuZXIpO1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayhudWxsLCB0b2tlbkRldGFpbHMpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ2ZhaWxlZCc6XG5cdFx0XHRcdFx0XHRjYXNlICdjbG9zZWQnOlxuXHRcdFx0XHRcdFx0Y2FzZSAnc3VzcGVuZGVkJzpcblx0XHRcdFx0XHRcdFx0c2VsZi5vZmYobGlzdGVuZXIpO1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayhzdGF0ZUNoYW5nZS5yZWFzb24gfHwgc2VsZi5nZXRTdGF0ZUVycm9yKCkpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdC8qIGlnbm9yZSB0aWxsIHdlIGdldCBlaXRoZXIgY29ubmVjdGVkIG9yIGZhaWxlZCAqL1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHRcdHNlbGYub24oJ2Nvbm5lY3Rpb25zdGF0ZScsIGxpc3RlbmVyKTtcblx0XHRcdFx0aWYodGhpcy5zdGF0ZS5zdGF0ZSA9PT0gJ2Nvbm5lY3RpbmcnKSB7XG5cdFx0XHRcdFx0LyogY2FuIGhhcHBlbiBpZiBpbiB0aGUgY29ubmVjdGluZyBzdGF0ZSBidXQgbm8gdHJhbnNwb3J0IHdhcyBwZW5kaW5nXG5cdFx0XHRcdFx0ICogeWV0LCBzbyBkaXNjb25uZWN0QWxsVHJhbnNwb3J0cyBkaWQgbm90IHRyaWdnZXIgYSBkaXNjb25uZWN0ZWQgc3RhdGUgKi9cblx0XHRcdFx0XHRzZWxmLnN0YXJ0Q29ubmVjdCgpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHNlbGYucmVxdWVzdFN0YXRlKHtzdGF0ZTogJ2Nvbm5lY3RpbmcnfSk7XG5cdFx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzID0gZnVuY3Rpb24oZXhjZXB0QWN0aXZlKSB7XG5cdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMoKScsICdEaXNjb25uZWN0aW5nIGFsbCB0cmFuc3BvcnRzJyArIChleGNlcHRBY3RpdmUgPyAnIGV4Y2VwdCB0aGUgYWN0aXZlIHRyYW5zcG9ydCcgOiAnJykpO1xuXG5cdFx0VXRpbHMuc2FmZUFyckZvckVhY2godGhpcy5wZW5kaW5nVHJhbnNwb3J0cywgZnVuY3Rpb24odHJhbnNwb3J0KSB7XG5cdFx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5kaXNjb25uZWN0QWxsVHJhbnNwb3J0cygpJywgJ0Rpc2Nvbm5lY3RpbmcgcGVuZGluZyB0cmFuc3BvcnQ6ICcgKyB0cmFuc3BvcnQpO1xuXHRcdFx0aWYodHJhbnNwb3J0KSB0cmFuc3BvcnQuZGlzY29ubmVjdCgpO1xuXHRcdH0pO1xuXHRcdHRoaXMucGVuZGluZ1RyYW5zcG9ydHMgPSBbXTtcblxuXHRcdFV0aWxzLnNhZmVBcnJGb3JFYWNoKHRoaXMucHJvcG9zZWRUcmFuc3BvcnRzLCBmdW5jdGlvbih0cmFuc3BvcnQpIHtcblx0XHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzKCknLCAnRGlzcG9zaW5nIG9mIHByb3Bvc2VkIHRyYW5zcG9ydDogJyArIHRyYW5zcG9ydCk7XG5cdFx0XHRpZih0cmFuc3BvcnQpIHRyYW5zcG9ydC5kaXNwb3NlKCk7XG5cdFx0fSk7XG5cdFx0dGhpcy5wcm9wb3NlZFRyYW5zcG9ydHMgPSBbXTtcblxuXHRcdGlmKHRoaXMuYWN0aXZlUHJvdG9jb2wgJiYgIWV4Y2VwdEFjdGl2ZSkge1xuXHRcdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMoKScsICdEaXNjb25uZWN0aW5nIGFjdGl2ZSB0cmFuc3BvcnQ6ICcgKyB0aGlzLmFjdGl2ZVByb3RvY29sLmdldFRyYW5zcG9ydCgpKTtcblx0XHRcdHRoaXMuYWN0aXZlUHJvdG9jb2wuZ2V0VHJhbnNwb3J0KCkuZGlzY29ubmVjdCgpO1xuXHRcdH1cblx0XHQvKiBObyBuZWVkIHRvIG5vdGlmeSBzdGF0ZSBkaXNjb25uZWN0ZWQ7IGRpc2Nvbm5lY3RpbmcgdGhlIGFjdGl2ZSB0cmFuc3BvcnRcblx0XHQgKiB3aWxsIGhhdmUgdGhhdCBlZmZlY3QgKi9cblx0fTtcblxuXHQvKioqKioqKioqKioqKioqKioqXG5cdCAqIGV2ZW50IHF1ZXVlaW5nXG5cdCAqKioqKioqKioqKioqKioqKiovXG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihtc2csIHF1ZXVlRXZlbnQsIGNhbGxiYWNrKSB7XG5cdFx0Y2FsbGJhY2sgPSBjYWxsYmFjayB8fCBub29wO1xuXHRcdHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG5cblx0XHRpZihzdGF0ZS5zZW5kRXZlbnRzKSB7XG5cdFx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5zZW5kKCknLCAnc2VuZGluZyBldmVudCcpO1xuXHRcdFx0dGhpcy5zZW5kSW1wbChuZXcgUGVuZGluZ01lc3NhZ2UobXNnLCBjYWxsYmFjaykpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR2YXIgc2hvdWxkUXVldWUgPSAocXVldWVFdmVudCAmJiBzdGF0ZS5xdWV1ZUV2ZW50cykgfHwgc3RhdGUuZm9yY2VRdWV1ZUV2ZW50cztcblx0XHRpZighc2hvdWxkUXVldWUpIHtcblx0XHRcdHZhciBlcnIgPSAncmVqZWN0aW5nIGV2ZW50LCBxdWV1ZUV2ZW50IHdhcyAnICsgcXVldWVFdmVudCArICcsIHN0YXRlIHdhcyAnICsgc3RhdGUuc3RhdGU7XG5cdFx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5zZW5kKCknLCBlcnIpO1xuXHRcdFx0Y2FsbGJhY2sodGhpcy5lcnJvclJlYXNvbiB8fCBuZXcgRXJyb3JJbmZvKGVyciwgOTAwMDAsIDQwMCkpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZihMb2dnZXIuc2hvdWxkTG9nKExvZ2dlci5MT0dfTUlDUk8pKSB7XG5cdFx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5zZW5kKCknLCAncXVldWVpbmcgbXNnOyAnICsgUHJvdG9jb2xNZXNzYWdlLnN0cmluZ2lmeShtc2cpKTtcblx0XHR9XG5cdFx0dGhpcy5xdWV1ZShtc2csIGNhbGxiYWNrKTtcblx0fTtcblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuc2VuZEltcGwgPSBmdW5jdGlvbihwZW5kaW5nTWVzc2FnZSkge1xuXHRcdHZhciBtc2cgPSBwZW5kaW5nTWVzc2FnZS5tZXNzYWdlO1xuXHRcdC8qIElmIGhhdmUgYWxyZWFkeSBhdHRlbXB0ZWQgdG8gc2VuZCB0aGlzLCByZXNlbmQgd2l0aCB0aGUgc2FtZSBtc2dTZXJpYWwsXG5cdFx0ICogc28gQWJseSBjYW4gZGVkdXAgaWYgdGhlIHByZXZpb3VzIHNlbmQgc3VjY2VlZGVkICovXG5cdFx0aWYocGVuZGluZ01lc3NhZ2UuYWNrUmVxdWlyZWQgJiYgIXBlbmRpbmdNZXNzYWdlLnNlbmRBdHRlbXB0ZWQpIHtcblx0XHRcdG1zZy5tc2dTZXJpYWwgPSB0aGlzLm1zZ1NlcmlhbCsrO1xuXHRcdH1cblx0XHR0cnkge1xuXHRcdFx0dGhpcy5hY3RpdmVQcm90b2NvbC5zZW5kKHBlbmRpbmdNZXNzYWdlKTtcblx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19FUlJPUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNlbmRJbXBsKCknLCAnVW5leHBlY3RlZCBleGNlcHRpb24gaW4gdHJhbnNwb3J0LnNlbmQoKTogJyArIGUuc3RhY2spO1xuXHRcdH1cblx0fTtcblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUucXVldWUgPSBmdW5jdGlvbihtc2csIGNhbGxiYWNrKSB7XG5cdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIucXVldWUoKScsICdxdWV1ZWluZyBldmVudCcpO1xuXHRcdHZhciBsYXN0UXVldWVkID0gdGhpcy5xdWV1ZWRNZXNzYWdlcy5sYXN0KCk7XG5cdFx0LyogSWYgaGF2ZSBhbHJlYWR5IGF0dGVtcHRlZCB0byBzZW5kIGEgbWVzc2FnZSwgZG9uJ3QgbWVyZ2UgbW9yZSBtZXNzYWdlc1xuXHRcdCAqIGludG8gaXQsIGFzIGlmIHRoZSBwcmV2aW91cyBzZW5kIGFjdHVhbGx5IHN1Y2NlZWRlZCBhbmQgcmVhbHRpbWUgaWdub3Jlc1xuXHRcdCAqIHRoZSBkdXAsIHRoZXknbGwgYmUgbG9zdCAqL1xuXHRcdGlmKGxhc3RRdWV1ZWQgJiYgIWxhc3RRdWV1ZWQuc2VuZEF0dGVtcHRlZCAmJiBSZWFsdGltZUNoYW5uZWwubWVyZ2VUbyhsYXN0UXVldWVkLm1lc3NhZ2UsIG1zZykpIHtcblx0XHRcdGlmKCFsYXN0UXVldWVkLm1lcmdlZCkge1xuXHRcdFx0XHRsYXN0UXVldWVkLmNhbGxiYWNrID0gTXVsdGljYXN0ZXIoW2xhc3RRdWV1ZWQuY2FsbGJhY2tdKTtcblx0XHRcdFx0bGFzdFF1ZXVlZC5tZXJnZWQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0bGFzdFF1ZXVlZC5jYWxsYmFjay5wdXNoKGNhbGxiYWNrKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5xdWV1ZWRNZXNzYWdlcy5wdXNoKG5ldyBQZW5kaW5nTWVzc2FnZShtc2csIGNhbGxiYWNrKSk7XG5cdFx0fVxuXHR9O1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zZW5kUXVldWVkTWVzc2FnZXMgPSBmdW5jdGlvbigpIHtcblx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5zZW5kUXVldWVkTWVzc2FnZXMoKScsICdzZW5kaW5nICcgKyB0aGlzLnF1ZXVlZE1lc3NhZ2VzLmNvdW50KCkgKyAnIHF1ZXVlZCBtZXNzYWdlcycpO1xuXHRcdHZhciBwZW5kaW5nTWVzc2FnZTtcblx0XHR3aGlsZShwZW5kaW5nTWVzc2FnZSA9IHRoaXMucXVldWVkTWVzc2FnZXMuc2hpZnQoKSlcblx0XHRcdHRoaXMuc2VuZEltcGwocGVuZGluZ01lc3NhZ2UpO1xuXHR9O1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5xdWV1ZVBlbmRpbmdNZXNzYWdlcyA9IGZ1bmN0aW9uKHBlbmRpbmdNZXNzYWdlcykge1xuXHRcdGlmKHBlbmRpbmdNZXNzYWdlcyAmJiBwZW5kaW5nTWVzc2FnZXMubGVuZ3RoKSB7XG5cdFx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5xdWV1ZVBlbmRpbmdNZXNzYWdlcygpJywgJ3F1ZXVlaW5nICcgKyBwZW5kaW5nTWVzc2FnZXMubGVuZ3RoICsgJyBwZW5kaW5nIG1lc3NhZ2VzJyk7XG5cdFx0XHR0aGlzLnF1ZXVlZE1lc3NhZ2VzLnByZXBlbmQocGVuZGluZ01lc3NhZ2VzKTtcblx0XHR9XG5cdH07XG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmZhaWxRdWV1ZWRNZXNzYWdlcyA9IGZ1bmN0aW9uKGVycikge1xuXHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmZhaWxRdWV1ZWRNZXNzYWdlcygpJywgJ2ZhaWxpbmcgJyArIHRoaXMucXVldWVkTWVzc2FnZXMuY291bnQoKSArICcgcXVldWVkIG1lc3NhZ2VzJyk7XG5cdFx0dGhpcy5xdWV1ZWRNZXNzYWdlcy5jb21wbGV0ZUFsbE1lc3NhZ2VzKGVycik7XG5cdH07XG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLm9uQ2hhbm5lbE1lc3NhZ2UgPSBmdW5jdGlvbihtZXNzYWdlLCB0cmFuc3BvcnQpIHtcblx0XHR2YXIgb25BY3RpdmVUcmFuc3BvcnQgPSB0aGlzLmFjdGl2ZVByb3RvY29sICYmIHRyYW5zcG9ydCA9PT0gdGhpcy5hY3RpdmVQcm90b2NvbC5nZXRUcmFuc3BvcnQoKSxcblx0XHRcdG9uVXBncmFkZVRyYW5zcG9ydCA9IFV0aWxzLmFyckluKHRoaXMucGVuZGluZ1RyYW5zcG9ydHMsIHRyYW5zcG9ydCkgJiYgdGhpcy5zdGF0ZSA9PSB0aGlzLnN0YXRlcy5zeW5jaHJvbml6aW5nO1xuXG5cdFx0LyogQXMgdGhlIGxpYiBub3cgaGFzIGEgcGVyaW9kIHdoZXJlIHRoZSB1cGdyYWRlIHRyYW5zcG9ydCBpcyBzeW5jZWQgYnV0XG5cdFx0ICogYmVmb3JlIGl0J3MgYmVjb21lIGFjdGl2ZSAod2hpbGUgd2FpdGluZyBmb3IgdGhlIG9sZCBvbmUgdG8gYmVjb21lXG5cdFx0ICogaWRsZSksIG1lc3NhZ2UgY2FuIHZhbGlkbHkgYXJyaXZlIG9uIGl0IGV2ZW4gdGhvdWdoIGl0IGlzbid0IGFjdGl2ZSAqL1xuXHRcdGlmKG9uQWN0aXZlVHJhbnNwb3J0IHx8IG9uVXBncmFkZVRyYW5zcG9ydCkge1xuXHRcdFx0dmFyIGNvbm5lY3Rpb25TZXJpYWwgPSBtZXNzYWdlLmNvbm5lY3Rpb25TZXJpYWw7XG5cdFx0XHRpZihjb25uZWN0aW9uU2VyaWFsIDw9IHRoaXMuY29ubmVjdGlvblNlcmlhbCkge1xuXHRcdFx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5vbkNoYW5uZWxNZXNzYWdlKCkgcmVjZWl2ZWQgbWVzc2FnZSB3aXRoIGNvbm5lY3Rpb25TZXJpYWwgJyArIGNvbm5lY3Rpb25TZXJpYWwgKyAnLCBidXQgY3VycmVudCBjb25uZWN0aW9uU2VyaWFsIGlzICcgKyB0aGlzLmNvbm5lY3Rpb25TZXJpYWwgKyAnOyBhc3N1bWluZyBtZXNzYWdlIGlzIGEgZHVwbGljYXRlIGFuZCBkaXNjYXJkaW5nIGl0Jyk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGlmKGNvbm5lY3Rpb25TZXJpYWwgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0aGlzLnJlYWx0aW1lLmNvbm5lY3Rpb24uc2VyaWFsID0gdGhpcy5jb25uZWN0aW9uU2VyaWFsID0gY29ubmVjdGlvblNlcmlhbDtcblx0XHRcdFx0dGhpcy5yZWFsdGltZS5jb25uZWN0aW9uLnJlY292ZXJ5S2V5ID0gdGhpcy5jb25uZWN0aW9uS2V5ICsgJzonICsgY29ubmVjdGlvblNlcmlhbDtcblx0XHRcdH1cblx0XHRcdHRoaXMucmVhbHRpbWUuY2hhbm5lbHMub25DaGFubmVsTWVzc2FnZShtZXNzYWdlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gTWVzc2FnZSBjYW1lIGluIG9uIGEgZGVmdW5jdCB0cmFuc3BvcnQuIEFsbG93IG9ubHkgYWNrcywgbmFja3MsICYgZXJyb3JzIGZvciBvdXRzdGFuZGluZ1xuXHRcdFx0Ly8gbWVzc2FnZXMsICBubyBuZXcgbWVzc2FnZXMgKGFzIHN5bmMgaGFzIGJlZW4gc2VudCBvbiBuZXcgdHJhbnNwb3J0IHNvIG5ldyBtZXNzYWdlcyB3aWxsXG5cdFx0XHQvLyBiZSByZXNlbnQgdGhlcmUsIG9yIGNvbm5lY3Rpb24gaGFzIGJlZW4gY2xvc2VkIHNvIGRvbid0IHdhbnQgbmV3IG1lc3NhZ2VzKVxuXHRcdFx0aWYoVXRpbHMuYXJySW5kZXhPZihbYWN0aW9ucy5BQ0ssIGFjdGlvbnMuTkFDSywgYWN0aW9ucy5FUlJPUl0sIG1lc3NhZ2UuYWN0aW9uKSA+IC0xKSB7XG5cdFx0XHRcdHRoaXMucmVhbHRpbWUuY2hhbm5lbHMub25DaGFubmVsTWVzc2FnZShtZXNzYWdlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLm9uQ2hhbm5lbE1lc3NhZ2UoKScsICdyZWNlaXZlZCBtZXNzYWdlICcgKyBKU09OLnN0cmluZ2lmeShtZXNzYWdlKSArICdvbiBkZWZ1bmN0IHRyYW5zcG9ydDsgZGlzY2FyZGluZycpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUucGluZyA9IGZ1bmN0aW9uKHRyYW5zcG9ydCwgY2FsbGJhY2spIHtcblx0XHQvKiBpZiB0cmFuc3BvcnQgaXMgc3BlY2lmaWVkLCB0cnkgdGhhdCAqL1xuXHRcdGlmKHRyYW5zcG9ydCkge1xuXHRcdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIucGluZygpJywgJ3RyYW5zcG9ydCA9ICcgKyB0cmFuc3BvcnQpO1xuXG5cdFx0XHR2YXIgb25UaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR0cmFuc3BvcnQub2ZmKCdoZWFydGJlYXQnLCBvbkhlYXJ0YmVhdCk7XG5cdFx0XHRcdGNhbGxiYWNrKG5ldyBFcnJvckluZm8oJ1RpbWVvdXQgd2FpdGluZyBmb3IgaGVhcnRiZWF0IHJlc3BvbnNlJywgNTAwMDAsIDUwMCkpO1xuXHRcdFx0fTtcblxuXHRcdFx0dmFyIHBpbmdTdGFydCA9IFV0aWxzLm5vdygpLFxuXHRcdFx0XHRpZCA9IFV0aWxzLnJhbmRTdHIoKTtcblxuXHRcdFx0dmFyIG9uSGVhcnRiZWF0ID0gZnVuY3Rpb24gKHJlc3BvbnNlSWQpIHtcblx0XHRcdFx0aWYocmVzcG9uc2VJZCA9PT0gaWQpIHtcblx0XHRcdFx0XHRjbGVhclRpbWVvdXQodGltZXIpO1xuXHRcdFx0XHRcdHZhciByZXNwb25zZVRpbWUgPSBVdGlscy5ub3coKSAtIHBpbmdTdGFydDtcblx0XHRcdFx0XHRjYWxsYmFjayhudWxsLCByZXNwb25zZVRpbWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHR2YXIgdGltZXIgPSBzZXRUaW1lb3V0KG9uVGltZW91dCwgdGhpcy5vcHRpb25zLnRpbWVvdXRzLnJlYWx0aW1lUmVxdWVzdFRpbWVvdXQpO1xuXG5cdFx0XHR0cmFuc3BvcnQub25jZSgnaGVhcnRiZWF0Jywgb25IZWFydGJlYXQpO1xuXHRcdFx0dHJhbnNwb3J0LnBpbmcoaWQpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8qIGlmIHdlJ3JlIG5vdCBjb25uZWN0ZWQsIGRvbid0IGF0dGVtcHQgKi9cblx0XHRpZih0aGlzLnN0YXRlLnN0YXRlICE9PSAnY29ubmVjdGVkJykge1xuXHRcdFx0Y2FsbGJhY2sobmV3IEVycm9ySW5mbygnVW5hYmxlIHRvIHBpbmcgc2VydmljZTsgbm90IGNvbm5lY3RlZCcsIDQwMDAwLCA0MDApKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvKiBubyB0cmFuc3BvcnQgd2FzIHNwZWNpZmllZCwgc28gdXNlIHRoZSBjdXJyZW50IChjb25uZWN0ZWQpIG9uZVxuXHRcdCAqIGJ1dCBlbnN1cmUgdGhhdCB3ZSByZXRyeSBpZiB0aGUgdHJhbnNwb3J0IGlzIHN1cGVyc2VkZWQgYmVmb3JlIHdlIGNvbXBsZXRlICovXG5cdFx0dmFyIGNvbXBsZXRlZCA9IGZhbHNlLCBzZWxmID0gdGhpcztcblxuXHRcdHZhciBvblBpbmdDb21wbGV0ZSA9IGZ1bmN0aW9uKGVyciwgcmVzcG9uc2VUaW1lKSB7XG5cdFx0XHRzZWxmLm9mZigndHJhbnNwb3J0LmFjdGl2ZScsIG9uVHJhbnNwb3J0QWN0aXZlKTtcblx0XHRcdGlmKCFjb21wbGV0ZWQpIHtcblx0XHRcdFx0Y29tcGxldGVkID0gdHJ1ZTtcblx0XHRcdFx0Y2FsbGJhY2soZXJyLCByZXNwb25zZVRpbWUpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHR2YXIgb25UcmFuc3BvcnRBY3RpdmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmKCFjb21wbGV0ZWQpIHtcblx0XHRcdFx0LyogZW5zdXJlIHRoYXQgbm8gY2FsbGJhY2sgaGFwcGVucyBmb3IgdGhlIGN1cnJlbnRseSBvdXRzdGFuZGluZyBvcGVyYXRpb24gKi9cblx0XHRcdFx0Y29tcGxldGVkID0gdHJ1ZTtcblx0XHRcdFx0LyogcmVwZWF0IGJ1dCBwaWNraW5nIHVwIHRoZSBuZXcgdHJhbnNwb3J0ICovXG5cdFx0XHRcdFV0aWxzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHNlbGYucGluZyhudWxsLCBjYWxsYmFjayk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHR0aGlzLm9uKCd0cmFuc3BvcnQuYWN0aXZlJywgb25UcmFuc3BvcnRBY3RpdmUpO1xuXHRcdHRoaXMucGluZyh0aGlzLmFjdGl2ZVByb3RvY29sLmdldFRyYW5zcG9ydCgpLCBvblBpbmdDb21wbGV0ZSk7XG5cdH07XG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oZXJyb3IpIHtcblx0XHR0aGlzLmFjdGl2ZVByb3RvY29sLmdldFRyYW5zcG9ydCgpLmZhaWwoZXJyb3IpO1xuXHR9O1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5yZWdpc3RlclByb3Bvc2VkVHJhbnNwb3J0ID0gZnVuY3Rpb24odHJhbnNwb3J0KSB7XG5cdFx0dGhpcy5wcm9wb3NlZFRyYW5zcG9ydHMucHVzaCh0cmFuc3BvcnQpO1xuXHR9O1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5nZXRUcmFuc3BvcnRQcmVmZXJlbmNlID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMudHJhbnNwb3J0UHJlZmVyZW5jZSB8fCAoaGF2ZVdlYlN0b3JhZ2UgJiYgV2ViU3RvcmFnZS5nZXQodHJhbnNwb3J0UHJlZmVyZW5jZU5hbWUpKTtcblx0fTtcblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUucGVyc2lzdFRyYW5zcG9ydFByZWZlcmVuY2UgPSBmdW5jdGlvbih0cmFuc3BvcnQpIHtcblx0XHRpZihVdGlscy5hcnJJbihEZWZhdWx0cy51cGdyYWRlVHJhbnNwb3J0cywgdHJhbnNwb3J0LnNob3J0TmFtZSkpIHtcblx0XHRcdHRoaXMudHJhbnNwb3J0UHJlZmVyZW5jZSA9IHRyYW5zcG9ydC5zaG9ydE5hbWU7XG5cdFx0XHRpZihoYXZlV2ViU3RvcmFnZSkge1xuXHRcdFx0XHRXZWJTdG9yYWdlLnNldCh0cmFuc3BvcnRQcmVmZXJlbmNlTmFtZSwgdHJhbnNwb3J0LnNob3J0TmFtZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS51bnBlcnNpc3RUcmFuc3BvcnRQcmVmZXJlbmNlID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy50cmFuc3BvcnRQcmVmZXJlbmNlID0gbnVsbDtcblx0XHRpZihoYXZlV2ViU3RvcmFnZSkge1xuXHRcdFx0V2ViU3RvcmFnZS5yZW1vdmUodHJhbnNwb3J0UHJlZmVyZW5jZU5hbWUpO1xuXHRcdH1cblx0fTtcblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuYWN0T25FcnJvckZyb21BdXRob3JpemUgPSBmdW5jdGlvbihlcnIpIHtcblx0XHRpZihlcnIuY29kZSA9PT0gNDAxNzApIHtcblx0XHRcdC8qIFNwZWNpYWwtY2FzZSBwcm9ibGVtcyB3aXRoIHRoZSBjbGllbnQgYXV0aCBjYWxsYmFjayAtIHVubGlrZSBvdGhlclxuXHRcdFx0ICogYXV0aCBlcnJvcnMgdGhlc2UgbWF5IGJlIG5vbmZhdGFsLiAoUlNBNGMpICovXG5cdFx0XHRlcnIuY29kZSA9IDgwMDE5O1xuXHRcdFx0dGhpcy5ub3RpZnlTdGF0ZSh7c3RhdGU6IHRoaXMuc3RhdGUuZmFpbFN0YXRlLCBlcnJvcjogZXJyfSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMubm90aWZ5U3RhdGUoe3N0YXRlOiAnZmFpbGVkJywgZXJyb3I6IGVycn0pO1xuXHRcdH1cblx0fTtcblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUub25Db25uZWN0aW9uRGV0YWlsc1VwZGF0ZSA9IGZ1bmN0aW9uKGNvbm5lY3Rpb25EZXRhaWxzLCB0cmFuc3BvcnQpIHtcblx0XHRpZighY29ubmVjdGlvbkRldGFpbHMpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dmFyIGNsaWVudElkID0gY29ubmVjdGlvbkRldGFpbHMuY2xpZW50SWQ7XG5cdFx0aWYoY2xpZW50SWQpIHtcblx0XHRcdHZhciBlcnIgPSB0aGlzLnJlYWx0aW1lLmF1dGguX3VuY2hlY2tlZFNldENsaWVudElkKGNsaWVudElkKTtcblx0XHRcdGlmKGVycikge1xuXHRcdFx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfRVJST1IsICdDb25uZWN0aW9uTWFuYWdlci5vbkNvbm5lY3Rpb25EZXRhaWxzVXBkYXRlKCknLCBlcnIubWVzc2FnZSk7XG5cdFx0XHRcdC8qIEVycm9ycyBzZXR0aW5nIHRoZSBjbGllbnRJZCBhcmUgZmF0YWwgdG8gdGhlIGNvbm5lY3Rpb24gKi9cblx0XHRcdFx0dHJhbnNwb3J0LmZhaWwoZXJyKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR2YXIgY29ubmVjdGlvblN0YXRlVHRsID0gY29ubmVjdGlvbkRldGFpbHMuY29ubmVjdGlvblN0YXRlVHRsO1xuXHRcdGlmKGNvbm5lY3Rpb25TdGF0ZVR0bCkge1xuXHRcdFx0dGhpcy5jb25uZWN0aW9uU3RhdGVUdGwgPSBjb25uZWN0aW9uU3RhdGVUdGw7XG5cdFx0fVxuXHRcdHRoaXMubWF4SWRsZUludGVydmFsID0gY29ubmVjdGlvbkRldGFpbHMubWF4SWRsZUludGVydmFsO1xuXHRcdHRoaXMuZW1pdCgnY29ubmVjdGlvbmRldGFpbHMnLCBjb25uZWN0aW9uRGV0YWlscyk7XG5cdH07XG5cblx0cmV0dXJuIENvbm5lY3Rpb25NYW5hZ2VyO1xufSkoKTtcblxudmFyIFRyYW5zcG9ydCA9IChmdW5jdGlvbigpIHtcblx0dmFyIGFjdGlvbnMgPSBQcm90b2NvbE1lc3NhZ2UuQWN0aW9uO1xuXHR2YXIgY2xvc2VNZXNzYWdlID0gUHJvdG9jb2xNZXNzYWdlLmZyb21WYWx1ZXMoe2FjdGlvbjogYWN0aW9ucy5DTE9TRX0pO1xuXHR2YXIgZGlzY29ubmVjdE1lc3NhZ2UgPSBQcm90b2NvbE1lc3NhZ2UuZnJvbVZhbHVlcyh7YWN0aW9uOiBhY3Rpb25zLkRJU0NPTk5FQ1R9KTtcblx0dmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9O1xuXG5cdC8qXG5cdCAqIEV2ZW50RW1pdHRlciwgZ2VuZXJhdGVzIHRoZSBmb2xsb3dpbmcgZXZlbnRzOlxuXHQgKlxuXHQgKiBldmVudCBuYW1lICAgICAgIGRhdGFcblx0ICogY2xvc2VkICAgICAgICAgICBlcnJvclxuXHQgKiBmYWlsZWQgICAgICAgICAgIGVycm9yXG5cdCAqIGRpc3Bvc2VkXG5cdCAqIGNvbm5lY3RlZCAgICAgICAgbnVsbCBlcnJvciwgY29ubmVjdGlvbktleVxuXHQgKiBldmVudCAgICAgICAgICAgIGNoYW5uZWwgbWVzc2FnZSBvYmplY3Rcblx0ICovXG5cblx0LyogcHVibGljIGNvbnN0cnVjdG9yICovXG5cdGZ1bmN0aW9uIFRyYW5zcG9ydChjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zKSB7XG5cdFx0RXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cdFx0dGhpcy5jb25uZWN0aW9uTWFuYWdlciA9IGNvbm5lY3Rpb25NYW5hZ2VyO1xuXHRcdGNvbm5lY3Rpb25NYW5hZ2VyLnJlZ2lzdGVyUHJvcG9zZWRUcmFuc3BvcnQodGhpcyk7XG5cdFx0dGhpcy5hdXRoID0gYXV0aDtcblx0XHR0aGlzLnBhcmFtcyA9IHBhcmFtcztcblx0XHR0aGlzLnRpbWVvdXRzID0gcGFyYW1zLm9wdGlvbnMudGltZW91dHM7XG5cdFx0dGhpcy5mb3JtYXQgPSBwYXJhbXMuZm9ybWF0O1xuXHRcdHRoaXMuaXNDb25uZWN0ZWQgPSBmYWxzZTtcblx0XHR0aGlzLmlzRmluaXNoZWQgPSBmYWxzZTtcblx0XHR0aGlzLm1heElkbGVJbnRlcnZhbCA9IG51bGw7XG5cdFx0dGhpcy5pZGxlVGltZXIgPSBudWxsO1xuXHRcdHRoaXMubGFzdEFjdGl2aXR5ID0gbnVsbDtcblx0fVxuXHRVdGlscy5pbmhlcml0cyhUcmFuc3BvcnQsIEV2ZW50RW1pdHRlcik7XG5cblx0VHJhbnNwb3J0LnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24oKSB7fTtcblxuXHRUcmFuc3BvcnQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYodGhpcy5pc0Nvbm5lY3RlZCkge1xuXHRcdFx0dGhpcy5yZXF1ZXN0Q2xvc2UoKTtcblx0XHR9XG5cdFx0dGhpcy5maW5pc2goJ2Nsb3NlZCcsIENvbm5lY3Rpb25FcnJvci5jbG9zZWQpO1xuXHR9O1xuXG5cdFRyYW5zcG9ydC5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uKGVycikge1xuXHRcdC8qIFVzZWQgZm9yIG5ldHdvcmsvdHJhbnNwb3J0IGlzc3VlcyB0aGF0IG5lZWQgdG8gcmVzdWx0IGluIHRoZSB0cmFuc3BvcnRcblx0XHQgKiBiZWluZyBkaXNjb25uZWN0ZWQsIGJ1dCBzaG91bGQgbm90IGFmZmVjdCB0aGUgY29ubmVjdGlvbiAqL1xuXHRcdGlmKHRoaXMuaXNDb25uZWN0ZWQpIHtcblx0XHRcdHRoaXMucmVxdWVzdERpc2Nvbm5lY3QoKTtcblx0XHR9XG5cdFx0dGhpcy5maW5pc2goJ2Rpc2Nvbm5lY3RlZCcsIGVyciB8fCBDb25uZWN0aW9uRXJyb3IuZGlzY29ubmVjdGVkKTtcblx0fTtcblxuXHRUcmFuc3BvcnQucHJvdG90eXBlLmZhaWwgPSBmdW5jdGlvbihlcnIpIHtcblx0XHQvKiBVc2VkIGZvciBjbGllbnQtc2lkZS1kZXRlY3RlZCBmYXRhbCBjb25uZWN0aW9uIGlzc3VlcyAqL1xuXHRcdGlmKHRoaXMuaXNDb25uZWN0ZWQpIHtcblx0XHRcdHRoaXMucmVxdWVzdERpc2Nvbm5lY3QoKTtcblx0XHR9XG5cdFx0dGhpcy5maW5pc2goJ2ZhaWxlZCcsIGVyciB8fCBDb25uZWN0aW9uRXJyb3IuZmFpbGVkKTtcblx0fTtcblxuXHRUcmFuc3BvcnQucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uKGV2ZW50LCBlcnIpIHtcblx0XHRpZih0aGlzLmlzRmluaXNoZWQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLmlzRmluaXNoZWQgPSB0cnVlO1xuXHRcdHRoaXMuaXNDb25uZWN0ZWQgPSBmYWxzZTtcblx0XHR0aGlzLm1heElkbGVJbnRlcnZhbCA9IG51bGw7XG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuaWRsZVRpbWVyKTtcblx0XHR0aGlzLmlkbGVUaW1lciA9IG51bGw7XG5cdFx0dGhpcy5lbWl0KGV2ZW50LCBlcnIpO1xuXHRcdHRoaXMuZGlzcG9zZSgpO1xuXHR9O1xuXG5cdFRyYW5zcG9ydC5wcm90b3R5cGUub25Qcm90b2NvbE1lc3NhZ2UgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG5cdFx0aWYgKExvZ2dlci5zaG91bGRMb2coTG9nZ2VyLkxPR19NSUNSTykpIHtcblx0XHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSUNSTywgJ1RyYW5zcG9ydC5vblByb3RvY29sTWVzc2FnZSgpJywgJ3JlY2VpdmVkIG9uICcgKyB0aGlzLnNob3J0TmFtZSArICc6ICcgKyBQcm90b2NvbE1lc3NhZ2Uuc3RyaW5naWZ5KG1lc3NhZ2UpKTtcblx0XHR9XG5cdFx0dGhpcy5sYXN0QWN0aXZpdHkgPSB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmxhc3RBY3Rpdml0eSA9IFV0aWxzLm5vdygpO1xuXHRcdGlmKHRoaXMubWF4SWRsZUludGVydmFsKSB7XG5cdFx0XHR0aGlzLnNldElkbGVUaW1lcigpO1xuXHRcdH1cblxuXHRcdHN3aXRjaChtZXNzYWdlLmFjdGlvbikge1xuXHRcdGNhc2UgYWN0aW9ucy5IRUFSVEJFQVQ6XG5cdFx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlDUk8sICdUcmFuc3BvcnQub25Qcm90b2NvbE1lc3NhZ2UoKScsIHRoaXMuc2hvcnROYW1lICsgJyBoZWFydGJlYXQ7IGNvbm5lY3Rpb25LZXkgPSAnICsgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5jb25uZWN0aW9uS2V5KTtcblx0XHRcdHRoaXMuZW1pdCgnaGVhcnRiZWF0JywgbWVzc2FnZS5pZCk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIGFjdGlvbnMuQ09OTkVDVEVEOlxuXHRcdFx0dGhpcy5vbkNvbm5lY3QobWVzc2FnZSk7XG5cdFx0XHR0aGlzLmVtaXQoJ2Nvbm5lY3RlZCcsIG1lc3NhZ2UuZXJyb3IsIChtZXNzYWdlLmNvbm5lY3Rpb25EZXRhaWxzID8gbWVzc2FnZS5jb25uZWN0aW9uRGV0YWlscy5jb25uZWN0aW9uS2V5IDogbWVzc2FnZS5jb25uZWN0aW9uS2V5KSwgbWVzc2FnZS5jb25uZWN0aW9uU2VyaWFsLCBtZXNzYWdlLmNvbm5lY3Rpb25JZCwgbWVzc2FnZS5jb25uZWN0aW9uRGV0YWlscyk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIGFjdGlvbnMuQ0xPU0VEOlxuXHRcdFx0dGhpcy5vbkNsb3NlKG1lc3NhZ2UpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSBhY3Rpb25zLkRJU0NPTk5FQ1RFRDpcblx0XHRcdHRoaXMub25EaXNjb25uZWN0KG1lc3NhZ2UpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSBhY3Rpb25zLkFDSzpcblx0XHRcdHRoaXMuZW1pdCgnYWNrJywgbWVzc2FnZS5tc2dTZXJpYWwsIG1lc3NhZ2UuY291bnQpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSBhY3Rpb25zLk5BQ0s6XG5cdFx0XHR0aGlzLmVtaXQoJ25hY2snLCBtZXNzYWdlLm1zZ1NlcmlhbCwgbWVzc2FnZS5jb3VudCwgbWVzc2FnZS5lcnJvcik7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIGFjdGlvbnMuU1lOQzpcblx0XHRcdGlmKG1lc3NhZ2UuY29ubmVjdGlvbklkICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0LyogYSB0cmFuc3BvcnQgU1lOQyAqL1xuXHRcdFx0XHR0aGlzLmVtaXQoJ3N5bmMnLCBtZXNzYWdlLmNvbm5lY3Rpb25TZXJpYWwsIG1lc3NhZ2UuY29ubmVjdGlvbklkKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHQvKiBvdGhlcndpc2UgaXQncyBhIGNoYW5uZWwgU1lOQywgc28gaGFuZGxlIGl0IGluIHRoZSBjaGFubmVsICovXG5cdFx0XHR0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLm9uQ2hhbm5lbE1lc3NhZ2UobWVzc2FnZSwgdGhpcyk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIGFjdGlvbnMuQVVUSDpcblx0XHRcdHRoaXMuYXV0aC5hdXRob3JpemUoZnVuY3Rpb24oZXJyKSB7XG5cdFx0XHRcdGlmKGVycikge1xuXHRcdFx0XHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19FUlJPUiwgJ1RyYW5zcG9ydC5vblByb3RvY29sTWVzc2FnZSgpJywgJ0FibHkgcmVxdWVzdGVkIHJlLWF1dGhlbnRpY2F0aW9uLCBidXQgdW5hYmxlIHRvIG9idGFpbiBhIG5ldyB0b2tlbjogJyArIFV0aWxzLmluc3BlY3RFcnJvcihlcnIpKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIGFjdGlvbnMuRVJST1I6XG5cdFx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlOT1IsICdUcmFuc3BvcnQub25Qcm90b2NvbE1lc3NhZ2UoKScsICdyZWNlaXZlZCBlcnJvciBhY3Rpb247IGNvbm5lY3Rpb25LZXkgPSAnICsgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5jb25uZWN0aW9uS2V5ICsgJzsgZXJyID0gJyArIFV0aWxzLmluc3BlY3QobWVzc2FnZS5lcnJvcikgKyAobWVzc2FnZS5jaGFubmVsID8gKCcsIGNoYW5uZWw6ICcgKyAgbWVzc2FnZS5jaGFubmVsKSA6ICcnKSk7XG5cdFx0XHRpZihtZXNzYWdlLmNoYW5uZWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0aGlzLm9uRmF0YWxFcnJvcihtZXNzYWdlKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHQvKiBvdGhlcndpc2UgaXQncyBhIGNoYW5uZWwtc3BlY2lmaWMgZXJyb3IsIHNvIGhhbmRsZSBpdCBpbiB0aGUgY2hhbm5lbCAqL1xuXHRcdFx0dGhpcy5jb25uZWN0aW9uTWFuYWdlci5vbkNoYW5uZWxNZXNzYWdlKG1lc3NhZ2UsIHRoaXMpO1xuXHRcdFx0YnJlYWs7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdC8qIGFsbCBvdGhlciBhY3Rpb25zIGFyZSBjaGFubmVsLXNwZWNpZmljICovXG5cdFx0XHR0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLm9uQ2hhbm5lbE1lc3NhZ2UobWVzc2FnZSwgdGhpcyk7XG5cdFx0fVxuXHR9O1xuXG5cdFRyYW5zcG9ydC5wcm90b3R5cGUub25Db25uZWN0ID0gZnVuY3Rpb24obWVzc2FnZSkge1xuXHRcdHRoaXMuaXNDb25uZWN0ZWQgPSB0cnVlO1xuXHRcdHZhciBtYXhQcm9taXNlZElkbGUgPSBtZXNzYWdlLmNvbm5lY3Rpb25EZXRhaWxzLm1heElkbGVJbnRlcnZhbDtcblx0XHRpZihtYXhQcm9taXNlZElkbGUpIHtcblx0XHRcdHRoaXMubWF4SWRsZUludGVydmFsID0gbWF4UHJvbWlzZWRJZGxlICsgdGhpcy50aW1lb3V0cy5yZWFsdGltZVJlcXVlc3RUaW1lb3V0O1xuXHRcdFx0dGhpcy5zZXRJZGxlVGltZXIoKTtcblx0XHR9XG5cdFx0LyogZWxzZSBSZWFsdGltZSBkZWNsaW5lcyB0byBndWFyYW50ZWUgYW55IG1heGltdW0gaWRsZSBpbnRlcnZhbCAtIENEMmggKi9cblx0fTtcblxuXHRUcmFuc3BvcnQucHJvdG90eXBlLm9uRGlzY29ubmVjdCA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcblx0XHQvKiBVc2VkIGZvciB3aGVuIHRoZSBzZXJ2ZXIgaGFzIGRpc2Nvbm5lY3RlZCB0aGUgY2xpZW50ICh1c3VhbGx5IHdpdGggYVxuXHRcdCAqIERJU0NPTk5FQ1RFRCBhY3Rpb24pICovXG5cdFx0dmFyIGVyciA9IG1lc3NhZ2UgJiYgbWVzc2FnZS5lcnJvcjtcblx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlOT1IsICdUcmFuc3BvcnQub25EaXNjb25uZWN0KCknLCAnZXJyID0gJyArIFV0aWxzLmluc3BlY3RFcnJvcihlcnIpKTtcblx0XHR0aGlzLmZpbmlzaCgnZGlzY29ubmVjdGVkJywgZXJyKTtcblx0fTtcblxuXHRUcmFuc3BvcnQucHJvdG90eXBlLm9uRmF0YWxFcnJvciA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcblx0XHQvKiBPbiByZWNlaXB0IG9mIGEgZmF0YWwgY29ubmVjdGlvbiBlcnJvciwgd2UgY2FuIGFzc3VtZSB0aGF0IHRoZSBzZXJ2ZXJcblx0XHQgKiB3aWxsIGNsb3NlIHRoZSBjb25uZWN0aW9uIGFuZCB0aGUgdHJhbnNwb3J0LCBhbmQgZG8gbm90IG5lZWQgdG8gcmVxdWVzdFxuXHRcdCAqIGEgZGlzY29ubmVjdGlvbiAtIFJUTjE1aSAqL1xuXHRcdHZhciBlcnIgPSBtZXNzYWdlICYmIG1lc3NhZ2UuZXJyb3I7XG5cdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX01JTk9SLCAnVHJhbnNwb3J0Lm9uRmF0YWxFcnJvcigpJywgJ2VyciA9ICcgKyBVdGlscy5pbnNwZWN0RXJyb3IoZXJyKSk7XG5cdFx0dGhpcy5maW5pc2goJ2ZhaWxlZCcsIGVycik7XG5cdH07XG5cblx0VHJhbnNwb3J0LnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24obWVzc2FnZSkge1xuXHRcdHZhciBlcnIgPSBtZXNzYWdlICYmIG1lc3NhZ2UuZXJyb3I7XG5cdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX01JTk9SLCAnVHJhbnNwb3J0Lm9uQ2xvc2UoKScsICdlcnIgPSAnICsgVXRpbHMuaW5zcGVjdEVycm9yKGVycikpO1xuXHRcdHRoaXMuZmluaXNoKCdjbG9zZWQnLCBlcnIpO1xuXHR9O1xuXG5cdFRyYW5zcG9ydC5wcm90b3R5cGUucmVxdWVzdENsb3NlID0gZnVuY3Rpb24oKSB7XG5cdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX01JTk9SLCAnVHJhbnNwb3J0LnJlcXVlc3RDbG9zZSgpJywgJycpO1xuXHRcdHRoaXMuc2VuZChjbG9zZU1lc3NhZ2UpO1xuXHR9O1xuXG5cdFRyYW5zcG9ydC5wcm90b3R5cGUucmVxdWVzdERpc2Nvbm5lY3QgPSBmdW5jdGlvbigpIHtcblx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlOT1IsICdUcmFuc3BvcnQucmVxdWVzdERpc2Nvbm5lY3QoKScsICcnKTtcblx0XHR0aGlzLnNlbmQoZGlzY29ubmVjdE1lc3NhZ2UpO1xuXHR9O1xuXG5cdFRyYW5zcG9ydC5wcm90b3R5cGUucGluZyA9IGZ1bmN0aW9uKGlkKSB7XG5cdFx0dmFyIG1zZyA9IHthY3Rpb246IFByb3RvY29sTWVzc2FnZS5BY3Rpb24uSEVBUlRCRUFUfTtcblx0XHRpZihpZCkgbXNnLmlkID0gaWQ7XG5cdFx0dGhpcy5zZW5kKFByb3RvY29sTWVzc2FnZS5mcm9tVmFsdWVzKG1zZykpO1xuXHR9O1xuXG5cdFRyYW5zcG9ydC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uKCkge1xuXHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSU5PUiwgJ1RyYW5zcG9ydC5kaXNwb3NlKCknLCAnJyk7XG5cdFx0dGhpcy5vZmYoKTtcblx0fTtcblxuXHRUcmFuc3BvcnQucHJvdG90eXBlLnNldElkbGVUaW1lciA9IGZ1bmN0aW9uKHRpbWVvdXQpIHtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0aWYoIXRoaXMuaWRsZVRpbWVyKSB7XG5cdFx0XHR0aGlzLmlkbGVUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNlbGYub25JZGxlVGltZXJFeHBpcmUoKTtcblx0XHRcdH0sIHRpbWVvdXQgfHwgdGhpcy5tYXhJZGxlSW50ZXJ2YWwpO1xuXHRcdH1cblx0fTtcblxuXHRUcmFuc3BvcnQucHJvdG90eXBlLm9uSWRsZVRpbWVyRXhwaXJlID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5pZGxlVGltZXIgPSBudWxsO1xuXHRcdHZhciBzaW5jZUxhc3QgPSBVdGlscy5ub3coKSAtIHRoaXMubGFzdEFjdGl2aXR5LFxuXHRcdFx0dGltZVJlbWFpbmluZyA9IHRoaXMubWF4SWRsZUludGVydmFsIC0gc2luY2VMYXN0O1xuXHRcdGlmKHRpbWVSZW1haW5pbmcgPD0gMCkge1xuXHRcdFx0dmFyIG1zZyA9ICdObyBhY3Rpdml0eSBzZWVuIGZyb20gcmVhbHRpbWUgaW4gJyArIHNpbmNlTGFzdCArICdtczsgYXNzdW1pbmcgY29ubmVjdGlvbiBoYXMgZHJvcHBlZCc7XG5cdFx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfRVJST1IsICdUcmFuc3BvcnQub25JZGxlVGltZXJFeHBpcmUoKScsIG1zZyk7XG5cdFx0XHR0aGlzLmRpc2Nvbm5lY3QobmV3IEVycm9ySW5mbyhtc2csIDgwMDAzLCA0MDgpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5zZXRJZGxlVGltZXIodGltZVJlbWFpbmluZyArIDEwKTtcblx0XHR9XG5cdH07XG5cblx0VHJhbnNwb3J0LnByb3RvdHlwZS5vbkF1dGhVcGRhdGVkID0gZnVuY3Rpb24oKSB7fTtcblxuXHRyZXR1cm4gVHJhbnNwb3J0O1xufSkoKTtcblxudmFyIFdlYlNvY2tldFRyYW5zcG9ydCA9IChmdW5jdGlvbigpIHtcblx0dmFyIFdlYlNvY2tldCA9IFBsYXRmb3JtLldlYlNvY2tldDtcblx0dmFyIHNob3J0TmFtZSA9ICd3ZWJfc29ja2V0JztcblxuXHQvKiBwdWJsaWMgY29uc3RydWN0b3IgKi9cblx0ZnVuY3Rpb24gV2ViU29ja2V0VHJhbnNwb3J0KGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMpIHtcblx0XHR0aGlzLnNob3J0TmFtZSA9IHNob3J0TmFtZTtcblx0XHQvKiBJZiBpcyBhIGJyb3dzZXIsIGNhbid0IGRldGVjdCBwaW5ncywgc28gcmVxdWVzdCBwcm90b2NvbCBoZWFydGJlYXRzICovXG5cdFx0cGFyYW1zLmhlYXJ0YmVhdHMgPSBQbGF0Zm9ybS51c2VQcm90b2NvbEhlYXJ0YmVhdHM7XG5cdFx0VHJhbnNwb3J0LmNhbGwodGhpcywgY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcyk7XG5cdFx0dGhpcy53c0hvc3QgPSBEZWZhdWx0cy5nZXRIb3N0KHBhcmFtcy5vcHRpb25zLCBwYXJhbXMuaG9zdCwgdHJ1ZSk7XG5cdH1cblx0VXRpbHMuaW5oZXJpdHMoV2ViU29ja2V0VHJhbnNwb3J0LCBUcmFuc3BvcnQpO1xuXG5cdFdlYlNvY2tldFRyYW5zcG9ydC5pc0F2YWlsYWJsZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhIVdlYlNvY2tldDtcblx0fTtcblxuXHRpZihXZWJTb2NrZXRUcmFuc3BvcnQuaXNBdmFpbGFibGUoKSlcblx0XHRDb25uZWN0aW9uTWFuYWdlci5zdXBwb3J0ZWRUcmFuc3BvcnRzW3Nob3J0TmFtZV0gPSBXZWJTb2NrZXRUcmFuc3BvcnQ7XG5cblx0V2ViU29ja2V0VHJhbnNwb3J0LnRyeUNvbm5lY3QgPSBmdW5jdGlvbihjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zLCBjYWxsYmFjaykge1xuXHRcdHZhciB0cmFuc3BvcnQgPSBuZXcgV2ViU29ja2V0VHJhbnNwb3J0KGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMpO1xuXHRcdHZhciBlcnJvckNiID0gZnVuY3Rpb24oZXJyKSB7IGNhbGxiYWNrKHtldmVudDogdGhpcy5ldmVudCwgZXJyb3I6IGVycn0pOyB9O1xuXHRcdHRyYW5zcG9ydC5vbihbJ2ZhaWxlZCcsICdkaXNjb25uZWN0ZWQnXSwgZXJyb3JDYik7XG5cdFx0dHJhbnNwb3J0Lm9uKCd3c29wZW4nLCBmdW5jdGlvbigpIHtcblx0XHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSU5PUiwgJ1dlYlNvY2tldFRyYW5zcG9ydC50cnlDb25uZWN0KCknLCAndmlhYmxlIHRyYW5zcG9ydCAnICsgdHJhbnNwb3J0KTtcblx0XHRcdHRyYW5zcG9ydC5vZmYoWydmYWlsZWQnLCAnZGlzY29ubmVjdGVkJ10sIGVycm9yQ2IpO1xuXHRcdFx0Y2FsbGJhY2sobnVsbCwgdHJhbnNwb3J0KTtcblx0XHR9KTtcblx0XHR0cmFuc3BvcnQuY29ubmVjdCgpO1xuXHR9O1xuXG5cdFdlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUuY3JlYXRlV2ViU29ja2V0ID0gZnVuY3Rpb24odXJpLCBjb25uZWN0UGFyYW1zKSB7XG5cdFx0dmFyIHBhcmFtQ291bnQgPSAwO1xuXHRcdGlmKGNvbm5lY3RQYXJhbXMpIHtcblx0XHRcdGZvcih2YXIga2V5IGluIGNvbm5lY3RQYXJhbXMpXG5cdFx0XHRcdHVyaSArPSAocGFyYW1Db3VudCsrID8gJyYnIDogJz8nKSArIGtleSArICc9JyArIGNvbm5lY3RQYXJhbXNba2V5XTtcblx0XHR9XG5cdFx0dGhpcy51cmkgPSB1cmk7XG5cdFx0cmV0dXJuIG5ldyBXZWJTb2NrZXQodXJpKTtcblx0fTtcblxuXHRXZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICdXZWJTb2NrZXRUcmFuc3BvcnQ7IHVyaT0nICsgdGhpcy51cmk7XG5cdH07XG5cblx0V2ViU29ja2V0VHJhbnNwb3J0LnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24oKSB7XG5cdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX01JTk9SLCAnV2ViU29ja2V0VHJhbnNwb3J0LmNvbm5lY3QoKScsICdzdGFydGluZycpO1xuXHRcdFRyYW5zcG9ydC5wcm90b3R5cGUuY29ubmVjdC5jYWxsKHRoaXMpO1xuXHRcdHZhciBzZWxmID0gdGhpcywgcGFyYW1zID0gdGhpcy5wYXJhbXMsIG9wdGlvbnMgPSBwYXJhbXMub3B0aW9ucztcblx0XHR2YXIgd3NTY2hlbWUgPSBvcHRpb25zLnRscyA/ICd3c3M6Ly8nIDogJ3dzOi8vJztcblx0XHR2YXIgd3NVcmkgPSB3c1NjaGVtZSArIHRoaXMud3NIb3N0ICsgJzonICsgRGVmYXVsdHMuZ2V0UG9ydChvcHRpb25zKSArICcvJztcblx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlOT1IsICdXZWJTb2NrZXRUcmFuc3BvcnQuY29ubmVjdCgpJywgJ3VyaTogJyArIHdzVXJpKTtcblx0XHR0aGlzLmF1dGguZ2V0QXV0aFBhcmFtcyhmdW5jdGlvbihlcnIsIGF1dGhQYXJhbXMpIHtcblx0XHRcdHZhciBwYXJhbVN0ciA9ICcnOyBmb3IodmFyIHBhcmFtIGluIGF1dGhQYXJhbXMpIHBhcmFtU3RyICs9ICcgJyArIHBhcmFtICsgJzogJyArIGF1dGhQYXJhbXNbcGFyYW1dICsgJzsnO1xuXHRcdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX01JTk9SLCAnV2ViU29ja2V0VHJhbnNwb3J0LmNvbm5lY3QoKScsICdhdXRoUGFyYW1zOicgKyBwYXJhbVN0ciArICcgZXJyOiAnICsgZXJyKTtcblx0XHRcdGlmKGVycikge1xuXHRcdFx0XHRzZWxmLmRpc2Nvbm5lY3QoZXJyKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGNvbm5lY3RQYXJhbXMgPSBwYXJhbXMuZ2V0Q29ubmVjdFBhcmFtcyhhdXRoUGFyYW1zKTtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHZhciB3c0Nvbm5lY3Rpb24gPSBzZWxmLndzQ29ubmVjdGlvbiA9IHNlbGYuY3JlYXRlV2ViU29ja2V0KHdzVXJpLCBjb25uZWN0UGFyYW1zKTtcblx0XHRcdFx0d3NDb25uZWN0aW9uLmJpbmFyeVR5cGUgPSBQbGF0Zm9ybS5iaW5hcnlUeXBlO1xuXHRcdFx0XHR3c0Nvbm5lY3Rpb24ub25vcGVuID0gZnVuY3Rpb24oKSB7IHNlbGYub25Xc09wZW4oKTsgfTtcblx0XHRcdFx0d3NDb25uZWN0aW9uLm9uY2xvc2UgPSBmdW5jdGlvbihldikgeyBzZWxmLm9uV3NDbG9zZShldik7IH07XG5cdFx0XHRcdHdzQ29ubmVjdGlvbi5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldikgeyBzZWxmLm9uV3NEYXRhKGV2LmRhdGEpOyB9O1xuXHRcdFx0XHR3c0Nvbm5lY3Rpb24ub25lcnJvciA9IGZ1bmN0aW9uKGV2KSB7IHNlbGYub25Xc0Vycm9yKGV2KTsgfTtcblx0XHRcdFx0aWYod3NDb25uZWN0aW9uLm9uKSB7XG5cdFx0XHRcdFx0Lyogbm9kZTsgYnJvd3NlcnMgY3VycmVudGx5IGRvbid0IGhhdmUgYSBnZW5lcmFsIGV2ZW50ZW1pdHRlciBhbmQgY2FuJ3QgZGV0ZWN0XG5cdFx0XHRcdFx0ICogcGluZ3MuIEFsc28sIG5vIG5lZWQgdG8gcmVwbHkgd2l0aCBhIHBvbmcgZXhwbGljaXRseSwgd3MgbGliIGhhbmRsZXMgdGhhdCAqL1xuXHRcdFx0XHRcdHdzQ29ubmVjdGlvbi5vbigncGluZycsIGZ1bmN0aW9uKCkgeyBzZWxmLnNldElkbGVUaW1lcigpIH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX0VSUk9SLCAnV2ViU29ja2V0VHJhbnNwb3J0LmNvbm5lY3QoKScsICdVbmV4cGVjdGVkIGV4Y2VwdGlvbiBjcmVhdGluZyB3ZWJzb2NrZXQ6IGVyciA9ICcgKyAoZS5zdGFjayB8fCBlLm1lc3NhZ2UpKTtcblx0XHRcdFx0c2VsZi5kaXNjb25uZWN0KGUpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9O1xuXG5cdFdlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcblx0XHR2YXIgd3NDb25uZWN0aW9uID0gdGhpcy53c0Nvbm5lY3Rpb247XG5cdFx0aWYoIXdzQ29ubmVjdGlvbikge1xuXHRcdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX0VSUk9SLCAnV2ViU29ja2V0VHJhbnNwb3J0LnNlbmQoKScsICdObyBzb2NrZXQgY29ubmVjdGlvbicpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR3c0Nvbm5lY3Rpb24uc2VuZChQcm90b2NvbE1lc3NhZ2Uuc2VyaWFsaXplKG1lc3NhZ2UsIHRoaXMucGFyYW1zLmZvcm1hdCkpO1xuXHR9O1xuXG5cdFdlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUub25Xc0RhdGEgPSBmdW5jdGlvbihkYXRhKSB7XG5cdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX01JQ1JPLCAnV2ViU29ja2V0VHJhbnNwb3J0Lm9uV3NEYXRhKCknLCAnZGF0YSByZWNlaXZlZDsgbGVuZ3RoID0gJyArIGRhdGEubGVuZ3RoICsgJzsgdHlwZSA9ICcgKyB0eXBlb2YoZGF0YSkpO1xuXHRcdHRyeSB7XG5cdFx0XHR0aGlzLm9uUHJvdG9jb2xNZXNzYWdlKFByb3RvY29sTWVzc2FnZS5kZXNlcmlhbGl6ZShkYXRhLCB0aGlzLmZvcm1hdCkpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19FUlJPUiwgJ1dlYlNvY2tldFRyYW5zcG9ydC5vbldzRGF0YSgpJywgJ1VuZXhwZWN0ZWQgZXhjZXB0aW9uIGhhbmRpbmcgY2hhbm5lbCBtZXNzYWdlOiAnICsgZS5zdGFjayk7XG5cdFx0fVxuXHR9O1xuXG5cdFdlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUub25Xc09wZW4gPSBmdW5jdGlvbigpIHtcblx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlOT1IsICdXZWJTb2NrZXRUcmFuc3BvcnQub25Xc09wZW4oKScsICdvcGVuZWQgV2ViU29ja2V0Jyk7XG5cdFx0dGhpcy5lbWl0KCd3c29wZW4nKTtcblx0fTtcblxuXHRXZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLm9uV3NDbG9zZSA9IGZ1bmN0aW9uKGV2KSB7XG5cdFx0dmFyIHdhc0NsZWFuLCBjb2RlLCByZWFzb247XG5cdFx0aWYodHlwZW9mKGV2KSA9PSAnb2JqZWN0Jykge1xuXHRcdFx0LyogVzNDIHNwZWMtY29tcGF0aWJsZSAqL1xuXHRcdFx0d2FzQ2xlYW4gPSBldi53YXNDbGVhbjtcblx0XHRcdGNvZGUgPSBldi5jb2RlO1xuXHRcdH0gZWxzZSAvKmlmKHR5cGVvZihldikgPT0gJ251bWJlcicpKi8ge1xuXHRcdFx0Lyogd3MgaW4gbm9kZSAqL1xuXHRcdFx0Y29kZSA9IGV2O1xuXHRcdFx0d2FzQ2xlYW4gPSAoY29kZSA9PSAxMDAwKTtcblx0XHR9XG5cdFx0ZGVsZXRlIHRoaXMud3NDb25uZWN0aW9uO1xuXHRcdGlmKHdhc0NsZWFuKSB7XG5cdFx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlOT1IsICdXZWJTb2NrZXRUcmFuc3BvcnQub25Xc0Nsb3NlKCknLCAnQ2xlYW5seSBjbG9zZWQgV2ViU29ja2V0Jyk7XG5cdFx0XHR2YXIgZXJyID0gbmV3IEVycm9ySW5mbygnV2Vic29ja2V0IGNsb3NlZCcsIDgwMDAzLCA0MDApO1xuXHRcdFx0dGhpcy5maW5pc2goJ2Rpc2Nvbm5lY3RlZCcsIGVycik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBtc2cgPSAnVW5jbGVhbiBkaXNjb25uZWN0aW9uIG9mIFdlYlNvY2tldCA7IGNvZGUgPSAnICsgY29kZSxcblx0XHRcdFx0ZXJyID0gbmV3IEVycm9ySW5mbyhtc2csIDgwMDAzLCA0MDApO1xuXHRcdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX0VSUk9SLCAnV2ViU29ja2V0VHJhbnNwb3J0Lm9uV3NDbG9zZSgpJywgbXNnKTtcblx0XHRcdHRoaXMuZmluaXNoKCdkaXNjb25uZWN0ZWQnLCBlcnIpO1xuXHRcdH1cblx0XHR0aGlzLmVtaXQoJ2Rpc3Bvc2VkJyk7XG5cdH07XG5cblx0V2ViU29ja2V0VHJhbnNwb3J0LnByb3RvdHlwZS5vbldzRXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcblx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfRVJST1IsICdXZWJTb2NrZXRUcmFuc3BvcnQub25FcnJvcigpJywgJ1VuZXhwZWN0ZWQgZXJyb3IgZnJvbSBXZWJTb2NrZXQ6ICcgKyBlcnIubWVzc2FnZSk7XG5cdFx0LyogV2FpdCBhIHRpY2sgYmVmb3JlIGFib3J0aW5nOiBpZiB0aGUgd2Vic29ja2V0IHdhcyBjb25uZWN0ZWQsIHRoaXMgZXZlbnRcblx0XHQgKiB3aWxsIGJlIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IGFuIG9uY2xvc2UgZXZlbnQgd2l0aCBhIGNsb3NlIGNvZGUuIEFsbG93XG5cdFx0ICogdGhhdCB0byBjbG9zZSBpdCAoc28gd2Ugc2VlIHRoZSBjbG9zZSBjb2RlKSByYXRoZXIgdGhhbiBhbnRpY2lwYXRpbmcgaXQgKi9cblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0VXRpbHMubmV4dFRpY2soZnVuY3Rpb24oKSB7XG5cdFx0XHRzZWxmLmRpc2Nvbm5lY3QoZXJyKTtcblx0XHR9KTtcblx0fTtcblxuXHRXZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbigpIHtcblx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlOT1IsICdXZWJTb2NrZXRUcmFuc3BvcnQuZGlzcG9zZSgpJywgJycpO1xuXHRcdHZhciB3c0Nvbm5lY3Rpb24gPSB0aGlzLndzQ29ubmVjdGlvbjtcblx0XHRpZih3c0Nvbm5lY3Rpb24pIHtcblx0XHRcdC8qIElnbm9yZSBhbnkgbWVzc2FnZXMgdGhhdCBjb21lIHRocm91Z2ggYWZ0ZXIgZGlzcG9zZSgpIGlzIGNhbGxlZCBidXQgYmVmb3JlXG5cdFx0XHQgKiB3ZWJzb2NrZXQgaXMgYWN0dWFsbHkgY2xvc2VkLiAobW9zdGx5IHdvdWxkIGJlIGhhcm1sZXNzLCBidXQgaWYgaXQncyBhXG5cdFx0XHQgKiBDT05ORUNURUQsIGl0J2xsIHJlLXRpY2sgaXNDb25uZWN0ZWQgYW5kIGNhdXNlIGFsbCBzb3J0cyBvZiBoYXZvYykgKi9cblx0XHRcdHdzQ29ubmVjdGlvbi5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHt9O1xuXHRcdFx0ZGVsZXRlIHRoaXMud3NDb25uZWN0aW9uO1xuXHRcdFx0LyogZGVmZXIgdW50aWwgdGhlIG5leHQgZXZlbnQgbG9vcCBjeWNsZSBiZWZvcmUgY2xvc2luZyB0aGUgc29ja2V0LFxuXHRcdFx0ICogZ2l2aW5nIHNvbWUgaW1wbGVtZW50YXRpb25zIHRoZSBvcHBvcnR1bml0eSB0byBzZW5kIGFueSBvdXRzdGFuZGluZyBjbG9zZSBtZXNzYWdlICovXG5cdFx0XHRVdGlscy5uZXh0VGljayhmdW5jdGlvbigpIHtcblx0XHRcdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX01JQ1JPLCAnV2ViU29ja2V0VHJhbnNwb3J0LmRpc3Bvc2UoKScsICdjbG9zaW5nIHdlYnNvY2tldCcpO1xuXHRcdFx0XHR3c0Nvbm5lY3Rpb24uY2xvc2UoKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gV2ViU29ja2V0VHJhbnNwb3J0O1xufSkoKTtcblxudmFyIENvbWV0VHJhbnNwb3J0ID0gKGZ1bmN0aW9uKCkge1xuXG5cdHZhciBSRVFfU0VORCA9IDAsXG5cdFx0UkVRX1JFQ1YgPSAxLFxuXHRcdFJFUV9SRUNWX1BPTEwgPSAyLFxuXHRcdFJFUV9SRUNWX1NUUkVBTSA9IDM7XG5cblx0ZnVuY3Rpb24gYWN0T25Db25uZWN0SGVhZGVycyhoZWFkZXJzLCBob3N0LCBjb25uZWN0aW9uTWFuYWdlcikge1xuXHRcdGlmKGhlYWRlcnMgJiYgaGVhZGVycy5zZXJ2ZXIgJiYgKGhlYWRlcnMuc2VydmVyLmluZGV4T2YoJ2Nsb3VkZmxhcmUnKSA+IC0xKSkge1xuXHRcdFx0LyogQ2xvdWRmbGFyZSBkb2Vzbid0IHN1cHBvcnQgeGhyIHN0cmVhbWluZyAqL1xuXHRcdFx0dmFyIGJsYWNrbGlzdCA9IGNvbm5lY3Rpb25NYW5hZ2VyLnRyYW5zcG9ydEhvc3RCbGFja2xpc3RbaG9zdF07XG5cdFx0XHRpZighYmxhY2tsaXN0KSB7XG5cdFx0XHRcdGNvbm5lY3Rpb25NYW5hZ2VyLnRyYW5zcG9ydEhvc3RCbGFja2xpc3RbaG9zdF0gPSBbJ3hocl9zdHJlYW1pbmcnXTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYoIVV0aWxzLmFyckluKGJsYWNrbGlzdCwgJ3hocl9zdHJlYW1pbmcnKSkge1xuXHRcdFx0XHRibGFja2xpc3QucHVzaCgneGhyX3N0cmVhbWluZycpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qIFRPRE86IGNhbiByZW1vdmUgb25jZSByZWFsdGltZSBzZW5kcyBwcm90b2NvbCBtZXNzYWdlIHJlc3BvbnNlcyBmb3IgY29tZXQgZXJyb3JzICovXG5cdGZ1bmN0aW9uIHNob3VsZEJlRXJyb3JBY3Rpb24oZXJyKSB7XG5cdFx0dmFyIFVOUkVTT0xWQUJMRV9FUlJPUl9DT0RFUyA9IFs4MDAxNSwgODAwMTcsIDgwMDMwXTtcblx0XHRpZihlcnIuY29kZSkge1xuXHRcdFx0aWYoQXV0aC5pc1Rva2VuRXJyKGVycikpIHJldHVybiBmYWxzZTtcblx0XHRcdGlmKFV0aWxzLmFyckluKFVOUkVTT0xWQUJMRV9FUlJPUl9DT0RFUywgZXJyLmNvZGUpKSByZXR1cm4gdHJ1ZTtcblx0XHRcdHJldHVybiAoZXJyLmNvZGUgPj0gNDAwMDAgJiYgZXJyLmNvZGUgPCA1MDAwMCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8qIExpa2VseSBhIG5ldHdvcmsgb3IgdHJhbnNwb3J0IGVycm9yIG9mIHNvbWUga2luZC4gQ2VydGFpbmx5IG5vdCBmYXRhbCB0byB0aGUgY29ubmVjdGlvbiAqL1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHByb3RvY29sTWVzc2FnZUZyb21SYXdFcnJvcihlcnIpIHtcblx0XHQvKiBlcnIgd2lsbCBiZSBlaXRoZXIgYSBsZWdhY3kgKG5vbi1wcm90b2NvbG1lc3NhZ2UpIGNvbWV0IGVycm9yIHJlc3BvbnNlXG5cdFx0ICogKHdoaWNoIHdpbGwgaGF2ZSBhbiBlcnIuY29kZSksIG9yIGEgeGhyL25ldHdvcmsgZXJyb3IgKHdoaWNoIHdvbid0KS4gKi9cblx0XHRpZihzaG91bGRCZUVycm9yQWN0aW9uKGVycikpIHtcblx0XHRcdHJldHVybiBbUHJvdG9jb2xNZXNzYWdlLmZyb21WYWx1ZXMoe2FjdGlvbjogUHJvdG9jb2xNZXNzYWdlLkFjdGlvbi5FUlJPUiwgZXJyb3I6IGVycn0pXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIFtQcm90b2NvbE1lc3NhZ2UuZnJvbVZhbHVlcyh7YWN0aW9uOiBQcm90b2NvbE1lc3NhZ2UuQWN0aW9uLkRJU0NPTk5FQ1RFRCwgZXJyb3I6IGVycn0pXTtcblx0XHR9XG5cdH1cblxuXHQvKlxuXHQgKiBBIGJhc2UgY29tZXQgdHJhbnNwb3J0IGNsYXNzXG5cdCAqL1xuXHRmdW5jdGlvbiBDb21ldFRyYW5zcG9ydChjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zKSB7XG5cdFx0LyogYmluYXJ5IG5vdCBzdXBwb3J0ZWQgZm9yIGNvbWV0LCBzbyBqdXN0IGZhbGwgYmFjayB0byBkZWZhdWx0ICovXG5cdFx0cGFyYW1zLmZvcm1hdCA9IHVuZGVmaW5lZDtcblx0XHRwYXJhbXMuaGVhcnRiZWF0cyA9IHRydWU7XG5cdFx0VHJhbnNwb3J0LmNhbGwodGhpcywgY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcyk7XG5cdFx0Lyogc3RyZWFtaW5nIGRlZmF1bHRzIHRvIHRydWUgKi9cblx0XHR0aGlzLnN0cmVhbSA9ICgnc3RyZWFtJyBpbiBwYXJhbXMpID8gcGFyYW1zLnN0cmVhbSA6IHRydWU7XG5cdFx0dGhpcy5zZW5kUmVxdWVzdCA9IG51bGw7XG5cdFx0dGhpcy5yZWN2UmVxdWVzdCA9IG51bGw7XG5cdFx0dGhpcy5wZW5kaW5nQ2FsbGJhY2sgPSBudWxsO1xuXHRcdHRoaXMucGVuZGluZ0l0ZW1zID0gbnVsbDtcblx0XHR0aGlzLmRpc3Bvc2VkID0gZmFsc2U7XG5cdH1cblx0VXRpbHMuaW5oZXJpdHMoQ29tZXRUcmFuc3BvcnQsIFRyYW5zcG9ydCk7XG5cblx0Q29tZXRUcmFuc3BvcnQuUkVRX1NFTkQgPSBSRVFfU0VORDtcblx0Q29tZXRUcmFuc3BvcnQuUkVRX1JFQ1YgPSBSRVFfUkVDVjtcblx0Q29tZXRUcmFuc3BvcnQuUkVRX1JFQ1ZfUE9MTCA9IFJFUV9SRUNWX1BPTEw7XG5cdENvbWV0VHJhbnNwb3J0LlJFUV9SRUNWX1NUUkVBTSA9IFJFUV9SRUNWX1NUUkVBTTtcblxuXHQvKiBwdWJsaWMgaW5zdGFuY2UgbWV0aG9kcyAqL1xuXHRDb21ldFRyYW5zcG9ydC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuXHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSU5PUiwgJ0NvbWV0VHJhbnNwb3J0LmNvbm5lY3QoKScsICdzdGFydGluZycpO1xuXHRcdFRyYW5zcG9ydC5wcm90b3R5cGUuY29ubmVjdC5jYWxsKHRoaXMpO1xuXHRcdHZhciBzZWxmID0gdGhpcywgcGFyYW1zID0gdGhpcy5wYXJhbXMsIG9wdGlvbnMgPSBwYXJhbXMub3B0aW9ucztcblx0XHR2YXIgaG9zdCA9IERlZmF1bHRzLmdldEhvc3Qob3B0aW9ucywgcGFyYW1zLmhvc3QpO1xuXHRcdHZhciBwb3J0ID0gRGVmYXVsdHMuZ2V0UG9ydChvcHRpb25zKTtcblx0XHR2YXIgY29tZXRTY2hlbWUgPSBvcHRpb25zLnRscyA/ICdodHRwczovLycgOiAnaHR0cDovLyc7XG5cblx0XHR0aGlzLmJhc2VVcmkgPSBjb21ldFNjaGVtZSArIGhvc3QgKyAnOicgKyBwb3J0ICsgJy9jb21ldC8nO1xuXHRcdHZhciBjb25uZWN0VXJpID0gdGhpcy5iYXNlVXJpICsgJ2Nvbm5lY3QnO1xuXHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSU5PUiwgJ0NvbWV0VHJhbnNwb3J0LmNvbm5lY3QoKScsICd1cmk6ICcgKyBjb25uZWN0VXJpKTtcblx0XHR0aGlzLmF1dGguZ2V0QXV0aFBhcmFtcyhmdW5jdGlvbihlcnIsIGF1dGhQYXJhbXMpIHtcblx0XHRcdGlmKGVycikge1xuXHRcdFx0XHRzZWxmLmRpc2Nvbm5lY3QoZXJyKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0c2VsZi5hdXRoUGFyYW1zID0gYXV0aFBhcmFtcztcblx0XHRcdHZhciBjb25uZWN0UGFyYW1zID0gc2VsZi5wYXJhbXMuZ2V0Q29ubmVjdFBhcmFtcyhhdXRoUGFyYW1zKTtcblx0XHRcdGlmKCdzdHJlYW0nIGluIGNvbm5lY3RQYXJhbXMpIHNlbGYuc3RyZWFtID0gY29ubmVjdFBhcmFtcy5zdHJlYW07XG5cdFx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlOT1IsICdDb21ldFRyYW5zcG9ydC5jb25uZWN0KCknLCAnY29ubmVjdFBhcmFtczonICsgVXRpbHMudG9RdWVyeVN0cmluZyhjb25uZWN0UGFyYW1zKSk7XG5cblx0XHRcdC8qIHRoaXMgd2lsbCBiZSB0aGUgJ3JlY3ZSZXF1ZXN0JyBzbyB0aGlzIGNvbm5lY3Rpb24gY2FuIHN0cmVhbSBtZXNzYWdlcyAqL1xuXHRcdFx0dmFyIHByZWNvbm5lY3RlZCA9IGZhbHNlLFxuXHRcdFx0XHRjb25uZWN0UmVxdWVzdCA9IHNlbGYucmVjdlJlcXVlc3QgPSBzZWxmLmNyZWF0ZVJlcXVlc3QoY29ubmVjdFVyaSwgbnVsbCwgY29ubmVjdFBhcmFtcywgbnVsbCwgKHNlbGYuc3RyZWFtID8gUkVRX1JFQ1ZfU1RSRUFNIDogUkVRX1JFQ1YpKTtcblxuXHRcdFx0Y29ubmVjdFJlcXVlc3Qub24oJ2RhdGEnLCBmdW5jdGlvbihkYXRhKSB7XG5cdFx0XHRcdGlmKCFzZWxmLnJlY3ZSZXF1ZXN0KSB7XG5cdFx0XHRcdFx0LyogdGhlIHRyYW5zcG9ydCB3YXMgZGlzcG9zZWQgYmVmb3JlIHdlIGNvbm5lY3RlZCAqL1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZighcHJlY29ubmVjdGVkKSB7XG5cdFx0XHRcdFx0cHJlY29ubmVjdGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRzZWxmLmVtaXQoJ3ByZWNvbm5lY3QnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzZWxmLm9uRGF0YShkYXRhKTtcblx0XHRcdH0pO1xuXHRcdFx0Y29ubmVjdFJlcXVlc3Qub24oJ2NvbXBsZXRlJywgZnVuY3Rpb24oZXJyLCBfYm9keSwgaGVhZGVycykge1xuXHRcdFx0XHRhY3RPbkNvbm5lY3RIZWFkZXJzKGhlYWRlcnMsIGhvc3QsIHNlbGYuY29ubmVjdGlvbk1hbmFnZXIpO1xuXHRcdFx0XHRpZighc2VsZi5yZWN2UmVxdWVzdCkge1xuXHRcdFx0XHRcdC8qIHRoZSB0cmFuc3BvcnQgd2FzIGRpc3Bvc2VkIGJlZm9yZSB3ZSBjb25uZWN0ZWQgKi9cblx0XHRcdFx0XHRlcnIgPSBlcnIgfHwgbmV3IEVycm9ySW5mbygnUmVxdWVzdCBjYW5jZWxsZWQnLCA4MDAwMCwgNDAwKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzZWxmLnJlY3ZSZXF1ZXN0ID0gbnVsbDtcblx0XHRcdFx0aWYodGhpcy5tYXhJZGxlSW50ZXJ2YWwpIHtcblx0XHRcdFx0XHR0aGlzLnNldElkbGVUaW1lcigpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKGVycikge1xuXHRcdFx0XHRcdGlmKGVyci5jb2RlKSB7XG5cdFx0XHRcdFx0XHQvKiBBIHByb3RvY29sIGVycm9yIHJlY2VpdmVkIGZyb20gcmVhbHRpbWUuIFRPRE86IG9uY2UgcmVhbHRpbWVcblx0XHRcdFx0XHRcdCAqIGNvbnNpc3RlbmRseSBzZW5kcyBlcnJvcnMgd3JhcHBlZCBpbiBwcm90b2NvbCBtZXNzYWdlcywgc2hvdWxkIGJlXG5cdFx0XHRcdFx0XHQgKiBhYmxlIHRvIHJlbW92ZSB0aGlzICovXG5cdFx0XHRcdFx0XHRzZWxmLm9uRGF0YShwcm90b2NvbE1lc3NhZ2VGcm9tUmF3RXJyb3IoZXJyKSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8qIEEgbmV0d29yay94aHIgZXJyb3IuIERvbid0IGJvdGhlciB3cmFwcGluZyBpbiBhIHByb3RvY29sIG1lc3NhZ2UsXG5cdFx0XHRcdFx0XHQgKiBqdXN0IGRpc2Nvbm5lY3QgdGhlIHRyYW5zcG9ydCAqL1xuXHRcdFx0XHRcdFx0c2VsZi5kaXNjb25uZWN0KGVycik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRVdGlscy5uZXh0VGljayhmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRzZWxmLnJlY3YoKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XHRcdGNvbm5lY3RSZXF1ZXN0LmV4ZWMoKTtcblx0XHR9KTtcblx0fTtcblxuXHRDb21ldFRyYW5zcG9ydC5wcm90b3R5cGUucmVxdWVzdENsb3NlID0gZnVuY3Rpb24oKSB7XG5cdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX01JTk9SLCAnQ29tZXRUcmFuc3BvcnQucmVxdWVzdENsb3NlKCknKTtcblx0XHR0aGlzLl9yZXF1ZXN0Q2xvc2VPckRpc2Nvbm5lY3QodHJ1ZSk7XG5cdH07XG5cblx0Q29tZXRUcmFuc3BvcnQucHJvdG90eXBlLnJlcXVlc3REaXNjb25uZWN0ID0gZnVuY3Rpb24oKSB7XG5cdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX01JTk9SLCAnQ29tZXRUcmFuc3BvcnQucmVxdWVzdERpc2Nvbm5lY3QoKScpO1xuXHRcdHRoaXMuX3JlcXVlc3RDbG9zZU9yRGlzY29ubmVjdChmYWxzZSk7XG5cdH07XG5cblx0Q29tZXRUcmFuc3BvcnQucHJvdG90eXBlLl9yZXF1ZXN0Q2xvc2VPckRpc2Nvbm5lY3QgPSBmdW5jdGlvbihjbG9zaW5nKSB7XG5cdFx0dmFyIGNsb3NlT3JEaXNjb25uZWN0VXJpID0gY2xvc2luZyA/IHRoaXMuY2xvc2VVcmkgOiB0aGlzLmRpc2Nvbm5lY3RVcmk7XG5cdFx0aWYoY2xvc2VPckRpc2Nvbm5lY3RVcmkpIHtcblx0XHRcdHZhciBzZWxmID0gdGhpcyxcblx0XHRcdFx0cmVxdWVzdCA9IHRoaXMuY3JlYXRlUmVxdWVzdChjbG9zZU9yRGlzY29ubmVjdFVyaSwgbnVsbCwgdGhpcy5hdXRoUGFyYW1zLCBudWxsLCBSRVFfU0VORCk7XG5cblx0XHRcdHJlcXVlc3Qub24oJ2NvbXBsZXRlJywgZnVuY3Rpb24gKGVycikge1xuXHRcdFx0XHRpZihlcnIpIHtcblx0XHRcdFx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfRVJST1IsICdDb21ldFRyYW5zcG9ydC5yZXF1ZXN0JyArIChjbG9zaW5nID8gJ0Nsb3NlKCknIDogJ0Rpc2Nvbm5lY3QoKScpLCAncmVxdWVzdCByZXR1cm5lZCBlcnIgPSAnICsgZXJyKTtcblx0XHRcdFx0XHRzZWxmLmZpbmlzaCgnZGlzY29ubmVjdGVkJywgZXJyKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRyZXF1ZXN0LmV4ZWMoKTtcblx0XHR9XG5cdH07XG5cblx0Q29tZXRUcmFuc3BvcnQucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbigpIHtcblx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlOT1IsICdDb21ldFRyYW5zcG9ydC5kaXNwb3NlKCknLCAnJyk7XG5cdFx0aWYoIXRoaXMuZGlzcG9zZWQpIHtcblx0XHRcdHRoaXMuZGlzcG9zZWQgPSB0cnVlO1xuXHRcdFx0aWYodGhpcy5yZWN2UmVxdWVzdCkge1xuXHRcdFx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlOT1IsICdDb21ldFRyYW5zcG9ydC5kaXNwb3NlKCknLCAnYWJvcnRpbmcgcmVjdiByZXF1ZXN0Jyk7XG5cdFx0XHRcdHRoaXMucmVjdlJlcXVlc3QuYWJvcnQoKTtcblx0XHRcdFx0dGhpcy5yZWN2UmVxdWVzdCA9IG51bGw7XG5cdFx0XHR9XG5cdFx0XHQvKiBJbiBhbG1vc3QgYWxsIGNhc2VzIHRoZSB0cmFuc3BvcnQgd2lsbCBiZSBmaW5pc2hlZCBiZWZvcmUgaXQnc1xuXHRcdFx0ICogZGlzcG9zZWQuIEZpbmlzaCBoZXJlIGp1c3QgdG8gbWFrZSBzdXJlLiAqL1xuXHRcdFx0dGhpcy5maW5pc2goJ2Rpc2Nvbm5lY3RlZCcsIENvbm5lY3Rpb25FcnJvci5kaXNjb25uZWN0ZWQpO1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0VXRpbHMubmV4dFRpY2soZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNlbGYuZW1pdCgnZGlzcG9zZWQnKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fTtcblxuXHRDb21ldFRyYW5zcG9ydC5wcm90b3R5cGUub25Db25uZWN0ID0gZnVuY3Rpb24obWVzc2FnZSkge1xuXHRcdC8qIGlmIHRoaXMgdHJhbnNwb3J0IGhhcyBiZWVuIGRpc3Bvc2VkIHdoaWxzdCBhd2FpdGluZyBjb25uZWN0aW9uLCBkbyBub3RoaW5nICovXG5cdFx0aWYodGhpcy5kaXNwb3NlZCkgcmV0dXJuO1xuXG5cdFx0LyogdGhlIGNvbm5lY3Rpb25LZXkgaW4gYSBjb21ldCBjb25uZWN0ZWQgcmVzcG9uc2UgaXMgcmVhbGx5XG5cdFx0ICogPGluc3RJZD4tPGNvbm5lY3Rpb25LZXk+ICovXG5cdFx0dmFyIGNvbm5lY3Rpb25TdHIgPSBtZXNzYWdlLmNvbm5lY3Rpb25LZXk7XG5cdFx0VHJhbnNwb3J0LnByb3RvdHlwZS5vbkNvbm5lY3QuY2FsbCh0aGlzLCBtZXNzYWdlKTtcblxuXHRcdHZhciBiYXNlQ29ubmVjdGlvblVyaSA9ICB0aGlzLmJhc2VVcmkgKyBjb25uZWN0aW9uU3RyO1xuXHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSUNSTywgJ0NvbWV0VHJhbnNwb3J0Lm9uQ29ubmVjdCgpJywgJ2Jhc2VVcmkgPSAnICsgYmFzZUNvbm5lY3Rpb25VcmkgKyAnOyBjb25uZWN0aW9uS2V5ID0gJyArIG1lc3NhZ2UuY29ubmVjdGlvbktleSk7XG5cdFx0dGhpcy5zZW5kVXJpID0gYmFzZUNvbm5lY3Rpb25VcmkgKyAnL3NlbmQnO1xuXHRcdHRoaXMucmVjdlVyaSA9IGJhc2VDb25uZWN0aW9uVXJpICsgJy9yZWN2Jztcblx0XHR0aGlzLmNsb3NlVXJpID0gYmFzZUNvbm5lY3Rpb25VcmkgKyAnL2Nsb3NlJztcblx0XHR0aGlzLmRpc2Nvbm5lY3RVcmkgPSBiYXNlQ29ubmVjdGlvblVyaSArICcvZGlzY29ubmVjdCc7XG5cdH07XG5cblx0Q29tZXRUcmFuc3BvcnQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG5cdFx0aWYodGhpcy5zZW5kUmVxdWVzdCkge1xuXHRcdFx0LyogdGhlcmUgaXMgYSBwZW5kaW5nIHNlbmQsIHNvIHF1ZXVlIHRoaXMgbWVzc2FnZSAqL1xuXHRcdFx0dGhpcy5wZW5kaW5nSXRlbXMgPSB0aGlzLnBlbmRpbmdJdGVtcyB8fCBbXTtcblx0XHRcdHRoaXMucGVuZGluZ0l0ZW1zLnB1c2gobWVzc2FnZSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdC8qIHNlbmQgdGhpcywgcGx1cyBhbnkgcGVuZGluZywgbm93ICovXG5cdFx0dmFyIHBlbmRpbmdJdGVtcyA9IHRoaXMucGVuZGluZ0l0ZW1zIHx8IFtdO1xuXHRcdHBlbmRpbmdJdGVtcy5wdXNoKG1lc3NhZ2UpO1xuXHRcdHRoaXMucGVuZGluZ0l0ZW1zID0gbnVsbDtcblxuXHRcdHRoaXMuc2VuZEl0ZW1zKHBlbmRpbmdJdGVtcyk7XG5cdH07XG5cblx0Q29tZXRUcmFuc3BvcnQucHJvdG90eXBlLnNlbmRBbnlQZW5kaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBlbmRpbmdJdGVtcyA9IHRoaXMucGVuZGluZ0l0ZW1zO1xuXG5cdFx0aWYoIXBlbmRpbmdJdGVtcykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMucGVuZGluZ0l0ZW1zID0gbnVsbDtcblx0XHR0aGlzLnNlbmRJdGVtcyhwZW5kaW5nSXRlbXMpO1xuXHR9XG5cblx0Q29tZXRUcmFuc3BvcnQucHJvdG90eXBlLnNlbmRJdGVtcyA9IGZ1bmN0aW9uKGl0ZW1zKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzLFxuXHRcdFx0c2VuZFJlcXVlc3QgPSB0aGlzLnNlbmRSZXF1ZXN0ID0gc2VsZi5jcmVhdGVSZXF1ZXN0KHNlbGYuc2VuZFVyaSwgbnVsbCwgc2VsZi5hdXRoUGFyYW1zLCB0aGlzLmVuY29kZVJlcXVlc3QoaXRlbXMpLCBSRVFfU0VORCk7XG5cblx0XHRzZW5kUmVxdWVzdC5vbignY29tcGxldGUnLCBmdW5jdGlvbihlcnIsIGRhdGEpIHtcblx0XHRcdGlmKGVycikgTG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX0VSUk9SLCAnQ29tZXRUcmFuc3BvcnQuc2VuZEl0ZW1zKCknLCAnb24gY29tcGxldGU6IGVyciA9ICcgKyBKU09OLnN0cmluZ2lmeShlcnIpKTtcblx0XHRcdHNlbGYuc2VuZFJlcXVlc3QgPSBudWxsO1xuXG5cdFx0XHQvKiB0aGUgcmVzdWx0cyBvZiB0aGUgcmVxdWVzdCB1c3VhbGx5IGdldCBoYW5kbGVkIGFzIHByb3RvY29sIHJlc3BvbnNlcyBpbnN0ZWFkIG9mIHNlbmQgZXJyb3JzICovXG5cdFx0XHRpZihkYXRhKSB7XG5cdFx0XHRcdHNlbGYub25EYXRhKGRhdGEpO1xuXHRcdFx0fSBlbHNlIGlmKGVyciAmJiBlcnIuY29kZSkge1xuXHRcdFx0XHQvKiBBIHByb3RvY29sIGVycm9yIHJlY2VpdmVkIGZyb20gcmVhbHRpbWUuIFRPRE86IG9uY2UgcmVhbHRpbWVcblx0XHRcdFx0ICogY29uc2lzdGVuZGx5IHNlbmRzIGVycm9ycyB3cmFwcGVkIGluIHByb3RvY29sIG1lc3NhZ2VzLCBzaG91bGQgYmVcblx0XHRcdFx0ICogYWJsZSB0byByZW1vdmUgdGhpcyAqL1xuXHRcdFx0XHRzZWxmLm9uRGF0YShwcm90b2NvbE1lc3NhZ2VGcm9tUmF3RXJyb3IoZXJyKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvKiBBIG5ldHdvcmsveGhyIGVycm9yLiBEb24ndCBib3RoZXIgd3JhcHBpbmcgaW4gYSBwcm90b2NvbCBtZXNzYWdlLFxuXHRcdFx0XHQgKiBqdXN0IGRpc2Nvbm5lY3QgdGhlIHRyYW5zcG9ydCAqL1xuXHRcdFx0XHRzZWxmLmRpc2Nvbm5lY3QoZXJyKTtcblx0XHRcdH1cblxuXHRcdFx0aWYoc2VsZi5wZW5kaW5nSXRlbXMpIHtcblx0XHRcdFx0VXRpbHMubmV4dFRpY2soZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0LyogSWYgdGhlcmUncyBhIG5ldyBzZW5kIHJlcXVlc3QgYnkgbm93LCBhbnkgcGVuZGluZyBpdGVtcyB3aWxsIGhhdmVcblx0XHRcdFx0XHQgKiBiZWVuIHBpY2tlZCB1cCBieSB0aGF0OyBhbnkgbmV3IG9uZXMgYWRkZWQgc2luY2UgdGhlbiB3aWxsIGJlXG5cdFx0XHRcdFx0ICogcGlja2VkIHVwIGFmdGVyIHRoYXQgb25lIGNvbXBsZXRlcyAqL1xuXHRcdFx0XHRcdGlmKCFzZWxmLnNlbmRSZXF1ZXN0KSB7XG5cdFx0XHRcdFx0XHRzZWxmLnNlbmRBbnlQZW5kaW5nKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRzZW5kUmVxdWVzdC5leGVjKCk7XG5cdH07XG5cblx0Q29tZXRUcmFuc3BvcnQucHJvdG90eXBlLnJlY3YgPSBmdW5jdGlvbigpIHtcblx0XHQvKiBkbyBub3RoaW5nIGlmIHRoZXJlIGlzIGFuIGFjdGl2ZSByZXF1ZXN0LCB3aGljaCBtaWdodCBiZSBzdHJlYW1pbmcgKi9cblx0XHRpZih0aGlzLnJlY3ZSZXF1ZXN0KVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0LyogSWYgd2UncmUgbm8gbG9uZ2VyIGNvbm5lY3RlZCwgZG8gbm90aGluZyAqL1xuXHRcdGlmKCF0aGlzLmlzQ29ubmVjdGVkKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0dmFyIHNlbGYgPSB0aGlzLFxuXHRcdFx0cmVjdlJlcXVlc3QgPSB0aGlzLnJlY3ZSZXF1ZXN0ID0gdGhpcy5jcmVhdGVSZXF1ZXN0KHRoaXMucmVjdlVyaSwgbnVsbCwgdGhpcy5hdXRoUGFyYW1zLCBudWxsLCAoc2VsZi5zdHJlYW0gPyBSRVFfUkVDVl9TVFJFQU0gOiBSRVFfUkVDVl9QT0xMKSk7XG5cblx0XHRyZWN2UmVxdWVzdC5vbignZGF0YScsIGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdHNlbGYub25EYXRhKGRhdGEpO1xuXHRcdH0pO1xuXHRcdHJlY3ZSZXF1ZXN0Lm9uKCdjb21wbGV0ZScsIGZ1bmN0aW9uKGVycikge1xuXHRcdFx0c2VsZi5yZWN2UmVxdWVzdCA9IG51bGw7XG5cdFx0XHRpZih0aGlzLm1heElkbGVJbnRlcnZhbCkge1xuXHRcdFx0XHQvKiBBIHJlcXVlc3QgY29tcGxldGluZyBtdXN0IGJlIGNvbnNpZGVyZWQgYWN0aXZpdHksIGFzIHJlYWx0aW1lIHNlbmRzXG5cdFx0XHRcdCAqIGhlYXJ0YmVhdHMgZXZlcnkgMTVzIHNpbmNlIGEgcmVxdWVzdCBiZWdhbiwgbm90IGV2ZXJ5IDE1cyBhYnNvbHV0ZWx5ICovXG5cdFx0XHRcdHRoaXMuc2V0SWRsZVRpbWVyKCk7XG5cdFx0XHR9XG5cdFx0XHRpZihlcnIpIHtcblx0XHRcdFx0aWYoZXJyLmNvZGUpIHtcblx0XHRcdFx0XHQvKiBBIHByb3RvY29sIGVycm9yIHJlY2VpdmVkIGZyb20gcmVhbHRpbWUuIFRPRE86IG9uY2UgcmVhbHRpbWVcblx0XHRcdFx0XHQgKiBjb25zaXN0ZW5kbHkgc2VuZHMgZXJyb3JzIHdyYXBwZWQgaW4gcHJvdG9jb2wgbWVzc2FnZXMsIHNob3VsZCBiZVxuXHRcdFx0XHRcdCAqIGFibGUgdG8gcmVtb3ZlIHRoaXMgKi9cblx0XHRcdFx0XHRzZWxmLm9uRGF0YShwcm90b2NvbE1lc3NhZ2VGcm9tUmF3RXJyb3IoZXJyKSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0LyogQSBuZXR3b3JrL3hociBlcnJvci4gRG9uJ3QgYm90aGVyIHdyYXBwaW5nIGluIGEgcHJvdG9jb2wgbWVzc2FnZSxcblx0XHRcdFx0XHQgKiBqdXN0IGRpc2Nvbm5lY3QgdGhlIHRyYW5zcG9ydCAqL1xuXHRcdFx0XHRcdHNlbGYuZGlzY29ubmVjdChlcnIpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdFV0aWxzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZWxmLnJlY3YoKTtcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHRcdHJlY3ZSZXF1ZXN0LmV4ZWMoKTtcblx0fTtcblxuXHRDb21ldFRyYW5zcG9ydC5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24ocmVzcG9uc2VEYXRhKSB7XG5cdFx0dHJ5IHtcblx0XHRcdHZhciBpdGVtcyA9IHRoaXMuZGVjb2RlUmVzcG9uc2UocmVzcG9uc2VEYXRhKTtcblx0XHRcdGlmKGl0ZW1zICYmIGl0ZW1zLmxlbmd0aClcblx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKVxuXHRcdFx0XHRcdHRoaXMub25Qcm90b2NvbE1lc3NhZ2UoUHJvdG9jb2xNZXNzYWdlLmZyb21EZXNlcmlhbGl6ZWQoaXRlbXNbaV0pKTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfRVJST1IsICdDb21ldFRyYW5zcG9ydC5vbkRhdGEoKScsICdVbmV4cGVjdGVkIGV4Y2VwdGlvbiBoYW5kaW5nIGNoYW5uZWwgZXZlbnQ6ICcgKyBlLnN0YWNrKTtcblx0XHR9XG5cdH07XG5cblx0Q29tZXRUcmFuc3BvcnQucHJvdG90eXBlLmVuY29kZVJlcXVlc3QgPSBmdW5jdGlvbihyZXF1ZXN0SXRlbXMpIHtcblx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkocmVxdWVzdEl0ZW1zKTtcblx0fTtcblxuXHRDb21ldFRyYW5zcG9ydC5wcm90b3R5cGUuZGVjb2RlUmVzcG9uc2UgPSBmdW5jdGlvbihyZXNwb25zZURhdGEpIHtcblx0XHRpZih0eXBlb2YocmVzcG9uc2VEYXRhKSA9PSAnc3RyaW5nJylcblx0XHRcdHJlc3BvbnNlRGF0YSA9IEpTT04ucGFyc2UocmVzcG9uc2VEYXRhKTtcblx0XHRyZXR1cm4gcmVzcG9uc2VEYXRhO1xuXHR9O1xuXG5cdC8qIEZvciBjb21ldCwgd2UgY291bGQgZG8gdGhlIGF1dGggdXBkYXRlIGJ5IGFib3J0aW5nIHRoZSBjdXJyZW50IHJlY3YgYW5kXG5cdCAqIHN0YXJ0aW5nIGEgbmV3IG9uZSB3aXRoIHRoZSBuZXcgdG9rZW4sIHRoYXQnZCBiZSBzdWZmaWNpZW50IGZvciByZWFsdGltZS5cblx0ICogUHJvYmxlbSBpcyBKU09OUCAtIHlvdSBjYW4ndCBjYW5jZWwgdHJ1bHkgYWJvcnQgYSByZWN2IG9uY2Ugc3RhcnRlZC4gU29cblx0ICogd2UgbmVlZCB0byBzZW5kIGFuIEFVVEggZm9yIGpzb25wLiBJbiB3aGljaCBjYXNlIGl0J3Mgc2ltcGxlciB0byBrZWVwIGFsbFxuXHQgKiBjb21ldCB0cmFuc3BvcnRzIHRoZSBzYW1lIGFuZCBkbyBpdCBmb3IgYWxsIG9mIHRoZW0uIFNvIHdlIHNlbmQgdGhlIEFVVEhcblx0ICogaW5zdGVhZCwgYW5kIGRvbid0IG5lZWQgdG8gYWJvcnQgdGhlIHJlY3YgKi9cblx0Q29tZXRUcmFuc3BvcnQucHJvdG90eXBlLm9uQXV0aFVwZGF0ZWQgPSBmdW5jdGlvbih0b2tlbkRldGFpbHMpIHtcblx0XHR0aGlzLmF1dGhQYXJhbXMgPSB7YWNjZXNzX3Rva2VuOiB0b2tlbkRldGFpbHMudG9rZW59O1xuXHR9O1xuXG5cdHJldHVybiBDb21ldFRyYW5zcG9ydDtcbn0pKCk7XG5cbnZhciBQcmVzZW5jZSA9IChmdW5jdGlvbigpIHtcblx0ZnVuY3Rpb24gbm9vcCgpIHt9XG5cdGZ1bmN0aW9uIFByZXNlbmNlKGNoYW5uZWwpIHtcblx0XHR0aGlzLmNoYW5uZWwgPSBjaGFubmVsO1xuXHRcdHRoaXMuYmFzZVBhdGggPSBjaGFubmVsLmJhc2VQYXRoICsgJy9wcmVzZW5jZSc7XG5cdH1cblx0VXRpbHMuaW5oZXJpdHMoUHJlc2VuY2UsIEV2ZW50RW1pdHRlcik7XG5cblx0UHJlc2VuY2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcblx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlDUk8sICdQcmVzZW5jZS5nZXQoKScsICdjaGFubmVsID0gJyArIHRoaXMuY2hhbm5lbC5uYW1lKTtcblx0XHQvKiBwYXJhbXMgYW5kIGNhbGxiYWNrIGFyZSBvcHRpb25hbDsgc2VlIGlmIHBhcmFtcyBjb250YWlucyB0aGUgY2FsbGJhY2sgKi9cblx0XHRpZihjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRpZih0eXBlb2YocGFyYW1zKSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdGNhbGxiYWNrID0gcGFyYW1zO1xuXHRcdFx0XHRwYXJhbXMgPSBudWxsO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2FsbGJhY2sgPSBub29wO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR2YXIgcmVzdCA9IHRoaXMuY2hhbm5lbC5yZXN0LFxuXHRcdFx0Zm9ybWF0ID0gcmVzdC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gJ21zZ3BhY2snIDogJ2pzb24nLFxuXHRcdFx0ZW52ZWxvcGUgPSBIdHRwLnN1cHBvcnRzTGlua0hlYWRlcnMgPyB1bmRlZmluZWQgOiBmb3JtYXQsXG5cdFx0XHRoZWFkZXJzID0gVXRpbHMuY29weShVdGlscy5kZWZhdWx0R2V0SGVhZGVycyhmb3JtYXQpKTtcblxuXHRcdGlmKHJlc3Qub3B0aW9ucy5oZWFkZXJzKVxuXHRcdFx0VXRpbHMubWl4aW4oaGVhZGVycywgcmVzdC5vcHRpb25zLmhlYWRlcnMpO1xuXG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLmNoYW5uZWwuY2hhbm5lbE9wdGlvbnM7XG5cdFx0KG5ldyBQYWdpbmF0ZWRSZXNvdXJjZShyZXN0LCB0aGlzLmJhc2VQYXRoLCBoZWFkZXJzLCBlbnZlbG9wZSwgZnVuY3Rpb24oYm9keSwgaGVhZGVycywgdW5wYWNrZWQpIHtcblx0XHRcdHJldHVybiBQcmVzZW5jZU1lc3NhZ2UuZnJvbVJlc3BvbnNlQm9keShib2R5LCBvcHRpb25zLCAhdW5wYWNrZWQgJiYgZm9ybWF0KTtcblx0XHR9KSkuZ2V0KHBhcmFtcywgY2FsbGJhY2spO1xuXHR9O1xuXG5cdFByZXNlbmNlLnByb3RvdHlwZS5oaXN0b3J5ID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuXHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSUNSTywgJ1ByZXNlbmNlLmhpc3RvcnkoKScsICdjaGFubmVsID0gJyArIHRoaXMuY2hhbm5lbC5uYW1lKTtcblx0XHR0aGlzLl9oaXN0b3J5KHBhcmFtcywgY2FsbGJhY2spO1xuXHR9O1xuXG5cdFByZXNlbmNlLnByb3RvdHlwZS5faGlzdG9yeSA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcblx0XHQvKiBwYXJhbXMgYW5kIGNhbGxiYWNrIGFyZSBvcHRpb25hbDsgc2VlIGlmIHBhcmFtcyBjb250YWlucyB0aGUgY2FsbGJhY2sgKi9cblx0XHRpZihjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRpZih0eXBlb2YocGFyYW1zKSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdGNhbGxiYWNrID0gcGFyYW1zO1xuXHRcdFx0XHRwYXJhbXMgPSBudWxsO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2FsbGJhY2sgPSBub29wO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR2YXIgcmVzdCA9IHRoaXMuY2hhbm5lbC5yZXN0LFxuXHRcdFx0Zm9ybWF0ID0gcmVzdC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gJ21zZ3BhY2snIDogJ2pzb24nLFxuXHRcdFx0ZW52ZWxvcGUgPSBIdHRwLnN1cHBvcnRzTGlua0hlYWRlcnMgPyB1bmRlZmluZWQgOiBmb3JtYXQsXG5cdFx0XHRoZWFkZXJzID0gVXRpbHMuY29weShVdGlscy5kZWZhdWx0R2V0SGVhZGVycyhmb3JtYXQpKSxcblx0XHRcdGNoYW5uZWwgPSB0aGlzLmNoYW5uZWw7XG5cblx0XHRpZihyZXN0Lm9wdGlvbnMuaGVhZGVycylcblx0XHRcdFV0aWxzLm1peGluKGhlYWRlcnMsIHJlc3Qub3B0aW9ucy5oZWFkZXJzKTtcblxuXHRcdHZhciBvcHRpb25zID0gdGhpcy5jaGFubmVsLmNoYW5uZWxPcHRpb25zO1xuXHRcdChuZXcgUGFnaW5hdGVkUmVzb3VyY2UocmVzdCwgdGhpcy5iYXNlUGF0aCArICcvaGlzdG9yeScsIGhlYWRlcnMsIGVudmVsb3BlLCBmdW5jdGlvbihib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCkge1xuXHRcdFx0cmV0dXJuIFByZXNlbmNlTWVzc2FnZS5mcm9tUmVzcG9uc2VCb2R5KGJvZHksIG9wdGlvbnMsICF1bnBhY2tlZCAmJiBmb3JtYXQpO1xuXHRcdH0pKS5nZXQocGFyYW1zLCBjYWxsYmFjayk7XG5cdH07XG5cblx0cmV0dXJuIFByZXNlbmNlO1xufSkoKTtcblxudmFyIFJlc291cmNlID0gKGZ1bmN0aW9uKCkge1xuXHR2YXIgbXNncGFjayA9IFBsYXRmb3JtLm1zZ3BhY2s7XG5cblx0ZnVuY3Rpb24gUmVzb3VyY2UoKSB7fVxuXG5cdGZ1bmN0aW9uIHdpdGhBdXRoRGV0YWlscyhyZXN0LCBoZWFkZXJzLCBwYXJhbXMsIGVyckNhbGxiYWNrLCBvcENhbGxiYWNrKSB7XG5cdFx0aWYgKEh0dHAuc3VwcG9ydHNBdXRoSGVhZGVycykge1xuXHRcdFx0cmVzdC5hdXRoLmdldEF1dGhIZWFkZXJzKGZ1bmN0aW9uKGVyciwgYXV0aEhlYWRlcnMpIHtcblx0XHRcdFx0aWYoZXJyKVxuXHRcdFx0XHRcdGVyckNhbGxiYWNrKGVycik7XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRvcENhbGxiYWNrKFV0aWxzLm1peGluKGF1dGhIZWFkZXJzLCBoZWFkZXJzKSwgcGFyYW1zKTtcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXN0LmF1dGguZ2V0QXV0aFBhcmFtcyhmdW5jdGlvbihlcnIsIGF1dGhQYXJhbXMpIHtcblx0XHRcdFx0aWYoZXJyKVxuXHRcdFx0XHRcdGVyckNhbGxiYWNrKGVycik7XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRvcENhbGxiYWNrKGhlYWRlcnMsIFV0aWxzLm1peGluKGF1dGhQYXJhbXMsIHBhcmFtcykpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gdW5lbnZlbG9wZShjYWxsYmFjaywgZm9ybWF0KSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKGVyciwgYm9keSwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUpIHtcblx0XHRcdGlmKGVycikge1xuXHRcdFx0XHRjYWxsYmFjayhlcnIpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmKCF1bnBhY2tlZCkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGJvZHkgPSAoZm9ybWF0ID09ICdtc2dwYWNrJykgPyBtc2dwYWNrLmRlY29kZShib2R5KSA6IEpTT04ucGFyc2UoYm9keSk7XG5cdFx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKGUpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZihib2R5LnN0YXR1c0NvZGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHQvKiBFbnZlbG9wZSBhbHJlYWR5IHVud3JhcHBlZCBieSB0aGUgdHJhbnNwb3J0ICovXG5cdFx0XHRcdGNhbGxiYWNrKGVyciwgYm9keSwgaGVhZGVycywgdHJ1ZSwgc3RhdHVzQ29kZSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHN0YXR1c0NvZGUgPSBib2R5LnN0YXR1c0NvZGUsXG5cdFx0XHRcdHJlc3BvbnNlID0gYm9keS5yZXNwb25zZSxcblx0XHRcdFx0aGVhZGVycyA9IGJvZHkuaGVhZGVycztcblxuXHRcdFx0aWYoc3RhdHVzQ29kZSA8IDIwMCB8fCBzdGF0dXNDb2RlID49IDMwMCkge1xuXHRcdFx0XHQvKiBoYW5kbGUgd3JhcHBlZCBlcnJvcnMgKi9cblx0XHRcdFx0dmFyIGVyciA9IHJlc3BvbnNlICYmIHJlc3BvbnNlLmVycm9yO1xuXHRcdFx0XHRpZighZXJyKSB7XG5cdFx0XHRcdFx0ZXJyID0gbmV3IEVycm9yKFN0cmluZyhyZXMpKTtcblx0XHRcdFx0XHRlcnIuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FsbGJhY2soZXJyKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjYWxsYmFjayhudWxsLCByZXNwb25zZSwgaGVhZGVycywgdHJ1ZSwgc3RhdHVzQ29kZSk7XG5cdFx0fTtcblx0fVxuXG5cdGZ1bmN0aW9uIHBhcmFtU3RyaW5nKHBhcmFtcykge1xuXHRcdHZhciBwYXJhbVBhaXJzID0gW107XG5cdFx0aWYgKHBhcmFtcykge1xuXHRcdFx0Zm9yICh2YXIgbmVlZGxlIGluIHBhcmFtcykge1xuXHRcdFx0XHRwYXJhbVBhaXJzLnB1c2gobmVlZGxlICsgJz0nICsgcGFyYW1zW25lZWRsZV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gcGFyYW1QYWlycy5qb2luKCcmJyk7XG5cdH1cblxuXHRmdW5jdGlvbiB1cmxGcm9tUGF0aEFuZFBhcmFtcyhwYXRoLCBwYXJhbXMpIHtcblx0XHRyZXR1cm4gcGF0aCArIChwYXJhbXMgPyAnPycgOiAnJykgKyBwYXJhbVN0cmluZyhwYXJhbXMpO1xuXHR9XG5cblx0ZnVuY3Rpb24gbG9nUmVzcG9uc2VIYW5kbGVyKGNhbGxiYWNrLCB2ZXJiLCBwYXRoLCBwYXJhbXMpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oZXJyLCBib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSkge1xuXHRcdFx0aWYgKGVycikge1xuXHRcdFx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlDUk8sICdSZXNvdXJjZS4nICsgdmVyYiArICcoKScsICdSZWNlaXZlZCBFcnJvcjsgJyArIHVybEZyb21QYXRoQW5kUGFyYW1zKHBhdGgsIHBhcmFtcykgKyAnOyBFcnJvcjogJyArIEpTT04uc3RyaW5naWZ5KGVycikpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX01JQ1JPLCAnUmVzb3VyY2UuJyArIHZlcmIgKyAnKCknLFxuXHRcdFx0XHRcdCdSZWNlaXZlZDsgJyArIHVybEZyb21QYXRoQW5kUGFyYW1zKHBhdGgsIHBhcmFtcykgKyAnOyBIZWFkZXJzOiAnICsgcGFyYW1TdHJpbmcoaGVhZGVycykgKyAnOyBTdGF0dXNDb2RlOiAnICsgc3RhdHVzQ29kZSArICc7IEJvZHk6ICcgKyAoQnVmZmVyVXRpbHMuaXNCdWZmZXIoYm9keSkgPyBib2R5LnRvU3RyaW5nKCkgOiBib2R5KSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2soZXJyLCBib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSk7IH1cblx0XHR9XG5cdH1cblxuXHRSZXNvdXJjZS5nZXQgPSBmdW5jdGlvbihyZXN0LCBwYXRoLCBvcmlnaGVhZGVycywgb3JpZ3BhcmFtcywgZW52ZWxvcGUsIGNhbGxiYWNrKSB7XG5cdFx0aWYgKExvZ2dlci5zaG91bGRMb2coTG9nZ2VyLkxPR19NSUNSTykpIHtcblx0XHRcdGNhbGxiYWNrID0gbG9nUmVzcG9uc2VIYW5kbGVyKGNhbGxiYWNrLCAnZ2V0JywgcGF0aCwgb3JpZ3BhcmFtcyk7XG5cdFx0fVxuXG5cdFx0aWYoZW52ZWxvcGUpIHtcblx0XHRcdGNhbGxiYWNrID0gKGNhbGxiYWNrICYmIHVuZW52ZWxvcGUoY2FsbGJhY2ssIGVudmVsb3BlKSk7XG5cdFx0XHQob3JpZ3BhcmFtcyA9IChvcmlncGFyYW1zIHx8IHt9KSlbJ2VudmVsb3BlJ10gPSBlbnZlbG9wZTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBkb0dldChoZWFkZXJzLCBwYXJhbXMpIHtcblx0XHRcdGlmIChMb2dnZXIuc2hvdWxkTG9nKExvZ2dlci5MT0dfTUlDUk8pKSB7XG5cdFx0XHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSUNSTywgJ1Jlc291cmNlLmdldCgpJywgJ1NlbmRpbmc7ICcgKyB1cmxGcm9tUGF0aEFuZFBhcmFtcyhwYXRoLCBwYXJhbXMpKTtcblx0XHRcdH1cblxuXHRcdFx0SHR0cC5nZXQocmVzdCwgcGF0aCwgaGVhZGVycywgcGFyYW1zLCBmdW5jdGlvbihlcnIsIHJlcywgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUpIHtcblx0XHRcdFx0aWYoZXJyICYmIEF1dGguaXNUb2tlbkVycihlcnIpKSB7XG5cdFx0XHRcdFx0LyogdG9rZW4gaGFzIGV4cGlyZWQsIHNvIGdldCBhIG5ldyBvbmUgKi9cblx0XHRcdFx0XHRyZXN0LmF1dGguYXV0aG9yaXplKG51bGwsIG51bGwsIGZ1bmN0aW9uKGVycikge1xuXHRcdFx0XHRcdFx0aWYoZXJyKSB7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrKGVycik7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8qIHJldHJ5IC4uLiAqL1xuXHRcdFx0XHRcdFx0d2l0aEF1dGhEZXRhaWxzKHJlc3QsIG9yaWdoZWFkZXJzLCBvcmlncGFyYW1zLCBjYWxsYmFjaywgZG9HZXQpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYWxsYmFjayhlcnIsIHJlcywgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdHdpdGhBdXRoRGV0YWlscyhyZXN0LCBvcmlnaGVhZGVycywgb3JpZ3BhcmFtcywgY2FsbGJhY2ssIGRvR2V0KTtcblx0fTtcblxuXHRSZXNvdXJjZS5wb3N0ID0gZnVuY3Rpb24ocmVzdCwgcGF0aCwgYm9keSwgb3JpZ2hlYWRlcnMsIG9yaWdwYXJhbXMsIGVudmVsb3BlLCBjYWxsYmFjaykge1xuXHRcdGlmIChMb2dnZXIuc2hvdWxkTG9nKExvZ2dlci5MT0dfTUlDUk8pKSB7XG5cdFx0XHRjYWxsYmFjayA9IGxvZ1Jlc3BvbnNlSGFuZGxlcihjYWxsYmFjaywgJ3Bvc3QnLCBwYXRoLCBvcmlncGFyYW1zKTtcblx0XHR9XG5cblx0XHRpZihlbnZlbG9wZSkge1xuXHRcdFx0Y2FsbGJhY2sgPSB1bmVudmVsb3BlKGNhbGxiYWNrLCBlbnZlbG9wZSk7XG5cdFx0XHRvcmlncGFyYW1zWydlbnZlbG9wZSddID0gZW52ZWxvcGU7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZG9Qb3N0KGhlYWRlcnMsIHBhcmFtcykge1xuXHRcdFx0aWYgKExvZ2dlci5zaG91bGRMb2coTG9nZ2VyLkxPR19NSUNSTykpIHtcblx0XHRcdFx0dmFyIGRlY29kZWRCb2R5ID0gYm9keTtcblx0XHRcdFx0aWYgKChoZWFkZXJzWydjb250ZW50LXR5cGUnXSB8fCAnJykuaW5kZXhPZignbXNncGFjaycpID4gMCkge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRib2R5ID0gbXNncGFjay5kZWNvZGUoYm9keSk7XG5cdFx0XHRcdFx0fSBjYXRjaCAoZGVjb2RlRXJyKSB7XG5cdFx0XHRcdFx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlDUk8sICdSZXNvdXJjZS5wb3N0KCknLCAnU2VuZGluZyBNc2dQYWNrIERlY29kaW5nIEVycm9yOiAnICsgSlNPTi5zdHJpbmdpZnkoZGVjb2RlRXJyKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSUNSTywgJ1Jlc291cmNlLnBvc3QoKScsICdTZW5kaW5nOyAnICsgdXJsRnJvbVBhdGhBbmRQYXJhbXMocGF0aCwgcGFyYW1zKSArICc7IEJvZHk6ICcgKyBkZWNvZGVkQm9keSk7XG5cdFx0XHR9XG5cblx0XHRcdEh0dHAucG9zdChyZXN0LCBwYXRoLCBoZWFkZXJzLCBib2R5LCBwYXJhbXMsIGZ1bmN0aW9uKGVyciwgcmVzLCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSkge1xuXHRcdFx0XHRpZihlcnIgJiYgQXV0aC5pc1Rva2VuRXJyKGVycikpIHtcblx0XHRcdFx0XHQvKiB0b2tlbiBoYXMgZXhwaXJlZCwgc28gZ2V0IGEgbmV3IG9uZSAqL1xuXHRcdFx0XHRcdHJlc3QuYXV0aC5hdXRob3JpemUobnVsbCwgbnVsbCwgZnVuY3Rpb24oZXJyKSB7XG5cdFx0XHRcdFx0XHRpZihlcnIpIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2soZXJyKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0LyogcmV0cnkgLi4uICovXG5cdFx0XHRcdFx0XHR3aXRoQXV0aERldGFpbHMocmVzdCwgb3JpZ2hlYWRlcnMsIG9yaWdwYXJhbXMsIGNhbGxiYWNrLCBkb1Bvc3QpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYWxsYmFjayhlcnIsIHJlcywgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdHdpdGhBdXRoRGV0YWlscyhyZXN0LCBvcmlnaGVhZGVycywgb3JpZ3BhcmFtcywgY2FsbGJhY2ssIGRvUG9zdCk7XG5cdH07XG5cblx0cmV0dXJuIFJlc291cmNlO1xufSkoKTtcblxudmFyIFBhZ2luYXRlZFJlc291cmNlID0gKGZ1bmN0aW9uKCkge1xuXG5cdGZ1bmN0aW9uIGdldFJlbFBhcmFtcyhsaW5rVXJsKSB7XG5cdFx0dmFyIHVybE1hdGNoID0gbGlua1VybC5tYXRjaCgvXlxcLlxcLyhcXHcrKVxcPyguKikkLyk7XG5cdFx0cmV0dXJuIHVybE1hdGNoICYmIFV0aWxzLnBhcnNlUXVlcnlTdHJpbmcodXJsTWF0Y2hbMl0pO1xuXHR9XG5cblx0ZnVuY3Rpb24gcGFyc2VSZWxMaW5rcyhsaW5rSGVhZGVyKSB7XG5cdFx0aWYodHlwZW9mKGxpbmtIZWFkZXIpID09ICdzdHJpbmcnKVxuXHRcdFx0bGlua0hlYWRlciA9IGxpbmtIZWFkZXIuc3BsaXQoJywnKTtcblxuXHRcdHZhciByZWxQYXJhbXMgPSB7fTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbGlua0hlYWRlci5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGxpbmtNYXRjaCA9IGxpbmtIZWFkZXJbaV0ubWF0Y2goL15cXHMqPCguKyk+O1xccypyZWw9XCIoXFx3KylcIiQvKTtcblx0XHRcdGlmKGxpbmtNYXRjaCkge1xuXHRcdFx0XHR2YXIgcGFyYW1zID0gZ2V0UmVsUGFyYW1zKGxpbmtNYXRjaFsxXSk7XG5cdFx0XHRcdGlmKHBhcmFtcylcblx0XHRcdFx0XHRyZWxQYXJhbXNbbGlua01hdGNoWzJdXSA9IHBhcmFtcztcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHJlbFBhcmFtcztcblx0fVxuXG5cdGZ1bmN0aW9uIFBhZ2luYXRlZFJlc291cmNlKHJlc3QsIHBhdGgsIGhlYWRlcnMsIGVudmVsb3BlLCBib2R5SGFuZGxlciwgdXNlSHR0cFBhZ2luYXRlZFJlc3BvbnNlKSB7XG5cdFx0dGhpcy5yZXN0ID0gcmVzdDtcblx0XHR0aGlzLnBhdGggPSBwYXRoO1xuXHRcdHRoaXMuaGVhZGVycyA9IGhlYWRlcnM7XG5cdFx0dGhpcy5lbnZlbG9wZSA9IGVudmVsb3BlO1xuXHRcdHRoaXMuYm9keUhhbmRsZXIgPSBib2R5SGFuZGxlcjtcblx0XHR0aGlzLnVzZUh0dHBQYWdpbmF0ZWRSZXNwb25zZSA9IHVzZUh0dHBQYWdpbmF0ZWRSZXNwb25zZSB8fCBmYWxzZTtcblx0fVxuXG5cdFBhZ2luYXRlZFJlc291cmNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFJlc291cmNlLmdldChzZWxmLnJlc3QsIHNlbGYucGF0aCwgc2VsZi5oZWFkZXJzLCBwYXJhbXMsIHNlbGYuZW52ZWxvcGUsIGZ1bmN0aW9uKGVyciwgYm9keSwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUpIHtcblx0XHRcdHNlbGYuaGFuZGxlUGFnZShlcnIsIGJvZHksIGhlYWRlcnMsIHVucGFja2VkLCBzdGF0dXNDb2RlLCBjYWxsYmFjayk7XG5cdFx0fSk7XG5cdH07XG5cblx0UGFnaW5hdGVkUmVzb3VyY2UucHJvdG90eXBlLnBvc3QgPSBmdW5jdGlvbihwYXJhbXMsIGJvZHksIGNhbGxiYWNrKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFJlc291cmNlLnBvc3Qoc2VsZi5yZXN0LCBzZWxmLnBhdGgsIGJvZHksIHNlbGYuaGVhZGVycywgcGFyYW1zLCBzZWxmLmVudmVsb3BlLCBmdW5jdGlvbihlcnIsIHJlc2JvZHksIGhlYWRlcnMsIHVucGFja2VkLCBzdGF0dXNDb2RlKSB7XG5cdFx0XHRpZihjYWxsYmFjaykgc2VsZi5oYW5kbGVQYWdlKGVyciwgcmVzYm9keSwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUsIGNhbGxiYWNrKTtcblx0XHR9KTtcblx0fTtcblxuXHRQYWdpbmF0ZWRSZXNvdXJjZS5wcm90b3R5cGUuaGFuZGxlUGFnZSA9IGZ1bmN0aW9uKGVyciwgYm9keSwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUsIGNhbGxiYWNrKSB7XG5cdFx0aWYoZXJyKSB7XG5cdFx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfRVJST1IsICdQYWdpbmF0ZWRSZXNvdXJjZS5oYW5kbGVQYWdlKCknLCAnVW5leHBlY3RlZCBlcnJvciBnZXR0aW5nIHJlc291cmNlOiBlcnIgPSAnICsgSlNPTi5zdHJpbmdpZnkoZXJyKSk7XG5cdFx0XHRjYWxsYmFjayhlcnIpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR2YXIgaXRlbXMsIGxpbmtIZWFkZXIsIHJlbFBhcmFtcztcblx0XHR0cnkge1xuXHRcdFx0aXRlbXMgPSB0aGlzLmJvZHlIYW5kbGVyKGJvZHksIGhlYWRlcnMsIHVucGFja2VkKTtcblx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdGNhbGxiYWNrKGUpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmKGhlYWRlcnMgJiYgKGxpbmtIZWFkZXIgPSAoaGVhZGVyc1snTGluayddIHx8IGhlYWRlcnNbJ2xpbmsnXSkpKSB7XG5cdFx0XHRyZWxQYXJhbXMgPSBwYXJzZVJlbExpbmtzKGxpbmtIZWFkZXIpO1xuXHRcdH1cblxuXHRcdGlmKHRoaXMudXNlSHR0cFBhZ2luYXRlZFJlc3BvbnNlKSB7XG5cdFx0XHRjYWxsYmFjayhudWxsLCBuZXcgSHR0cFBhZ2luYXRlZFJlc3BvbnNlKHRoaXMsIGl0ZW1zLCBoZWFkZXJzLCBzdGF0dXNDb2RlLCByZWxQYXJhbXMpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2FsbGJhY2sobnVsbCwgbmV3IFBhZ2luYXRlZFJlc3VsdCh0aGlzLCBpdGVtcywgcmVsUGFyYW1zKSk7XG5cdFx0fVxuXHR9O1xuXG5cdGZ1bmN0aW9uIFBhZ2luYXRlZFJlc3VsdChyZXNvdXJjZSwgaXRlbXMsIHJlbFBhcmFtcykge1xuXHRcdHRoaXMucmVzb3VyY2UgPSByZXNvdXJjZTtcblx0XHR0aGlzLml0ZW1zID0gaXRlbXM7XG5cblx0XHRpZihyZWxQYXJhbXMpIHtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdGlmKCdmaXJzdCcgaW4gcmVsUGFyYW1zKVxuXHRcdFx0XHR0aGlzLmZpcnN0ID0gZnVuY3Rpb24oY2IpIHsgc2VsZi5nZXQocmVsUGFyYW1zLmZpcnN0LCBjYik7IH07XG5cdFx0XHRpZignY3VycmVudCcgaW4gcmVsUGFyYW1zKVxuXHRcdFx0XHR0aGlzLmN1cnJlbnQgPSBmdW5jdGlvbihjYikgeyBzZWxmLmdldChyZWxQYXJhbXMuY3VycmVudCwgY2IpOyB9O1xuXHRcdFx0dGhpcy5uZXh0ID0gZnVuY3Rpb24oY2IpIHtcblx0XHRcdFx0aWYoJ25leHQnIGluIHJlbFBhcmFtcylcblx0XHRcdFx0XHRzZWxmLmdldChyZWxQYXJhbXMubmV4dCwgY2IpO1xuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0Y2IobnVsbCwgbnVsbCk7XG5cdFx0XHR9O1xuXG5cdFx0XHR0aGlzLmhhc05leHQgPSBmdW5jdGlvbigpIHsgcmV0dXJuICgnbmV4dCcgaW4gcmVsUGFyYW1zKSB9O1xuXHRcdFx0dGhpcy5pc0xhc3QgPSBmdW5jdGlvbigpIHsgcmV0dXJuICF0aGlzLmhhc05leHQoKTsgfVxuXHRcdH1cblx0fVxuXG5cdC8qIFdlIGFzc3VtZSB0aGF0IG9ubHkgdGhlIGluaXRpYWwgcmVxdWVzdCBjYW4gYmUgYSBQT1NULCBhbmQgdGhhdCBhY2Nlc3Npbmdcblx0ICogdGhlIHJlc3Qgb2YgYSBtdWx0aXBhZ2Ugc2V0IG9mIHJlc3VsdHMgY2FuIGFsd2F5cyBiZSBkb25lIHdpdGggR0VUICovXG5cdFBhZ2luYXRlZFJlc3VsdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuXHRcdHZhciByZXMgPSB0aGlzLnJlc291cmNlO1xuXHRcdFJlc291cmNlLmdldChyZXMucmVzdCwgcmVzLnBhdGgsIHJlcy5oZWFkZXJzLCBwYXJhbXMsIHJlcy5lbnZlbG9wZSwgZnVuY3Rpb24oZXJyLCBib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSkge1xuXHRcdFx0cmVzLmhhbmRsZVBhZ2UoZXJyLCBib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSwgY2FsbGJhY2spO1xuXHRcdH0pO1xuXHR9O1xuXG5cdGZ1bmN0aW9uIEh0dHBQYWdpbmF0ZWRSZXNwb25zZShyZXNvdXJjZSwgaXRlbXMsIGhlYWRlcnMsIHN0YXR1c0NvZGUsIHJlbFBhcmFtcykge1xuXHRcdFBhZ2luYXRlZFJlc3VsdC5jYWxsKHRoaXMsIHJlc291cmNlLCBpdGVtcywgcmVsUGFyYW1zKTtcblx0XHR0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuXHRcdHRoaXMuc3VjY2VzcyA9IHN0YXR1c0NvZGUgPCAzMDAgJiYgc3RhdHVzQ29kZSA+PSAyMDA7XG5cdFx0dGhpcy5oZWFkZXJzID0gaGVhZGVycztcblx0XHQvKiBOb3RlOiB3ZSBkb24ndCBwb3B1bGF0ZSBlcnJvckNvZGUgb3IgZXJyb3JNZXNzYWdlOiBmb3IgY29uc2lzdGVuY3kgd2l0aFxuXHRcdCAqIHRoZSB3YXkgdGhlIHJlc3Qgb2YgdGhlIGpzIGxpYnJhcnkgd29ya3MsIGVycm9yIGRhdGEgaXMgcGFzc2VkIGFzXG5cdFx0ICogRXJyb3JJbmZvcyB0byB0aGUgZXJyIGFyZ3VtZW50IG9mIHRoZSBjYWxsYmFjazsgYW4gIEh0dHBQYWdpbmF0ZWRSZXNwb25zZVxuXHRcdCAqIGlzIG9ubHkgZXZlciBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrIGlmIHRoZXJlIHdhcyBubyBlcnJvciAqL1xuXHR9XG5cdFV0aWxzLmluaGVyaXRzKEh0dHBQYWdpbmF0ZWRSZXNwb25zZSwgUGFnaW5hdGVkUmVzdWx0KTtcblxuXHRyZXR1cm4gUGFnaW5hdGVkUmVzb3VyY2U7XG59KSgpO1xuXG52YXIgQXV0aCA9IChmdW5jdGlvbigpIHtcblx0dmFyIG1zZ3BhY2sgPSBQbGF0Zm9ybS5tc2dwYWNrO1xuXHR2YXIgTUFYX1RPS0VOT0JKRUNUX0xFTkdUSCA9IE1hdGgucG93KDIsIDE3KTtcblx0dmFyIE1BWF9UT0tFTlNUUklOR19MRU5HVEggPSAzODQ7XG5cdGZ1bmN0aW9uIG5vb3AoKSB7fVxuXHRmdW5jdGlvbiByYW5kb20oKSB7IHJldHVybiAoJzAwMDAwMCcgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxRTE2KSkuc2xpY2UoLTE2KTsgfVxuXG5cdHZhciBobWFjLCB0b0Jhc2U2NDtcblx0aWYoUGxhdGZvcm0uY3JlYXRlSG1hYykge1xuXHRcdHRvQmFzZTY0ID0gZnVuY3Rpb24oc3RyKSB7IHJldHVybiAobmV3IEJ1ZmZlcihzdHIsICdhc2NpaScpKS50b1N0cmluZygnYmFzZTY0Jyk7IH07XG5cdFx0aG1hYyA9IGZ1bmN0aW9uKHRleHQsIGtleSkge1xuXHRcdFx0dmFyIGluc3QgPSBQbGF0Zm9ybS5jcmVhdGVIbWFjKCdTSEEyNTYnLCBrZXkpO1xuXHRcdFx0aW5zdC51cGRhdGUodGV4dCk7XG5cdFx0XHRyZXR1cm4gaW5zdC5kaWdlc3QoJ2Jhc2U2NCcpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0dG9CYXNlNjQgPSBCYXNlNjQuZW5jb2RlO1xuXHRcdGhtYWMgPSBmdW5jdGlvbih0ZXh0LCBrZXkpIHtcblx0XHRcdHJldHVybiBDcnlwdG9KUy5IbWFjU0hBMjU2KHRleHQsIGtleSkudG9TdHJpbmcoQ3J5cHRvSlMuZW5jLkJhc2U2NCk7XG5cdFx0fTtcblx0fVxuXG5cdGZ1bmN0aW9uIGMxNG4oY2FwYWJpbGl0eSkge1xuXHRcdGlmKCFjYXBhYmlsaXR5KVxuXHRcdFx0cmV0dXJuICcnO1xuXG5cdFx0aWYodHlwZW9mKGNhcGFiaWxpdHkpID09ICdzdHJpbmcnKVxuXHRcdFx0Y2FwYWJpbGl0eSA9IEpTT04ucGFyc2UoY2FwYWJpbGl0eSk7XG5cblx0XHR2YXIgYzE0bkNhcGFiaWxpdHkgPSB7fTtcblx0XHR2YXIga2V5cyA9IFV0aWxzLmtleXNBcnJheShjYXBhYmlsaXR5LCB0cnVlKTtcblx0XHRpZigha2V5cylcblx0XHRcdHJldHVybiAnJztcblx0XHRrZXlzLnNvcnQoKTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0YzE0bkNhcGFiaWxpdHlba2V5c1tpXV0gPSBjYXBhYmlsaXR5W2tleXNbaV1dLnNvcnQoKTtcblx0XHR9XG5cdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KGMxNG5DYXBhYmlsaXR5KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGxvZ0FuZFZhbGlkYXRlVG9rZW5BdXRoTWV0aG9kKGF1dGhPcHRpb25zKSB7XG5cdFx0aWYoYXV0aE9wdGlvbnMuYXV0aENhbGxiYWNrKSB7XG5cdFx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlOT1IsICdBdXRoKCknLCAndXNpbmcgdG9rZW4gYXV0aCB3aXRoIGF1dGhDYWxsYmFjaycpO1xuXHRcdH0gZWxzZSBpZihhdXRoT3B0aW9ucy5hdXRoVXJsKSB7XG5cdFx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlOT1IsICdBdXRoKCknLCAndXNpbmcgdG9rZW4gYXV0aCB3aXRoIGF1dGhVcmwnKTtcblx0XHR9IGVsc2UgaWYoYXV0aE9wdGlvbnMua2V5KSB7XG5cdFx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlOT1IsICdBdXRoKCknLCAndXNpbmcgdG9rZW4gYXV0aCB3aXRoIGNsaWVudC1zaWRlIHNpZ25pbmcnKTtcblx0XHR9IGVsc2UgaWYoYXV0aE9wdGlvbnMudG9rZW5EZXRhaWxzKSB7XG5cdFx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlOT1IsICdBdXRoKCknLCAndXNpbmcgdG9rZW4gYXV0aCB3aXRoIHN1cHBsaWVkIHRva2VuIG9ubHknKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIG1zZyA9ICdhdXRoT3B0aW9ucyBtdXN0IGluY2x1ZGUgdmFsaWQgYXV0aGVudGljYXRpb24gcGFyYW1ldGVycyc7XG5cdFx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfRVJST1IsICdBdXRoKCknLCBtc2cpO1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKG1zZyk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gYmFzaWNBdXRoRm9yY2VkKG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gJ3VzZVRva2VuQXV0aCcgaW4gb3B0aW9ucyAmJiAhb3B0aW9ucy51c2VUb2tlbkF1dGg7XG5cdH1cblxuXHQvKiBSU0E0ICovXG5cdGZ1bmN0aW9uIHVzZVRva2VuQXV0aChvcHRpb25zKSB7XG5cdFx0cmV0dXJuIG9wdGlvbnMudXNlVG9rZW5BdXRoIHx8XG5cdFx0XHQoIWJhc2ljQXV0aEZvcmNlZChvcHRpb25zKSAmJlxuXHRcdFx0IChvcHRpb25zLmNsaWVudElkICAgICB8fFxuXHRcdFx0ICBvcHRpb25zLmF1dGhDYWxsYmFjayB8fFxuXHRcdFx0ICBvcHRpb25zLmF1dGhVcmwgICAgICB8fFxuXHRcdFx0ICBvcHRpb25zLnRva2VuICAgICAgICB8fFxuXHRcdFx0ICBvcHRpb25zLnRva2VuRGV0YWlscykpXG5cdH1cblxuXHRmdW5jdGlvbiBBdXRoKGNsaWVudCwgb3B0aW9ucykge1xuXHRcdHRoaXMuY2xpZW50ID0gY2xpZW50O1xuXHRcdHRoaXMudG9rZW5QYXJhbXMgPSBvcHRpb25zLmRlZmF1bHRUb2tlblBhcmFtcyB8fCB7fTtcblxuXHRcdGlmKHVzZVRva2VuQXV0aChvcHRpb25zKSkge1xuXHRcdFx0LyogVG9rZW4gYXV0aCAqL1xuXHRcdFx0aWYob3B0aW9ucy5rZXkgJiYgIWhtYWMpIHtcblx0XHRcdFx0dmFyIG1zZyA9ICdjbGllbnQtc2lkZSB0b2tlbiByZXF1ZXN0IHNpZ25pbmcgbm90IHN1cHBvcnRlZCc7XG5cdFx0XHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19FUlJPUiwgJ0F1dGgoKScsIG1zZyk7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihtc2cpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fc2F2ZVRva2VuT3B0aW9ucyhvcHRpb25zLmRlZmF1bHRUb2tlblBhcmFtcywgb3B0aW9ucyk7XG5cdFx0XHRsb2dBbmRWYWxpZGF0ZVRva2VuQXV0aE1ldGhvZCh0aGlzLmF1dGhPcHRpb25zKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0LyogQmFzaWMgYXV0aCAqL1xuXHRcdFx0aWYob3B0aW9ucy5jbGllbnRJZCB8fCAhb3B0aW9ucy5rZXkpIHtcblx0XHRcdFx0dmFyIG1zZyA9ICdDYW5ub3QgYXV0aGVudGljYXRlIHdpdGggYmFzaWMgYXV0aCcgK1xuXHRcdFx0XHRcdChvcHRpb25zLmNsaWVudElkID8gJyBhcyBhIGNsaWVudElkIGltcGxpZXMgdG9rZW4gYXV0aCcgOlxuXHRcdFx0XHRcdCAoIW9wdGlvbnMua2V5ID8gJyBhcyBubyBrZXkgd2FzIGdpdmVuJyA6ICcnKSk7XG5cdFx0XHRcdFx0IExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19FUlJPUiwgJ0F1dGgoKScsIG1zZyk7XG5cdFx0XHRcdFx0IHRocm93IG5ldyBFcnJvcihtc2cpO1xuXHRcdFx0fVxuXHRcdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX01JTk9SLCAnQXV0aCgpJywgJ2Fub255bW91cywgdXNpbmcgYmFzaWMgYXV0aCcpO1xuXHRcdFx0dGhpcy5fc2F2ZUJhc2ljT3B0aW9ucyhvcHRpb25zKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogSW5zdHJ1Y3RzIHRoZSBsaWJyYXJ5IHRvIGdldCBhIHRva2VuIGltbWVkaWF0ZWx5IGFuZCBlbnN1cmVzIFRva2VuIEF1dGhcblx0ICogaXMgdXNlZCBmb3IgYWxsIGZ1dHVyZSByZXF1ZXN0cywgc3RvcmluZyB0aGUgdG9rZW5QYXJhbXMgYW5kIGF1dGhPcHRpb25zXG5cdCAqIGdpdmVuIGFzIHRoZSBuZXcgZGVmYXVsdHMgZm9yIHN1YnNlcXVlbnQgdXNlLlxuXHQgKlxuXHQgKiBAcGFyYW0gdG9rZW5QYXJhbXNcblx0ICogYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHBhcmFtZXRlcnMgZm9yIHRoZSByZXF1ZXN0ZWQgdG9rZW46XG5cdCAqXG5cdCAqIC0gdHRsOiAgICAgICAgKG9wdGlvbmFsKSB0aGUgcmVxdWVzdGVkIGxpZmUgb2YgYW55IG5ldyB0b2tlbiBpbiBtcy4gSWYgbm9uZVxuXHQgKiAgICAgICAgICAgICAgIGlzIHNwZWNpZmllZCBhIGRlZmF1bHQgb2YgMSBob3VyIGlzIHByb3ZpZGVkLiBUaGUgbWF4aW11bSBsaWZldGltZVxuXHQgKiAgICAgICAgICAgICAgIGlzIDI0aG91cnM7IGFueSByZXF1ZXN0IGV4Y2VlZWRpbmcgdGhhdCBsaWZldGltZSB3aWxsIGJlIHJlamVjdGVkXG5cdCAqICAgICAgICAgICAgICAgd2l0aCBhbiBlcnJvci5cblx0ICpcblx0ICogLSBjYXBhYmlsaXR5OiAob3B0aW9uYWwpIHRoZSBjYXBhYmlsaXR5IHRvIGFzc29jaWF0ZSB3aXRoIHRoZSBhY2Nlc3MgdG9rZW4uXG5cdCAqICAgICAgICAgICAgICAgSWYgbm9uZSBpcyBzcGVjaWZpZWQsIGEgdG9rZW4gd2lsbCBiZSByZXF1ZXN0ZWQgd2l0aCBhbGwgb2YgdGhlXG5cdCAqICAgICAgICAgICAgICAgY2FwYWJpbGl0aWVzIG9mIHRoZSBzcGVjaWZpZWQga2V5LlxuXHQgKlxuXHQgKiAtIGNsaWVudElkOiAgIChvcHRpb25hbCkgYSBjbGllbnQgSWQgdG8gYXNzb2NpYXRlIHdpdGggdGhlIHRva2VuXG5cdCAqXG5cdCAqIC0gdGltZXN0YW1wOiAgKG9wdGlvbmFsKSB0aGUgdGltZSBpbiBtcyBzaW5jZSB0aGUgZXBvY2guIElmIG5vbmUgaXMgc3BlY2lmaWVkLFxuXHQgKiAgICAgICAgICAgICAgIHRoZSBzeXN0ZW0gd2lsbCBiZSBxdWVyaWVkIGZvciBhIHRpbWUgdmFsdWUgdG8gdXNlLlxuXHQgKlxuXHQgKiBAcGFyYW0gYXV0aE9wdGlvbnNcblx0ICogYW4gb2JqZWN0IGNvbnRhaW5pbmcgYXV0aCBvcHRpb25zIHJlbGV2YW50IHRvIHRva2VuIGF1dGg6XG5cdCAqXG5cdCAqIC0gcXVlcnlUaW1lICAgKG9wdGlvbmFsKSBib29sZWFuIGluZGljYXRpbmcgdGhhdCB0aGUgQWJseSBzeXN0ZW0gc2hvdWxkIGJlXG5cdCAqICAgICAgICAgICAgICAgcXVlcmllZCBmb3IgdGhlIGN1cnJlbnQgdGltZSB3aGVuIG5vbmUgaXMgc3BlY2lmaWVkIGV4cGxpY2l0bHkuXG5cdCAqXG5cdCAqIC0gdG9rZW5EZXRhaWxzOiAob3B0aW9uYWwpIG9iamVjdDogQW4gYXV0aGVudGljYXRlZCBUb2tlbkRldGFpbHMgb2JqZWN0LlxuXHQgKlxuXHQgKiAtIHRva2VuOiAgICAgICAgKG9wdGlvbmFsKSBzdHJpbmc6IHRoZSBgdG9rZW5gIHByb3BlcnR5IG9mIGEgdG9rZW5EZXRhaWxzIG9iamVjdFxuXHQgKlxuXHQgKiAtIGF1dGhDYWxsYmFjazogIChvcHRpb25hbCkgYSBqYXZhc2NyaXB0IGNhbGxiYWNrIHRvIGJlIGNhbGxlZCB0byBnZXQgYXV0aCBpbmZvcm1hdGlvbi5cblx0ICogICAgICAgICAgICAgICAgICBhdXRoQ2FsbGJhY2sgc2hvdWxkIGJlIGEgZnVuY3Rpb24gb2YgKHRva2VuUGFyYW1zLCBjYWxsYmFjaykgdGhhdCBjYWxsc1xuXHQgKiAgICAgICAgICAgICAgICAgIHRoZSBjYWxsYmFjayB3aXRoIChlcnIsIHJlc3VsdCksIHdoZXJlIHJlc3VsdCBpcyBhbnkgb2Y6XG5cdCAqICAgICAgICAgICAgICAgICAgLSBhIHRva2VuUmVxdWVzdCBvYmplY3QgKGllIHRoZSByZXN1bHQgb2YgYSByZXN0LmF1dGguY3JlYXRlVG9rZW5SZXF1ZXN0IGNhbGwpLFxuXHQgKiAgICAgICAgICAgICAgICAgIC0gYSB0b2tlbkRldGFpbHMgb2JqZWN0IChpZSB0aGUgcmVzdWx0IG9mIGEgcmVzdC5hdXRoLnJlcXVlc3RUb2tlbiBjYWxsKSxcblx0ICogICAgICAgICAgICAgICAgICAtIGEgdG9rZW4gc3RyaW5nXG5cdCAqXG5cdCAqIC0gYXV0aFVybDogICAgICAgKG9wdGlvbmFsKSBhIFVSTCB0byBiZSB1c2VkIHRvIEdFVCBvciBQT1NUIGEgc2V0IG9mIHRva2VuIHJlcXVlc3Rcblx0ICogICAgICAgICAgICAgICAgICBwYXJhbXMsIHRvIG9idGFpbiBhIHNpZ25lZCB0b2tlbiByZXF1ZXN0LlxuXHQgKlxuXHQgKiAtIGF1dGhIZWFkZXJzOiAgIChvcHRpb25hbCkgYSBzZXQgb2YgYXBwbGljYXRpb24tc3BlY2lmaWMgaGVhZGVycyB0byBiZSBhZGRlZCB0byBhbnkgcmVxdWVzdFxuXHQgKiAgICAgICAgICAgICAgICAgIG1hZGUgdG8gdGhlIGF1dGhVcmwuXG5cdCAqXG5cdCAqIC0gYXV0aFBhcmFtczogICAgKG9wdGlvbmFsKSBhIHNldCBvZiBhcHBsaWNhdGlvbi1zcGVjaWZpYyBxdWVyeSBwYXJhbXMgdG8gYmUgYWRkZWQgdG8gYW55XG5cdCAqICAgICAgICAgICAgICAgICAgcmVxdWVzdCBtYWRlIHRvIHRoZSBhdXRoVXJsLlxuXHQgKlxuXHQgKlxuXHQgKiAtIHJlcXVlc3RIZWFkZXJzIChvcHRpb25hbCwgdW5zdXBwb3J0ZWQsIGZvciB0ZXN0aW5nIG9ubHkpIGV4dHJhIGhlYWRlcnMgdG8gYWRkIHRvIHRoZVxuXHQgKiAgICAgICAgICAgICAgICAgIHJlcXVlc3RUb2tlbiByZXF1ZXN0XG5cdCAqXG5cdCAqIEBwYXJhbSBjYWxsYmFjayAoZXJyLCB0b2tlbkRldGFpbHMpXG5cdCAqL1xuXHRBdXRoLnByb3RvdHlwZS5hdXRob3JpemUgPSBmdW5jdGlvbih0b2tlblBhcmFtcywgYXV0aE9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cdFx0Lyogc2h1ZmZsZSBhbmQgbm9ybWFsaXNlIGFyZ3VtZW50cyBhcyBuZWNlc3NhcnkgKi9cblx0XHRpZih0eXBlb2YodG9rZW5QYXJhbXMpID09ICdmdW5jdGlvbicgJiYgIWNhbGxiYWNrKSB7XG5cdFx0XHRjYWxsYmFjayA9IHRva2VuUGFyYW1zO1xuXHRcdFx0YXV0aE9wdGlvbnMgPSB0b2tlblBhcmFtcyA9IG51bGw7XG5cdFx0fSBlbHNlIGlmKHR5cGVvZihhdXRoT3B0aW9ucykgPT0gJ2Z1bmN0aW9uJyAmJiAhY2FsbGJhY2spIHtcblx0XHRcdGNhbGxiYWNrID0gYXV0aE9wdGlvbnM7XG5cdFx0XHRhdXRoT3B0aW9ucyA9IG51bGw7XG5cdFx0fVxuXHRcdGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgbm9vcDtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cblx0XHQvKiBSU0ExMGE6IGF1dGhvcml6ZSgpIGNhbGwgaW1wbGllcyB0b2tlbiBhdXRoLiBJZiBhIGtleSBpcyBwYXNzZWQgaXQsIHdlXG5cdFx0ICoganVzdCBjaGVjayBpZiBpdCBkb2Vzbid0IGNsYXNoIGFuZCBhc3N1bWUgd2UncmUgZ2VuZXJhdGluZyBhIHRva2VuIGZyb20gaXQgKi9cblx0XHRpZihhdXRoT3B0aW9ucyAmJiBhdXRoT3B0aW9ucy5rZXkgJiYgKHRoaXMua2V5ICE9PSBhdXRoT3B0aW9ucy5rZXkpKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3JJbmZvKCdVbmFibGUgdG8gdXBkYXRlIGF1dGggb3B0aW9ucyB3aXRoIGluY29tcGF0aWJsZSBrZXknLCA0MDEwMiwgNDAxKTtcblx0XHR9XG5cblx0XHRpZihhdXRoT3B0aW9ucyAmJiAoJ2ZvcmNlJyBpbiBhdXRoT3B0aW9ucykpIHtcblx0XHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19FUlJPUiwgJ0F1dGguYXV0aG9yaXplJywgJ0RlcHJlY2F0aW9uIHdhcm5pbmc6IHNwZWNpZnlpbmcge2ZvcmNlOiB0cnVlfSBpbiBhdXRoT3B0aW9ucyBpcyBubyBsb25nZXIgbmVjZXNzYXJ5LCBhdXRob3JpemUoKSBub3cgYWx3YXlzIGdldHMgYSBuZXcgdG9rZW4uIFBsZWFzZSByZW1vdmUgdGhpcywgYXMgaW4gdmVyc2lvbiAxLjAgYW5kIGxhdGVyLCBoYXZpbmcgYSBub24tbnVsbCBhdXRoT3B0aW9ucyB3aWxsIG92ZXJ3cml0ZSBzdG9yZWQgbGlicmFyeSBhdXRoT3B0aW9ucywgd2hpY2ggbWF5IG5vdCBiZSB3aGF0IHlvdSB3YW50Jyk7XG5cdFx0XHQvKiBFbXVsYXRlIHRoZSBvbGQgYmVoYXZpb3VyOiBpZiAnZm9yY2UnIHdhcyB0aGUgb25seSBtZW1iZXIgb2YgYXV0aE9wdGlvbnMsXG5cdFx0XHQgKiBzZXQgaXQgdG8gbnVsbCBzbyBpdCBkb2Vzbid0IG92ZXJ3cml0ZSBzdG9yZWQuIFRPRE86IHJlbW92ZSBpbiB2ZXJzaW9uIDEuMCAqL1xuXHRcdFx0aWYoVXRpbHMuaXNPbmx5UHJvcEluKGF1dGhPcHRpb25zLCAnZm9yY2UnKSkge1xuXHRcdFx0XHRhdXRoT3B0aW9ucyA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5fZm9yY2VOZXdUb2tlbih0b2tlblBhcmFtcywgYXV0aE9wdGlvbnMsIGZ1bmN0aW9uKGVyciwgdG9rZW5EZXRhaWxzKSB7XG5cdFx0XHRpZihlcnIpIHtcblx0XHRcdFx0Y2FsbGJhY2soZXJyKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0LyogUlRDOFxuXHRcdFx0ICogLSBXaGVuIGF1dGhvcml6ZSBjYWxsZWQgYnkgYW4gZW5kIHVzZXIgYW5kIGhhdmUgYSByZWFsdGltZSBjb25uZWN0aW9uLFxuXHRcdFx0ICogZG9uJ3QgY2FsbCBiYWNrIHRpbGwgbmV3IHRva2VuIGhhcyB0YWtlbiBlZmZlY3QuXG5cdFx0XHQgKiAtIFVzZSBzZWxmLmNsaWVudC5jb25uZWN0aW9uIGFzIGEgcHJveHkgZm9yIChzZWxmLmNsaWVudCBpbnN0YW5jZW9mIFJlYWx0aW1lKSxcblx0XHRcdCAqIHdoaWNoIGRvZXNuJ3Qgd29yayBpbiBub2RlIGFzIFJlYWx0aW1lIGlzbid0IHBhcnQgb2YgdGhlIHZtIGNvbnRleHQgZm9yIFJlc3QgY2xpZW50cyAqL1xuXHRcdFx0aWYoc2VsZi5jbGllbnQuY29ubmVjdGlvbikge1xuXHRcdFx0XHRzZWxmLmNsaWVudC5jb25uZWN0aW9uLmNvbm5lY3Rpb25NYW5hZ2VyLm9uQXV0aFVwZGF0ZWQodG9rZW5EZXRhaWxzLCBjYWxsYmFjayk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjYWxsYmFjayhudWxsLCB0b2tlbkRldGFpbHMpO1xuXHRcdFx0fVxuXHRcdH0pXG5cdH07XG5cblx0QXV0aC5wcm90b3R5cGUuYXV0aG9yaXNlID0gZnVuY3Rpb24oKSB7XG5cdFx0TG9nZ2VyLmRlcHJlY2F0ZWQoJ0F1dGguYXV0aG9yaXNlJywgJ0F1dGguYXV0aG9yaXplJyk7XG5cdFx0dGhpcy5hdXRob3JpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0fTtcblxuXHQvKiBGb3IgaW50ZXJuYWwgdXNlLCBlZyBieSBjb25uZWN0aW9uTWFuYWdlciAtIHVzZWZ1bCB3aGVuIHdhbnQgdG8gY2FsbCBiYWNrXG5cdCAqIGFzIHNvb24gYXMgd2UgaGF2ZSB0aGUgbmV3IHRva2VuLCByYXRoZXIgdGhhbiB3YWl0aW5nIGZvciBpdCB0byB0YWtlXG5cdCAqIGVmZmVjdCBvbiB0aGUgY29ubmVjdGlvbiBhcyAjYXV0aG9yaXplIGRvZXMgKi9cblx0QXV0aC5wcm90b3R5cGUuX2ZvcmNlTmV3VG9rZW4gPSBmdW5jdGlvbih0b2tlblBhcmFtcywgYXV0aE9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXG5cdFx0LyogZ2V0IHJpZCBvZiBjdXJyZW50IHRva2VuIGV2ZW4gaWYgc3RpbGwgdmFsaWQgKi9cblx0XHR0aGlzLnRva2VuRGV0YWlscyA9IG51bGw7XG5cblx0XHQvKiBfc2F2ZSBub3JtYWxpc2VzIHRoZSB0b2tlblBhcmFtcyBhbmQgYXV0aE9wdGlvbnMgYW5kIHVwZGF0ZXMgdGhlIGF1dGhcblx0XHQgKiBvYmplY3QuIEFsbCBzdWJzZXF1ZW50IG9wZXJhdGlvbnMgc2hvdWxkIHVzZSB0aGUgdmFsdWVzIG9uIGB0aGlzYCxcblx0XHQgKiBub3QgdGhlIHBhc3NlZCBpbiBvbmVzLiAqL1xuXHRcdHRoaXMuX3NhdmVUb2tlbk9wdGlvbnModG9rZW5QYXJhbXMsIGF1dGhPcHRpb25zKTtcblxuXHRcdGxvZ0FuZFZhbGlkYXRlVG9rZW5BdXRoTWV0aG9kKHRoaXMuYXV0aE9wdGlvbnMpO1xuXG5cdFx0dGhpcy5fZW5zdXJlVmFsaWRBdXRoQ3JlZGVudGlhbHMoZnVuY3Rpb24oZXJyLCB0b2tlbkRldGFpbHMpIHtcblx0XHRcdC8qIFJTQTEwZyAqL1xuXHRcdFx0ZGVsZXRlIHNlbGYudG9rZW5QYXJhbXMudGltZXN0YW1wO1xuXHRcdFx0ZGVsZXRlIHNlbGYuYXV0aE9wdGlvbnMucXVlcnlUaW1lO1xuXHRcdFx0Y2FsbGJhY2soZXJyLCB0b2tlbkRldGFpbHMpO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlcXVlc3QgYW4gYWNjZXNzIHRva2VuXG5cdCAqIEBwYXJhbSBhdXRoT3B0aW9uc1xuXHQgKiBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgcmVxdWVzdCBvcHRpb25zOlxuXHQgKiAtIGtleTogICAgICAgICAgIHRoZSBrZXkgdG8gdXNlLlxuXHQgKlxuXHQgKiAtIGF1dGhDYWxsYmFjazogIChvcHRpb25hbCkgYSBqYXZhc2NyaXB0IGNhbGxiYWNrIHRvIGJlIGNhbGxlZCB0byBnZXQgYXV0aCBpbmZvcm1hdGlvbi5cblx0ICogICAgICAgICAgICAgICAgICBhdXRoQ2FsbGJhY2sgc2hvdWxkIGJlIGEgZnVuY3Rpb24gb2YgKHRva2VuUGFyYW1zLCBjYWxsYmFjaykgdGhhdCBjYWxsc1xuXHQgKiAgICAgICAgICAgICAgICAgIHRoZSBjYWxsYmFjayB3aXRoIChlcnIsIHJlc3VsdCksIHdoZXJlIHJlc3VsdCBpcyBhbnkgb2Y6XG5cdCAqICAgICAgICAgICAgICAgICAgLSBhIHRva2VuUmVxdWVzdCBvYmplY3QgKGllIHRoZSByZXN1bHQgb2YgYSByZXN0LmF1dGguY3JlYXRlVG9rZW5SZXF1ZXN0IGNhbGwpLFxuXHQgKiAgICAgICAgICAgICAgICAgIC0gYSB0b2tlbkRldGFpbHMgb2JqZWN0IChpZSB0aGUgcmVzdWx0IG9mIGEgcmVzdC5hdXRoLnJlcXVlc3RUb2tlbiBjYWxsKSxcblx0ICogICAgICAgICAgICAgICAgICAtIGEgdG9rZW4gc3RyaW5nXG5cdCAqXG5cdCAqIC0gYXV0aFVybDogICAgICAgKG9wdGlvbmFsKSBhIFVSTCB0byBiZSB1c2VkIHRvIEdFVCBvciBQT1NUIGEgc2V0IG9mIHRva2VuIHJlcXVlc3Rcblx0ICogICAgICAgICAgICAgICAgICBwYXJhbXMsIHRvIG9idGFpbiBhIHNpZ25lZCB0b2tlbiByZXF1ZXN0LlxuXHQgKlxuXHQgKiAtIGF1dGhIZWFkZXJzOiAgIChvcHRpb25hbCkgYSBzZXQgb2YgYXBwbGljYXRpb24tc3BlY2lmaWMgaGVhZGVycyB0byBiZSBhZGRlZCB0byBhbnkgcmVxdWVzdFxuXHQgKiAgICAgICAgICAgICAgICAgIG1hZGUgdG8gdGhlIGF1dGhVcmwuXG5cdCAqXG5cdCAqIC0gYXV0aFBhcmFtczogICAgKG9wdGlvbmFsKSBhIHNldCBvZiBhcHBsaWNhdGlvbi1zcGVjaWZpYyBxdWVyeSBwYXJhbXMgdG8gYmUgYWRkZWQgdG8gYW55XG5cdCAqICAgICAgICAgICAgICAgICAgcmVxdWVzdCBtYWRlIHRvIHRoZSBhdXRoVXJsLlxuXHQgKlxuXHQgKiAtIHF1ZXJ5VGltZSAgICAgIChvcHRpb25hbCkgYm9vbGVhbiBpbmRpY2F0aW5nIHRoYXQgdGhlIGFibHkgc3lzdGVtIHNob3VsZCBiZVxuXHQgKiAgICAgICAgICAgICAgICAgIHF1ZXJpZWQgZm9yIHRoZSBjdXJyZW50IHRpbWUgd2hlbiBub25lIGlzIHNwZWNpZmllZCBleHBsaWNpdGx5XG5cdCAqXG5cdCAqIC0gcmVxdWVzdEhlYWRlcnMgKG9wdGlvbmFsLCB1bnN1cHBvcnRlZCwgZm9yIHRlc3Rpbmcgb25seSkgZXh0cmEgaGVhZGVycyB0byBhZGQgdG8gdGhlXG5cdCAqICAgICAgICAgICAgICAgICAgcmVxdWVzdFRva2VuIHJlcXVlc3Rcblx0ICpcblx0ICogQHBhcmFtIHRva2VuUGFyYW1zXG5cdCAqIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgcmVxdWVzdGVkIHRva2VuOlxuXHQgKiAtIHR0bDogICAgICAgICAgKG9wdGlvbmFsKSB0aGUgcmVxdWVzdGVkIGxpZmUgb2YgdGhlIHRva2VuIGluIG1pbGxpc2Vjb25kcy4gSWYgbm9uZSBpcyBzcGVjaWZpZWRcblx0ICogICAgICAgICAgICAgICAgICBhIGRlZmF1bHQgb2YgMSBob3VyIGlzIHByb3ZpZGVkLiBUaGUgbWF4aW11bSBsaWZldGltZSBpcyAyNGhvdXJzOyBhbnkgcmVxdWVzdFxuXHQgKiAgICAgICAgICAgICAgICAgIGV4Y2VlZWRpbmcgdGhhdCBsaWZldGltZSB3aWxsIGJlIHJlamVjdGVkIHdpdGggYW4gZXJyb3IuXG5cdCAqXG5cdCAqIC0gY2FwYWJpbGl0eTogICAgKG9wdGlvbmFsKSB0aGUgY2FwYWJpbGl0eSB0byBhc3NvY2lhdGUgd2l0aCB0aGUgYWNjZXNzIHRva2VuLlxuXHQgKiAgICAgICAgICAgICAgICAgIElmIG5vbmUgaXMgc3BlY2lmaWVkLCBhIHRva2VuIHdpbGwgYmUgcmVxdWVzdGVkIHdpdGggYWxsIG9mIHRoZVxuXHQgKiAgICAgICAgICAgICAgICAgIGNhcGFiaWxpdGllcyBvZiB0aGUgc3BlY2lmaWVkIGtleS5cblx0ICpcblx0ICogLSBjbGllbnRJZDogICAgICAob3B0aW9uYWwpIGEgY2xpZW50IElkIHRvIGFzc29jaWF0ZSB3aXRoIHRoZSB0b2tlbjsgaWYgbm90XG5cdCAqICAgICAgICAgICAgICAgICAgc3BlY2lmaWVkLCBhIGNsaWVudElkIHBhc3NlZCBpbiBjb25zdHJ1Y3RpbmcgdGhlIFJlc3QgaW50ZXJmYWNlIHdpbGwgYmUgdXNlZFxuXHQgKlxuXHQgKiAtIHRpbWVzdGFtcDogICAgIChvcHRpb25hbCkgdGhlIHRpbWUgaW4gbXMgc2luY2UgdGhlIGVwb2NoLiBJZiBub25lIGlzIHNwZWNpZmllZCxcblx0ICogICAgICAgICAgICAgICAgICB0aGUgc3lzdGVtIHdpbGwgYmUgcXVlcmllZCBmb3IgYSB0aW1lIHZhbHVlIHRvIHVzZS5cblx0ICpcblx0ICogQHBhcmFtIGNhbGxiYWNrIChlcnIsIHRva2VuRGV0YWlscylcblx0ICovXG5cdEF1dGgucHJvdG90eXBlLnJlcXVlc3RUb2tlbiA9IGZ1bmN0aW9uKHRva2VuUGFyYW1zLCBhdXRoT3B0aW9ucywgY2FsbGJhY2spIHtcblx0XHQvKiBzaHVmZmxlIGFuZCBub3JtYWxpc2UgYXJndW1lbnRzIGFzIG5lY2Vzc2FyeSAqL1xuXHRcdGlmKHR5cGVvZih0b2tlblBhcmFtcykgPT0gJ2Z1bmN0aW9uJyAmJiAhY2FsbGJhY2spIHtcblx0XHRcdGNhbGxiYWNrID0gdG9rZW5QYXJhbXM7XG5cdFx0XHRhdXRoT3B0aW9ucyA9IHRva2VuUGFyYW1zID0gbnVsbDtcblx0XHR9XG5cdFx0ZWxzZSBpZih0eXBlb2YoYXV0aE9wdGlvbnMpID09ICdmdW5jdGlvbicgJiYgIWNhbGxiYWNrKSB7XG5cdFx0XHRjYWxsYmFjayA9IGF1dGhPcHRpb25zO1xuXHRcdFx0YXV0aE9wdGlvbnMgPSBudWxsO1xuXHRcdH1cblxuXHRcdC8qIFJTQThlOiBpZiBhdXRoT3B0aW9ucyBwYXNzZWQgaW4sIHRoZXkncmUgdXNlZCBpbnN0ZWFkIG9mIHN0b3JlZCwgZG9uJ3QgbWVyZ2UgdGhlbSAqL1xuXHRcdGF1dGhPcHRpb25zID0gYXV0aE9wdGlvbnMgfHwgdGhpcy5hdXRoT3B0aW9ucztcblx0XHR0b2tlblBhcmFtcyA9IHRva2VuUGFyYW1zIHx8IFV0aWxzLmNvcHkodGhpcy50b2tlblBhcmFtcyk7XG5cdFx0Y2FsbGJhY2sgPSBjYWxsYmFjayB8fCBub29wO1xuXHRcdHZhciBmb3JtYXQgPSBhdXRoT3B0aW9ucy5mb3JtYXQgfHwgJ2pzb24nO1xuXG5cdFx0LyogZmlyc3Qgc2V0IHVwIHdoYXRldmVyIGNhbGxiYWNrIHdpbGwgYmUgdXNlZCB0byBnZXQgc2lnbmVkXG5cdFx0ICogdG9rZW4gcmVxdWVzdHMgKi9cblx0XHR2YXIgdG9rZW5SZXF1ZXN0Q2FsbGJhY2ssIGNsaWVudCA9IHRoaXMuY2xpZW50O1xuXG5cdFx0aWYoYXV0aE9wdGlvbnMuYXV0aENhbGxiYWNrKSB7XG5cdFx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlOT1IsICdBdXRoLnJlcXVlc3RUb2tlbigpJywgJ3VzaW5nIHRva2VuIGF1dGggd2l0aCBhdXRoQ2FsbGJhY2snKTtcblx0XHRcdHRva2VuUmVxdWVzdENhbGxiYWNrID0gYXV0aE9wdGlvbnMuYXV0aENhbGxiYWNrO1xuXHRcdH0gZWxzZSBpZihhdXRoT3B0aW9ucy5hdXRoVXJsKSB7XG5cdFx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlOT1IsICdBdXRoLnJlcXVlc3RUb2tlbigpJywgJ3VzaW5nIHRva2VuIGF1dGggd2l0aCBhdXRoVXJsJyk7XG5cdFx0XHQvKiBpZiBubyBhdXRoUGFyYW1zIGdpdmVuLCBjaGVjayBpZiB0aGV5IHdlcmUgZ2l2ZW4gaW4gdGhlIFVSTCAqL1xuXHRcdFx0aWYoIWF1dGhPcHRpb25zLmF1dGhQYXJhbXMpIHtcblx0XHRcdFx0dmFyIHF1ZXJ5SWR4ID0gYXV0aE9wdGlvbnMuYXV0aFVybC5pbmRleE9mKCc/Jyk7XG5cdFx0XHRcdGlmKHF1ZXJ5SWR4ID4gLTEpIHtcblx0XHRcdFx0XHRhdXRoT3B0aW9ucy5hdXRoUGFyYW1zID0gVXRpbHMucGFyc2VRdWVyeVN0cmluZyhhdXRoT3B0aW9ucy5hdXRoVXJsLnNsaWNlKHF1ZXJ5SWR4KSk7XG5cdFx0XHRcdFx0YXV0aE9wdGlvbnMuYXV0aFVybCA9IGF1dGhPcHRpb25zLmF1dGhVcmwuc2xpY2UoMCwgcXVlcnlJZHgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0b2tlblJlcXVlc3RDYWxsYmFjayA9IGZ1bmN0aW9uKHBhcmFtcywgY2IpIHtcblx0XHRcdFx0dmFyIGF1dGhIZWFkZXJzID0gVXRpbHMubWl4aW4oe2FjY2VwdDogJ2FwcGxpY2F0aW9uL2pzb24sIHRleHQvcGxhaW4nfSwgYXV0aE9wdGlvbnMuYXV0aEhlYWRlcnMpLFxuXHRcdFx0XHRcdFx0YXV0aFBhcmFtcyA9IFV0aWxzLm1peGluKHBhcmFtcywgYXV0aE9wdGlvbnMuYXV0aFBhcmFtcyk7XG5cdFx0XHRcdHZhciBhdXRoVXJsUmVxdWVzdENhbGxiYWNrID0gZnVuY3Rpb24oZXJyLCBib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCkge1xuXHRcdFx0XHRcdGlmIChlcnIpIHtcblx0XHRcdFx0XHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSUNSTywgJ0F1dGgucmVxdWVzdFRva2VuKCkudG9rZW5SZXF1ZXN0Q2FsbGJhY2snLCAnUmVjZWl2ZWQgRXJyb3I7ICcgKyBKU09OLnN0cmluZ2lmeShlcnIpKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX01JQ1JPLCAnQXV0aC5yZXF1ZXN0VG9rZW4oKS50b2tlblJlcXVlc3RDYWxsYmFjaycsICdSZWNlaXZlZDsgYm9keTogJyArIChCdWZmZXJVdGlscy5pc0J1ZmZlcihib2R5KSA/IGJvZHkudG9TdHJpbmcoKSA6IGJvZHkpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYoZXJyIHx8IHVucGFja2VkKSByZXR1cm4gY2IoZXJyLCBib2R5KTtcblx0XHRcdFx0XHRpZihCdWZmZXJVdGlscy5pc0J1ZmZlcihib2R5KSkgYm9keSA9IGJvZHkudG9TdHJpbmcoKTtcblx0XHRcdFx0XHR2YXIgY29udGVudFR5cGUgPSBoZWFkZXJzWydjb250ZW50LXR5cGUnXTtcblx0XHRcdFx0XHRpZighY29udGVudFR5cGUpIHtcblx0XHRcdFx0XHRcdGNiKG5ldyBFcnJvckluZm8oJ2F1dGhVcmwgcmVzcG9uc2UgaXMgbWlzc2luZyBhIGNvbnRlbnQtdHlwZSBoZWFkZXInLCA0MDE3MCwgNDAxKSk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHZhciBqc29uID0gY29udGVudFR5cGUuaW5kZXhPZignYXBwbGljYXRpb24vanNvbicpID4gLTEsXG5cdFx0XHRcdFx0XHR0ZXh0ID0gY29udGVudFR5cGUuaW5kZXhPZigndGV4dC9wbGFpbicpID4gLTE7XG5cdFx0XHRcdFx0aWYoIWpzb24gJiYgIXRleHQpIHtcblx0XHRcdFx0XHRcdGNiKG5ldyBFcnJvckluZm8oJ2F1dGhVcmwgcmVzcG9uZGVkIHdpdGggdW5hY2NlcHRhYmxlIGNvbnRlbnQtdHlwZSAnICsgY29udGVudFR5cGUgKyAnLCBzaG91bGQgYmUgZWl0aGVyIHRleHQvcGxhaW4gb3IgYXBwbGljYXRpb24vanNvbicsIDQwMTcwLCA0MDEpKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYoanNvbikge1xuXHRcdFx0XHRcdFx0aWYoYm9keS5sZW5ndGggPiBNQVhfVE9LRU5PQkpFQ1RfTEVOR1RIKSB7XG5cdFx0XHRcdFx0XHRcdGNiKG5ldyBFcnJvckluZm8oJ2F1dGhVcmwgcmVzcG9uc2UgZXhjZWVkZWQgbWF4IHBlcm1pdHRlZCBsZW5ndGgnLCA0MDE3MCwgNDAxKSk7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdGJvZHkgPSBKU09OLnBhcnNlKGJvZHkpO1xuXHRcdFx0XHRcdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRcdFx0XHRcdGNiKG5ldyBFcnJvckluZm8oJ1VuZXhwZWN0ZWQgZXJyb3IgcHJvY2Vzc2luZyBhdXRoVVJMIHJlc3BvbnNlOyBlcnIgPSAnICsgZS5tZXNzYWdlLCA0MDE3MCwgNDAxKSk7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2IobnVsbCwgYm9keSk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSUNSTywgJ0F1dGgucmVxdWVzdFRva2VuKCkudG9rZW5SZXF1ZXN0Q2FsbGJhY2snLCAnU2VuZGluZzsgJyArIGF1dGhPcHRpb25zLmF1dGhVcmwgKyAnOyBQYXJhbXM6ICcgKyBKU09OLnN0cmluZ2lmeShhdXRoUGFyYW1zKSk7XG5cdFx0XHRcdGlmKGF1dGhPcHRpb25zLmF1dGhNZXRob2QgJiYgYXV0aE9wdGlvbnMuYXV0aE1ldGhvZC50b0xvd2VyQ2FzZSgpID09PSAncG9zdCcpIHtcblx0XHRcdFx0XHQvKiBzZW5kIGJvZHkgZm9ybS1lbmNvZGVkICovXG5cdFx0XHRcdFx0dmFyIGhlYWRlcnMgPSBhdXRoSGVhZGVycyB8fCB7fTtcblx0XHRcdFx0XHRoZWFkZXJzWydjb250ZW50LXR5cGUnXSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnO1xuXHRcdFx0XHRcdHZhciBib2R5ID0gVXRpbHMudG9RdWVyeVN0cmluZyhhdXRoUGFyYW1zKS5zbGljZSgxKTsgLyogc2xpY2UgaXMgdG8gcmVtb3ZlIHRoZSBpbml0aWFsICc/JyAqL1xuXHRcdFx0XHRcdEh0dHAucG9zdFVyaShjbGllbnQsIGF1dGhPcHRpb25zLmF1dGhVcmwsIGhlYWRlcnMsIGJvZHksIHt9LCBhdXRoVXJsUmVxdWVzdENhbGxiYWNrKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRIdHRwLmdldFVyaShjbGllbnQsIGF1dGhPcHRpb25zLmF1dGhVcmwsIGF1dGhIZWFkZXJzIHx8IHt9LCBhdXRoUGFyYW1zLCBhdXRoVXJsUmVxdWVzdENhbGxiYWNrKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9IGVsc2UgaWYoYXV0aE9wdGlvbnMua2V5KSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlOT1IsICdBdXRoLnJlcXVlc3RUb2tlbigpJywgJ3VzaW5nIHRva2VuIGF1dGggd2l0aCBjbGllbnQtc2lkZSBzaWduaW5nJyk7XG5cdFx0XHR0b2tlblJlcXVlc3RDYWxsYmFjayA9IGZ1bmN0aW9uKHBhcmFtcywgY2IpIHsgc2VsZi5jcmVhdGVUb2tlblJlcXVlc3QocGFyYW1zLCBhdXRoT3B0aW9ucywgY2IpOyB9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgbXNnID0gXCJOZWVkIGEgbmV3IHRva2VuLCBidXQgYXV0aE9wdGlvbnMgZG9lcyBub3QgaW5jbHVkZSBhbnkgd2F5IHRvIHJlcXVlc3Qgb25lXCI7XG5cdFx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfRVJST1IsICdBdXRoLnJlcXVlc3RUb2tlbigpJywgbXNnKTtcblx0XHRcdGNhbGxiYWNrKG5ldyBFcnJvckluZm8obXNnLCA0MDEwMSwgNDAxKSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Lyogbm9ybWFsaXNlIHRva2VuIHBhcmFtcyAqL1xuXHRcdGlmKCdjYXBhYmlsaXR5JyBpbiB0b2tlblBhcmFtcylcblx0XHRcdHRva2VuUGFyYW1zLmNhcGFiaWxpdHkgPSBjMTRuKHRva2VuUGFyYW1zLmNhcGFiaWxpdHkpO1xuXG5cdFx0dmFyIGNsaWVudCA9IHRoaXMuY2xpZW50O1xuXHRcdHZhciB0b2tlblJlcXVlc3QgPSBmdW5jdGlvbihzaWduZWRUb2tlblBhcmFtcywgdG9rZW5DYikge1xuXHRcdFx0dmFyIGtleU5hbWUgPSBzaWduZWRUb2tlblBhcmFtcy5rZXlOYW1lLFxuXHRcdFx0XHR0b2tlblVyaSA9IGZ1bmN0aW9uKGhvc3QpIHsgcmV0dXJuIGNsaWVudC5iYXNlVXJpKGhvc3QpICsgJy9rZXlzLycgKyBrZXlOYW1lICsgJy9yZXF1ZXN0VG9rZW4nOyB9O1xuXG5cdFx0XHR2YXIgcmVxdWVzdEhlYWRlcnMgPSBVdGlscy5kZWZhdWx0UG9zdEhlYWRlcnMoZm9ybWF0KTtcblx0XHRcdGlmKGF1dGhPcHRpb25zLnJlcXVlc3RIZWFkZXJzKSBVdGlscy5taXhpbihyZXF1ZXN0SGVhZGVycywgYXV0aE9wdGlvbnMucmVxdWVzdEhlYWRlcnMpO1xuXHRcdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX01JQ1JPLCAnQXV0aC5yZXF1ZXN0VG9rZW4oKS5yZXF1ZXN0VG9rZW4nLCAnU2VuZGluZyBQT1NUOyAnICsgdG9rZW5VcmkgKyAnOyBUb2tlbiBwYXJhbXM6ICcgKyBKU09OLnN0cmluZ2lmeShzaWduZWRUb2tlblBhcmFtcykpO1xuXHRcdFx0c2lnbmVkVG9rZW5QYXJhbXMgPSAoZm9ybWF0ID09ICdtc2dwYWNrJykgPyBtc2dwYWNrLmVuY29kZShzaWduZWRUb2tlblBhcmFtcywgdHJ1ZSkgOiBKU09OLnN0cmluZ2lmeShzaWduZWRUb2tlblBhcmFtcyk7XG5cdFx0XHRIdHRwLnBvc3QoY2xpZW50LCB0b2tlblVyaSwgcmVxdWVzdEhlYWRlcnMsIHNpZ25lZFRva2VuUGFyYW1zLCBudWxsLCB0b2tlbkNiKTtcblx0XHR9O1xuXG5cdFx0dmFyIHRva2VuUmVxdWVzdENhbGxiYWNrVGltZW91dEV4cGlyZWQgPSBmYWxzZSxcblx0XHRcdHRpbWVvdXRMZW5ndGggPSB0aGlzLmNsaWVudC5vcHRpb25zLnRpbWVvdXRzLnJlYWx0aW1lUmVxdWVzdFRpbWVvdXQsXG5cdFx0XHR0b2tlblJlcXVlc3RDYWxsYmFja1RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0b2tlblJlcXVlc3RDYWxsYmFja1RpbWVvdXRFeHBpcmVkID0gdHJ1ZTtcblx0XHRcdFx0dmFyIG1zZyA9ICdUb2tlbiByZXF1ZXN0IGNhbGxiYWNrIHRpbWVkIG91dCBhZnRlciAnICsgKHRpbWVvdXRMZW5ndGggLyAxMDAwKSArICcgc2Vjb25kcyc7XG5cdFx0XHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19FUlJPUiwgJ0F1dGgucmVxdWVzdFRva2VuKCknLCBtc2cpO1xuXHRcdFx0XHRjYWxsYmFjayhuZXcgRXJyb3JJbmZvKG1zZywgNDAxNzAsIDQwMSkpO1xuXHRcdFx0fSwgdGltZW91dExlbmd0aCk7XG5cblx0XHR0b2tlblJlcXVlc3RDYWxsYmFjayh0b2tlblBhcmFtcywgZnVuY3Rpb24oZXJyLCB0b2tlblJlcXVlc3RPckRldGFpbHMpIHtcblx0XHRcdGlmKHRva2VuUmVxdWVzdENhbGxiYWNrVGltZW91dEV4cGlyZWQpIHJldHVybjtcblx0XHRcdGNsZWFyVGltZW91dCh0b2tlblJlcXVlc3RDYWxsYmFja1RpbWVvdXQpO1xuXG5cdFx0XHRpZihlcnIpIHtcblx0XHRcdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX0VSUk9SLCAnQXV0aC5yZXF1ZXN0VG9rZW4oKScsICd0b2tlbiByZXF1ZXN0IHNpZ25pbmcgY2FsbCByZXR1cm5lZCBlcnJvcjsgZXJyID0gJyArIFV0aWxzLmluc3BlY3RFcnJvcihlcnIpKTtcblx0XHRcdFx0aWYoIShlcnIgJiYgZXJyLmNvZGUpKSB7XG5cdFx0XHRcdFx0LyogbmV0d29yayBlcnJvcnMgZG9uJ3QgaGF2ZSBhbiBlcnJvciBjb2RlLCBzbyBhc3NpZ24gdGhlbVxuXHRcdFx0XHRcdCAqIDQwMTcwIHNvIHRoZXknbGwgYnkgY29ubmVjdGlvbk1hbmFnZXIgYXMgbm9uZmF0YWwgKi9cblx0XHRcdFx0XHRlcnIgPSBuZXcgRXJyb3JJbmZvKFV0aWxzLmluc3BlY3RFcnJvcihlcnIpLCA0MDE3MCwgNDAxKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYWxsYmFjayhlcnIpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHQvKiB0aGUgcmVzcG9uc2UgZnJvbSB0aGUgY2FsbGJhY2sgbWlnaHQgYmUgYSB0b2tlbiBzdHJpbmcsIGEgc2lnbmVkIHJlcXVlc3Qgb3IgYSB0b2tlbiBkZXRhaWxzICovXG5cdFx0XHRpZih0eXBlb2YodG9rZW5SZXF1ZXN0T3JEZXRhaWxzKSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0aWYodG9rZW5SZXF1ZXN0T3JEZXRhaWxzLmxlbmd0aCA+IE1BWF9UT0tFTlNUUklOR19MRU5HVEgpIHtcblx0XHRcdFx0XHRjYWxsYmFjayhuZXcgRXJyb3JJbmZvKCdUb2tlbiBzdHJpbmcgZXhjZWVkZWQgbWF4IHBlcm1pdHRlZCBsZW5ndGggKHdhcyAnICsgdG9rZW5SZXF1ZXN0T3JEZXRhaWxzLmxlbmd0aCArICcgYnl0ZXMpJywgNDAxNzAsIDQwMSkpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNhbGxiYWNrKG51bGwsIHt0b2tlbjogdG9rZW5SZXF1ZXN0T3JEZXRhaWxzfSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYodHlwZW9mKHRva2VuUmVxdWVzdE9yRGV0YWlscykgIT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdHZhciBtc2cgPSAnRXhwZWN0ZWQgdG9rZW4gcmVxdWVzdCBjYWxsYmFjayB0byBjYWxsIGJhY2sgd2l0aCBhIHRva2VuIHN0cmluZyBvciB0b2tlbiByZXF1ZXN0L2RldGFpbHMgb2JqZWN0LCBidXQgZ290IGEgJyArIHR5cGVvZih0b2tlblJlcXVlc3RPckRldGFpbHMpO1xuXHRcdFx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfRVJST1IsICdBdXRoLnJlcXVlc3RUb2tlbigpJywgbXNnKTtcblx0XHRcdFx0Y2FsbGJhY2sobmV3IEVycm9ySW5mbyhtc2csIDQwMTcwLCA0MDEpKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dmFyIG9iamVjdFNpemUgPSBKU09OLnN0cmluZ2lmeSh0b2tlblJlcXVlc3RPckRldGFpbHMpLmxlbmd0aDtcblx0XHRcdGlmKG9iamVjdFNpemUgPiBNQVhfVE9LRU5PQkpFQ1RfTEVOR1RIKSB7XG5cdFx0XHRcdGNhbGxiYWNrKG5ldyBFcnJvckluZm8oJ1Rva2VuIHJlcXVlc3QvZGV0YWlscyBvYmplY3QgZXhjZWVkZWQgbWF4IHBlcm1pdHRlZCBzdHJpbmdpZmllZCBzaXplICh3YXMgJyArIG9iamVjdFNpemUgKyAnIGJ5dGVzKScsIDQwMTcwLCA0MDEpKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYoJ2lzc3VlZCcgaW4gdG9rZW5SZXF1ZXN0T3JEZXRhaWxzKSB7XG5cdFx0XHRcdC8qIGEgdG9rZW5EZXRhaWxzIG9iamVjdCAqL1xuXHRcdFx0XHRjYWxsYmFjayhudWxsLCB0b2tlblJlcXVlc3RPckRldGFpbHMpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRpZighKCdrZXlOYW1lJyBpbiB0b2tlblJlcXVlc3RPckRldGFpbHMpKSB7XG5cdFx0XHRcdHZhciBtc2cgPSAnRXhwZWN0ZWQgdG9rZW4gcmVxdWVzdCBjYWxsYmFjayB0byBjYWxsIGJhY2sgd2l0aCBhIHRva2VuIHN0cmluZywgdG9rZW4gcmVxdWVzdCBvYmplY3QsIG9yIHRva2VuIGRldGFpbHMgb2JqZWN0Jztcblx0XHRcdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX0VSUk9SLCAnQXV0aC5yZXF1ZXN0VG9rZW4oKScsIG1zZyk7XG5cdFx0XHRcdGNhbGxiYWNrKG5ldyBFcnJvckluZm8obXNnLCA0MDE3MCwgNDAxKSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdC8qIGl0J3MgYSB0b2tlbiByZXF1ZXN0LCBzbyBtYWtlIHRoZSByZXF1ZXN0ICovXG5cdFx0XHR0b2tlblJlcXVlc3QodG9rZW5SZXF1ZXN0T3JEZXRhaWxzLCBmdW5jdGlvbihlcnIsIHRva2VuUmVzcG9uc2UsIGhlYWRlcnMsIHVucGFja2VkKSB7XG5cdFx0XHRcdGlmKGVycikge1xuXHRcdFx0XHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19FUlJPUiwgJ0F1dGgucmVxdWVzdFRva2VuKCknLCAndG9rZW4gcmVxdWVzdCBBUEkgY2FsbCByZXR1cm5lZCBlcnJvcjsgZXJyID0gJyArIFV0aWxzLmluc3BlY3RFcnJvcihlcnIpKTtcblx0XHRcdFx0XHRjYWxsYmFjayhlcnIpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZighdW5wYWNrZWQpIHRva2VuUmVzcG9uc2UgPSAoZm9ybWF0ID09ICdtc2dwYWNrJykgPyBtc2dwYWNrLmRlY29kZSh0b2tlblJlc3BvbnNlKSA6IEpTT04ucGFyc2UodG9rZW5SZXNwb25zZSk7XG5cdFx0XHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSU5PUiwgJ0F1dGguZ2V0VG9rZW4oKScsICd0b2tlbiByZWNlaXZlZCcpO1xuXHRcdFx0XHRjYWxsYmFjayhudWxsLCB0b2tlblJlc3BvbnNlKTtcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYW5kIHNpZ24gYSB0b2tlbiByZXF1ZXN0IGJhc2VkIG9uIHRoZSBnaXZlbiBvcHRpb25zLlxuXHQgKiBOT1RFIHRoaXMgY2FuIG9ubHkgYmUgdXNlZCB3aGVuIHRoZSBrZXkgdmFsdWUgaXMgYXZhaWxhYmxlIGxvY2FsbHkuXG5cdCAqIE90aGVyd2lzZSwgc2lnbmVkIHRva2VuIHJlcXVlc3RzIG11c3QgYmUgb2J0YWluZWQgZnJvbSB0aGUga2V5XG5cdCAqIG93bmVyIChlaXRoZXIgdXNpbmcgdGhlIHRva2VuIHJlcXVlc3QgY2FsbGJhY2sgb3IgdXJsKS5cblx0ICpcblx0ICogQHBhcmFtIGF1dGhPcHRpb25zXG5cdCAqIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSByZXF1ZXN0IG9wdGlvbnM6XG5cdCAqIC0ga2V5OiAgICAgICAgICAgdGhlIGtleSB0byB1c2UuIElmIG5vdCBzcGVjaWZpZWQsIGEga2V5IHBhc3NlZCBpbiBjb25zdHJ1Y3Rpbmdcblx0ICogICAgICAgICAgICAgICAgICB0aGUgUmVzdCBpbnRlcmZhY2Ugd2lsbCBiZSB1c2VkXG5cdCAqXG5cdCAqIC0gcXVlcnlUaW1lICAgICAgKG9wdGlvbmFsKSBib29sZWFuIGluZGljYXRpbmcgdGhhdCB0aGUgYWJseSBzeXN0ZW0gc2hvdWxkIGJlXG5cdCAqICAgICAgICAgICAgICAgICAgcXVlcmllZCBmb3IgdGhlIGN1cnJlbnQgdGltZSB3aGVuIG5vbmUgaXMgc3BlY2lmaWVkIGV4cGxpY2l0bHlcblx0ICpcblx0ICogLSByZXF1ZXN0SGVhZGVycyAob3B0aW9uYWwsIHVuc3VwcG9ydGVkLCBmb3IgdGVzdGluZyBvbmx5KSBleHRyYSBoZWFkZXJzIHRvIGFkZCB0byB0aGVcblx0ICogICAgICAgICAgICAgICAgICByZXF1ZXN0VG9rZW4gcmVxdWVzdFxuXHQgKlxuXHQgKiBAcGFyYW0gdG9rZW5QYXJhbXNcblx0ICogYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHBhcmFtZXRlcnMgZm9yIHRoZSByZXF1ZXN0ZWQgdG9rZW46XG5cdCAqIC0gdHRsOiAgICAgICAob3B0aW9uYWwpIHRoZSByZXF1ZXN0ZWQgbGlmZSBvZiB0aGUgdG9rZW4gaW4gbXMuIElmIG5vbmUgaXMgc3BlY2lmaWVkXG5cdCAqICAgICAgICAgICAgICAgICAgYSBkZWZhdWx0IG9mIDEgaG91ciBpcyBwcm92aWRlZC4gVGhlIG1heGltdW0gbGlmZXRpbWUgaXMgMjRob3VyczsgYW55IHJlcXVlc3Rcblx0ICogICAgICAgICAgICAgICAgICBleGNlZWVkaW5nIHRoYXQgbGlmZXRpbWUgd2lsbCBiZSByZWplY3RlZCB3aXRoIGFuIGVycm9yLlxuXHQgKlxuXHQgKiAtIGNhcGFiaWxpdHk6ICAgIChvcHRpb25hbCkgdGhlIGNhcGFiaWxpdHkgdG8gYXNzb2NpYXRlIHdpdGggdGhlIGFjY2VzcyB0b2tlbi5cblx0ICogICAgICAgICAgICAgICAgICBJZiBub25lIGlzIHNwZWNpZmllZCwgYSB0b2tlbiB3aWxsIGJlIHJlcXVlc3RlZCB3aXRoIGFsbCBvZiB0aGVcblx0ICogICAgICAgICAgICAgICAgICBjYXBhYmlsaXRpZXMgb2YgdGhlIHNwZWNpZmllZCBrZXkuXG5cdCAqXG5cdCAqIC0gY2xpZW50SWQ6ICAgICAgKG9wdGlvbmFsKSBhIGNsaWVudCBJZCB0byBhc3NvY2lhdGUgd2l0aCB0aGUgdG9rZW47IGlmIG5vdFxuXHQgKiAgICAgICAgICAgICAgICAgIHNwZWNpZmllZCwgYSBjbGllbnRJZCBwYXNzZWQgaW4gY29uc3RydWN0aW5nIHRoZSBSZXN0IGludGVyZmFjZSB3aWxsIGJlIHVzZWRcblx0ICpcblx0ICogLSB0aW1lc3RhbXA6ICAgICAob3B0aW9uYWwpIHRoZSB0aW1lIGluIG1zIHNpbmNlIHRoZSBlcG9jaC4gSWYgbm9uZSBpcyBzcGVjaWZpZWQsXG5cdCAqICAgICAgICAgICAgICAgICAgdGhlIHN5c3RlbSB3aWxsIGJlIHF1ZXJpZWQgZm9yIGEgdGltZSB2YWx1ZSB0byB1c2UuXG5cdCAqXG5cdCAqL1xuXHRBdXRoLnByb3RvdHlwZS5jcmVhdGVUb2tlblJlcXVlc3QgPSBmdW5jdGlvbih0b2tlblBhcmFtcywgYXV0aE9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cdFx0Lyogc2h1ZmZsZSBhbmQgbm9ybWFsaXNlIGFyZ3VtZW50cyBhcyBuZWNlc3NhcnkgKi9cblx0XHRpZih0eXBlb2YodG9rZW5QYXJhbXMpID09ICdmdW5jdGlvbicgJiYgIWNhbGxiYWNrKSB7XG5cdFx0XHRjYWxsYmFjayA9IHRva2VuUGFyYW1zO1xuXHRcdFx0YXV0aE9wdGlvbnMgPSB0b2tlblBhcmFtcyA9IG51bGw7XG5cdFx0fSBlbHNlIGlmKHR5cGVvZihhdXRoT3B0aW9ucykgPT0gJ2Z1bmN0aW9uJyAmJiAhY2FsbGJhY2spIHtcblx0XHRcdGNhbGxiYWNrID0gYXV0aE9wdGlvbnM7XG5cdFx0XHRhdXRoT3B0aW9ucyA9IG51bGw7XG5cdFx0fVxuXG5cdFx0LyogUlNBOWg6IGlmIGF1dGhPcHRpb25zIHBhc3NlZCBpbiwgdGhleSdyZSB1c2VkIGluc3RlYWQgb2Ygc3RvcmVkLCBkb24ndCBtZXJnZSB0aGVtICovXG5cdFx0YXV0aE9wdGlvbnMgPSBhdXRoT3B0aW9ucyB8fCB0aGlzLmF1dGhPcHRpb25zO1xuXHRcdHRva2VuUGFyYW1zID0gdG9rZW5QYXJhbXMgfHwgVXRpbHMuY29weSh0aGlzLnRva2VuUGFyYW1zKTtcblxuXHRcdHZhciBrZXkgPSBhdXRoT3B0aW9ucy5rZXk7XG5cdFx0aWYoIWtleSkge1xuXHRcdFx0Y2FsbGJhY2sobmV3IEVycm9yKCdObyBrZXkgc3BlY2lmaWVkJykpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR2YXIga2V5UGFydHMgPSBrZXkuc3BsaXQoJzonKSxcblx0XHRcdGtleU5hbWUgPSBrZXlQYXJ0c1swXSxcblx0XHRcdGtleVNlY3JldCA9IGtleVBhcnRzWzFdO1xuXG5cdFx0aWYoIWtleVNlY3JldCkge1xuXHRcdFx0Y2FsbGJhY2sobmV3IEVycm9yKCdJbnZhbGlkIGtleSBzcGVjaWZpZWQnKSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYodG9rZW5QYXJhbXMuY2xpZW50SWQgPT09ICcnKSB7XG5cdFx0XHRjYWxsYmFjayhuZXcgRXJyb3JJbmZvKCdjbGllbnRJZCBjYW7igJl0IGJlIGFuIGVtcHR5IHN0cmluZycsIDQwMDEyLCA0MDApKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0b2tlblBhcmFtcy5jYXBhYmlsaXR5ID0gYzE0bih0b2tlblBhcmFtcy5jYXBhYmlsaXR5KTtcblxuXHRcdHZhciByZXF1ZXN0ID0gVXRpbHMubWl4aW4oeyBrZXlOYW1lOiBrZXlOYW1lIH0sIHRva2VuUGFyYW1zKSxcblx0XHRcdGNsaWVudElkID0gdG9rZW5QYXJhbXMuY2xpZW50SWQgfHwgJycsXG5cdFx0XHR0dGwgPSB0b2tlblBhcmFtcy50dGwgfHwgJycsXG5cdFx0XHRjYXBhYmlsaXR5ID0gdG9rZW5QYXJhbXMuY2FwYWJpbGl0eSxcblx0XHRcdHNlbGYgPSB0aGlzO1xuXG5cdFx0KGZ1bmN0aW9uKGF1dGhvcmlzZUNiKSB7XG5cdFx0XHRpZihyZXF1ZXN0LnRpbWVzdGFtcCkge1xuXHRcdFx0XHRhdXRob3Jpc2VDYigpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9O1xuXHRcdFx0c2VsZi5nZXRUaW1lc3RhbXAoYXV0aE9wdGlvbnMgJiYgYXV0aE9wdGlvbnMucXVlcnlUaW1lLCBmdW5jdGlvbihlcnIsIHRpbWUpIHtcblx0XHRcdFx0aWYoZXJyKSB7Y2FsbGJhY2soZXJyKTsgcmV0dXJuO31cblx0XHRcdFx0cmVxdWVzdC50aW1lc3RhbXAgPSB0aW1lO1xuXHRcdFx0XHRhdXRob3Jpc2VDYigpO1xuXHRcdFx0fSk7XG5cdFx0fSkoZnVuY3Rpb24oKSB7XG5cdFx0XHQvKiBub25jZSAqL1xuXHRcdFx0LyogTk9URTogdGhlcmUgaXMgbm8gZXhwZWN0YXRpb24gdGhhdCB0aGUgY2xpZW50XG5cdFx0XHQgKiBzcGVjaWZpZXMgdGhlIG5vbmNlOyB0aGlzIGlzIGRvbmUgYnkgdGhlIGxpYnJhcnlcblx0XHRcdCAqIEhvd2V2ZXIsIHRoaXMgY2FuIGJlIG92ZXJyaWRkZW4gYnkgdGhlIGNsaWVudFxuXHRcdFx0ICogc2ltcGx5IGZvciB0ZXN0aW5nIHB1cnBvc2VzLiAqL1xuXHRcdFx0dmFyIG5vbmNlID0gcmVxdWVzdC5ub25jZSB8fCAocmVxdWVzdC5ub25jZSA9IHJhbmRvbSgpKSxcblx0XHRcdFx0dGltZXN0YW1wID0gcmVxdWVzdC50aW1lc3RhbXA7XG5cblx0XHRcdHZhciBzaWduVGV4dFxuXHRcdFx0PVx0cmVxdWVzdC5rZXlOYW1lICsgJ1xcbidcblx0XHRcdCtcdHR0bCArICdcXG4nXG5cdFx0XHQrXHRjYXBhYmlsaXR5ICsgJ1xcbidcblx0XHRcdCtcdGNsaWVudElkICsgJ1xcbidcblx0XHRcdCtcdHRpbWVzdGFtcCArICdcXG4nXG5cdFx0XHQrXHRub25jZSArICdcXG4nO1xuXG5cdFx0XHQvKiBtYWMgKi9cblx0XHRcdC8qIE5PVEU6IHRoZXJlIGlzIG5vIGV4cGVjdGF0aW9uIHRoYXQgdGhlIGNsaWVudFxuXHRcdFx0ICogc3BlY2lmaWVzIHRoZSBtYWM7IHRoaXMgaXMgZG9uZSBieSB0aGUgbGlicmFyeVxuXHRcdFx0ICogSG93ZXZlciwgdGhpcyBjYW4gYmUgb3ZlcnJpZGRlbiBieSB0aGUgY2xpZW50XG5cdFx0XHQgKiBzaW1wbHkgZm9yIHRlc3RpbmcgcHVycG9zZXMuICovXG5cdFx0XHRyZXF1ZXN0Lm1hYyA9IHJlcXVlc3QubWFjIHx8IGhtYWMoc2lnblRleHQsIGtleVNlY3JldCk7XG5cblx0XHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSU5PUiwgJ0F1dGguZ2V0VG9rZW5SZXF1ZXN0KCknLCAnZ2VuZXJhdGVkIHNpZ25lZCByZXF1ZXN0Jyk7XG5cdFx0XHRjYWxsYmFjayhudWxsLCByZXF1ZXN0KTtcblx0XHR9KTtcblx0fTtcblxuXHQvKipcblx0ICogR2V0IHRoZSBhdXRoIHF1ZXJ5IHBhcmFtcyB0byB1c2UgZm9yIGEgd2Vic29ja2V0IGNvbm5lY3Rpb24sXG5cdCAqIGJhc2VkIG9uIHRoZSBjdXJyZW50IGF1dGggcGFyYW1ldGVyc1xuXHQgKi9cblx0QXV0aC5wcm90b3R5cGUuZ2V0QXV0aFBhcmFtcyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdFx0aWYodGhpcy5tZXRob2QgPT0gJ2Jhc2ljJylcblx0XHRcdGNhbGxiYWNrKG51bGwsIHtrZXk6IHRoaXMua2V5fSk7XG5cdFx0ZWxzZVxuXHRcdFx0dGhpcy5fZW5zdXJlVmFsaWRBdXRoQ3JlZGVudGlhbHMoZnVuY3Rpb24oZXJyLCB0b2tlbkRldGFpbHMpIHtcblx0XHRcdFx0aWYoZXJyKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soZXJyKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FsbGJhY2sobnVsbCwge2FjY2Vzc190b2tlbjogdG9rZW5EZXRhaWxzLnRva2VufSk7XG5cdFx0XHR9KTtcblx0fTtcblxuXHQvKipcblx0ICogR2V0IHRoZSBhdXRob3JpemF0aW9uIGhlYWRlciB0byB1c2UgZm9yIGEgUkVTVCBvciBjb21ldCByZXF1ZXN0LFxuXHQgKiBiYXNlZCBvbiB0aGUgY3VycmVudCBhdXRoIHBhcmFtZXRlcnNcblx0ICovXG5cdEF1dGgucHJvdG90eXBlLmdldEF1dGhIZWFkZXJzID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0XHRpZih0aGlzLm1ldGhvZCA9PSAnYmFzaWMnKSB7XG5cdFx0XHRjYWxsYmFjayhudWxsLCB7YXV0aG9yaXphdGlvbjogJ0Jhc2ljICcgKyB0aGlzLmJhc2ljS2V5fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2Vuc3VyZVZhbGlkQXV0aENyZWRlbnRpYWxzKGZ1bmN0aW9uKGVyciwgdG9rZW5EZXRhaWxzKSB7XG5cdFx0XHRcdGlmKGVycikge1xuXHRcdFx0XHRcdGNhbGxiYWNrKGVycik7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhbGxiYWNrKG51bGwsIHthdXRob3JpemF0aW9uOiAnQmVhcmVyICcgKyB0b0Jhc2U2NCh0b2tlbkRldGFpbHMudG9rZW4pfSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEdldCB0aGUgY3VycmVudCB0aW1lIGJhc2VkIG9uIHRoZSBsb2NhbCBjbG9jayxcblx0ICogb3IgaWYgdGhlIG9wdGlvbiBxdWVyeVRpbWUgaXMgdHJ1ZSwgcmV0dXJuIHRoZSBzZXJ2ZXIgdGltZS5cblx0ICogVGhlIHNlcnZlciB0aW1lIG9mZnNldCBmcm9tIHRoZSBsb2NhbCB0aW1lIGlzIHN0b3JlZCBzbyB0aGF0XG5cdCAqIG9ubHkgb25lIHJlcXVlc3QgdG8gdGhlIHNlcnZlciB0byBnZXQgdGhlIHRpbWUgaXMgZXZlciBuZWVkZWRcblx0ICovXG5cdEF1dGgucHJvdG90eXBlLmdldFRpbWVzdGFtcCA9IGZ1bmN0aW9uKHF1ZXJ5VGltZSwgY2FsbGJhY2spIHtcblx0XHR2YXIgb2Zmc2V0U2V0ID0gIWlzTmFOKHBhcnNlSW50KHRoaXMuY2xpZW50LnNlcnZlclRpbWVPZmZzZXQpKTtcblx0XHRpZiAoIW9mZnNldFNldCAmJiAocXVlcnlUaW1lIHx8IHRoaXMuYXV0aE9wdGlvbnMucXVlcnlUaW1lKSkge1xuXHRcdFx0dGhpcy5jbGllbnQudGltZShmdW5jdGlvbihlcnIsIHRpbWUpIHtcblx0XHRcdFx0aWYoZXJyKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soZXJyKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FsbGJhY2sobnVsbCwgdGltZSk7XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2FsbGJhY2sobnVsbCwgVXRpbHMubm93KCkgKyAodGhpcy5jbGllbnQuc2VydmVyVGltZU9mZnNldCB8fCAwKSk7XG5cdFx0fVxuXHR9O1xuXG5cdEF1dGgucHJvdG90eXBlLl9zYXZlQmFzaWNPcHRpb25zID0gZnVuY3Rpb24oYXV0aE9wdGlvbnMpIHtcblx0XHR0aGlzLm1ldGhvZCA9ICdiYXNpYyc7XG5cdFx0dGhpcy5rZXkgPSBhdXRoT3B0aW9ucy5rZXk7XG5cdFx0dGhpcy5iYXNpY0tleSA9IHRvQmFzZTY0KGF1dGhPcHRpb25zLmtleSk7XG5cdFx0dGhpcy5hdXRoT3B0aW9ucyA9IGF1dGhPcHRpb25zIHx8IHt9O1xuXHRcdGlmKCdjbGllbnRJZCcgaW4gYXV0aE9wdGlvbnMpIHtcblx0XHRcdHRoaXMuX3VzZXJTZXRDbGllbnRJZChhdXRoT3B0aW9ucy5jbGllbnRJZCk7XG5cdFx0fVxuXHR9XG5cblx0QXV0aC5wcm90b3R5cGUuX3NhdmVUb2tlbk9wdGlvbnMgPSBmdW5jdGlvbih0b2tlblBhcmFtcywgYXV0aE9wdGlvbnMpIHtcblx0XHR0aGlzLm1ldGhvZCA9ICd0b2tlbic7XG5cblx0XHRpZih0b2tlblBhcmFtcykge1xuXHRcdFx0LyogV2UgdGVtcG9yYXJpbHkgcGVyc2lzdCB0b2tlblBhcmFtcy50aW1lc3RhbXAgaW4gY2FzZSBhIG5ldyB0b2tlbiBuZWVkc1xuXHRcdFx0ICogdG8gYmUgcmVxdWVzdGVkLCB0aGVuIG51bGwgaXQgb3V0IGluIHRoZSBjYWxsYmFjayBvZlxuXHRcdFx0ICogX2Vuc3VyZVZhbGlkQXV0aENyZWRlbnRpYWxzIGZvciBSU0ExMGcgY29tcGxpYW5jZSAqL1xuXHRcdFx0dGhpcy50b2tlblBhcmFtcyA9IHRva2VuUGFyYW1zO1xuXHRcdH1cblxuXHRcdGlmKGF1dGhPcHRpb25zKSB7XG5cdFx0XHQvKiBub3JtYWxpc2UgKi9cblx0XHRcdGlmKGF1dGhPcHRpb25zLnRva2VuKSB7XG5cdFx0XHRcdC8qIG9wdGlvbnMudG9rZW4gbWF5IGNvbnRhaW4gYSB0b2tlbiBzdHJpbmcgb3IsIGZvciBjb252ZW5pZW5jZSwgYSBUb2tlbkRldGFpbHMgKi9cblx0XHRcdFx0YXV0aE9wdGlvbnMudG9rZW5EZXRhaWxzID0gKHR5cGVvZihhdXRoT3B0aW9ucy50b2tlbikgPT09ICdzdHJpbmcnKSA/IHt0b2tlbjogYXV0aE9wdGlvbnMudG9rZW59IDogYXV0aE9wdGlvbnMudG9rZW47XG5cdFx0XHR9XG5cblx0XHRcdGlmKGF1dGhPcHRpb25zLnRva2VuRGV0YWlscykge1xuXHRcdFx0XHR0aGlzLnRva2VuRGV0YWlscyA9IGF1dGhPcHRpb25zLnRva2VuRGV0YWlscztcblx0XHRcdH1cblxuXHRcdFx0aWYoJ2NsaWVudElkJyBpbiBhdXRoT3B0aW9ucykge1xuXHRcdFx0XHR0aGlzLl91c2VyU2V0Q2xpZW50SWQoYXV0aE9wdGlvbnMuY2xpZW50SWQpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmF1dGhPcHRpb25zID0gYXV0aE9wdGlvbnM7XG5cdFx0fVxuXHR9O1xuXG5cdEF1dGgucHJvdG90eXBlLl9lbnN1cmVWYWxpZEF1dGhDcmVkZW50aWFscyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzLFxuXHRcdFx0dG9rZW4gPSB0aGlzLnRva2VuRGV0YWlscztcblxuXHRcdHZhciByZXF1ZXN0VG9rZW4gPSBmdW5jdGlvbigpIHtcblx0XHRcdHNlbGYucmVxdWVzdFRva2VuKHNlbGYudG9rZW5QYXJhbXMsIHNlbGYuYXV0aE9wdGlvbnMsIGZ1bmN0aW9uKGVyciwgdG9rZW5SZXNwb25zZSkge1xuXHRcdFx0XHRpZihlcnIpIHtcblx0XHRcdFx0XHRjYWxsYmFjayhlcnIpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYWxsYmFjayhudWxsLCAoc2VsZi50b2tlbkRldGFpbHMgPSB0b2tlblJlc3BvbnNlKSk7XG5cdFx0XHR9KTtcblx0XHR9O1xuXG5cdFx0aWYodG9rZW4pIHtcblx0XHRcdGlmKHRoaXMuX3Rva2VuQ2xpZW50SWRNaXNtYXRjaCh0b2tlbi5jbGllbnRJZCkpIHtcblx0XHRcdFx0Y2FsbGJhY2sobmV3IEVycm9ySW5mbygnTWlzbWF0Y2ggYmV0d2VlbiBjbGllbnRJZCBpbiB0b2tlbiAoJyArIHRva2VuLmNsaWVudElkICsgJykgYW5kIGN1cnJlbnQgY2xpZW50SWQgKCcgKyB0aGlzLmNsaWVudElkICsgJyknLCA0MDEwMiwgNDAxKSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHRoaXMuZ2V0VGltZXN0YW1wKHNlbGYuYXV0aE9wdGlvbnMgJiYgc2VsZi5hdXRoT3B0aW9ucy5xdWVyeVRpbWUsIGZ1bmN0aW9uKGVyciwgdGltZSkge1xuXHRcdFx0XHRpZihlcnIpXG5cdFx0XHRcdFx0Y2FsbGJhY2soZXJyKTtcblxuXHRcdFx0XHRpZih0b2tlbi5leHBpcmVzID09PSB1bmRlZmluZWQgfHwgKHRva2VuLmV4cGlyZXMgPj0gdGltZSkpIHtcblx0XHRcdFx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlOT1IsICdBdXRoLmdldFRva2VuKCknLCAndXNpbmcgY2FjaGVkIHRva2VuOyBleHBpcmVzID0gJyArIHRva2VuLmV4cGlyZXMpO1xuXHRcdFx0XHRcdGNhbGxiYWNrKG51bGwsIHRva2VuKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0LyogZXhwaXJlZCwgc28gcmVtb3ZlICovXG5cdFx0XHRcdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX01JTk9SLCAnQXV0aC5nZXRUb2tlbigpJywgJ2RlbGV0aW5nIGV4cGlyZWQgdG9rZW4nKTtcblx0XHRcdFx0XHRzZWxmLnRva2VuRGV0YWlscyA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmVxdWVzdFRva2VuKCk7XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVxdWVzdFRva2VuKCk7XG5cdFx0fVxuXHR9O1xuXG5cblx0LyogVXNlci1zZXQ6IGNoZWNrIHR5cGVzLCAnKicgaXMgZGlzYWxsb3dlZCwgdGhyb3cgYW55IGVycm9ycyAqL1xuXHRBdXRoLnByb3RvdHlwZS5fdXNlclNldENsaWVudElkID0gZnVuY3Rpb24oY2xpZW50SWQpIHtcblx0XHRpZighKHR5cGVvZihjbGllbnRJZCkgPT09ICdzdHJpbmcnIHx8IGNsaWVudElkID09PSBudWxsKSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9ySW5mbygnY2xpZW50SWQgbXVzdCBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgbnVsbCcsIDQwMDEyLCA0MDApO1xuXHRcdH0gZWxzZSBpZihjbGllbnRJZCA9PT0gJyonKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3JJbmZvKCdDYW7igJl0IHVzZSBcIipcIiBhcyBhIGNsaWVudElkIGFzIHRoYXQgc3RyaW5nIGlzIHJlc2VydmVkLiAoVG8gY2hhbmdlIHRoZSBkZWZhdWx0IHRva2VuIHJlcXVlc3QgYmVoYXZpb3VyIHRvIHVzZSBhIHdpbGRjYXJkIGNsaWVudElkLCBpbnN0YW50aWF0ZSB0aGUgbGlicmFyeSB3aXRoIHtkZWZhdWx0VG9rZW5QYXJhbXM6IHtjbGllbnRJZDogXCIqXCJ9fSksIG9yIGlmIGNhbGxpbmcgYXV0aG9yaXplKCksIHBhc3MgaXQgaW4gYXMgYSB0b2tlblBhcmFtOiBhdXRob3JpemUoe2NsaWVudElkOiBcIipcIn0sIGF1dGhPcHRpb25zKScsIDQwMDEyLCA0MDApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgZXJyID0gdGhpcy5fdW5jaGVja2VkU2V0Q2xpZW50SWQoY2xpZW50SWQpO1xuXHRcdFx0aWYoZXJyKSB0aHJvdyBlcnI7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIEFibHktc2V0OiBubyB0eXBlY2hlY2tpbmcsICcqJyBpcyBhbGxvd2VkIGJ1dCBub3Qgc2V0IG9uIHRoaXMuY2xpZW50SWQpLCByZXR1cm4gZXJyb3JzIHRvIHRoZSBjYWxsZXIgKi9cblx0QXV0aC5wcm90b3R5cGUuX3VuY2hlY2tlZFNldENsaWVudElkID0gZnVuY3Rpb24oY2xpZW50SWQpIHtcblx0XHRpZih0aGlzLl90b2tlbkNsaWVudElkTWlzbWF0Y2goY2xpZW50SWQpKSB7XG5cdFx0XHQvKiBTaG91bGQgbmV2ZXIgaGFwcGVuIGluIG5vcm1hbCBjaXJjdW1zdGFuY2VzIGFzIHJlYWx0aW1lIHNob3VsZFxuXHRcdFx0ICogcmVjb2duaXNlIG1pc21hdGNoIGFuZCByZXR1cm4gYW4gZXJyb3IgKi9cblx0XHRcdHZhciBtc2cgPSAnVW5leHBlY3RlZCBjbGllbnRJZCBtaXNtYXRjaDogY2xpZW50IGhhcyAnICsgdGhpcy5jbGllbnRJZCArICcsIHJlcXVlc3RlZCAnICsgY2xpZW50SWQ7XG5cdFx0XHR2YXIgZXJyID0gbmV3IEVycm9ySW5mbyhtc2csIDQwMTAyLCA0MDEpO1xuXHRcdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX0VSUk9SLCAnQXV0aC5fdW5jaGVja2VkU2V0Q2xpZW50SWQoKScsIG1zZyk7XG5cdFx0XHRyZXR1cm4gZXJyO1xuXHRcdH0gZWxzZSBpZihjbGllbnRJZCA9PT0gJyonKSB7XG5cdFx0XHR0aGlzLnRva2VuUGFyYW1zLmNsaWVudElkID0gY2xpZW50SWQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8qIFJTQTdhNDogaWYgb3B0aW9ucy5jbGllbnRJZCBpcyBwcm92aWRlZCBhbmQgaXMgbm90XG5cdFx0XHQgKiBudWxsLCBpdCBvdmVycmlkZXMgZGVmYXVsdFRva2VuUGFyYW1zLmNsaWVudElkICovXG5cdFx0XHR0aGlzLmNsaWVudElkID0gdGhpcy50b2tlblBhcmFtcy5jbGllbnRJZCA9IGNsaWVudElkO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHR9O1xuXG5cdEF1dGgucHJvdG90eXBlLl90b2tlbkNsaWVudElkTWlzbWF0Y2ggPSBmdW5jdGlvbih0b2tlbkNsaWVudElkKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2xpZW50SWQgJiZcblx0XHRcdHRva2VuQ2xpZW50SWQgJiZcblx0XHRcdCh0b2tlbkNsaWVudElkICE9PSAnKicpICYmXG5cdFx0XHQodGhpcy5jbGllbnRJZCAhPT0gdG9rZW5DbGllbnRJZCk7XG5cdH07XG5cblx0QXV0aC5pc1Rva2VuRXJyID0gZnVuY3Rpb24oZXJyb3IpIHtcblx0XHRyZXR1cm4gZXJyb3IuY29kZSAmJiAoZXJyb3IuY29kZSA+PSA0MDE0MCkgJiYgKGVycm9yLmNvZGUgPCA0MDE1MCk7XG5cdH07XG5cblx0cmV0dXJuIEF1dGg7XG59KSgpO1xuXG52YXIgUmVzdCA9IChmdW5jdGlvbigpIHtcblx0dmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9O1xuXG5cdGZ1bmN0aW9uIFJlc3Qob3B0aW9ucykge1xuXHRcdGlmKCEodGhpcyBpbnN0YW5jZW9mIFJlc3QpKXtcblx0XHRcdHJldHVybiBuZXcgUmVzdChvcHRpb25zKTtcblx0XHR9XG5cblx0XHQvKiBub3JtYWxpc2Ugb3B0aW9ucyAqL1xuXHRcdGlmKCFvcHRpb25zKSB7XG5cdFx0XHR2YXIgbXNnID0gJ25vIG9wdGlvbnMgcHJvdmlkZWQnO1xuXHRcdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX0VSUk9SLCAnUmVzdCgpJywgbXNnKTtcblx0XHRcdHRocm93IG5ldyBFcnJvcihtc2cpO1xuXHRcdH1cblx0XHRpZih0eXBlb2Yob3B0aW9ucykgPT0gJ3N0cmluZycpIHtcblx0XHRcdG9wdGlvbnMgPSAob3B0aW9ucy5pbmRleE9mKCc6JykgPT0gLTEpID8ge3Rva2VuOiBvcHRpb25zfSA6IHtrZXk6IG9wdGlvbnN9O1xuXHRcdH1cblx0XHR0aGlzLm9wdGlvbnMgPSBEZWZhdWx0cy5ub3JtYWxpc2VPcHRpb25zKG9wdGlvbnMpO1xuXG5cdFx0LyogcHJvY2VzcyBvcHRpb25zICovXG5cdFx0aWYob3B0aW9ucy5rZXkpIHtcblx0XHRcdHZhciBrZXlNYXRjaCA9IG9wdGlvbnMua2V5Lm1hdGNoKC9eKFteOlxcc10rKTooW146Llxcc10rKSQvKTtcblx0XHRcdGlmKCFrZXlNYXRjaCkge1xuXHRcdFx0XHR2YXIgbXNnID0gJ2ludmFsaWQga2V5IHBhcmFtZXRlcic7XG5cdFx0XHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19FUlJPUiwgJ1Jlc3QoKScsIG1zZyk7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihtc2cpO1xuXHRcdFx0fVxuXHRcdFx0b3B0aW9ucy5rZXlOYW1lID0ga2V5TWF0Y2hbMV07XG5cdFx0XHRvcHRpb25zLmtleVNlY3JldCA9IGtleU1hdGNoWzJdO1xuXHRcdH1cblxuXHRcdGlmKCdjbGllbnRJZCcgaW4gb3B0aW9ucykge1xuXHRcdFx0aWYoISh0eXBlb2Yob3B0aW9ucy5jbGllbnRJZCkgPT09ICdzdHJpbmcnIHx8IG9wdGlvbnMuY2xpZW50SWQgPT09IG51bGwpKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3JJbmZvKCdjbGllbnRJZCBtdXN0IGJlIGVpdGhlciBhIHN0cmluZyBvciBudWxsJywgNDAwMTIsIDQwMCk7XG5cdFx0XHRlbHNlIGlmKG9wdGlvbnMuY2xpZW50SWQgPT09ICcqJylcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9ySW5mbygnQ2Fu4oCZdCB1c2UgXCIqXCIgYXMgYSBjbGllbnRJZCBhcyB0aGF0IHN0cmluZyBpcyByZXNlcnZlZC4gKFRvIGNoYW5nZSB0aGUgZGVmYXVsdCB0b2tlbiByZXF1ZXN0IGJlaGF2aW91ciB0byB1c2UgYSB3aWxkY2FyZCBjbGllbnRJZCwgdXNlIHtkZWZhdWx0VG9rZW5QYXJhbXM6IHtjbGllbnRJZDogXCIqXCJ9fSknLCA0MDAxMiwgNDAwKTtcblx0XHR9XG5cblx0XHRpZihvcHRpb25zLmxvZylcblx0XHRcdExvZ2dlci5zZXRMb2cob3B0aW9ucy5sb2cubGV2ZWwsIG9wdGlvbnMubG9nLmhhbmRsZXIpO1xuXHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSU5PUiwgJ1Jlc3QoKScsICdzdGFydGVkJyk7XG5cblx0XHR0aGlzLmJhc2VVcmkgPSB0aGlzLmF1dGhvcml0eSA9IGZ1bmN0aW9uKGhvc3QpIHsgcmV0dXJuIERlZmF1bHRzLmdldEh0dHBTY2hlbWUob3B0aW9ucykgKyBob3N0ICsgJzonICsgRGVmYXVsdHMuZ2V0UG9ydChvcHRpb25zLCBmYWxzZSk7IH07XG5cblx0XHR0aGlzLnNlcnZlclRpbWVPZmZzZXQgPSBudWxsO1xuXHRcdHRoaXMuYXV0aCA9IG5ldyBBdXRoKHRoaXMsIG9wdGlvbnMpO1xuXHRcdHRoaXMuY2hhbm5lbHMgPSBuZXcgQ2hhbm5lbHModGhpcyk7XG5cdH1cblxuXHRSZXN0LnByb3RvdHlwZS5zdGF0cyA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcblx0XHQvKiBwYXJhbXMgYW5kIGNhbGxiYWNrIGFyZSBvcHRpb25hbDsgc2VlIGlmIHBhcmFtcyBjb250YWlucyB0aGUgY2FsbGJhY2sgKi9cblx0XHRpZihjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRpZih0eXBlb2YocGFyYW1zKSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdGNhbGxiYWNrID0gcGFyYW1zO1xuXHRcdFx0XHRwYXJhbXMgPSBudWxsO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2FsbGJhY2sgPSBub29wO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR2YXIgaGVhZGVycyA9IFV0aWxzLmNvcHkoVXRpbHMuZGVmYXVsdEdldEhlYWRlcnMoKSksXG5cdFx0XHRlbnZlbG9wZSA9IEh0dHAuc3VwcG9ydHNMaW5rSGVhZGVycyA/IHVuZGVmaW5lZCA6ICdqc29uJztcblxuXHRcdGlmKHRoaXMub3B0aW9ucy5oZWFkZXJzKVxuXHRcdFx0VXRpbHMubWl4aW4oaGVhZGVycywgdGhpcy5vcHRpb25zLmhlYWRlcnMpO1xuXG5cdFx0KG5ldyBQYWdpbmF0ZWRSZXNvdXJjZSh0aGlzLCAnL3N0YXRzJywgaGVhZGVycywgZW52ZWxvcGUsIGZ1bmN0aW9uKGJvZHksIGhlYWRlcnMsIHVucGFja2VkKSB7XG5cdFx0XHR2YXIgc3RhdHNWYWx1ZXMgPSAodW5wYWNrZWQgPyBib2R5IDogSlNPTi5wYXJzZShib2R5KSk7XG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgc3RhdHNWYWx1ZXMubGVuZ3RoOyBpKyspIHN0YXRzVmFsdWVzW2ldID0gU3RhdHMuZnJvbVZhbHVlcyhzdGF0c1ZhbHVlc1tpXSk7XG5cdFx0XHRyZXR1cm4gc3RhdHNWYWx1ZXM7XG5cdFx0fSkpLmdldChwYXJhbXMsIGNhbGxiYWNrKTtcblx0fTtcblxuXHRSZXN0LnByb3RvdHlwZS50aW1lID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuXHRcdC8qIHBhcmFtcyBhbmQgY2FsbGJhY2sgYXJlIG9wdGlvbmFsOyBzZWUgaWYgcGFyYW1zIGNvbnRhaW5zIHRoZSBjYWxsYmFjayAqL1xuXHRcdGlmKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGlmKHR5cGVvZihwYXJhbXMpID09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0Y2FsbGJhY2sgPSBwYXJhbXM7XG5cdFx0XHRcdHBhcmFtcyA9IG51bGw7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjYWxsYmFjayA9IG5vb3A7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHZhciBoZWFkZXJzID0gVXRpbHMuY29weShVdGlscy5kZWZhdWx0R2V0SGVhZGVycygpKTtcblx0XHRpZih0aGlzLm9wdGlvbnMuaGVhZGVycylcblx0XHRcdFV0aWxzLm1peGluKGhlYWRlcnMsIHRoaXMub3B0aW9ucy5oZWFkZXJzKTtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0dmFyIHRpbWVVcmkgPSBmdW5jdGlvbihob3N0KSB7IHJldHVybiBzZWxmLmF1dGhvcml0eShob3N0KSArICcvdGltZScgfTtcblx0XHRIdHRwLmdldCh0aGlzLCB0aW1lVXJpLCBoZWFkZXJzLCBwYXJhbXMsIGZ1bmN0aW9uKGVyciwgcmVzLCBoZWFkZXJzLCB1bnBhY2tlZCkge1xuXHRcdFx0aWYoZXJyKSB7XG5cdFx0XHRcdGNhbGxiYWNrKGVycik7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGlmKCF1bnBhY2tlZCkgcmVzID0gSlNPTi5wYXJzZShyZXMpO1xuXHRcdFx0dmFyIHRpbWUgPSByZXNbMF07XG5cdFx0XHRpZighdGltZSkge1xuXHRcdFx0XHRlcnIgPSBuZXcgRXJyb3IoJ0ludGVybmFsIGVycm9yICh1bmV4cGVjdGVkIHJlc3VsdCB0eXBlIGZyb20gR0VUIC90aW1lKScpO1xuXHRcdFx0XHRlcnIuc3RhdHVzQ29kZSA9IDUwMDtcblx0XHRcdFx0Y2FsbGJhY2soZXJyKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0LyogY2FsY3VsYXRlIHRpbWUgb2Zmc2V0IG9ubHkgb25jZSBmb3IgdGhpcyBkZXZpY2UgYnkgYWRkaW5nIHRvIHRoZSBwcm90b3R5cGUgKi9cblx0XHRcdHNlbGYuc2VydmVyVGltZU9mZnNldCA9ICh0aW1lIC0gVXRpbHMubm93KCkpO1xuXHRcdFx0Y2FsbGJhY2sobnVsbCwgdGltZSk7XG5cdFx0fSk7XG5cdH07XG5cblx0UmVzdC5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uKG1ldGhvZCwgcGF0aCwgcGFyYW1zLCBib2R5LCBjdXN0b21IZWFkZXJzLCBjYWxsYmFjaykge1xuXHRcdHZhciBmb3JtYXQgPSB0aGlzLm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyAnbXNncGFjaycgOiAnanNvbicsXG5cdFx0XHRtZXRob2QgPSBtZXRob2QudG9Mb3dlckNhc2UoKSxcblx0XHRcdGVudmVsb3BlID0gSHR0cC5zdXBwb3J0c0xpbmtIZWFkZXJzID8gdW5kZWZpbmVkIDogJ2pzb24nLFxuXHRcdFx0cGFyYW1zID0gcGFyYW1zIHx8IHt9LFxuXHRcdFx0aGVhZGVycyA9IFV0aWxzLmNvcHkobWV0aG9kID09ICdnZXQnID8gVXRpbHMuZGVmYXVsdEdldEhlYWRlcnMoKSA6IFV0aWxzLmRlZmF1bHRQb3N0SGVhZGVycyhmb3JtYXQpKTtcblxuXHRcdGlmKHR5cGVvZiBib2R5ICE9PSAnc3RyaW5nJykge1xuXHRcdFx0Ym9keSA9IEpTT04uc3RyaW5naWZ5KGJvZHkpO1xuXHRcdH1cblx0XHRpZih0aGlzLm9wdGlvbnMuaGVhZGVycykge1xuXHRcdFx0VXRpbHMubWl4aW4oaGVhZGVycywgdGhpcy5vcHRpb25zLmhlYWRlcnMpO1xuXHRcdH1cblx0XHRpZihjdXN0b21IZWFkZXJzKSB7XG5cdFx0XHRVdGlscy5taXhpbihoZWFkZXJzLCBjdXN0b21IZWFkZXJzKTtcblx0XHR9XG5cdFx0dmFyIHBhZ2luYXRlZFJlc291cmNlID0gbmV3IFBhZ2luYXRlZFJlc291cmNlKHRoaXMsIHBhdGgsIGhlYWRlcnMsIGVudmVsb3BlLCBmdW5jdGlvbihyZXNib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCkge1xuXHRcdFx0cmV0dXJuIFV0aWxzLmVuc3VyZUFycmF5KHVucGFja2VkID8gcmVzYm9keSA6IEpTT04ucGFyc2UocmVzYm9keSkpO1xuXHRcdH0sIC8qIHVzZUh0dHBQYWdpbmF0ZWRSZXNwb25zZTogKi8gdHJ1ZSk7XG5cblx0XHRzd2l0Y2gobWV0aG9kKSB7XG5cdFx0XHRjYXNlICdnZXQnOlxuXHRcdFx0XHRwYWdpbmF0ZWRSZXNvdXJjZS5nZXQocGFyYW1zLCBjYWxsYmFjayk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAncG9zdCc6XG5cdFx0XHRcdHBhZ2luYXRlZFJlc291cmNlLnBvc3QocGFyYW1zLCBib2R5LCBjYWxsYmFjayk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9ySW5mbygnQ3VycmVudGx5IG9ubHkgR0VUIGFuZCBQT1NUIG1ldGhvZHMgYXJlIHN1cHBvcnRlZCcsIDQwNTAwLCA0MDUpO1xuXHRcdH1cblx0fTtcblxuXHRmdW5jdGlvbiBDaGFubmVscyhyZXN0KSB7XG5cdFx0dGhpcy5yZXN0ID0gcmVzdDtcblx0XHR0aGlzLmF0dGFjaGVkID0ge307XG5cdH1cblxuXHRDaGFubmVscy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24obmFtZSwgY2hhbm5lbE9wdGlvbnMpIHtcblx0XHRuYW1lID0gU3RyaW5nKG5hbWUpO1xuXHRcdHZhciBjaGFubmVsID0gdGhpcy5hdHRhY2hlZFtuYW1lXTtcblx0XHRpZighY2hhbm5lbCkge1xuXHRcdFx0dGhpcy5hdHRhY2hlZFtuYW1lXSA9IGNoYW5uZWwgPSBuZXcgQ2hhbm5lbCh0aGlzLnJlc3QsIG5hbWUsIGNoYW5uZWxPcHRpb25zKTtcblx0XHR9IGVsc2UgaWYoY2hhbm5lbE9wdGlvbnMpIHtcblx0XHRcdGNoYW5uZWwuc2V0T3B0aW9ucyhjaGFubmVsT3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNoYW5uZWw7XG5cdH07XG5cblx0cmV0dXJuIFJlc3Q7XG59KSgpO1xuXG52YXIgUmVhbHRpbWUgPSAoZnVuY3Rpb24oKSB7XG5cblx0ZnVuY3Rpb24gUmVhbHRpbWUob3B0aW9ucykge1xuXHRcdGlmKCEodGhpcyBpbnN0YW5jZW9mIFJlYWx0aW1lKSl7XG5cdFx0XHRyZXR1cm4gbmV3IFJlYWx0aW1lKG9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSU5PUiwgJ1JlYWx0aW1lKCknLCAnJyk7XG5cdFx0UmVzdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHRcdHRoaXMuY29ubmVjdGlvbiA9IG5ldyBDb25uZWN0aW9uKHRoaXMsIHRoaXMub3B0aW9ucyk7XG5cdFx0dGhpcy5jaGFubmVscyA9IG5ldyBDaGFubmVscyh0aGlzKTtcblx0XHRpZihvcHRpb25zLmF1dG9Db25uZWN0ICE9PSBmYWxzZSlcblx0XHRcdHRoaXMuY29ubmVjdCgpO1xuXHR9XG5cdFV0aWxzLmluaGVyaXRzKFJlYWx0aW1lLCBSZXN0KTtcblxuXHRSZWFsdGltZS5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuXHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSU5PUiwgJ1JlYWx0aW1lLmNvbm5lY3QoKScsICcnKTtcblx0XHR0aGlzLmNvbm5lY3Rpb24uY29ubmVjdCgpO1xuXHR9O1xuXG5cdFJlYWx0aW1lLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuXHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSU5PUiwgJ1JlYWx0aW1lLmNsb3NlKCknLCAnJyk7XG5cdFx0dGhpcy5jb25uZWN0aW9uLmNsb3NlKCk7XG5cdH07XG5cblx0ZnVuY3Rpb24gQ2hhbm5lbHMocmVhbHRpbWUpIHtcblx0XHRFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblx0XHR0aGlzLnJlYWx0aW1lID0gcmVhbHRpbWU7XG5cdFx0dGhpcy5hbGwgPSB7fTtcblx0XHR0aGlzLmluUHJvZ3Jlc3MgPSB7fTtcblx0XHRyZWFsdGltZS5jb25uZWN0aW9uLmNvbm5lY3Rpb25NYW5hZ2VyLm9uKCd0cmFuc3BvcnQuYWN0aXZlJywgdGhpcy5vblRyYW5zcG9ydEFjdGl2ZS5iaW5kKHRoaXMpKTtcblx0fVxuXHRVdGlscy5pbmhlcml0cyhDaGFubmVscywgRXZlbnRFbWl0dGVyKTtcblxuXHRDaGFubmVscy5wcm90b3R5cGUub25DaGFubmVsTWVzc2FnZSA9IGZ1bmN0aW9uKG1zZykge1xuXHRcdHZhciBjaGFubmVsTmFtZSA9IG1zZy5jaGFubmVsO1xuXHRcdGlmKGNoYW5uZWxOYW1lID09PSB1bmRlZmluZWQpIHtcblx0XHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19FUlJPUiwgJ0NoYW5uZWxzLm9uQ2hhbm5lbE1lc3NhZ2UoKScsICdyZWNlaXZlZCBldmVudCB1bnNwZWNpZmllZCBjaGFubmVsLCBhY3Rpb24gPSAnICsgbXNnLmFjdGlvbik7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHZhciBjaGFubmVsID0gdGhpcy5hbGxbY2hhbm5lbE5hbWVdO1xuXHRcdGlmKCFjaGFubmVsKSB7XG5cdFx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfRVJST1IsICdDaGFubmVscy5vbkNoYW5uZWxNZXNzYWdlKCknLCAncmVjZWl2ZWQgZXZlbnQgZm9yIG5vbi1leGlzdGVudCBjaGFubmVsOiAnICsgY2hhbm5lbE5hbWUpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRjaGFubmVsLm9uTWVzc2FnZShtc2cpO1xuXHR9O1xuXG5cdC8qIGNhbGxlZCB3aGVuIGEgdHJhbnNwb3J0IGJlY29tZXMgY29ubmVjdGVkOyByZWF0dGVtcHQgYXR0YWNoL2RldGFjaFxuXHQgKiBmb3IgY2hhbm5lbHMgdGhhdCBhcmUgYXR0YWNoaW5nIG9yIGRldGFjaGluZy5cblx0ICogTm90ZSB0aGF0IHRoaXMgZG9lcyBub3QgdXNlIGluUHJvZ3Jlc3MgYXMgaW5Qcm9ncmVzcyBpcyBvbmx5IGNoYW5uZWxzIHdoaWNoIGhhdmUgYWxyZWFkeSBtYWRlXG5cdCogYXQgbGVhc3Qgb25lIGF0dGVtcHQgdG8gYXR0YWNoL2RldGFjaCAqL1xuXHRDaGFubmVscy5wcm90b3R5cGUub25UcmFuc3BvcnRBY3RpdmUgPSBmdW5jdGlvbigpIHtcblx0XHRmb3IodmFyIGNoYW5uZWxOYW1lIGluIHRoaXMuYWxsKSB7XG5cdFx0XHR2YXIgY2hhbm5lbCA9IHRoaXMuYWxsW2NoYW5uZWxOYW1lXTtcblx0XHRcdGlmKGNoYW5uZWwuc3RhdGUgPT09ICdhdHRhY2hpbmcnIHx8IGNoYW5uZWwuc3RhdGUgPT09ICdkZXRhY2hpbmcnKSB7XG5cdFx0XHRcdGNoYW5uZWwuY2hlY2tQZW5kaW5nU3RhdGUoKTtcblx0XHRcdH0gZWxzZSBpZihjaGFubmVsLnN0YXRlID09PSAnc3VzcGVuZGVkJykge1xuXHRcdFx0XHRjaGFubmVsLmF1dG9ub21vdXNBdHRhY2goKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0Q2hhbm5lbHMucHJvdG90eXBlLnJlYXR0YWNoID0gZnVuY3Rpb24ocmVhc29uKSB7XG5cdFx0Zm9yKHZhciBjaGFubmVsSWQgaW4gdGhpcy5hbGwpIHtcblx0XHRcdHZhciBjaGFubmVsID0gdGhpcy5hbGxbY2hhbm5lbElkXTtcblx0XHRcdC8qIE5CIHRoaXMgc2hvdWxkIG5vdCB0cmlnZ2VyIGZvciBtZXJlbHkgYXR0YWNoaW5nIGNoYW5uZWxzLCBhcyB0aGV5IHdpbGxcblx0XHRcdCAqIGJlIHJlYXR0YWNoZWQgYW55d2F5IHRocm91Z2ggdGhlIG9uVHJhbnNwb3J0QWN0aXZlIGNoZWNrUGVuZGluZ1N0YXRlICovXG5cdFx0XHRpZihjaGFubmVsLnN0YXRlID09PSAnYXR0YWNoZWQnKSB7XG5cdFx0XHRcdGNoYW5uZWwucmVxdWVzdFN0YXRlKCdhdHRhY2hpbmcnLCByZWFzb24pO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKiBDb25uZWN0aW9uIGludGVycnVwdGlvbnMgKGllIHdoZW4gdGhlIGNvbm5lY3Rpb24gd2lsbCBubyBsb25nZXIgcXVldWVcblx0ICogZXZlbnRzKSBpbXBseSBjb25uZWN0aW9uIHN0YXRlIGNoYW5nZXMgZm9yIGFueSBjaGFubmVsIHdoaWNoIGlzIGVpdGhlclxuXHQgKiBhdHRhY2hlZCwgcGVuZGluZywgb3Igd2lsbCBhdHRlbXB0IHRvIGJlY29tZSBhdHRhY2hlZCBpbiB0aGUgZnV0dXJlICovXG5cdENoYW5uZWxzLnByb3RvdHlwZS5wcm9wb2dhdGVDb25uZWN0aW9uSW50ZXJydXB0aW9uID0gZnVuY3Rpb24oY29ubmVjdGlvblN0YXRlLCByZWFzb24pIHtcblx0XHR2YXIgY29ubmVjdGlvblN0YXRlVG9DaGFubmVsU3RhdGUgPSB7XG5cdFx0XHQnY2xvc2luZycgIDogJ2RldGFjaGVkJyxcblx0XHRcdCdjbG9zZWQnICAgOiAnZGV0YWNoZWQnLFxuXHRcdFx0J2ZhaWxlZCcgICA6ICdmYWlsZWQnLFxuXHRcdFx0J3N1c3BlbmRlZCc6ICdzdXNwZW5kZWQnXG5cdFx0fTtcblx0XHR2YXIgZnJvbUNoYW5uZWxTdGF0ZXMgPSBbJ2F0dGFjaGluZycsICdhdHRhY2hlZCcsICdkZXRhY2hpbmcnLCAnc3VzcGVuZGVkJ107XG5cdFx0dmFyIHRvQ2hhbm5lbFN0YXRlID0gY29ubmVjdGlvblN0YXRlVG9DaGFubmVsU3RhdGVbY29ubmVjdGlvblN0YXRlXTtcblxuXHRcdGZvcih2YXIgY2hhbm5lbElkIGluIHRoaXMuYWxsKSB7XG5cdFx0XHR2YXIgY2hhbm5lbCA9IHRoaXMuYWxsW2NoYW5uZWxJZF07XG5cdFx0XHRpZihVdGlscy5hcnJJbihmcm9tQ2hhbm5lbFN0YXRlcywgY2hhbm5lbC5zdGF0ZSkpIHtcblx0XHRcdFx0IGNoYW5uZWwubm90aWZ5U3RhdGUodG9DaGFubmVsU3RhdGUsIHJlYXNvbik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdENoYW5uZWxzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihuYW1lLCBjaGFubmVsT3B0aW9ucykge1xuXHRcdG5hbWUgPSBTdHJpbmcobmFtZSk7XG5cdFx0dmFyIGNoYW5uZWwgPSB0aGlzLmFsbFtuYW1lXTtcblx0XHRpZighY2hhbm5lbCkge1xuXHRcdFx0Y2hhbm5lbCA9IHRoaXMuYWxsW25hbWVdID0gbmV3IFJlYWx0aW1lQ2hhbm5lbCh0aGlzLnJlYWx0aW1lLCBuYW1lLCBjaGFubmVsT3B0aW9ucyk7XG5cdFx0fSBlbHNlIGlmKGNoYW5uZWxPcHRpb25zKSB7XG5cdFx0XHRjaGFubmVsLnNldE9wdGlvbnMoY2hhbm5lbE9wdGlvbnMpO1xuXHRcdH1cblx0XHRyZXR1cm4gY2hhbm5lbDtcblx0fTtcblxuXHRDaGFubmVscy5wcm90b3R5cGUucmVsZWFzZSA9IGZ1bmN0aW9uKG5hbWUpIHtcblx0XHR2YXIgY2hhbm5lbCA9IHRoaXMuYWxsW25hbWVdO1xuXHRcdGlmKGNoYW5uZWwpIHtcblx0XHRcdGRlbGV0ZSB0aGlzLmFsbFtuYW1lXTtcblx0XHR9XG5cdH07XG5cblx0LyogUmVjb3JkcyBvcGVyYXRpb25zIGN1cnJlbnRseSBwZW5kaW5nIG9uIGEgdHJhbnNwb3J0OyB1c2VkIGJ5IGNvbm5lY3Rpb25NYW5hZ2VyIHRvIGRlY2lkZSB3aGVuXG5cdCAqIGl0J3Mgc2FmZSB0byB1cGdyYWRlLiBOb3RlIHRoYXQgYSBjaGFubmVsIG1pZ2h0IGJlIGluIHRoZSBhdHRhY2hpbmcgc3RhdGUgd2l0aG91dCBhbnkgcGVuZGluZ1xuXHQgKiBvcGVyYXRpb25zIChlZyBpZiBhdHRhY2hlZCB3aGlsZSB0aGUgY29ubmVjdGlvbiBzdGF0ZSBpcyBjb25uZWN0aW5nKSAtIHN1Y2ggYSBjaGFubmVsIG11c3Qgbm90XG5cdCAqIGhvbGQgdXAgYW4gdXBncmFkZSwgc28gaXMgbm90IGNvbnNpZGVyZWQgaW5Qcm9ncmVzcy5cblx0ICogT3BlcmF0aW9uIGlzIGN1cnJlbnRseSBvbmUgb2YgZWl0aGVyICdzdGF0ZWNoYW5nZScgb3IgJ3N5bmMnICovXG5cdENoYW5uZWxzLnByb3RvdHlwZS5zZXRJblByb2dyZXNzID0gZnVuY3Rpb24oY2hhbm5lbCwgb3BlcmF0aW9uLCBpblByb2dyZXNzKSB7XG5cdFx0dGhpcy5pblByb2dyZXNzW2NoYW5uZWwubmFtZV0gPSB0aGlzLmluUHJvZ3Jlc3NbY2hhbm5lbC5uYW1lXSB8fCB7fTtcblx0XHR0aGlzLmluUHJvZ3Jlc3NbY2hhbm5lbC5uYW1lXVtvcGVyYXRpb25dID0gaW5Qcm9ncmVzcztcblx0XHRpZighaW5Qcm9ncmVzcyAmJiB0aGlzLmhhc05vcGVuZGluZygpKSB7XG5cdFx0XHR0aGlzLmVtaXQoJ25vcGVuZGluZycpO1xuXHRcdH1cblx0fTtcblxuXHRDaGFubmVscy5wcm90b3R5cGUub25jZU5vcGVuZGluZyA9IGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG5cdFx0aWYodGhpcy5oYXNOb3BlbmRpbmcoKSkge1xuXHRcdFx0bGlzdGVuZXIoKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5vbmNlKCdub3BlbmRpbmcnLCBsaXN0ZW5lcik7XG5cdH07XG5cblx0Q2hhbm5lbHMucHJvdG90eXBlLmhhc05vcGVuZGluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBVdGlscy5hcnJFdmVyeShVdGlscy52YWx1ZXNBcnJheSh0aGlzLmluUHJvZ3Jlc3MsIHRydWUpLCBmdW5jdGlvbihvcGVyYXRpb25zKSB7XG5cdFx0XHRyZXR1cm4gIVV0aWxzLmNvbnRhaW5zVmFsdWUob3BlcmF0aW9ucywgdHJ1ZSk7XG5cdFx0fSk7XG5cdH07XG5cblx0cmV0dXJuIFJlYWx0aW1lO1xufSkoKTtcblxudmFyIENvbm5lY3Rpb25TdGF0ZUNoYW5nZSA9IChmdW5jdGlvbigpIHtcblxuXHQvKiBwdWJsaWMgY29uc3RydWN0b3IgKi9cblx0ZnVuY3Rpb24gQ29ubmVjdGlvblN0YXRlQ2hhbmdlKHByZXZpb3VzLCBjdXJyZW50LCByZXRyeUluLCByZWFzb24pIHtcblx0XHR0aGlzLnByZXZpb3VzID0gcHJldmlvdXM7XG5cdFx0dGhpcy5jdXJyZW50ID0gY3VycmVudDtcblx0XHRpZihyZXRyeUluKSB0aGlzLnJldHJ5SW4gPSByZXRyeUluO1xuXHRcdGlmKHJlYXNvbikgdGhpcy5yZWFzb24gPSByZWFzb247XG5cdH1cblxuXHRyZXR1cm4gQ29ubmVjdGlvblN0YXRlQ2hhbmdlO1xufSkoKTtcblxudmFyIENoYW5uZWxTdGF0ZUNoYW5nZSA9IChmdW5jdGlvbigpIHtcblxuXHQvKiBwdWJsaWMgY29uc3RydWN0b3IgKi9cblx0ZnVuY3Rpb24gQ2hhbm5lbFN0YXRlQ2hhbmdlKHByZXZpb3VzLCBjdXJyZW50LCByZXN1bWVkLCByZWFzb24pIHtcblx0XHR0aGlzLnByZXZpb3VzID0gcHJldmlvdXM7XG5cdFx0dGhpcy5jdXJyZW50ID0gY3VycmVudDtcblx0XHRpZihjdXJyZW50ID09PSAnYXR0YWNoZWQnKSB0aGlzLnJlc3VtZWQgPSByZXN1bWVkO1xuXHRcdGlmKHJlYXNvbikgdGhpcy5yZWFzb24gPSByZWFzb247XG5cdH1cblxuXHRyZXR1cm4gQ2hhbm5lbFN0YXRlQ2hhbmdlO1xufSkoKTtcblxudmFyIENvbm5lY3Rpb24gPSAoZnVuY3Rpb24oKSB7XG5cblx0LyogcHVibGljIGNvbnN0cnVjdG9yICovXG5cdGZ1bmN0aW9uIENvbm5lY3Rpb24oYWJseSwgb3B0aW9ucykge1xuXHRcdEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXHRcdHRoaXMuYWJseSA9IGFibHk7XG5cdFx0dGhpcy5jb25uZWN0aW9uTWFuYWdlciA9IG5ldyBDb25uZWN0aW9uTWFuYWdlcihhYmx5LCBvcHRpb25zKTtcblx0XHR0aGlzLnN0YXRlID0gdGhpcy5jb25uZWN0aW9uTWFuYWdlci5zdGF0ZS5zdGF0ZTtcblx0XHR0aGlzLmtleSA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLmlkID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuc2VyaWFsID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMucmVjb3ZlcnlLZXkgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5lcnJvclJlYXNvbiA9IG51bGw7XG5cblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0dGhpcy5jb25uZWN0aW9uTWFuYWdlci5vbignY29ubmVjdGlvbnN0YXRlJywgZnVuY3Rpb24oc3RhdGVDaGFuZ2UpIHtcblx0XHRcdHZhciBzdGF0ZSA9IHNlbGYuc3RhdGUgPSBzdGF0ZUNoYW5nZS5jdXJyZW50O1xuXHRcdFx0VXRpbHMubmV4dFRpY2soZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNlbGYuZW1pdChzdGF0ZSwgc3RhdGVDaGFuZ2UpO1xuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdFx0dGhpcy5jb25uZWN0aW9uTWFuYWdlci5vbigndXBkYXRlJywgZnVuY3Rpb24oc3RhdGVDaGFuZ2UpIHtcblx0XHRcdFV0aWxzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZWxmLmVtaXQoJ3VwZGF0ZScsIHN0YXRlQ2hhbmdlKTtcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHR9XG5cdFV0aWxzLmluaGVyaXRzKENvbm5lY3Rpb24sIEV2ZW50RW1pdHRlcik7XG5cblx0Q29ubmVjdGlvbi5wcm90b3R5cGUud2hlblN0YXRlID0gZnVuY3Rpb24oc3RhdGUsIGxpc3RlbmVyKSB7XG5cdFx0RXZlbnRFbWl0dGVyLnByb3RvdHlwZS53aGVuU3RhdGUuY2FsbCh0aGlzLCBzdGF0ZSwgdGhpcy5zdGF0ZSwgbGlzdGVuZXIsIG5ldyBDb25uZWN0aW9uU3RhdGVDaGFuZ2UodW5kZWZpbmVkLCBzdGF0ZSkpO1xuXHR9XG5cblx0Q29ubmVjdGlvbi5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuXHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb24uY29ubmVjdCgpJywgJycpO1xuXHRcdHRoaXMuY29ubmVjdGlvbk1hbmFnZXIucmVxdWVzdFN0YXRlKHtzdGF0ZTogJ2Nvbm5lY3RpbmcnfSk7XG5cdH07XG5cblx0Q29ubmVjdGlvbi5wcm90b3R5cGUucGluZyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX01JTk9SLCAnQ29ubmVjdGlvbi5waW5nKCknLCAnJyk7XG5cdFx0Y2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbigpIHt9O1xuXHRcdHRoaXMuY29ubmVjdGlvbk1hbmFnZXIucGluZyhudWxsLCBjYWxsYmFjayk7XG5cdH07XG5cblx0Q29ubmVjdGlvbi5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcblx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlOT1IsICdDb25uZWN0aW9uLmNsb3NlKCknLCAnY29ubmVjdGlvbktleSA9ICcgKyB0aGlzLmtleSk7XG5cdFx0dGhpcy5jb25uZWN0aW9uTWFuYWdlci5yZXF1ZXN0U3RhdGUoe3N0YXRlOiAnY2xvc2luZyd9KTtcblx0fTtcblxuXHRyZXR1cm4gQ29ubmVjdGlvbjtcbn0pKCk7XG5cbnZhciBDaGFubmVsID0gKGZ1bmN0aW9uKCkge1xuXHRmdW5jdGlvbiBub29wKCkge31cblxuXHQvKiBwdWJsaWMgY29uc3RydWN0b3IgKi9cblx0ZnVuY3Rpb24gQ2hhbm5lbChyZXN0LCBuYW1lLCBjaGFubmVsT3B0aW9ucykge1xuXHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSU5PUiwgJ0NoYW5uZWwoKScsICdzdGFydGVkOyBuYW1lID0gJyArIG5hbWUpO1xuXHRcdEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXHRcdHRoaXMucmVzdCA9IHJlc3Q7XG5cdFx0dGhpcy5uYW1lID0gbmFtZTtcblx0XHR0aGlzLmJhc2VQYXRoID0gJy9jaGFubmVscy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KG5hbWUpO1xuXHRcdHRoaXMucHJlc2VuY2UgPSBuZXcgUHJlc2VuY2UodGhpcyk7XG5cdFx0dGhpcy5zZXRPcHRpb25zKGNoYW5uZWxPcHRpb25zKTtcblx0fVxuXHRVdGlscy5pbmhlcml0cyhDaGFubmVsLCBFdmVudEVtaXR0ZXIpO1xuXG5cdENoYW5uZWwucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0dGhpcy5jaGFubmVsT3B0aW9ucyA9IG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRcdGlmKG9wdGlvbnMuY2lwaGVyKSB7XG5cdFx0XHRpZighQ3J5cHRvKSB0aHJvdyBuZXcgRXJyb3IoJ0VuY3J5cHRpb24gbm90IGVuYWJsZWQ7IHVzZSBhYmx5LmVuY3J5cHRpb24uanMgaW5zdGVhZCcpO1xuXHRcdFx0dmFyIGNpcGhlciA9IENyeXB0by5nZXRDaXBoZXIob3B0aW9ucy5jaXBoZXIpO1xuXHRcdFx0b3B0aW9ucy5jaXBoZXIgPSBjaXBoZXIuY2lwaGVyUGFyYW1zO1xuXHRcdFx0b3B0aW9ucy5jaGFubmVsQ2lwaGVyID0gY2lwaGVyLmNpcGhlcjtcblx0XHR9IGVsc2UgaWYoJ2NpcGhlcicgaW4gb3B0aW9ucykge1xuXHRcdFx0LyogRG9uJ3QgZGVhY3RpdmF0ZSBhbiBleGlzdGluZyBjaXBoZXIgdW5sZXNzIG9wdGlvbnNcblx0XHRcdCAqIGhhcyBhICdjaXBoZXInIGtleSB0aGF0J3MgZmFsc2V5ICovXG5cdFx0XHRvcHRpb25zLmNpcGhlciA9IG51bGw7XG5cdFx0XHRvcHRpb25zLmNoYW5uZWxDaXBoZXIgPSBudWxsO1xuXHRcdH1cblx0fTtcblxuXHRDaGFubmVsLnByb3RvdHlwZS5oaXN0b3J5ID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuXHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSUNSTywgJ0NoYW5uZWwuaGlzdG9yeSgpJywgJ2NoYW5uZWwgPSAnICsgdGhpcy5uYW1lKTtcblx0XHQvKiBwYXJhbXMgYW5kIGNhbGxiYWNrIGFyZSBvcHRpb25hbDsgc2VlIGlmIHBhcmFtcyBjb250YWlucyB0aGUgY2FsbGJhY2sgKi9cblx0XHRpZihjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRpZih0eXBlb2YocGFyYW1zKSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdGNhbGxiYWNrID0gcGFyYW1zO1xuXHRcdFx0XHRwYXJhbXMgPSBudWxsO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2FsbGJhY2sgPSBub29wO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuX2hpc3RvcnkocGFyYW1zLCBjYWxsYmFjayk7XG5cdH07XG5cblx0Q2hhbm5lbC5wcm90b3R5cGUuX2hpc3RvcnkgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG5cdFx0dmFyIHJlc3QgPSB0aGlzLnJlc3QsXG5cdFx0XHRmb3JtYXQgPSByZXN0Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyAnbXNncGFjaycgOiAnanNvbicsXG5cdFx0XHRlbnZlbG9wZSA9IEh0dHAuc3VwcG9ydHNMaW5rSGVhZGVycyA/IHVuZGVmaW5lZCA6IGZvcm1hdCxcblx0XHRcdGhlYWRlcnMgPSBVdGlscy5jb3B5KFV0aWxzLmRlZmF1bHRHZXRIZWFkZXJzKGZvcm1hdCkpLFxuXHRcdFx0Y2hhbm5lbCA9IHRoaXM7XG5cblx0XHRpZihyZXN0Lm9wdGlvbnMuaGVhZGVycylcblx0XHRcdFV0aWxzLm1peGluKGhlYWRlcnMsIHJlc3Qub3B0aW9ucy5oZWFkZXJzKTtcblxuXHRcdHZhciBvcHRpb25zID0gdGhpcy5jaGFubmVsT3B0aW9ucztcblx0XHQobmV3IFBhZ2luYXRlZFJlc291cmNlKHJlc3QsIHRoaXMuYmFzZVBhdGggKyAnL21lc3NhZ2VzJywgaGVhZGVycywgZW52ZWxvcGUsIGZ1bmN0aW9uKGJvZHksIGhlYWRlcnMsIHVucGFja2VkKSB7XG5cdFx0XHRyZXR1cm4gTWVzc2FnZS5mcm9tUmVzcG9uc2VCb2R5KGJvZHksIG9wdGlvbnMsICF1bnBhY2tlZCAmJiBmb3JtYXQpO1xuXHRcdH0pKS5nZXQocGFyYW1zLCBjYWxsYmFjayk7XG5cdH07XG5cblx0Q2hhbm5lbC5wcm90b3R5cGUucHVibGlzaCA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBhcmdDb3VudCA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdFx0XHRtZXNzYWdlcyA9IGFyZ3VtZW50c1swXSxcblx0XHRcdGNhbGxiYWNrID0gYXJndW1lbnRzW2FyZ0NvdW50IC0gMV0sXG5cdFx0XHRzZWxmID0gdGhpcztcblxuXHRcdGlmKHR5cGVvZihjYWxsYmFjaykgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGNhbGxiYWNrID0gbm9vcDtcblx0XHRcdCsrYXJnQ291bnQ7XG5cdFx0fVxuXHRcdGlmKGFyZ0NvdW50ID09IDIpIHtcblx0XHRcdGlmKFV0aWxzLmlzT2JqZWN0KG1lc3NhZ2VzKSlcblx0XHRcdFx0bWVzc2FnZXMgPSBbTWVzc2FnZS5mcm9tVmFsdWVzKG1lc3NhZ2VzKV07XG5cdFx0XHRlbHNlIGlmKFV0aWxzLmlzQXJyYXkobWVzc2FnZXMpKVxuXHRcdFx0XHRtZXNzYWdlcyA9IE1lc3NhZ2UuZnJvbVZhbHVlc0FycmF5KG1lc3NhZ2VzKTtcblx0XHRcdGVsc2Vcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9ySW5mbygnVGhlIHNpbmdsZS1hcmd1bWVudCBmb3JtIG9mIHB1Ymxpc2goKSBleHBlY3RzIGEgbWVzc2FnZSBvYmplY3Qgb3IgYW4gYXJyYXkgb2YgbWVzc2FnZSBvYmplY3RzJywgNDAwMTMsIDQwMCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1lc3NhZ2VzID0gW01lc3NhZ2UuZnJvbVZhbHVlcyh7bmFtZTogYXJndW1lbnRzWzBdLCBkYXRhOiBhcmd1bWVudHNbMV19KV07XG5cdFx0fVxuXG5cdFx0dmFyIHJlc3QgPSB0aGlzLnJlc3QsXG5cdFx0XHRmb3JtYXQgPSByZXN0Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyAnbXNncGFjaycgOiAnanNvbicsXG5cdFx0XHRoZWFkZXJzID0gVXRpbHMuY29weShVdGlscy5kZWZhdWx0UG9zdEhlYWRlcnMoZm9ybWF0KSk7XG5cblx0XHRpZihyZXN0Lm9wdGlvbnMuaGVhZGVycylcblx0XHRcdFV0aWxzLm1peGluKGhlYWRlcnMsIHJlc3Qub3B0aW9ucy5oZWFkZXJzKTtcblxuXHRcdE1lc3NhZ2UudG9SZXF1ZXN0Qm9keShtZXNzYWdlcywgdGhpcy5jaGFubmVsT3B0aW9ucywgZm9ybWF0LCBmdW5jdGlvbihlcnIsIHJlcXVlc3RCb2R5KSB7XG5cdFx0XHRpZiAoZXJyKSB7XG5cdFx0XHRcdGNhbGxiYWNrKGVycik7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHNlbGYuX3B1Ymxpc2gocmVxdWVzdEJvZHksIGhlYWRlcnMsIGNhbGxiYWNrKTtcblx0XHR9KTtcblx0fTtcblxuXHRDaGFubmVsLnByb3RvdHlwZS5fcHVibGlzaCA9IGZ1bmN0aW9uKHJlcXVlc3RCb2R5LCBoZWFkZXJzLCBjYWxsYmFjaykge1xuXHRcdFJlc291cmNlLnBvc3QodGhpcy5yZXN0LCB0aGlzLmJhc2VQYXRoICsgJy9tZXNzYWdlcycsIHJlcXVlc3RCb2R5LCBoZWFkZXJzLCBudWxsLCBmYWxzZSwgY2FsbGJhY2spO1xuXHR9O1xuXG5cdHJldHVybiBDaGFubmVsO1xufSkoKTtcblxudmFyIFJlYWx0aW1lQ2hhbm5lbCA9IChmdW5jdGlvbigpIHtcblx0dmFyIGFjdGlvbnMgPSBQcm90b2NvbE1lc3NhZ2UuQWN0aW9uO1xuXHR2YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XG5cdHZhciBzdGF0ZWNoYW5nZU9wID0gJ3N0YXRlY2hhbmdlJztcblx0dmFyIHN5bmNPcCA9ICdzeW5jJztcblxuXHQvKiBwdWJsaWMgY29uc3RydWN0b3IgKi9cblx0ZnVuY3Rpb24gUmVhbHRpbWVDaGFubmVsKHJlYWx0aW1lLCBuYW1lLCBvcHRpb25zKSB7XG5cdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX01JTk9SLCAnUmVhbHRpbWVDaGFubmVsKCknLCAnc3RhcnRlZDsgbmFtZSA9ICcgKyBuYW1lKTtcblx0XHRDaGFubmVsLmNhbGwodGhpcywgcmVhbHRpbWUsIG5hbWUsIG9wdGlvbnMpO1xuXHRcdHRoaXMucmVhbHRpbWUgPSByZWFsdGltZTtcblx0XHR0aGlzLnByZXNlbmNlID0gbmV3IFJlYWx0aW1lUHJlc2VuY2UodGhpcywgcmVhbHRpbWUub3B0aW9ucyk7XG5cdFx0dGhpcy5jb25uZWN0aW9uTWFuYWdlciA9IHJlYWx0aW1lLmNvbm5lY3Rpb24uY29ubmVjdGlvbk1hbmFnZXI7XG5cdFx0dGhpcy5zdGF0ZSA9ICdpbml0aWFsaXplZCc7XG5cdFx0dGhpcy5zdWJzY3JpcHRpb25zID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXHRcdHRoaXMucGVuZGluZ0V2ZW50cyA9IFtdO1xuXHRcdHRoaXMuc3luY0NoYW5uZWxTZXJpYWwgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5hdHRhY2hTZXJpYWwgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuXHRcdHRoaXMuZXJyb3JSZWFzb24gPSBudWxsO1xuXHRcdHRoaXMuX3JlcXVlc3RlZEZsYWdzID0gbnVsbDtcblx0XHR0aGlzLl9tb2RlID0gbnVsbDtcblx0fVxuXHRVdGlscy5pbmhlcml0cyhSZWFsdGltZUNoYW5uZWwsIENoYW5uZWwpO1xuXG5cdFJlYWx0aW1lQ2hhbm5lbC5pbnZhbGlkU3RhdGVFcnJvciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHN0YXR1c0NvZGU6IDQwMCxcblx0XHRcdGNvZGU6IDkwMDAxLFxuXHRcdFx0bWVzc2FnZTogJ0NoYW5uZWwgb3BlcmF0aW9uIGZhaWxlZCBhcyBjaGFubmVsIHN0YXRlIGlzICcgKyBzdGF0ZVxuXHRcdH07XG5cdH07XG5cblx0UmVhbHRpbWVDaGFubmVsLnByb2dyZXNzT3BzID0ge1xuXHRcdHN0YXRlY2hhbmdlOiBzdGF0ZWNoYW5nZU9wLFxuXHRcdHN5bmM6IHN5bmNPcFxuXHR9O1xuXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm9jZXNzTGlzdGVuZXJBcmdzID0gZnVuY3Rpb24oYXJncykge1xuXHRcdC8qIFtldmVudF0sIGxpc3RlbmVyLCBbY2FsbGJhY2tdICovXG5cdFx0aWYodHlwZW9mKGFyZ3NbMF0pID09ICdmdW5jdGlvbicpXG5cdFx0XHRyZXR1cm4gW251bGwsIGFyZ3NbMF0sIGFyZ3NbMV0gfHwgbm9vcF07XG5cdFx0ZWxzZVxuXHRcdFx0cmV0dXJuIFthcmdzWzBdLCBhcmdzWzFdLCAoYXJnc1syXSB8fCBub29wKV07XG5cdH1cblxuXHRSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLnB1Ymxpc2ggPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgYXJnQ291bnQgPSBhcmd1bWVudHMubGVuZ3RoLFxuXHRcdFx0bWVzc2FnZXMgPSBhcmd1bWVudHNbMF0sXG5cdFx0XHRjYWxsYmFjayA9IGFyZ3VtZW50c1thcmdDb3VudCAtIDFdO1xuXG5cdFx0aWYodHlwZW9mKGNhbGxiYWNrKSAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Y2FsbGJhY2sgPSBub29wO1xuXHRcdFx0KythcmdDb3VudDtcblx0XHR9XG5cdFx0aWYoIXRoaXMuY29ubmVjdGlvbk1hbmFnZXIuYWN0aXZlU3RhdGUoKSkge1xuXHRcdFx0Y2FsbGJhY2sodGhpcy5jb25uZWN0aW9uTWFuYWdlci5nZXRTdGF0ZUVycm9yKCkpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZihhcmdDb3VudCA9PSAyKSB7XG5cdFx0XHRpZihVdGlscy5pc09iamVjdChtZXNzYWdlcykpXG5cdFx0XHRcdG1lc3NhZ2VzID0gW01lc3NhZ2UuZnJvbVZhbHVlcyhtZXNzYWdlcyldO1xuXHRcdFx0ZWxzZSBpZihVdGlscy5pc0FycmF5KG1lc3NhZ2VzKSlcblx0XHRcdFx0bWVzc2FnZXMgPSBNZXNzYWdlLmZyb21WYWx1ZXNBcnJheShtZXNzYWdlcyk7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvckluZm8oJ1RoZSBzaW5nbGUtYXJndW1lbnQgZm9ybSBvZiBwdWJsaXNoKCkgZXhwZWN0cyBhIG1lc3NhZ2Ugb2JqZWN0IG9yIGFuIGFycmF5IG9mIG1lc3NhZ2Ugb2JqZWN0cycsIDQwMDEzLCA0MDApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtZXNzYWdlcyA9IFtNZXNzYWdlLmZyb21WYWx1ZXMoe25hbWU6IGFyZ3VtZW50c1swXSwgZGF0YTogYXJndW1lbnRzWzFdfSldO1xuXHRcdH1cblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMuY2hhbm5lbE9wdGlvbnM7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdE1lc3NhZ2UuZW5jb2RlQXJyYXkobWVzc2FnZXMsIG9wdGlvbnMsIGZ1bmN0aW9uKGVycikge1xuXHRcdFx0aWYgKGVycikge1xuXHRcdFx0XHRjYWxsYmFjayhlcnIpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRzZWxmLl9wdWJsaXNoKG1lc3NhZ2VzLCBjYWxsYmFjayk7XG5cdFx0fSk7XG5cdH07XG5cblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5fcHVibGlzaCA9IGZ1bmN0aW9uKG1lc3NhZ2VzLCBjYWxsYmFjaykge1xuXHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSUNSTywgJ1JlYWx0aW1lQ2hhbm5lbC5wdWJsaXNoKCknLCAnbWVzc2FnZSBjb3VudCA9ICcgKyBtZXNzYWdlcy5sZW5ndGgpO1xuXHRcdHN3aXRjaCh0aGlzLnN0YXRlKSB7XG5cdFx0XHRjYXNlICdmYWlsZWQnOlxuXHRcdFx0XHRjYWxsYmFjayhFcnJvckluZm8uZnJvbVZhbHVlcyhSZWFsdGltZUNoYW5uZWwuaW52YWxpZFN0YXRlRXJyb3IoJ2ZhaWxlZCcpKSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnYXR0YWNoZWQnOlxuXHRcdFx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlDUk8sICdSZWFsdGltZUNoYW5uZWwucHVibGlzaCgpJywgJ3NlbmRpbmcgbWVzc2FnZScpO1xuXHRcdFx0XHR2YXIgbXNnID0gbmV3IFByb3RvY29sTWVzc2FnZSgpO1xuXHRcdFx0XHRtc2cuYWN0aW9uID0gYWN0aW9ucy5NRVNTQUdFO1xuXHRcdFx0XHRtc2cuY2hhbm5lbCA9IHRoaXMubmFtZTtcblx0XHRcdFx0bXNnLm1lc3NhZ2VzID0gbWVzc2FnZXM7XG5cdFx0XHRcdHRoaXMuc2VuZE1lc3NhZ2UobXNnLCBjYWxsYmFjayk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0dGhpcy5hdXRvbm9tb3VzQXR0YWNoKCk7XG5cdFx0XHRjYXNlICdhdHRhY2hpbmcnOlxuXHRcdFx0XHRpZih0aGlzLnJlYWx0aW1lLm9wdGlvbnMucXVldWVNZXNzYWdlcykge1xuXHRcdFx0XHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSUNSTywgJ1JlYWx0aW1lQ2hhbm5lbC5wdWJsaXNoKCknLCAncXVldWVpbmcgbWVzc2FnZScpO1xuXHRcdFx0XHRcdHRoaXMucGVuZGluZ0V2ZW50cy5wdXNoKHttZXNzYWdlczogbWVzc2FnZXMsIGNhbGxiYWNrOiBjYWxsYmFja30pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhciBtc2cgPSAnQ2Fubm90IHB1Ymxpc2ggbWVzc2FnZXMgd2hpbGUgY2hhbm5lbCBpcyBhdHRhY2hpbmcgYXMgcXVldWVNZXNzYWdlcyB3YXMgZGlzYWJsZWQnO1xuXHRcdFx0XHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSUNSTywgJ1JlYWx0aW1lQ2hhbm5lbC5wdWJsaXNoKCknLCBtc2cpO1xuXHRcdFx0XHRcdGNhbGxiYWNrKG5ldyBFcnJvckluZm8obXNnLCA5MDAwMSwgNDA5KSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9O1xuXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUub25FdmVudCA9IGZ1bmN0aW9uKG1lc3NhZ2VzKSB7XG5cdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX01JQ1JPLCAnUmVhbHRpbWVDaGFubmVsLm9uRXZlbnQoKScsICdyZWNlaXZlZCBtZXNzYWdlJyk7XG5cdFx0dmFyIHN1YnNjcmlwdGlvbnMgPSB0aGlzLnN1YnNjcmlwdGlvbnM7XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IG1lc3NhZ2VzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgbWVzc2FnZSA9IG1lc3NhZ2VzW2ldO1xuXHRcdFx0c3Vic2NyaXB0aW9ucy5lbWl0KG1lc3NhZ2UubmFtZSwgbWVzc2FnZSk7XG5cdFx0fVxuXHR9O1xuXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuYXR0YWNoID0gZnVuY3Rpb24oZmxhZ3MsIGNhbGxiYWNrKSB7XG5cdFx0aWYodHlwZW9mKGZsYWdzKSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Y2FsbGJhY2sgPSBmbGFncztcblx0XHRcdGZsYWdzID0gbnVsbDtcblx0XHR9XG5cdFx0Y2FsbGJhY2sgPSBjYWxsYmFjayB8fCBub29wO1xuXHRcdGlmKGZsYWdzKSB7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0ZWRGbGFncyA9IGZsYWdzO1xuXHRcdH1cblx0XHR2YXIgY29ubmVjdGlvbk1hbmFnZXIgPSB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyO1xuXHRcdGlmKCFjb25uZWN0aW9uTWFuYWdlci5hY3RpdmVTdGF0ZSgpKSB7XG5cdFx0XHRjYWxsYmFjayhjb25uZWN0aW9uTWFuYWdlci5nZXRTdGF0ZUVycm9yKCkpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRzd2l0Y2godGhpcy5zdGF0ZSkge1xuXHRcdFx0Y2FzZSAnYXR0YWNoZWQnOlxuXHRcdFx0XHQvKiBJZiBmbGFncyByZXF1ZXN0ZWQsIGFsd2F5cyBkbyBhIHJlLWF0dGFjaC4gVE9ETyBvbmx5IGRvIHRoaXMgaWYgaWZcblx0XHRcdFx0KiBjdXJyZW50IG1vZGUgZGlmZmVycyBmcm9tIHJlcXVlc3RlZCBtb2RlICovXG5cdFx0XHRcdGlmKCFmbGFncykge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH0gLyogZWxzZSBmYWxsdGhyb3VnaCAqL1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0dGhpcy5yZXF1ZXN0U3RhdGUoJ2F0dGFjaGluZycpO1xuXHRcdFx0Y2FzZSAnYXR0YWNoaW5nJzpcblx0XHRcdFx0dGhpcy5vbmNlKGZ1bmN0aW9uKHN0YXRlQ2hhbmdlKSB7XG5cdFx0XHRcdFx0c3dpdGNoKHRoaXMuZXZlbnQpIHtcblx0XHRcdFx0XHRcdGNhc2UgJ2F0dGFjaGVkJzpcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdkZXRhY2hlZCc6XG5cdFx0XHRcdFx0XHRjYXNlICdzdXNwZW5kZWQnOlxuXHRcdFx0XHRcdFx0Y2FzZSAnZmFpbGVkJzpcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2soc3RhdGVDaGFuZ2UucmVhc29uIHx8IGNvbm5lY3Rpb25NYW5hZ2VyLmdldFN0YXRlRXJyb3IoKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cbiAgICB9O1xuXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuYXR0YWNoSW1wbCA9IGZ1bmN0aW9uKCkge1xuXHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSUNSTywgJ1JlYWx0aW1lQ2hhbm5lbC5hdHRhY2hJbXBsKCknLCAnc2VuZGluZyBBVFRBQ0ggbWVzc2FnZScpO1xuXHRcdHRoaXMuc2V0SW5Qcm9ncmVzcyhzdGF0ZWNoYW5nZU9wLCB0cnVlKTtcblx0XHR2YXIgYXR0YWNoTXNnID0gUHJvdG9jb2xNZXNzYWdlLmZyb21WYWx1ZXMoe2FjdGlvbjogYWN0aW9ucy5BVFRBQ0gsIGNoYW5uZWw6IHRoaXMubmFtZX0pO1xuXHRcdGlmKHRoaXMuX3JlcXVlc3RlZEZsYWdzKSB7XG5cdFx0XHRVdGlscy5hcnJGb3JFYWNoKHRoaXMuX3JlcXVlc3RlZEZsYWdzLCBmdW5jdGlvbihmbGFnKSB7XG5cdFx0XHRcdGF0dGFjaE1zZy5zZXRGbGFnKGZsYWcpO1xuXHRcdFx0fSlcblx0XHR9XG5cdFx0dGhpcy5zZW5kTWVzc2FnZShhdHRhY2hNc2csIG5vb3ApO1xuXHR9O1xuXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuZGV0YWNoID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0XHRjYWxsYmFjayA9IGNhbGxiYWNrIHx8IG5vb3A7XG5cdFx0dmFyIGNvbm5lY3Rpb25NYW5hZ2VyID0gdGhpcy5jb25uZWN0aW9uTWFuYWdlcjtcblx0XHRpZighY29ubmVjdGlvbk1hbmFnZXIuYWN0aXZlU3RhdGUoKSkge1xuXHRcdFx0Y2FsbGJhY2soY29ubmVjdGlvbk1hbmFnZXIuZ2V0U3RhdGVFcnJvcigpKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0c3dpdGNoKHRoaXMuc3RhdGUpIHtcblx0XHRcdGNhc2UgJ2RldGFjaGVkJzpcblx0XHRcdGNhc2UgJ2ZhaWxlZCc6XG5cdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0dGhpcy5yZXF1ZXN0U3RhdGUoJ2RldGFjaGluZycpO1xuXHRcdFx0Y2FzZSAnZGV0YWNoaW5nJzpcblx0XHRcdFx0dGhpcy5vbmNlKGZ1bmN0aW9uKHN0YXRlQ2hhbmdlKSB7XG5cdFx0XHRcdFx0c3dpdGNoKHRoaXMuZXZlbnQpIHtcblx0XHRcdFx0XHRcdGNhc2UgJ2RldGFjaGVkJzpcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdmYWlsZWQnOlxuXHRcdFx0XHRcdFx0Y2FzZSAnYXR0YWNoZWQnOlxuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayhzdGF0ZUNoYW5nZS5yZWFzb24gfHwgY29ubmVjdGlvbk1hbmFnZXIuZ2V0U3RhdGVFcnJvcigpKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHQvKiB0aGlzIHNob3VsZG4ndCBoYXBwZW4gLi4uICovXG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrKENvbm5lY3Rpb25FcnJvci51bmtub3duQ2hhbm5lbEVycik7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0fVxuXHR9O1xuXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuYXV0b25vbW91c0F0dGFjaCA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHR0aGlzLmF0dGFjaChmdW5jdGlvbihlcnIpIHtcblx0XHRcdGlmKGVycikge1xuXHRcdFx0XHR2YXIgbXNnID0gJ0NoYW5uZWwgYXV0by1hdHRhY2ggZmFpbGVkOiAnICsgZXJyLnRvU3RyaW5nKCk7XG5cdFx0XHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSU5PUiwgJ1JlYWx0aW1lQ2hhbm5lbC5hdXRvbm9tb3VzQXR0YWNoKCknLCBtc2cpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9O1xuXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuZGV0YWNoSW1wbCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX01JQ1JPLCAnUmVhbHRpbWVDaGFubmVsLmRldGFjaCgpJywgJ3NlbmRpbmcgREVUQUNIIG1lc3NhZ2UnKTtcblx0XHR0aGlzLnNldEluUHJvZ3Jlc3Moc3RhdGVjaGFuZ2VPcCwgdHJ1ZSk7XG5cdFx0dmFyIG1zZyA9IFByb3RvY29sTWVzc2FnZS5mcm9tVmFsdWVzKHthY3Rpb246IGFjdGlvbnMuREVUQUNILCBjaGFubmVsOiB0aGlzLm5hbWV9KTtcblx0XHR0aGlzLnNlbmRNZXNzYWdlKG1zZywgKGNhbGxiYWNrIHx8IG5vb3ApKTtcblx0fTtcblxuXHRSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uKC8qIFtldmVudF0sIGxpc3RlbmVyLCBbY2FsbGJhY2tdICovKSB7XG5cdFx0dmFyIGFyZ3MgPSBSZWFsdGltZUNoYW5uZWwucHJvY2Vzc0xpc3RlbmVyQXJncyhhcmd1bWVudHMpO1xuXHRcdHZhciBldmVudCA9IGFyZ3NbMF07XG5cdFx0dmFyIGxpc3RlbmVyID0gYXJnc1sxXTtcblx0XHR2YXIgY2FsbGJhY2sgPSBhcmdzWzJdO1xuXHRcdHZhciBzdWJzY3JpcHRpb25zID0gdGhpcy5zdWJzY3JpcHRpb25zO1xuXHRcdHZhciBldmVudHM7XG5cblx0XHRpZih0aGlzLnN0YXRlID09PSAnZmFpbGVkJykge1xuXHRcdFx0Y2FsbGJhY2soRXJyb3JJbmZvLmZyb21WYWx1ZXMoUmVhbHRpbWVDaGFubmVsLmludmFsaWRTdGF0ZUVycm9yKCdmYWlsZWQnKSkpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHN1YnNjcmlwdGlvbnMub24oZXZlbnQsIGxpc3RlbmVyKTtcblxuXHRcdGlmKGNhbGxiYWNrKSB7XG5cdFx0XHR0aGlzLmF0dGFjaChjYWxsYmFjayk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuYXV0b25vbW91c0F0dGFjaCgpO1xuXHRcdH1cblx0fTtcblxuXHRSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24oLyogW2V2ZW50XSwgbGlzdGVuZXIsIFtjYWxsYmFja10gKi8pIHtcblx0XHR2YXIgYXJncyA9IFJlYWx0aW1lQ2hhbm5lbC5wcm9jZXNzTGlzdGVuZXJBcmdzKGFyZ3VtZW50cyk7XG5cdFx0dmFyIGV2ZW50ID0gYXJnc1swXTtcblx0XHR2YXIgbGlzdGVuZXIgPSBhcmdzWzFdO1xuXHRcdHZhciBjYWxsYmFjayA9IGFyZ3NbMl07XG5cdFx0dmFyIHN1YnNjcmlwdGlvbnMgPSB0aGlzLnN1YnNjcmlwdGlvbnM7XG5cdFx0dmFyIGV2ZW50cztcblxuXHRcdGlmKHRoaXMuc3RhdGUgPT09ICdmYWlsZWQnKSB7XG5cdFx0XHRjYWxsYmFjayhFcnJvckluZm8uZnJvbVZhbHVlcyhSZWFsdGltZUNoYW5uZWwuaW52YWxpZFN0YXRlRXJyb3IoJ2ZhaWxlZCcpKSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0c3Vic2NyaXB0aW9ucy5vZmYoZXZlbnQsIGxpc3RlbmVyKTtcblx0fTtcblxuXHRSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLnN5bmMgPSBmdW5jdGlvbigpIHtcblx0XHQvKiBjaGVjayBwcmVjb25kaXRpb25zICovXG5cdFx0c3dpdGNoKHRoaXMuc3RhdGUpIHtcblx0XHRcdGNhc2UgJ2luaXRpYWxpemVkJzpcblx0XHRcdGNhc2UgJ2RldGFjaGluZyc6XG5cdFx0XHRjYXNlICdkZXRhY2hlZCc6XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvckluZm8oXCJVbmFibGUgdG8gc3luYyB0byBjaGFubmVsOyBub3QgYXR0YWNoZWRcIiwgNDAwMDApO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHR9XG5cdFx0dmFyIGNvbm5lY3Rpb25NYW5hZ2VyID0gdGhpcy5jb25uZWN0aW9uTWFuYWdlcjtcblx0XHRpZighY29ubmVjdGlvbk1hbmFnZXIuYWN0aXZlU3RhdGUoKSkge1xuXHRcdFx0dGhyb3cgY29ubmVjdGlvbk1hbmFnZXIuZ2V0U3RhdGVFcnJvcigpO1xuXHRcdH1cblxuXHRcdC8qIHNlbmQgc3luYyByZXF1ZXN0ICovXG5cdFx0dmFyIHN5bmNNZXNzYWdlID0gUHJvdG9jb2xNZXNzYWdlLmZyb21WYWx1ZXMoe2FjdGlvbjogYWN0aW9ucy5TWU5DLCBjaGFubmVsOiB0aGlzLm5hbWV9KTtcblx0XHRpZih0aGlzLnN5bmNDaGFubmVsU2VyaWFsKSB7XG5cdFx0XHRzeW5jTWVzc2FnZS5jaGFubmVsU2VyaWFsID0gdGhpcy5zeW5jQ2hhbm5lbFNlcmlhbDtcblx0XHR9XG5cdFx0Y29ubmVjdGlvbk1hbmFnZXIuc2VuZChzeW5jTWVzc2FnZSk7XG5cdH07XG5cblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5zZW5kTWVzc2FnZSA9IGZ1bmN0aW9uKG1zZywgY2FsbGJhY2spIHtcblx0XHR0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnNlbmQobXNnLCB0aGlzLnJlYWx0aW1lLm9wdGlvbnMucXVldWVNZXNzYWdlcywgY2FsbGJhY2spO1xuXHR9O1xuXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuc2VuZFByZXNlbmNlID0gZnVuY3Rpb24ocHJlc2VuY2UsIGNhbGxiYWNrKSB7XG5cdFx0dmFyIG1zZyA9IFByb3RvY29sTWVzc2FnZS5mcm9tVmFsdWVzKHtcblx0XHRcdGFjdGlvbjogYWN0aW9ucy5QUkVTRU5DRSxcblx0XHRcdGNoYW5uZWw6IHRoaXMubmFtZSxcblx0XHRcdHByZXNlbmNlOiAoVXRpbHMuaXNBcnJheShwcmVzZW5jZSkgP1xuXHRcdFx0XHRQcmVzZW5jZU1lc3NhZ2UuZnJvbVZhbHVlc0FycmF5KHByZXNlbmNlKSA6XG5cdFx0XHRcdFtQcmVzZW5jZU1lc3NhZ2UuZnJvbVZhbHVlcyhwcmVzZW5jZSldKVxuXHRcdH0pO1xuXHRcdHRoaXMuc2VuZE1lc3NhZ2UobXNnLCBjYWxsYmFjayk7XG5cdH07XG5cblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5vbk1lc3NhZ2UgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG5cdFx0dmFyIHN5bmNDaGFubmVsU2VyaWFsLCBpc1N5bmMgPSBmYWxzZTtcblx0XHRzd2l0Y2gobWVzc2FnZS5hY3Rpb24pIHtcblx0XHRjYXNlIGFjdGlvbnMuQVRUQUNIRUQ6XG5cdFx0XHR0aGlzLmF0dGFjaFNlcmlhbCA9IG1lc3NhZ2UuY2hhbm5lbFNlcmlhbDtcblx0XHRcdHRoaXMuX21vZGUgPSBtZXNzYWdlLmdldE1vZGUoKTtcblx0XHRcdGlmKHRoaXMuc3RhdGUgPT09ICdhdHRhY2hlZCcpIHtcblx0XHRcdFx0aWYoIW1lc3NhZ2UuaGFzRmxhZygnUkVTVU1FRCcpKSB7XG5cdFx0XHRcdFx0LyogT24gYSBsb3NzIG9mIGNvbnRpbnVpdHksIHRoZSBwcmVzZW5jZSBzZXQgbmVlZHMgdG8gYmUgcmUtc3luY2VkICovXG5cdFx0XHRcdFx0dGhpcy5wcmVzZW5jZS5vbkF0dGFjaGVkKG1lc3NhZ2UuaGFzRmxhZygnSEFTX1BSRVNFTkNFJykpXG5cdFx0XHRcdFx0dmFyIGNoYW5nZSA9IG5ldyBDaGFubmVsU3RhdGVDaGFuZ2UodGhpcy5zdGF0ZSwgdGhpcy5zdGF0ZSwgZmFsc2UsIG1lc3NhZ2UuZXJyb3IpO1xuXHRcdFx0XHRcdHRoaXMuZW1pdCgndXBkYXRlJywgY2hhbmdlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5ub3RpZnlTdGF0ZSgnYXR0YWNoZWQnLCBtZXNzYWdlLmVycm9yLCBtZXNzYWdlLmhhc0ZsYWcoJ1JFU1VNRUQnKSwgbWVzc2FnZS5oYXNGbGFnKCdIQVNfUFJFU0VOQ0UnKSk7XG5cdFx0XHR9XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgYWN0aW9ucy5ERVRBQ0hFRDpcblx0XHRcdHZhciBlcnIgPSBtZXNzYWdlLmVycm9yID8gRXJyb3JJbmZvLmZyb21WYWx1ZXMobWVzc2FnZS5lcnJvcikgOiBuZXcgRXJyb3JJbmZvKCdDaGFubmVsIGRldGFjaGVkJywgOTAwMDEsIDQwNCk7XG5cdFx0XHRpZih0aGlzLnN0YXRlID09PSAnZGV0YWNoaW5nJykge1xuXHRcdFx0XHR0aGlzLm5vdGlmeVN0YXRlKCdkZXRhY2hlZCcsIGVycik7XG5cdFx0XHR9IGVsc2UgaWYodGhpcy5zdGF0ZSA9PT0gJ2F0dGFjaGluZycpIHtcblx0XHRcdFx0LyogT25seSByZXRyeSBpbW1lZGlhdGVseSBpZiB3ZSB3ZXJlIHByZXZpb3VzbHkgYXR0YWNoZWQuIElmIHdlIHdlcmVcblx0XHRcdFx0ICogYXR0YWNoaW5nLCBnbyBpbnRvIHN1c3BlbmRlZCwgZmFpbCBtZXNzYWdlcywgYW5kIHdhaXQgYSBmZXcgc2Vjb25kc1xuXHRcdFx0XHQgKiBiZWZvcmUgcmV0cnlpbmcgKi9cblx0XHRcdFx0dGhpcy5ub3RpZnlTdGF0ZSgnc3VzcGVuZGVkJywgZXJyKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMucmVxdWVzdFN0YXRlKCdhdHRhY2hpbmcnLCBlcnIpO1xuXHRcdFx0fVxuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlIGFjdGlvbnMuU1lOQzpcblx0XHRcdC8qIHN5bmNzIGNhbiBoYXZlIGNoYW5uZWxTZXJpYWxzLCBidXQgbWlnaHQgbm90IGlmIHRoZSBzeW5jIGlzIG9uZSBwYWdlIGxvbmcgKi9cblx0XHRcdGlzU3luYyA9IHRydWU7XG5cdFx0XHRzeW5jQ2hhbm5lbFNlcmlhbCA9IHRoaXMuc3luY0NoYW5uZWxTZXJpYWwgPSBtZXNzYWdlLmNoYW5uZWxTZXJpYWw7XG5cdFx0XHQvKiBzeW5jcyBjYW4gaGFwcGVuIG9uIGNoYW5uZWxzIHdpdGggbm8gcHJlc2VuY2UgZGF0YSBhcyBwYXJ0IG9mIGNvbm5lY3Rpb25cblx0XHRcdCAqIHJlc3VtaW5nLCBpbiB3aGljaCBjYXNlIHByb3RvY29sIG1lc3NhZ2UgaGFzIG5vIHByZXNlbmNlIHByb3BlcnR5ICovXG5cdFx0XHRpZighbWVzc2FnZS5wcmVzZW5jZSkgYnJlYWs7XG5cdFx0Y2FzZSBhY3Rpb25zLlBSRVNFTkNFOlxuXHRcdFx0dmFyIHByZXNlbmNlID0gbWVzc2FnZS5wcmVzZW5jZSxcblx0XHRcdFx0aWQgPSBtZXNzYWdlLmlkLFxuXHRcdFx0XHRjb25uZWN0aW9uSWQgPSBtZXNzYWdlLmNvbm5lY3Rpb25JZCxcblx0XHRcdFx0dGltZXN0YW1wID0gbWVzc2FnZS50aW1lc3RhbXA7XG5cblx0XHRcdHZhciBvcHRpb25zID0gdGhpcy5jaGFubmVsT3B0aW9ucztcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBwcmVzZW5jZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHZhciBwcmVzZW5jZU1zZyA9IHByZXNlbmNlW2ldO1xuXHRcdFx0XHRcdFByZXNlbmNlTWVzc2FnZS5kZWNvZGUocHJlc2VuY2VNc2csIG9wdGlvbnMpO1xuXHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX0VSUk9SLCAnUmVhbHRpbWVDaGFubmVsLm9uTWVzc2FnZSgpJywgZS50b1N0cmluZygpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZighcHJlc2VuY2VNc2cuY29ubmVjdGlvbklkKSBwcmVzZW5jZU1zZy5jb25uZWN0aW9uSWQgPSBjb25uZWN0aW9uSWQ7XG5cdFx0XHRcdGlmKCFwcmVzZW5jZU1zZy50aW1lc3RhbXApIHByZXNlbmNlTXNnLnRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcblx0XHRcdFx0aWYoIXByZXNlbmNlTXNnLmlkKSBwcmVzZW5jZU1zZy5pZCA9IGlkICsgJzonICsgaTtcblx0XHRcdH1cblx0XHRcdHRoaXMucHJlc2VuY2Uuc2V0UHJlc2VuY2UocHJlc2VuY2UsIGlzU3luYywgc3luY0NoYW5uZWxTZXJpYWwpO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlIGFjdGlvbnMuTUVTU0FHRTpcblx0XHRcdHZhciBtZXNzYWdlcyA9IG1lc3NhZ2UubWVzc2FnZXMsXG5cdFx0XHRcdGlkID0gbWVzc2FnZS5pZCxcblx0XHRcdFx0Y29ubmVjdGlvbklkID0gbWVzc2FnZS5jb25uZWN0aW9uSWQsXG5cdFx0XHRcdHRpbWVzdGFtcCA9IG1lc3NhZ2UudGltZXN0YW1wO1xuXG5cdFx0XHR2YXIgb3B0aW9ucyA9IHRoaXMuY2hhbm5lbE9wdGlvbnM7XG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbWVzc2FnZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHR2YXIgbXNnID0gbWVzc2FnZXNbaV07XG5cdFx0XHRcdFx0TWVzc2FnZS5kZWNvZGUobXNnLCBvcHRpb25zKTtcblx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRcdC8qIGRlY3J5cHQgZmFpbGVkIC4uIHRoZSBtb3N0IGxpa2VseSBjYXVzZSBpcyB0aGF0IHdlIGhhdmUgdGhlIHdyb25nIGtleSAqL1xuXHRcdFx0XHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19FUlJPUiwgJ1JlYWx0aW1lQ2hhbm5lbC5vbk1lc3NhZ2UoKScsIGUudG9TdHJpbmcoKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoIW1zZy5jb25uZWN0aW9uSWQpIG1zZy5jb25uZWN0aW9uSWQgPSBjb25uZWN0aW9uSWQ7XG5cdFx0XHRcdGlmKCFtc2cudGltZXN0YW1wKSBtc2cudGltZXN0YW1wID0gdGltZXN0YW1wO1xuXHRcdFx0XHRpZighbXNnLmlkKSBtc2cuaWQgPSBpZCArICc6JyArIGk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLm9uRXZlbnQobWVzc2FnZXMpO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlIGFjdGlvbnMuRVJST1I6XG5cdFx0XHQvKiB0aGVyZSB3YXMgYSBjaGFubmVsLXNwZWNpZmljIGVycm9yICovXG5cdFx0XHR2YXIgZXJyID0gbWVzc2FnZS5lcnJvcjtcblx0XHRcdGlmKGVyciAmJiBlcnIuY29kZSA9PSA4MDAxNikge1xuXHRcdFx0XHQvKiBhdHRhY2gvZGV0YWNoIG9wZXJhdGlvbiBhdHRlbXB0ZWQgb24gc3VwZXJzZWRlZCB0cmFuc3BvcnQgaGFuZGxlICovXG5cdFx0XHRcdHRoaXMuY2hlY2tQZW5kaW5nU3RhdGUoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMubm90aWZ5U3RhdGUoJ2ZhaWxlZCcsIEVycm9ySW5mby5mcm9tVmFsdWVzKGVycikpO1xuXHRcdFx0fVxuXHRcdFx0YnJlYWs7XG5cblx0XHRkZWZhdWx0OlxuXHRcdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX0VSUk9SLCAnUmVhbHRpbWVDaGFubmVsLm9uTWVzc2FnZSgpJywgJ0ZhdGFsIHByb3RvY29sIGVycm9yOiB1bnJlY29nbmlzZWQgYWN0aW9uICgnICsgbWVzc2FnZS5hY3Rpb24gKyAnKScpO1xuXHRcdFx0dGhpcy5jb25uZWN0aW9uTWFuYWdlci5hYm9ydChDb25uZWN0aW9uRXJyb3IudW5rbm93bkNoYW5uZWxFcnIpO1xuXHRcdH1cblx0fTtcblxuXHRSZWFsdGltZUNoYW5uZWwubWVyZ2VUbyA9IGZ1bmN0aW9uKGRlc3QsIHNyYykge1xuXHRcdHZhciByZXN1bHQgPSBmYWxzZTtcblx0XHR2YXIgYWN0aW9uO1xuXHRcdGlmKGRlc3QuY2hhbm5lbCA9PSBzcmMuY2hhbm5lbCkge1xuXHRcdFx0aWYoKGFjdGlvbiA9IGRlc3QuYWN0aW9uKSA9PSBzcmMuYWN0aW9uKSB7XG5cdFx0XHRcdHN3aXRjaChhY3Rpb24pIHtcblx0XHRcdFx0Y2FzZSBhY3Rpb25zLk1FU1NBR0U6XG5cdFx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IHNyYy5tZXNzYWdlcy5sZW5ndGg7IGkrKylcblx0XHRcdFx0XHRcdGRlc3QubWVzc2FnZXMucHVzaChzcmMubWVzc2FnZXNbaV0pO1xuXHRcdFx0XHRcdHJlc3VsdCA9IHRydWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgYWN0aW9ucy5QUkVTRU5DRTpcblx0XHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgc3JjLnByZXNlbmNlLmxlbmd0aDsgaSsrKVxuXHRcdFx0XHRcdFx0ZGVzdC5wcmVzZW5jZS5wdXNoKHNyYy5wcmVzZW5jZVtpXSk7XG5cdFx0XHRcdFx0cmVzdWx0ID0gdHJ1ZTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUub25BdHRhY2hlZCA9IGZ1bmN0aW9uKCkge1xuXHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSU5PUiwgJ1JlYWx0aW1lQ2hhbm5lbC5vbkF0dGFjaGVkJywgJ2FjdGl2YXRpbmcgY2hhbm5lbDsgbmFtZSA9ICcgKyB0aGlzLm5hbWUpO1xuXG5cdFx0dmFyIHBlbmRpbmdFdmVudHMgPSB0aGlzLnBlbmRpbmdFdmVudHMsIHBlbmRpbmdDb3VudCA9IHBlbmRpbmdFdmVudHMubGVuZ3RoO1xuXHRcdGlmKHBlbmRpbmdDb3VudCkge1xuXHRcdFx0dGhpcy5wZW5kaW5nRXZlbnRzID0gW107XG5cdFx0XHR2YXIgbXNnID0gUHJvdG9jb2xNZXNzYWdlLmZyb21WYWx1ZXMoe2FjdGlvbjogYWN0aW9ucy5NRVNTQUdFLCBjaGFubmVsOiB0aGlzLm5hbWUsIG1lc3NhZ2VzOiBbXX0pO1xuXHRcdFx0dmFyIG11bHRpY2FzdGVyID0gTXVsdGljYXN0ZXIoKTtcblx0XHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSUNSTywgJ1JlYWx0aW1lQ2hhbm5lbC5zZXRBdHRhY2hlZCcsICdzZW5kaW5nICcgKyBwZW5kaW5nQ291bnQgKyAnIHF1ZXVlZCBtZXNzYWdlcycpO1xuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IHBlbmRpbmdDb3VudDsgaSsrKSB7XG5cdFx0XHRcdHZhciBldmVudCA9IHBlbmRpbmdFdmVudHNbaV07XG5cdFx0XHRcdEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KG1zZy5tZXNzYWdlcywgZXZlbnQubWVzc2FnZXMpO1xuXHRcdFx0XHRtdWx0aWNhc3Rlci5wdXNoKGV2ZW50LmNhbGxiYWNrKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuc2VuZE1lc3NhZ2UobXNnLCBtdWx0aWNhc3Rlcik7XG5cdFx0fVxuXHR9O1xuXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUubm90aWZ5U3RhdGUgPSBmdW5jdGlvbihzdGF0ZSwgcmVhc29uLCByZXN1bWVkLCBoYXNQcmVzZW5jZSkge1xuXHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSUNSTywgJ1JlYWx0aW1lQ2hhbm5lbC5ub3RpZnlTdGF0ZScsICduYW1lID0gJyArIHRoaXMubmFtZSArICcsIGN1cnJlbnQgc3RhdGUgPSAnICsgdGhpcy5zdGF0ZSArICcsIG5vdGlmeWluZyBzdGF0ZSAnICsgc3RhdGUpO1xuXHRcdHRoaXMuY2xlYXJTdGF0ZVRpbWVyKCk7XG5cblx0XHRpZihzdGF0ZSA9PT0gdGhpcy5zdGF0ZSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLnByZXNlbmNlLmFjdE9uQ2hhbm5lbFN0YXRlKHN0YXRlLCBoYXNQcmVzZW5jZSwgcmVhc29uKTtcblx0XHRpZihzdGF0ZSAhPT0gJ2F0dGFjaGVkJyAmJiBzdGF0ZSAhPT0gJ2F0dGFjaGluZycpIHtcblx0XHRcdHRoaXMuZmFpbFBlbmRpbmdNZXNzYWdlcyhyZWFzb24gfHwgUmVhbHRpbWVDaGFubmVsLmludmFsaWRTdGF0ZUVycm9yKHN0YXRlKSk7XG5cdFx0fVxuXHRcdGlmKHN0YXRlID09PSAnc3VzcGVuZGVkJyAmJiB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnN0YXRlLnNlbmRFdmVudHMpIHtcblx0XHRcdHRoaXMuc3RhcnRSZXRyeVRpbWVyKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuY2FuY2VsUmV0cnlUaW1lcigpO1xuXHRcdH1cblx0XHRpZihyZWFzb24pIHtcblx0XHRcdHRoaXMuZXJyb3JSZWFzb24gPSByZWFzb247XG5cdFx0fVxuXHRcdHZhciBjaGFuZ2UgPSBuZXcgQ2hhbm5lbFN0YXRlQ2hhbmdlKHRoaXMuc3RhdGUsIHN0YXRlLCByZXN1bWVkLCByZWFzb24pO1xuXHRcdHZhciBsb2dMZXZlbCA9IHN0YXRlID09PSAnZmFpbGVkJyA/IExvZ2dlci5MT0dfRVJST1IgOiBMb2dnZXIuTE9HX01BSk9SO1xuXHRcdExvZ2dlci5sb2dBY3Rpb24obG9nTGV2ZWwsICdDaGFubmVsIHN0YXRlIGZvciBjaGFubmVsIFwiJyArIHRoaXMubmFtZSArICdcIicsIHN0YXRlICsgKHJlYXNvbiA/ICgnOyByZWFzb246ICcgKyByZWFzb24udG9TdHJpbmcoKSkgOiAnJykpO1xuXG5cdFx0LyogTm90ZTogd2UgZG9uJ3Qgc2V0IGluUHJvZ3Jlc3MgZm9yIHBlbmRpbmcgc3RhdGVzIHVudGlsIHRoZSByZXF1ZXN0IGlzIGFjdHVhbGx5IGluIHByb2dyZXNzICovXG5cdFx0aWYoc3RhdGUgPT09ICdhdHRhY2hlZCcpIHtcblx0XHRcdHRoaXMub25BdHRhY2hlZCgpO1xuXHRcdFx0dGhpcy5zZXRJblByb2dyZXNzKHN5bmNPcCwgaGFzUHJlc2VuY2UpO1xuXHRcdFx0dGhpcy5zZXRJblByb2dyZXNzKHN0YXRlY2hhbmdlT3AsIGZhbHNlKTtcblx0XHR9IGVsc2UgaWYoc3RhdGUgPT09ICdkZXRhY2hlZCcgfHwgc3RhdGUgPT09ICdmYWlsZWQnIHx8IHN0YXRlID09PSAnc3VzcGVuZGVkJykge1xuXHRcdFx0dGhpcy5zZXRJblByb2dyZXNzKHN0YXRlY2hhbmdlT3AsIGZhbHNlKTtcblx0XHRcdHRoaXMuc2V0SW5Qcm9ncmVzcyhzeW5jT3AsIGZhbHNlKTtcblx0XHR9XG5cblx0XHR0aGlzLnN0YXRlID0gc3RhdGU7XG5cdFx0dGhpcy5lbWl0KHN0YXRlLCBjaGFuZ2UpO1xuXHR9O1xuXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUucmVxdWVzdFN0YXRlID0gZnVuY3Rpb24oc3RhdGUsIHJlYXNvbikge1xuXHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSU5PUiwgJ1JlYWx0aW1lQ2hhbm5lbC5yZXF1ZXN0U3RhdGUnLCAnbmFtZSA9ICcgKyB0aGlzLm5hbWUgKyAnLCBzdGF0ZSA9ICcgKyBzdGF0ZSk7XG5cdFx0dGhpcy5ub3RpZnlTdGF0ZShzdGF0ZSwgcmVhc29uKTtcblx0XHQvKiBzZW5kIHRoZSBldmVudCBhbmQgYXdhaXQgcmVzcG9uc2UgKi9cblx0XHR0aGlzLmNoZWNrUGVuZGluZ1N0YXRlKCk7XG5cdH07XG5cblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5jaGVja1BlbmRpbmdTdGF0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdC8qIGlmIGNhbid0IHNlbmQgZXZlbnRzLCBkbyBub3RoaW5nICovXG5cdFx0dmFyIGNtU3RhdGUgPSB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnN0YXRlO1xuXHRcdC8qIEFsbG93IGF0dGFjaCBtZXNzYWdlcyB0byBxdWV1ZSB1cCB3aGVuIHN5bmNocm9uaXppbmcsIHNpbmNlIHRoaXMgd2lsbCBiZVxuXHRcdCAqIHRoZSBzdGF0ZSB3ZSdsbCBiZSBpbiB3aGVuIHVwZ3JhZGUgdHJhbnNwb3J0LmFjdGl2ZSB0cmlnZ2VycyBhIGNoZWNrcGVuZGluZ3N0YXRlICovXG5cdFx0aWYoIShjbVN0YXRlLnNlbmRFdmVudHMgfHwgY21TdGF0ZS5mb3JjZVF1ZXVlRXZlbnRzKSkge1xuXHRcdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX01JTk9SLCAnUmVhbHRpbWVDaGFubmVsLmNoZWNrUGVuZGluZ1N0YXRlJywgJ3NlbmRFdmVudHMgaXMgZmFsc2U7IHN0YXRlIGlzICcgKyB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnN0YXRlLnN0YXRlKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlOT1IsICdSZWFsdGltZUNoYW5uZWwuY2hlY2tQZW5kaW5nU3RhdGUnLCAnbmFtZSA9ICcgKyB0aGlzLm5hbWUgKyAnLCBzdGF0ZSA9ICcgKyB0aGlzLnN0YXRlKTtcblx0XHQvKiBPbmx5IHN0YXJ0IHRoZSBzdGF0ZSB0aW1lciBydW5uaW5nIHdoZW4gYWN0dWFsbHkgc2VuZGluZyB0aGUgZXZlbnQgKi9cblx0XHRzd2l0Y2godGhpcy5zdGF0ZSkge1xuXHRcdFx0Y2FzZSAnYXR0YWNoaW5nJzpcblx0XHRcdFx0dGhpcy5zdGFydFN0YXRlVGltZXJJZk5vdFJ1bm5pbmcoKTtcblx0XHRcdFx0dGhpcy5hdHRhY2hJbXBsKCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnZGV0YWNoaW5nJzpcblx0XHRcdFx0dGhpcy5zdGFydFN0YXRlVGltZXJJZk5vdFJ1bm5pbmcoKTtcblx0XHRcdFx0dGhpcy5kZXRhY2hJbXBsKCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnYXR0YWNoZWQnOlxuXHRcdFx0XHQvKiByZXN1bWUgYW55IHN5bmMgb3BlcmF0aW9uIHRoYXQgd2FzIGluIHByb2dyZXNzICovXG5cdFx0XHRcdHRoaXMuc3luYygpO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9O1xuXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUudGltZW91dFBlbmRpbmdTdGF0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHN3aXRjaCh0aGlzLnN0YXRlKSB7XG5cdFx0XHRjYXNlICdhdHRhY2hpbmcnOlxuXHRcdFx0XHR2YXIgZXJyID0gbmV3IEVycm9ySW5mbygnQ2hhbm5lbCBhdHRhY2ggdGltZWQgb3V0JywgOTAwMDcsIDQwOCk7XG5cdFx0XHRcdHRoaXMubm90aWZ5U3RhdGUoJ3N1c3BlbmRlZCcsIGVycik7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnZGV0YWNoaW5nJzpcblx0XHRcdFx0dmFyIGVyciA9IG5ldyBFcnJvckluZm8oJ0NoYW5uZWwgZGV0YWNoIHRpbWVkIG91dCcsIDkwMDA3LCA0MDgpO1xuXHRcdFx0XHR0aGlzLm5vdGlmeVN0YXRlKCdhdHRhY2hlZCcsIGVycik7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0dGhpcy5jaGVja1BlbmRpbmdTdGF0ZSgpO1xuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cdH07XG5cblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5zdGFydFN0YXRlVGltZXJJZk5vdFJ1bm5pbmcgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0aWYoIXRoaXMuc3RhdGVUaW1lcikge1xuXHRcdFx0dGhpcy5zdGF0ZVRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX01JTk9SLCAnUmVhbHRpbWVDaGFubmVsLnN0YXJ0U3RhdGVUaW1lcklmTm90UnVubmluZycsICd0aW1lciBleHBpcmVkJyk7XG5cdFx0XHRcdHNlbGYuc3RhdGVUaW1lciA9IG51bGw7XG5cdFx0XHRcdHNlbGYudGltZW91dFBlbmRpbmdTdGF0ZSgpO1xuXHRcdFx0fSwgdGhpcy5yZWFsdGltZS5vcHRpb25zLnRpbWVvdXRzLnJlYWx0aW1lUmVxdWVzdFRpbWVvdXQpO1xuXHRcdH1cblx0fTtcblxuXHRSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLmNsZWFyU3RhdGVUaW1lciA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzdGF0ZVRpbWVyID0gdGhpcy5zdGF0ZVRpbWVyO1xuXHRcdGlmKHN0YXRlVGltZXIpIHtcblx0XHRcdGNsZWFyVGltZW91dChzdGF0ZVRpbWVyKTtcblx0XHRcdHRoaXMuc3RhdGVUaW1lciA9IG51bGw7XG5cdFx0fVxuXHR9O1xuXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuc3RhcnRSZXRyeVRpbWVyID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdGlmKHRoaXMucmV0cnlUaW1lcikgcmV0dXJuO1xuXG5cdFx0dGhpcy5yZXRyeVRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdC8qIElmIGNvbm5lY3Rpb24gaXMgbm90IGNvbm5lY3RlZCwganVzdCBsZWF2ZSBpbiBzdXNwZW5kZWQsIGEgcmVhdHRhY2hcblx0XHRcdCAqIHdpbGwgYmUgdHJpZ2dlcmVkIG9uY2UgaXQgY29ubmVjdHMgYWdhaW4gKi9cblx0XHRcdGlmKHNlbGYuc3RhdGUgPT09ICdzdXNwZW5kZWQnICYmIHNlbGYuY29ubmVjdGlvbk1hbmFnZXIuc3RhdGUuc2VuZEV2ZW50cykge1xuXHRcdFx0XHRzZWxmLnJldHJ5VGltZXIgPSBudWxsO1xuXHRcdFx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlOT1IsICdSZWFsdGltZUNoYW5uZWwgcmV0cnkgdGltZXIgZXhwaXJlZCcsICdhdHRlbXB0aW5nIGEgbmV3IGF0dGFjaCcpO1xuXHRcdFx0XHRzZWxmLnJlcXVlc3RTdGF0ZSgnYXR0YWNoaW5nJyk7XG5cdFx0XHR9XG5cdFx0fSwgdGhpcy5yZWFsdGltZS5vcHRpb25zLnRpbWVvdXRzLmNoYW5uZWxSZXRyeVRpbWVvdXQpO1xuXHR9O1xuXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuY2FuY2VsUmV0cnlUaW1lciA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmKHRoaXMucmV0cnlUaW1lcikge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMucmV0cnlUaW1lcik7XG5cdFx0XHR0aGlzLnN1c3BlbmRUaW1lciA9IG51bGw7XG5cdFx0fVxuXHR9O1xuXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuc2V0SW5Qcm9ncmVzcyA9IGZ1bmN0aW9uKG9wZXJhdGlvbiwgdmFsdWUpIHtcblx0XHR0aGlzLnJlc3QuY2hhbm5lbHMuc2V0SW5Qcm9ncmVzcyh0aGlzLCBvcGVyYXRpb24sIHZhbHVlKTtcblx0fTtcblxuXHRSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLmZhaWxQZW5kaW5nTWVzc2FnZXMgPSBmdW5jdGlvbihlcnIpIHtcblx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlOT1IsICdSZWFsdGltZUNoYW5uZWwuZmFpbFBlbmRpbmdNZXNzYWdlcycsICdjaGFubmVsOyBuYW1lID0gJyArIHRoaXMubmFtZSArICcsIGVyciA9ICcgKyBVdGlscy5pbnNwZWN0RXJyb3IoZXJyKSk7XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMucGVuZGluZ0V2ZW50cy5sZW5ndGg7IGkrKylcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHRoaXMucGVuZGluZ0V2ZW50c1tpXS5jYWxsYmFjayhlcnIpO1xuXHRcdFx0fSBjYXRjaChlKSB7fVxuXHRcdHRoaXMucGVuZGluZ0V2ZW50cyA9IFtdO1xuXHR9O1xuXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuaGlzdG9yeSA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcblx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlDUk8sICdSZWFsdGltZUNoYW5uZWwuaGlzdG9yeSgpJywgJ2NoYW5uZWwgPSAnICsgdGhpcy5uYW1lKTtcblx0XHQvKiBwYXJhbXMgYW5kIGNhbGxiYWNrIGFyZSBvcHRpb25hbDsgc2VlIGlmIHBhcmFtcyBjb250YWlucyB0aGUgY2FsbGJhY2sgKi9cblx0XHRpZihjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRpZih0eXBlb2YocGFyYW1zKSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdGNhbGxiYWNrID0gcGFyYW1zO1xuXHRcdFx0XHRwYXJhbXMgPSBudWxsO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2FsbGJhY2sgPSBub29wO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmKHBhcmFtcyAmJiBwYXJhbXMudW50aWxBdHRhY2gpIHtcblx0XHRcdGlmKHRoaXMuc3RhdGUgIT09ICdhdHRhY2hlZCcpIHtcblx0XHRcdFx0Y2FsbGJhY2sobmV3IEVycm9ySW5mbyhcIm9wdGlvbiB1bnRpbEF0dGFjaCByZXF1aXJlcyB0aGUgY2hhbm5lbCB0byBiZSBhdHRhY2hlZFwiLCA0MDAwMCwgNDAwKSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGlmKCF0aGlzLmF0dGFjaFNlcmlhbCkge1xuXHRcdFx0XHRjYWxsYmFjayhuZXcgRXJyb3JJbmZvKFwidW50aWxBdHRhY2ggd2FzIHNwZWNpZmllZCBhbmQgY2hhbm5lbCBpcyBhdHRhY2hlZCwgYnV0IGF0dGFjaFNlcmlhbCBpcyBub3QgZGVmaW5lZFwiLCA0MDAwMCwgNDAwKSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGRlbGV0ZSBwYXJhbXMudW50aWxBdHRhY2g7XG5cdFx0XHRwYXJhbXMuZnJvbV9zZXJpYWwgPSB0aGlzLmF0dGFjaFNlcmlhbDtcblx0XHR9XG5cblx0XHRDaGFubmVsLnByb3RvdHlwZS5faGlzdG9yeS5jYWxsKHRoaXMsIHBhcmFtcywgY2FsbGJhY2spO1xuXHR9O1xuXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUud2hlblN0YXRlID0gZnVuY3Rpb24oc3RhdGUsIGxpc3RlbmVyKSB7XG5cdFx0RXZlbnRFbWl0dGVyLnByb3RvdHlwZS53aGVuU3RhdGUuY2FsbCh0aGlzLCBzdGF0ZSwgdGhpcy5zdGF0ZSwgbGlzdGVuZXIpO1xuXHR9XG5cblx0cmV0dXJuIFJlYWx0aW1lQ2hhbm5lbDtcbn0pKCk7XG5cbnZhciBSZWFsdGltZVByZXNlbmNlID0gKGZ1bmN0aW9uKCkge1xuXHR2YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XG5cblx0ZnVuY3Rpb24gbWVtYmVyS2V5KGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbS5jbGllbnRJZCArICc6JyArIGl0ZW0uY29ubmVjdGlvbklkO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0Q2xpZW50SWQocmVhbHRpbWVQcmVzZW5jZSkge1xuXHRcdHJldHVybiByZWFsdGltZVByZXNlbmNlLmNoYW5uZWwucmVhbHRpbWUuYXV0aC5jbGllbnRJZDtcblx0fVxuXG5cdGZ1bmN0aW9uIGlzQW5vbnltb3VzKHJlYWx0aW1lUHJlc2VuY2UpIHtcblx0XHR2YXIgcmVhbHRpbWUgPSByZWFsdGltZVByZXNlbmNlLmNoYW5uZWwucmVhbHRpbWU7XG5cdFx0LyogSWYgbm90IGN1cnJlbnRseSBjb25uZWN0ZWQsIHdlIGNhbid0IGFzc3VtZSB0aGF0IHdlJ3JlIGFuIGFub255bW91c1xuXHRcdCAqIGNsaWVudCwgYXMgcmVhbHRpbWUgbWF5IGluZm9ybSB1cyBvZiBvdXIgY2xpZW50SWQgaW4gdGhlIENPTk5FQ1RFRFxuXHRcdCAqIG1lc3NhZ2UuIFNvIGFzc3VtZSB3ZSdyZSBub3QgYW5vbnltb3VzIGFuZCBsZWF2ZSBpdCB0byByZWFsdGltZSB0b1xuXHRcdCAqIHJldHVybiBhbiBlcnJvciBpZiB3ZSBhcmUgKi9cblx0XHRyZXR1cm4gIXJlYWx0aW1lLmF1dGguY2xpZW50SWQgJiYgcmVhbHRpbWUuY29ubmVjdGlvbi5zdGF0ZSA9PT0gJ2Nvbm5lY3RlZCc7XG5cdH1cblxuXHRmdW5jdGlvbiB3YWl0QXR0YWNoZWQoY2hhbm5lbCwgY2FsbGJhY2ssIGFjdGlvbikge1xuXHRcdHN3aXRjaChjaGFubmVsLnN0YXRlKSB7XG5cdFx0XHRjYXNlICdhdHRhY2hlZCc6XG5cdFx0XHRjYXNlICdzdXNwZW5kZWQnOlxuXHRcdFx0XHRhY3Rpb24oKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdpbml0aWFsaXplZCc6XG5cdFx0XHRjYXNlICdkZXRhY2hlZCc6XG5cdFx0XHRjYXNlICdkZXRhY2hpbmcnOlxuXHRcdFx0Y2FzZSAnYXR0YWNoaW5nJzpcblx0XHRcdFx0Y2hhbm5lbC5hdHRhY2goZnVuY3Rpb24oZXJyKSB7XG5cdFx0XHRcdFx0aWYoZXJyKSBjYWxsYmFjayhlcnIpO1xuXHRcdFx0XHRcdGVsc2UgYWN0aW9uKCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdGNhbGxiYWNrKEVycm9ySW5mby5mcm9tVmFsdWVzKFJlYWx0aW1lQ2hhbm5lbC5pbnZhbGlkU3RhdGVFcnJvcihjaGFubmVsLnN0YXRlKSkpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIFJlYWx0aW1lUHJlc2VuY2UoY2hhbm5lbCwgb3B0aW9ucykge1xuXHRcdFByZXNlbmNlLmNhbGwodGhpcywgY2hhbm5lbCk7XG5cdFx0dGhpcy5tZW1iZXJzID0gbmV3IFByZXNlbmNlTWFwKHRoaXMpO1xuXHRcdHRoaXMuX215TWVtYmVycyA9IG5ldyBQcmVzZW5jZU1hcCh0aGlzKTtcblx0XHR0aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cdFx0dGhpcy5wZW5kaW5nUHJlc2VuY2UgPSBbXTtcblx0fVxuXHRVdGlscy5pbmhlcml0cyhSZWFsdGltZVByZXNlbmNlLCBQcmVzZW5jZSk7XG5cblx0UmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUuZW50ZXIgPSBmdW5jdGlvbihkYXRhLCBjYWxsYmFjaykge1xuXHRcdGlmKGlzQW5vbnltb3VzKHRoaXMpKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9ySW5mbygnY2xpZW50SWQgbXVzdCBiZSBzcGVjaWZpZWQgdG8gZW50ZXIgYSBwcmVzZW5jZSBjaGFubmVsJywgNDAwMTIsIDQwMCk7XG5cdFx0dGhpcy5fZW50ZXJPclVwZGF0ZUNsaWVudCh1bmRlZmluZWQsIGRhdGEsIGNhbGxiYWNrLCAnZW50ZXInKTtcblx0fTtcblxuXHRSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihkYXRhLCBjYWxsYmFjaykge1xuXHRcdGlmKGlzQW5vbnltb3VzKHRoaXMpKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9ySW5mbygnY2xpZW50SWQgbXVzdCBiZSBzcGVjaWZpZWQgdG8gdXBkYXRlIHByZXNlbmNlIGRhdGEnLCA0MDAxMiwgNDAwKTtcblx0XHR0aGlzLl9lbnRlck9yVXBkYXRlQ2xpZW50KHVuZGVmaW5lZCwgZGF0YSwgY2FsbGJhY2ssICd1cGRhdGUnKTtcblx0fTtcblxuXHRSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS5lbnRlckNsaWVudCA9IGZ1bmN0aW9uKGNsaWVudElkLCBkYXRhLCBjYWxsYmFjaykge1xuXHRcdHRoaXMuX2VudGVyT3JVcGRhdGVDbGllbnQoY2xpZW50SWQsIGRhdGEsIGNhbGxiYWNrLCAnZW50ZXInKTtcblx0fTtcblxuXHRSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS51cGRhdGVDbGllbnQgPSBmdW5jdGlvbihjbGllbnRJZCwgZGF0YSwgY2FsbGJhY2spIHtcblx0XHR0aGlzLl9lbnRlck9yVXBkYXRlQ2xpZW50KGNsaWVudElkLCBkYXRhLCBjYWxsYmFjaywgJ3VwZGF0ZScpO1xuXHR9O1xuXG5cdFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLl9lbnRlck9yVXBkYXRlQ2xpZW50ID0gZnVuY3Rpb24oY2xpZW50SWQsIGRhdGEsIGNhbGxiYWNrLCBhY3Rpb24pIHtcblx0XHRpZiAoIWNhbGxiYWNrKSB7XG5cdFx0XHRpZiAodHlwZW9mKGRhdGEpPT09J2Z1bmN0aW9uJykge1xuXHRcdFx0XHRjYWxsYmFjayA9IGRhdGE7XG5cdFx0XHRcdGRhdGEgPSBudWxsO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2FsbGJhY2sgPSBub29wO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBjaGFubmVsID0gdGhpcy5jaGFubmVsO1xuXHRcdGlmKCFjaGFubmVsLmNvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2ZVN0YXRlKCkpIHtcblx0XHRcdGNhbGxiYWNrKGNoYW5uZWwuY29ubmVjdGlvbk1hbmFnZXIuZ2V0U3RhdGVFcnJvcigpKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlDUk8sICdSZWFsdGltZVByZXNlbmNlLicgKyBhY3Rpb24gKyAnQ2xpZW50KCknLFxuXHRcdCAgYWN0aW9uICsgJ2luZzsgY2hhbm5lbCA9ICcgKyBjaGFubmVsLm5hbWUgKyAnLCBjbGllbnQgPSAnICsgY2xpZW50SWQgfHwgJyhpbXBsaWNpdCkgJyArIGdldENsaWVudElkKHRoaXMpKTtcblxuXHRcdHZhciBwcmVzZW5jZSA9IFByZXNlbmNlTWVzc2FnZS5mcm9tVmFsdWVzKHtcblx0XHRcdGFjdGlvbiA6IGFjdGlvbixcblx0XHRcdGRhdGEgICA6IGRhdGFcblx0XHR9KTtcblx0XHRpZiAoY2xpZW50SWQpIHsgcHJlc2VuY2UuY2xpZW50SWQgPSBjbGllbnRJZDsgfVxuXG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFByZXNlbmNlTWVzc2FnZS5lbmNvZGUocHJlc2VuY2UsIGNoYW5uZWwuY2hhbm5lbE9wdGlvbnMsIGZ1bmN0aW9uKGVycikge1xuXHRcdFx0aWYgKGVycikge1xuXHRcdFx0XHRjYWxsYmFjayhlcnIpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRzd2l0Y2goY2hhbm5lbC5zdGF0ZSkge1xuXHRcdFx0XHRjYXNlICdhdHRhY2hlZCc6XG5cdFx0XHRcdFx0Y2hhbm5lbC5zZW5kUHJlc2VuY2UocHJlc2VuY2UsIGNhbGxiYWNrKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnaW5pdGlhbGl6ZWQnOlxuXHRcdFx0XHRjYXNlICdkZXRhY2hlZCc6XG5cdFx0XHRcdFx0Y2hhbm5lbC5hdXRvbm9tb3VzQXR0YWNoKCk7XG5cdFx0XHRcdGNhc2UgJ2F0dGFjaGluZyc6XG5cdFx0XHRcdFx0c2VsZi5wZW5kaW5nUHJlc2VuY2UucHVzaCh7XG5cdFx0XHRcdFx0XHRwcmVzZW5jZSA6IHByZXNlbmNlLFxuXHRcdFx0XHRcdFx0Y2FsbGJhY2sgOiBjYWxsYmFja1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHZhciBlcnIgPSBuZXcgRXJyb3JJbmZvKCdVbmFibGUgdG8gJyArIGFjdGlvbiArICcgcHJlc2VuY2UgY2hhbm5lbCAoaW5jb21wYXRpYmxlIHN0YXRlKScsIDkwMDAxKTtcblx0XHRcdFx0XHRlcnIuY29kZSA9IDkwMDAxO1xuXHRcdFx0XHRcdGNhbGxiYWNrKGVycik7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH07XG5cblx0UmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUubGVhdmUgPSBmdW5jdGlvbihkYXRhLCBjYWxsYmFjaykge1xuXHRcdGlmKGlzQW5vbnltb3VzKHRoaXMpKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9ySW5mbygnY2xpZW50SWQgbXVzdCBoYXZlIGJlZW4gc3BlY2lmaWVkIHRvIGVudGVyIG9yIGxlYXZlIGEgcHJlc2VuY2UgY2hhbm5lbCcsIDQwMDEyLCA0MDApO1xuXHRcdHRoaXMubGVhdmVDbGllbnQodW5kZWZpbmVkLCBkYXRhLCBjYWxsYmFjayk7XG5cdH07XG5cblx0UmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUubGVhdmVDbGllbnQgPSBmdW5jdGlvbihjbGllbnRJZCwgZGF0YSwgY2FsbGJhY2spIHtcblx0XHRpZiAoIWNhbGxiYWNrKSB7XG5cdFx0XHRpZiAodHlwZW9mKGRhdGEpPT09J2Z1bmN0aW9uJykge1xuXHRcdFx0XHRjYWxsYmFjayA9IGRhdGE7XG5cdFx0XHRcdGRhdGEgPSBudWxsO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2FsbGJhY2sgPSBub29wO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBjaGFubmVsID0gdGhpcy5jaGFubmVsO1xuXHRcdGlmKCFjaGFubmVsLmNvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2ZVN0YXRlKCkpIHtcblx0XHRcdGNhbGxiYWNrKGNoYW5uZWwuY29ubmVjdGlvbk1hbmFnZXIuZ2V0U3RhdGVFcnJvcigpKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlDUk8sICdSZWFsdGltZVByZXNlbmNlLmxlYXZlQ2xpZW50KCknLCAnbGVhdmluZzsgY2hhbm5lbCA9ICcgKyB0aGlzLmNoYW5uZWwubmFtZSArICcsIGNsaWVudCA9ICcgKyBjbGllbnRJZCk7XG5cdFx0dmFyIHByZXNlbmNlID0gUHJlc2VuY2VNZXNzYWdlLmZyb21WYWx1ZXMoe1xuXHRcdFx0YWN0aW9uIDogJ2xlYXZlJyxcblx0XHRcdGRhdGEgICA6IGRhdGFcblx0XHR9KTtcblx0XHRpZiAoY2xpZW50SWQpIHsgcHJlc2VuY2UuY2xpZW50SWQgPSBjbGllbnRJZDsgfVxuXG5cdFx0c3dpdGNoKGNoYW5uZWwuc3RhdGUpIHtcblx0XHRcdGNhc2UgJ2F0dGFjaGVkJzpcblx0XHRcdFx0Y2hhbm5lbC5zZW5kUHJlc2VuY2UocHJlc2VuY2UsIGNhbGxiYWNrKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdhdHRhY2hpbmcnOlxuXHRcdFx0XHR0aGlzLnBlbmRpbmdQcmVzZW5jZS5wdXNoKHtcblx0XHRcdFx0XHRwcmVzZW5jZSA6IHByZXNlbmNlLFxuXHRcdFx0XHRcdGNhbGxiYWNrIDogY2FsbGJhY2tcblx0XHRcdFx0fSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnaW5pdGlhbGl6ZWQnOlxuXHRcdFx0Y2FzZSAnZmFpbGVkJzpcblx0XHRcdFx0Lyogd2UncmUgbm90IGF0dGFjaGVkOyB0aGVyZWZvcmUgd2UgbGV0IGFueSBlbnRlcmVkIHN0YXR1c1xuXHRcdFx0XHQgKiB0aW1lb3V0IGJ5IGl0c2VsZiBpbnN0ZWFkIG9mIGF0dGFjaGluZyBqdXN0IGluIG9yZGVyIHRvIGxlYXZlICovXG5cdFx0XHRcdHZhciBlcnIgPSBuZXcgRXJyb3JJbmZvKCdVbmFibGUgdG8gbGVhdmUgcHJlc2VuY2UgY2hhbm5lbCAoaW5jb21wYXRpYmxlIHN0YXRlKScsIDkwMDAxKTtcblx0XHRcdFx0Y2FsbGJhY2soZXJyKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHQvKiB0aGVyZSBpcyBubyBjb25uZWN0aW9uOyB0aGVyZWZvcmUgd2UgbGV0XG5cdFx0XHRcdCAqIGFueSBlbnRlcmVkIHN0YXR1cyB0aW1lb3V0IGJ5IGl0c2VsZiAqL1xuXHRcdFx0XHRjYWxsYmFjayhDb25uZWN0aW9uRXJyb3IuZmFpbGVkKTtcblx0XHR9XG5cdH07XG5cblx0UmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oLyogcGFyYW1zLCBjYWxsYmFjayAqLykge1xuXHRcdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblx0XHRpZihhcmdzLmxlbmd0aCA9PSAxICYmIHR5cGVvZihhcmdzWzBdKSA9PSAnZnVuY3Rpb24nKVxuXHRcdFx0YXJncy51bnNoaWZ0KG51bGwpO1xuXG5cdFx0dmFyIHBhcmFtcyA9IGFyZ3NbMF0sXG5cdFx0XHRjYWxsYmFjayA9IGFyZ3NbMV0gfHwgbm9vcCxcblx0XHRcdHdhaXRGb3JTeW5jID0gIXBhcmFtcyB8fCAoJ3dhaXRGb3JTeW5jJyBpbiBwYXJhbXMgPyBwYXJhbXMud2FpdEZvclN5bmMgOiB0cnVlKVxuXG5cdFx0ZnVuY3Rpb24gcmV0dXJuTWVtYmVycyhtZW1iZXJzKSB7XG5cdFx0XHRjYWxsYmFjayhudWxsLCBwYXJhbXMgPyBtZW1iZXJzLmxpc3QocGFyYW1zKSA6IG1lbWJlcnMudmFsdWVzKCkpO1xuXHRcdH1cblxuXHRcdC8qIFNwZWNpYWwtY2FzZSB0aGUgc3VzcGVuZGVkIHN0YXRlOiBjYW4gc3RpbGwgZ2V0IChzdGFsZSkgcHJlc2VuY2Ugc2V0IGlmIHdhaXRGb3JTeW5jIGlzIGZhbHNlICovXG5cdFx0aWYodGhpcy5jaGFubmVsLnN0YXRlID09PSAnc3VzcGVuZGVkJykge1xuXHRcdFx0aWYod2FpdEZvclN5bmMpIHtcblx0XHRcdFx0Y2FsbGJhY2soRXJyb3JJbmZvLmZyb21WYWx1ZXMoe1xuXHRcdFx0XHRcdHN0YXR1c0NvZGU6IDQwMCxcblx0XHRcdFx0XHRjb2RlOiA5MTAwNSxcblx0XHRcdFx0XHRtZXNzYWdlOiAnUHJlc2VuY2Ugc3RhdGUgaXMgb3V0IG9mIHN5bmMgZHVlIHRvIGNoYW5uZWwgYmVpbmcgaW4gdGhlIFNVU1BFTkRFRCBzdGF0ZSdcblx0XHRcdFx0fSkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuTWVtYmVycyh0aGlzLm1lbWJlcnMpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHR3YWl0QXR0YWNoZWQodGhpcy5jaGFubmVsLCBjYWxsYmFjaywgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWVtYmVycyA9IHNlbGYubWVtYmVycztcblx0XHRcdGlmKHdhaXRGb3JTeW5jKSB7XG5cdFx0XHRcdG1lbWJlcnMud2FpdFN5bmMoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuTWVtYmVycyhtZW1iZXJzKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm5NZW1iZXJzKG1lbWJlcnMpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9O1xuXG5cdFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLmhpc3RvcnkgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG5cdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX01JQ1JPLCAnUmVhbHRpbWVQcmVzZW5jZS5oaXN0b3J5KCknLCAnY2hhbm5lbCA9ICcgKyB0aGlzLm5hbWUpO1xuXHRcdC8qIHBhcmFtcyBhbmQgY2FsbGJhY2sgYXJlIG9wdGlvbmFsOyBzZWUgaWYgcGFyYW1zIGNvbnRhaW5zIHRoZSBjYWxsYmFjayAqL1xuXHRcdGlmKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGlmKHR5cGVvZihwYXJhbXMpID09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0Y2FsbGJhY2sgPSBwYXJhbXM7XG5cdFx0XHRcdHBhcmFtcyA9IG51bGw7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjYWxsYmFjayA9IG5vb3A7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYocGFyYW1zICYmIHBhcmFtcy51bnRpbEF0dGFjaCkge1xuXHRcdFx0aWYodGhpcy5jaGFubmVsLnN0YXRlID09PSAnYXR0YWNoZWQnKSB7XG5cdFx0XHRcdGRlbGV0ZSBwYXJhbXMudW50aWxBdHRhY2g7XG5cdFx0XHRcdHBhcmFtcy5mcm9tX3NlcmlhbCA9IHRoaXMuY2hhbm5lbC5hdHRhY2hTZXJpYWw7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjYWxsYmFjayhuZXcgRXJyb3JJbmZvKFwib3B0aW9uIHVudGlsQXR0YWNoIHJlcXVpcmVzIHRoZSBjaGFubmVsIHRvIGJlIGF0dGFjaGVkLCB3YXM6IFwiICsgdGhpcy5jaGFubmVsLnN0YXRlLCA0MDAwMCwgNDAwKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0UHJlc2VuY2UucHJvdG90eXBlLl9oaXN0b3J5LmNhbGwodGhpcywgcGFyYW1zLCBjYWxsYmFjayk7XG5cdH07XG5cblx0UmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUuc2V0UHJlc2VuY2UgPSBmdW5jdGlvbihwcmVzZW5jZVNldCwgaXNTeW5jLCBzeW5jQ2hhbm5lbFNlcmlhbCkge1xuXHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSUNSTywgJ1JlYWx0aW1lUHJlc2VuY2Uuc2V0UHJlc2VuY2UoKScsICdyZWNlaXZlZCBwcmVzZW5jZSBmb3IgJyArIHByZXNlbmNlU2V0Lmxlbmd0aCArICcgcGFydGljaXBhbnRzOyBzeW5jQ2hhbm5lbFNlcmlhbCA9ICcgKyBzeW5jQ2hhbm5lbFNlcmlhbCk7XG5cdFx0dmFyIHN5bmNDdXJzb3IsIG1hdGNoLCBtZW1iZXJzID0gdGhpcy5tZW1iZXJzLCBteU1lbWJlcnMgPSB0aGlzLl9teU1lbWJlcnMsXG5cdFx0XHRicm9hZGNhc3RNZXNzYWdlcyA9IFtdLCBjb25uSWQgPSB0aGlzLmNoYW5uZWwuY29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdGlvbklkO1xuXG5cdFx0aWYoaXNTeW5jKSB7XG5cdFx0XHR0aGlzLm1lbWJlcnMuc3RhcnRTeW5jKCk7XG5cdFx0XHRpZihzeW5jQ2hhbm5lbFNlcmlhbCAmJiAobWF0Y2ggPSBzeW5jQ2hhbm5lbFNlcmlhbC5tYXRjaCgvXltcXHdcXC1dKzooLiopJC8pKSkge1xuXHRcdFx0XHRzeW5jQ3Vyc29yID0gbWF0Y2hbMV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHByZXNlbmNlU2V0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgcHJlc2VuY2UgPSBQcmVzZW5jZU1lc3NhZ2UuZnJvbVZhbHVlcyhwcmVzZW5jZVNldFtpXSk7XG5cdFx0XHRzd2l0Y2gocHJlc2VuY2UuYWN0aW9uKSB7XG5cdFx0XHRcdGNhc2UgJ2xlYXZlJzpcblx0XHRcdFx0XHRpZihtZW1iZXJzLnJlbW92ZShwcmVzZW5jZSkpIHtcblx0XHRcdFx0XHRcdGJyb2FkY2FzdE1lc3NhZ2VzLnB1c2gocHJlc2VuY2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZihwcmVzZW5jZS5jb25uZWN0aW9uSWQgPT09IGNvbm5JZCAmJiAhcHJlc2VuY2UuaXNTeW50aGVzaXplZCkge1xuXHRcdFx0XHRcdFx0bXlNZW1iZXJzLnJlbW92ZShwcmVzZW5jZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdlbnRlcic6XG5cdFx0XHRcdGNhc2UgJ3ByZXNlbnQnOlxuXHRcdFx0XHRjYXNlICd1cGRhdGUnOlxuXHRcdFx0XHRcdGlmKG1lbWJlcnMucHV0KHByZXNlbmNlKSkge1xuXHRcdFx0XHRcdFx0YnJvYWRjYXN0TWVzc2FnZXMucHVzaChwcmVzZW5jZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKHByZXNlbmNlLmNvbm5lY3Rpb25JZCA9PT0gY29ubklkKSB7XG5cdFx0XHRcdFx0XHRteU1lbWJlcnMucHV0KHByZXNlbmNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8qIGlmIHRoaXMgaXMgdGhlIGxhc3QgKG9yIG9ubHkpIG1lc3NhZ2UgaW4gYSBzZXF1ZW5jZSBvZiBzeW5jIHVwZGF0ZXMsIGVuZCB0aGUgc3luYyAqL1xuXHRcdGlmKGlzU3luYyAmJiAhc3luY0N1cnNvcikge1xuXHRcdFx0bWVtYmVycy5lbmRTeW5jKCk7XG5cdFx0XHQvKiBSVFA1YzI6IHJlLWVudGVyIG91ciBvd24gbWVtYmVycyBpZiB0aGV5IGhhdmVuJ3Qgc2hvd24gdXAgaW4gdGhlIHN5bmMgKi9cblx0XHRcdHRoaXMuX2Vuc3VyZU15TWVtYmVyc1ByZXNlbnQoKTtcblx0XHRcdHRoaXMuY2hhbm5lbC5zZXRJblByb2dyZXNzKFJlYWx0aW1lQ2hhbm5lbC5wcm9ncmVzc09wcy5zeW5jLCBmYWxzZSk7XG5cdFx0XHR0aGlzLmNoYW5uZWwuc3luY0NoYW5uZWxTZXJpYWwgPSBudWxsO1xuXHRcdH1cblxuXHRcdC8qIGJyb2FkY2FzdCB0byBsaXN0ZW5lcnMgKi9cblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgYnJvYWRjYXN0TWVzc2FnZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBwcmVzZW5jZSA9IGJyb2FkY2FzdE1lc3NhZ2VzW2ldO1xuXHRcdFx0dGhpcy5zdWJzY3JpcHRpb25zLmVtaXQocHJlc2VuY2UuYWN0aW9uLCBwcmVzZW5jZSk7XG5cdFx0fVxuXHR9O1xuXG5cdFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLm9uQXR0YWNoZWQgPSBmdW5jdGlvbihoYXNQcmVzZW5jZSkge1xuXHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSU5PUiwgJ1JlYWx0aW1lUHJlc2VuY2Uub25BdHRhY2hlZCgpJywgJ2NoYW5uZWwgPSAnICsgdGhpcy5jaGFubmVsLm5hbWUgKyAnLCBoYXNQcmVzZW5jZSA9ICcgKyBoYXNQcmVzZW5jZSk7XG5cblx0XHRpZihoYXNQcmVzZW5jZSkge1xuXHRcdFx0dGhpcy5tZW1iZXJzLnN0YXJ0U3luYygpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9zeW50aGVzaXplTGVhdmVzKHRoaXMubWVtYmVycy52YWx1ZXMoKSk7XG5cdFx0XHR0aGlzLm1lbWJlcnMuY2xlYXIoKTtcblx0XHRcdHRoaXMuX2Vuc3VyZU15TWVtYmVyc1ByZXNlbnQoKTtcblx0XHR9XG5cblx0XHQvKiBOQiB0aGlzIG11c3QgYmUgYWZ0ZXIgdGhlIF9lbnN1cmVNeU1lbWJlcnNQcmVzZW50IGNhbGwsIHdoaWNoIG1heSBhZGQgaXRlbXMgdG8gcGVuZGluZ1ByZXNlbmNlICovXG5cdFx0dmFyIHBlbmRpbmdQcmVzZW5jZSA9IHRoaXMucGVuZGluZ1ByZXNlbmNlLFxuXHRcdFx0cGVuZGluZ1ByZXNDb3VudCA9IHBlbmRpbmdQcmVzZW5jZS5sZW5ndGg7XG5cblx0XHRpZihwZW5kaW5nUHJlc0NvdW50KSB7XG5cdFx0XHR0aGlzLnBlbmRpbmdQcmVzZW5jZSA9IFtdO1xuXHRcdFx0dmFyIHByZXNlbmNlQXJyYXkgPSBbXTtcblx0XHRcdHZhciBtdWx0aWNhc3RlciA9IE11bHRpY2FzdGVyKCk7XG5cdFx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlDUk8sICdSZWFsdGltZVByZXNlbmNlLm9uQXR0YWNoZWQnLCAnc2VuZGluZyAnICsgcGVuZGluZ1ByZXNDb3VudCArICcgcXVldWVkIHByZXNlbmNlIG1lc3NhZ2VzJyk7XG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgcGVuZGluZ1ByZXNDb3VudDsgaSsrKSB7XG5cdFx0XHRcdHZhciBldmVudCA9IHBlbmRpbmdQcmVzZW5jZVtpXTtcblx0XHRcdFx0cHJlc2VuY2VBcnJheS5wdXNoKGV2ZW50LnByZXNlbmNlKTtcblx0XHRcdFx0bXVsdGljYXN0ZXIucHVzaChldmVudC5jYWxsYmFjayk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmNoYW5uZWwuc2VuZFByZXNlbmNlKHByZXNlbmNlQXJyYXksIG11bHRpY2FzdGVyKTtcblx0XHR9XG5cdH07XG5cblx0UmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUuYWN0T25DaGFubmVsU3RhdGUgPSBmdW5jdGlvbihzdGF0ZSwgaGFzUHJlc2VuY2UsIGVycikge1xuXHRcdHN3aXRjaChzdGF0ZSkge1xuXHRcdFx0Y2FzZSAnYXR0YWNoZWQnOlxuXHRcdFx0XHR0aGlzLm9uQXR0YWNoZWQoaGFzUHJlc2VuY2UpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ2RldGFjaGVkJzpcblx0XHRcdGNhc2UgJ2ZhaWxlZCc6XG5cdFx0XHRcdHRoaXMuX2NsZWFyTXlNZW1iZXJzKCk7XG5cdFx0XHRcdHRoaXMubWVtYmVycy5jbGVhcigpO1xuXHRcdFx0XHQvKiBmYWxscyB0aHJvdWdoICovXG5cdFx0XHRjYXNlICdzdXNwZW5kZWQnOlxuXHRcdFx0XHR0aGlzLmZhaWxQZW5kaW5nUHJlc2VuY2UoZXJyKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9O1xuXG5cdFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLmZhaWxQZW5kaW5nUHJlc2VuY2UgPSBmdW5jdGlvbihlcnIpIHtcblx0XHRpZih0aGlzLnBlbmRpbmdQcmVzZW5jZS5sZW5ndGgpIHtcblx0XHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSU5PUiwgJ1JlYWx0aW1lQ2hhbm5lbC5mYWlsUGVuZGluZ1ByZXNlbmNlJywgJ2NoYW5uZWw7IG5hbWUgPSAnICsgdGhpcy5jaGFubmVsLm5hbWUgKyAnLCBlcnIgPSAnICsgVXRpbHMuaW5zcGVjdEVycm9yKGVycikpO1xuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMucGVuZGluZ1ByZXNlbmNlLmxlbmd0aDsgaSsrKVxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHRoaXMucGVuZGluZ1ByZXNlbmNlW2ldLmNhbGxiYWNrKGVycik7XG5cdFx0XHRcdH0gY2F0Y2goZSkge31cblx0XHRcdHRoaXMucGVuZGluZ1ByZXNlbmNlID0gW107XG5cdFx0fVxuXHR9O1xuXG5cdFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLl9jbGVhck15TWVtYmVycyA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX215TWVtYmVycy5jbGVhcigpO1xuXHR9O1xuXG5cdFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLl9lbnN1cmVNeU1lbWJlcnNQcmVzZW50ID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzLCBtZW1iZXJzID0gdGhpcy5tZW1iZXJzLCBteU1lbWJlcnMgPSB0aGlzLl9teU1lbWJlcnMsXG5cdFx0XHRyZWVudGVyQ2IgPSBmdW5jdGlvbihlcnIpIHtcblx0XHRcdFx0aWYoZXJyKSB7XG5cdFx0XHRcdFx0dmFyIG1zZyA9ICdQcmVzZW5jZSBhdXRvLXJlLWVudGVyIGZhaWxlZDogJyArIGVyci50b1N0cmluZygpO1xuXHRcdFx0XHRcdHZhciB3cmFwcGVkRXJyID0gbmV3IEVycm9ySW5mbyhtc2csIDkxMDA0LCA0MDApO1xuXHRcdFx0XHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19FUlJPUiwgJ1JlYWx0aW1lUHJlc2VuY2UuX2Vuc3VyZU15TWVtYmVyc1ByZXNlbnQoKScsIG1zZyk7XG5cdFx0XHRcdFx0dmFyIGNoYW5nZSA9IG5ldyBDaGFubmVsU3RhdGVDaGFuZ2Uoc2VsZi5jaGFubmVsLnN0YXRlLCBzZWxmLmNoYW5uZWwuc3RhdGUsIHRydWUsIHdyYXBwZWRFcnIpO1xuXHRcdFx0XHRcdHNlbGYuY2hhbm5lbC5lbWl0KCd1cGRhdGUnLCBjaGFuZ2UpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0Zm9yKHZhciBtZW1iZXJLZXkgaW4gbXlNZW1iZXJzLm1hcCkge1xuXHRcdFx0aWYoIShtZW1iZXJLZXkgaW4gbWVtYmVycy5tYXApKSB7XG5cdFx0XHRcdHZhciBlbnRyeSA9IG15TWVtYmVycy5tYXBbbWVtYmVyS2V5XTtcblx0XHRcdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX01JQ1JPLCAnUmVhbHRpbWVQcmVzZW5jZS5fZW5zdXJlTXlNZW1iZXJzUHJlc2VudCgpJywgJ0F1dG8tcmVlbnRlcmluZyBjbGllbnRJZCBcIicgKyBlbnRyeS5jbGllbnRJZCArICdcIiBpbnRvIHRoZSBwcmVzZW5jZSBzZXQnKTtcblx0XHRcdFx0dGhpcy5fZW50ZXJPclVwZGF0ZUNsaWVudChlbnRyeS5jbGllbnRJZCwgZW50cnkuZGF0YSwgcmVlbnRlckNiLCAnZW50ZXInKTtcblx0XHRcdFx0ZGVsZXRlIG15TWVtYmVycy5tYXBbbWVtYmVyS2V5XTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0UmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUuX3N5bnRoZXNpemVMZWF2ZXMgPSBmdW5jdGlvbihpdGVtcykge1xuXHRcdHZhciBzdWJzY3JpcHRpb25zID0gdGhpcy5zdWJzY3JpcHRpb25zO1xuXHRcdFV0aWxzLmFyckZvckVhY2goaXRlbXMsIGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdHZhciBwcmVzZW5jZSA9IFByZXNlbmNlTWVzc2FnZS5mcm9tVmFsdWVzKHtcblx0XHRcdFx0YWN0aW9uOiAnbGVhdmUnLFxuXHRcdFx0XHRjb25uZWN0aW9uSWQ6IGl0ZW0uY29ubmVjdGlvbklkLFxuXHRcdFx0XHRjbGllbnRJZDogaXRlbS5jbGllbnRJZCxcblx0XHRcdFx0ZGF0YTogaXRlbS5kYXRhLFxuXHRcdFx0XHRlbmNvZGluZzogaXRlbS5lbmNvZGluZyxcblx0XHRcdFx0dGltZXN0YW1wOiBVdGlscy5ub3coKVxuXHRcdFx0fSk7XG5cdFx0XHRzdWJzY3JpcHRpb25zLmVtaXQoJ2xlYXZlJywgcHJlc2VuY2UpO1xuXHRcdH0pO1xuXHR9O1xuXG5cdC8qIERlcHJlY2F0ZWQgKi9cblx0UmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbigpIHtcblx0XHRMb2dnZXIuZGVwcmVjYXRlZCgncHJlc2VuY2Uub24nLCAncHJlc2VuY2Uuc3Vic2NyaWJlJyk7XG5cdFx0dGhpcy5zdWJzY3JpYmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0fTtcblxuXHQvKiBEZXByZWNhdGVkICovXG5cdFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uKCkge1xuXHRcdExvZ2dlci5kZXByZWNhdGVkKCdwcmVzZW5jZS5vZmYnLCAncHJlc2VuY2UudW5zdWJzY3JpYmUnKTtcblx0XHR0aGlzLnVuc3Vic2NyaWJlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdH07XG5cblx0UmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24oLyogW2V2ZW50XSwgbGlzdGVuZXIsIFtjYWxsYmFja10gKi8pIHtcblx0XHR2YXIgYXJncyA9IFJlYWx0aW1lQ2hhbm5lbC5wcm9jZXNzTGlzdGVuZXJBcmdzKGFyZ3VtZW50cyk7XG5cdFx0dmFyIGV2ZW50ID0gYXJnc1swXTtcblx0XHR2YXIgbGlzdGVuZXIgPSBhcmdzWzFdO1xuXHRcdHZhciBjYWxsYmFjayA9IGFyZ3NbMl07XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXG5cdFx0d2FpdEF0dGFjaGVkKHRoaXMuY2hhbm5lbCwgY2FsbGJhY2ssIGZ1bmN0aW9uKCkge1xuXHRcdFx0c2VsZi5zdWJzY3JpcHRpb25zLm9uKGV2ZW50LCBsaXN0ZW5lcik7XG5cdFx0fSk7XG5cdH07XG5cblx0UmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbigvKiBbZXZlbnRdLCBsaXN0ZW5lciwgW2NhbGxiYWNrXSAqLykge1xuXHRcdHZhciBhcmdzID0gUmVhbHRpbWVDaGFubmVsLnByb2Nlc3NMaXN0ZW5lckFyZ3MoYXJndW1lbnRzKTtcblx0XHR2YXIgZXZlbnQgPSBhcmdzWzBdO1xuXHRcdHZhciBsaXN0ZW5lciA9IGFyZ3NbMV07XG5cdFx0dmFyIGNhbGxiYWNrID0gYXJnc1syXTtcblxuXHRcdGlmKHRoaXMuY2hhbm5lbC5zdGF0ZSA9PT0gJ2ZhaWxlZCcpXG5cdFx0XHRjYWxsYmFjayhFcnJvckluZm8uZnJvbVZhbHVlcyhSZWFsdGltZUNoYW5uZWwuaW52YWxpZFN0YXRlRXJyb3IoJ2ZhaWxlZCcpKSk7XG5cblx0XHR0aGlzLnN1YnNjcmlwdGlvbnMub2ZmKGV2ZW50LCBsaXN0ZW5lcik7XG5cdH07XG5cblx0UmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUuc3luY0NvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICF0aGlzLm1lbWJlcnMuc3luY0luUHJvZ3Jlc3M7XG5cdH07XG5cblx0ZnVuY3Rpb24gUHJlc2VuY2VNYXAocHJlc2VuY2UpIHtcblx0XHRFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblx0XHR0aGlzLnByZXNlbmNlID0gcHJlc2VuY2U7XG5cdFx0dGhpcy5tYXAgPSB7fTtcblx0XHR0aGlzLnN5bmNJblByb2dyZXNzID0gZmFsc2U7XG5cdFx0dGhpcy5yZXNpZHVhbE1lbWJlcnMgPSBudWxsO1xuXHR9XG5cdFV0aWxzLmluaGVyaXRzKFByZXNlbmNlTWFwLCBFdmVudEVtaXR0ZXIpO1xuXG5cdFByZXNlbmNlTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihrZXkpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXBba2V5XTtcblx0fTtcblxuXHRQcmVzZW5jZU1hcC5wcm90b3R5cGUuZ2V0Q2xpZW50ID0gZnVuY3Rpb24oY2xpZW50SWQpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5tYXAsIHJlc3VsdCA9IFtdO1xuXHRcdGZvcih2YXIga2V5IGluIG1hcCkge1xuXHRcdFx0dmFyIGl0ZW0gPSBtYXBba2V5XTtcblx0XHRcdGlmKGl0ZW0uY2xpZW50SWQgPT0gY2xpZW50SWQgJiYgaXRlbS5hY3Rpb24gIT0gJ2Fic2VudCcpXG5cdFx0XHRcdHJlc3VsdC5wdXNoKGl0ZW0pO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdFByZXNlbmNlTWFwLnByb3RvdHlwZS5saXN0ID0gZnVuY3Rpb24ocGFyYW1zKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMubWFwLFxuXHRcdFx0Y2xpZW50SWQgPSBwYXJhbXMgJiYgcGFyYW1zLmNsaWVudElkLFxuXHRcdFx0Y29ubmVjdGlvbklkID0gcGFyYW1zICYmIHBhcmFtcy5jb25uZWN0aW9uSWQsXG5cdFx0XHRyZXN1bHQgPSBbXTtcblxuXHRcdGZvcih2YXIga2V5IGluIG1hcCkge1xuXHRcdFx0dmFyIGl0ZW0gPSBtYXBba2V5XTtcblx0XHRcdGlmKGl0ZW0uYWN0aW9uID09PSAnYWJzZW50JykgY29udGludWU7XG5cdFx0XHRpZihjbGllbnRJZCAmJiBjbGllbnRJZCAhPSBpdGVtLmNsaWVudElkKSBjb250aW51ZTtcblx0XHRcdGlmKGNvbm5lY3Rpb25JZCAmJiBjb25uZWN0aW9uSWQgIT0gaXRlbS5jb25uZWN0aW9uSWQpIGNvbnRpbnVlO1xuXHRcdFx0cmVzdWx0LnB1c2goaXRlbSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0ZnVuY3Rpb24gbmV3ZXJUaGFuKGl0ZW0sIGV4aXN0aW5nKSB7XG5cdFx0LyogUlRQMmIxOiBpZiBlaXRoZXIgaXMgc3ludGhlc2lzZWQsIGNvbXBhcmUgYnkgdGltZXN0YW1wICovXG5cdFx0aWYoaXRlbS5pc1N5bnRoZXNpemVkKCkgfHwgZXhpc3RpbmcuaXNTeW50aGVzaXplZCgpKSB7XG5cdFx0XHRyZXR1cm4gaXRlbS50aW1lc3RhbXAgPiBleGlzdGluZy50aW1lc3RhbXA7XG5cdFx0fVxuXG5cdFx0LyogUlRQMmIyICovXG5cdFx0dmFyIGl0ZW1PcmRlcmluZ3MgPSBpdGVtLnBhcnNlSWQoKSxcblx0XHRcdGV4aXN0aW5nT3JkZXJpbmdzID0gZXhpc3RpbmcucGFyc2VJZCgpO1xuXHRcdGlmKGl0ZW1PcmRlcmluZ3MubXNnU2VyaWFsID09PSBleGlzdGluZ09yZGVyaW5ncy5tc2dTZXJpYWwpIHtcblx0XHRcdHJldHVybiBpdGVtT3JkZXJpbmdzLmluZGV4ID4gZXhpc3RpbmdPcmRlcmluZ3MuaW5kZXg7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBpdGVtT3JkZXJpbmdzLm1zZ1NlcmlhbCA+IGV4aXN0aW5nT3JkZXJpbmdzLm1zZ1NlcmlhbDtcblx0XHR9XG5cdH1cblxuXHRQcmVzZW5jZU1hcC5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24oaXRlbSkge1xuXHRcdGlmKGl0ZW0uYWN0aW9uID09PSAnZW50ZXInIHx8IGl0ZW0uYWN0aW9uID09PSAndXBkYXRlJykge1xuXHRcdFx0aXRlbSA9IFByZXNlbmNlTWVzc2FnZS5mcm9tVmFsdWVzKGl0ZW0pO1xuXHRcdFx0aXRlbS5hY3Rpb24gPSAncHJlc2VudCc7XG5cdFx0fVxuXHRcdHZhciBtYXAgPSB0aGlzLm1hcCwga2V5ID0gbWVtYmVyS2V5KGl0ZW0pO1xuXHRcdC8qIHdlJ3ZlIHNlZW4gdGhpcyBtZW1iZXIsIHNvIGRvIG5vdCByZW1vdmUgaXQgYXQgdGhlIGVuZCBvZiBzeW5jICovXG5cdFx0aWYodGhpcy5yZXNpZHVhbE1lbWJlcnMpXG5cdFx0XHRkZWxldGUgdGhpcy5yZXNpZHVhbE1lbWJlcnNba2V5XTtcblxuXHRcdC8qIGNvbXBhcmUgdGhlIHRpbWVzdGFtcCBvZiB0aGUgbmV3IGl0ZW0gd2l0aCBhbnkgZXhpc3RpbmcgbWVtYmVyIChvciBBQlNFTlQgd2l0bmVzcykgKi9cblx0XHR2YXIgZXhpc3RpbmdJdGVtID0gbWFwW2tleV07XG5cdFx0aWYoZXhpc3RpbmdJdGVtICYmICFuZXdlclRoYW4oaXRlbSwgZXhpc3RpbmdJdGVtKSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRtYXBba2V5XSA9IGl0ZW07XG5cdFx0cmV0dXJuIHRydWU7XG5cblx0fTtcblxuXHRQcmVzZW5jZU1hcC5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMubWFwLCByZXN1bHQgPSBbXTtcblx0XHRmb3IodmFyIGtleSBpbiBtYXApIHtcblx0XHRcdHZhciBpdGVtID0gbWFwW2tleV07XG5cdFx0XHRpZihpdGVtLmFjdGlvbiAhPSAnYWJzZW50Jylcblx0XHRcdFx0cmVzdWx0LnB1c2goaXRlbSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0UHJlc2VuY2VNYXAucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHR2YXIgbWFwID0gdGhpcy5tYXAsIGtleSA9IG1lbWJlcktleShpdGVtKTtcblx0XHR2YXIgZXhpc3RpbmdJdGVtID0gbWFwW2tleV07XG5cblx0XHRpZihleGlzdGluZ0l0ZW0gJiYgIW5ld2VyVGhhbihpdGVtLCBleGlzdGluZ0l0ZW0pKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0LyogUlRQMmYgKi9cblx0XHRpZih0aGlzLnN5bmNJblByb2dyZXNzKSB7XG5cdFx0XHRpdGVtID0gUHJlc2VuY2VNZXNzYWdlLmZyb21WYWx1ZXMoaXRlbSk7XG5cdFx0XHRpdGVtLmFjdGlvbiA9ICdhYnNlbnQnO1xuXHRcdFx0bWFwW2tleV0gPSBpdGVtO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkZWxldGUgbWFwW2tleV07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblx0UHJlc2VuY2VNYXAucHJvdG90eXBlLnN0YXJ0U3luYyA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtYXAgPSB0aGlzLm1hcCwgc3luY0luUHJvZ3Jlc3MgPSB0aGlzLnN5bmNJblByb2dyZXNzO1xuXHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSU5PUiwgJ1ByZXNlbmNlTWFwLnN0YXJ0U3luYygpJywgJ2NoYW5uZWwgPSAnICsgdGhpcy5wcmVzZW5jZS5jaGFubmVsLm5hbWUgKyAnOyBzeW5jSW5Qcm9ncmVzcyA9ICcgKyBzeW5jSW5Qcm9ncmVzcyk7XG5cdFx0Lyogd2UgbWlnaHQgYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzIHdoaWxlIGEgc3luYyBpcyBpbiBwcm9ncmVzcyAqL1xuXHRcdGlmKCF0aGlzLnN5bmNJblByb2dyZXNzKSB7XG5cdFx0XHR0aGlzLnJlc2lkdWFsTWVtYmVycyA9IFV0aWxzLmNvcHkobWFwKTtcblx0XHRcdHRoaXMuc3luY0luUHJvZ3Jlc3MgPSB0cnVlO1xuXHRcdH1cblx0fTtcblxuXHRQcmVzZW5jZU1hcC5wcm90b3R5cGUuZW5kU3luYyA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtYXAgPSB0aGlzLm1hcCwgc3luY0luUHJvZ3Jlc3MgPSB0aGlzLnN5bmNJblByb2dyZXNzO1xuXHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSU5PUiwgJ1ByZXNlbmNlTWFwLmVuZFN5bmMoKScsICdjaGFubmVsID0gJyArIHRoaXMucHJlc2VuY2UuY2hhbm5lbC5uYW1lICsgJzsgc3luY0luUHJvZ3Jlc3MgPSAnICsgc3luY0luUHJvZ3Jlc3MpO1xuXHRcdGlmKHN5bmNJblByb2dyZXNzKSB7XG5cdFx0XHQvKiB3ZSBjYW4gbm93IHN0cmlwIG91dCB0aGUgQUJTRU5UIG1lbWJlcnMsIGFzIHdlIGhhdmVcblx0XHRcdCAqIHJlY2VpdmVkIGFsbCBvZiB0aGUgb3V0LW9mLW9yZGVyIHN5bmMgbWVzc2FnZXMgKi9cblx0XHRcdGZvcih2YXIgbWVtYmVyS2V5IGluIG1hcCkge1xuXHRcdFx0XHR2YXIgZW50cnkgPSBtYXBbbWVtYmVyS2V5XTtcblx0XHRcdFx0aWYoZW50cnkuYWN0aW9uID09PSAnYWJzZW50Jykge1xuXHRcdFx0XHRcdGRlbGV0ZSBtYXBbbWVtYmVyS2V5XTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0LyogYW55IG1lbWJlcnMgdGhhdCB3ZXJlIHByZXNlbnQgYXQgdGhlIHN0YXJ0IG9mIHRoZSBzeW5jLFxuXHRcdFx0ICogYW5kIGhhdmUgbm90IGJlZW4gc2VlbiBpbiBzeW5jLCBjYW4gYmUgcmVtb3ZlZCwgYW5kIGxlYXZlIGV2ZW50cyBlbWl0dGVkICovXG5cdFx0XHR0aGlzLnByZXNlbmNlLl9zeW50aGVzaXplTGVhdmVzKFV0aWxzLnZhbHVlc0FycmF5KHRoaXMucmVzaWR1YWxNZW1iZXJzKSk7XG5cdFx0XHRmb3IodmFyIG1lbWJlcktleSBpbiB0aGlzLnJlc2lkdWFsTWVtYmVycykge1xuXHRcdFx0XHRkZWxldGUgbWFwW21lbWJlcktleV07XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnJlc2lkdWFsTWVtYmVycyA9IG51bGw7XG5cblx0XHRcdC8qIGZpbmlzaCwgbm90aWZ5aW5nIGFueSB3YWl0ZXJzICovXG5cdFx0XHR0aGlzLnN5bmNJblByb2dyZXNzID0gZmFsc2U7XG5cdFx0fVxuXHRcdHRoaXMuZW1pdCgnc3luYycpO1xuXHR9O1xuXG5cdFByZXNlbmNlTWFwLnByb3RvdHlwZS53YWl0U3luYyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdFx0dmFyIHN5bmNJblByb2dyZXNzID0gdGhpcy5zeW5jSW5Qcm9ncmVzcztcblx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlOT1IsICdQcmVzZW5jZU1hcC53YWl0U3luYygpJywgJ2NoYW5uZWwgPSAnICsgdGhpcy5wcmVzZW5jZS5jaGFubmVsLm5hbWUgKyAnOyBzeW5jSW5Qcm9ncmVzcyA9ICcgKyBzeW5jSW5Qcm9ncmVzcyk7XG5cdFx0aWYoIXN5bmNJblByb2dyZXNzKSB7XG5cdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLm9uY2UoJ3N5bmMnLCBjYWxsYmFjayk7XG5cdH07XG5cblx0UHJlc2VuY2VNYXAucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0XHR0aGlzLm1hcCA9IHt9O1xuXHRcdHRoaXMuc3luY0luUHJvZ3Jlc3MgPSBmYWxzZTtcblx0XHR0aGlzLnJlc2lkdWFsTWVtYmVycyA9IG51bGw7XG5cdH07XG5cblx0cmV0dXJuIFJlYWx0aW1lUHJlc2VuY2U7XG59KSgpO1xuXG52YXIgWEhSUmVxdWVzdCA9IChmdW5jdGlvbigpIHtcblx0dmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9O1xuXHR2YXIgaWRDb3VudGVyID0gMDtcblx0dmFyIHBlbmRpbmdSZXF1ZXN0cyA9IHt9O1xuXG5cdHZhciBSRVFfU0VORCA9IDAsXG5cdFx0UkVRX1JFQ1YgPSAxLFxuXHRcdFJFUV9SRUNWX1BPTEwgPSAyLFxuXHRcdFJFUV9SRUNWX1NUUkVBTSA9IDM7XG5cblx0ZnVuY3Rpb24gY2xlYXJQZW5kaW5nUmVxdWVzdHMoKSB7XG5cdFx0Zm9yKHZhciBpZCBpbiBwZW5kaW5nUmVxdWVzdHMpXG5cdFx0XHRwZW5kaW5nUmVxdWVzdHNbaWRdLmRpc3Bvc2UoKTtcblx0fVxuXG5cdHZhciBpc0lFID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LlhEb21haW5SZXF1ZXN0O1xuXG5cdGZ1bmN0aW9uIGllVmVyc2lvbigpIHtcblx0XHR2YXIgbWF0Y2ggPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvU3RyaW5nKCkubWF0Y2goL01TSUVcXHMoW1xcZC5dKykvKTtcblx0XHRyZXR1cm4gbWF0Y2ggJiYgTnVtYmVyKG1hdGNoWzFdKTtcblx0fVxuXG5cdGZ1bmN0aW9uIG5lZWRKc29uRW52ZWxvcGUoKSB7XG5cdFx0LyogSUUgMTAgeGhyIGJ1ZzogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTYzMjAzMzkgKi9cblx0XHR2YXIgdmVyc2lvbjtcblx0XHRyZXR1cm4gaXNJRSAmJiAodmVyc2lvbiA9IGllVmVyc2lvbigpKSAmJiB2ZXJzaW9uID09PSAxMDtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldEhlYWRlcih4aHIsIGhlYWRlcikge1xuXHRcdHJldHVybiB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIgJiYgeGhyLmdldFJlc3BvbnNlSGVhZGVyKGhlYWRlcik7XG5cdH1cblxuXHQvKiBTYWZhcmkgbXlzdGVyaW91c2x5IHJldHVybnMgJ0lkZW50aXR5JyBmb3IgdHJhbnNmZXItZW5jb2Rpbmdcblx0ICogd2hlbiBpbiBmYWN0IGl0IGlzICdjaHVua2VkJy4gU28gaW5zdGVhZCwgZGVjaWRlIHRoYXQgaXQgaXNcblx0ICogY2h1bmtlZCB3aGVuIHRyYW5zZmVyLWVuY29kaW5nIGlzIHByZXNlbnQsIGNvbnRlbnQtbGVuZ3RoIGlzIGFic2VudCAqL1xuXHRmdW5jdGlvbiBpc0VuY29kaW5nQ2h1bmtlZCh4aHIpIHtcblx0XHRyZXR1cm4geGhyLmdldFJlc3BvbnNlSGVhZGVyXG5cdFx0XHQmJiB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ3RyYW5zZmVyLWVuY29kaW5nJylcblx0XHRcdCYmICF4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ2NvbnRlbnQtbGVuZ3RoJyk7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRIZWFkZXJzQXNPYmplY3QoeGhyKSB7XG5cdFx0dmFyIGhlYWRlclBhaXJzID0gVXRpbHMudHJpbSh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpLnNwbGl0KCdcXHJcXG4nKSxcblx0XHRcdGhlYWRlcnMgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGhlYWRlclBhaXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgcGFydHMgPSBVdGlscy5hcnJNYXAoaGVhZGVyUGFpcnNbaV0uc3BsaXQoJzonKSwgVXRpbHMudHJpbSk7XG5cdFx0XHRoZWFkZXJzW3BhcnRzWzBdLnRvTG93ZXJDYXNlKCldID0gcGFydHNbMV07XG5cdFx0fVxuXHRcdHJldHVybiBoZWFkZXJzO1xuXHR9XG5cblx0ZnVuY3Rpb24gWEhSUmVxdWVzdCh1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSwgcmVxdWVzdE1vZGUsIHRpbWVvdXRzKSB7XG5cdFx0RXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cdFx0cGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuXHRcdHBhcmFtcy5ybmQgPSBVdGlscy5yYW5kU3RyKCk7XG5cdFx0aWYobmVlZEpzb25FbnZlbG9wZSgpICYmICFwYXJhbXMuZW52ZWxvcGUpXG5cdFx0XHRwYXJhbXMuZW52ZWxvcGUgPSAnanNvbic7XG5cdFx0dGhpcy51cmkgPSB1cmkgKyBVdGlscy50b1F1ZXJ5U3RyaW5nKHBhcmFtcyk7XG5cdFx0dGhpcy5oZWFkZXJzID0gaGVhZGVycyB8fCB7fTtcblx0XHR0aGlzLmJvZHkgPSBib2R5O1xuXHRcdHRoaXMucmVxdWVzdE1vZGUgPSByZXF1ZXN0TW9kZTtcblx0XHR0aGlzLnRpbWVvdXRzID0gdGltZW91dHM7XG5cdFx0dGhpcy50aW1lZE91dCA9IGZhbHNlO1xuXHRcdHRoaXMucmVxdWVzdENvbXBsZXRlID0gZmFsc2U7XG5cdFx0cGVuZGluZ1JlcXVlc3RzW3RoaXMuaWQgPSBTdHJpbmcoKytpZENvdW50ZXIpXSA9IHRoaXM7XG5cdH1cblx0VXRpbHMuaW5oZXJpdHMoWEhSUmVxdWVzdCwgRXZlbnRFbWl0dGVyKTtcblxuXHR2YXIgY3JlYXRlUmVxdWVzdCA9IFhIUlJlcXVlc3QuY3JlYXRlUmVxdWVzdCA9IGZ1bmN0aW9uKHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCByZXF1ZXN0TW9kZSwgdGltZW91dHMpIHtcblx0XHQvKiBYSFIgcmVxdWVzdHMgYXJlIHVzZWQgZWl0aGVyIHdpdGggdGhlIGNvbnRleHQgYmVpbmcgYSByZWFsdGltZVxuXHRcdCAqIHRyYW5zcG9ydCwgb3Igd2l0aCB0aW1lb3V0cyBwYXNzZWQgaW4gKGZvciB3aGVuIHVzZWQgYnkgYSByZXN0IGNsaWVudCksXG5cdFx0ICogb3IgY29tcGxldGVseSBzdGFuZGFsb25lLiAgVXNlIHRoZSBhcHByb3ByaWF0ZSB0aW1lb3V0cyBpbiBlYWNoIGNhc2UgKi9cblx0XHR0aW1lb3V0cyA9ICh0aGlzICYmIHRoaXMudGltZW91dHMpIHx8IHRpbWVvdXRzIHx8IERlZmF1bHRzLlRJTUVPVVRTO1xuXHRcdHJldHVybiBuZXcgWEhSUmVxdWVzdCh1cmksIGhlYWRlcnMsIFV0aWxzLmNvcHkocGFyYW1zKSwgYm9keSwgcmVxdWVzdE1vZGUsIHRpbWVvdXRzKTtcblx0fTtcblxuXHRYSFJSZXF1ZXN0LnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uKGVyciwgYm9keSwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUpIHtcblx0XHRpZighdGhpcy5yZXF1ZXN0Q29tcGxldGUpIHtcblx0XHRcdHRoaXMucmVxdWVzdENvbXBsZXRlID0gdHJ1ZTtcblx0XHRcdGlmKGJvZHkpXG5cdFx0XHRcdHRoaXMuZW1pdCgnZGF0YScsIGJvZHkpO1xuXHRcdFx0dGhpcy5lbWl0KCdjb21wbGV0ZScsIGVyciwgYm9keSwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUpO1xuXHRcdFx0dGhpcy5kaXNwb3NlKCk7XG5cdFx0fVxuXHR9O1xuXG5cdFhIUlJlcXVlc3QucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5kaXNwb3NlKCk7XG5cdH07XG5cblx0WEhSUmVxdWVzdC5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0aW1lb3V0ID0gKHRoaXMucmVxdWVzdE1vZGUgPT0gUkVRX1NFTkQpID8gdGhpcy50aW1lb3V0cy5odHRwUmVxdWVzdFRpbWVvdXQgOiB0aGlzLnRpbWVvdXRzLnJlY3ZUaW1lb3V0LFxuXHRcdFx0c2VsZiA9IHRoaXMsXG5cdFx0XHR0aW1lciA9IHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZWxmLnRpbWVkT3V0ID0gdHJ1ZTtcblx0XHRcdFx0eGhyLmFib3J0KCk7XG5cdFx0XHR9LCB0aW1lb3V0KSxcblx0XHRcdGJvZHkgPSB0aGlzLmJvZHksXG5cdFx0XHRtZXRob2QgPSBib2R5ID8gJ1BPU1QnIDogJ0dFVCcsXG5cdFx0XHRoZWFkZXJzID0gdGhpcy5oZWFkZXJzLFxuXHRcdFx0eGhyID0gdGhpcy54aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKSxcblx0XHRcdGFjY2VwdCA9IGhlYWRlcnNbJ2FjY2VwdCddLFxuXHRcdFx0cmVzcG9uc2VUeXBlID0gJ3RleHQnO1xuXG5cdFx0aWYoIWFjY2VwdCkge1xuXHRcdFx0aGVhZGVyc1snYWNjZXB0J10gPSAnYXBwbGljYXRpb24vanNvbic7XG5cdFx0fSBlbHNlIGlmKGFjY2VwdC5pbmRleE9mKCdhcHBsaWNhdGlvbi9qc29uJykgPT09IC0xKSB7XG5cdFx0XHRyZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuXHRcdH1cblxuXHRcdGlmKGJvZHkpIHtcblx0XHRcdHZhciBjb250ZW50VHlwZSA9IGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddIHx8IChoZWFkZXJzWydjb250ZW50LXR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJyk7XG5cdFx0XHRpZihjb250ZW50VHlwZS5pbmRleE9mKCdhcHBsaWNhdGlvbi9qc29uJykgPiAtMSAmJiB0eXBlb2YoYm9keSkgIT0gJ3N0cmluZycpXG5cdFx0XHRcdGJvZHkgPSBKU09OLnN0cmluZ2lmeShib2R5KTtcblx0XHR9XG5cblxuXHRcdHhoci5vcGVuKG1ldGhvZCwgdGhpcy51cmksIHRydWUpO1xuXHRcdHhoci5yZXNwb25zZVR5cGUgPSByZXNwb25zZVR5cGU7XG5cblx0XHRpZiAoJ2F1dGhvcml6YXRpb24nIGluIGhlYWRlcnMpIHtcblx0XHRcdHhoci53aXRoQ3JlZGVudGlhbHMgPSAndHJ1ZSc7XG5cdFx0fVxuXG5cdFx0Zm9yKHZhciBoIGluIGhlYWRlcnMpXG5cdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihoLCBoZWFkZXJzW2hdKTtcblxuXHRcdHZhciBlcnJvckhhbmRsZXIgPSBmdW5jdGlvbihlcnJvckV2ZW50LCBtZXNzYWdlLCBjb2RlLCBzdGF0dXNDb2RlKSB7XG5cdFx0XHR2YXIgZXJyb3JNZXNzYWdlID0gbWVzc2FnZSArICcgKGV2ZW50IHR5cGU6ICcgKyBlcnJvckV2ZW50LnR5cGUgKyAnKScgKyAoc2VsZi54aHIuc3RhdHVzVGV4dCA/ICcsIGN1cnJlbnQgc3RhdHVzVGV4dCBpcyAnICsgc2VsZi54aHIuc3RhdHVzVGV4dCA6ICcnKTtcblx0XHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19FUlJPUiwgJ1JlcXVlc3Qub24nICsgZXJyb3JFdmVudC50eXBlICsgJygpJywgZXJyb3JNZXNzYWdlKTtcblx0XHRcdHNlbGYuY29tcGxldGUobmV3IEVycm9ySW5mbyhlcnJvck1lc3NhZ2UsIGNvZGUsIHN0YXR1c0NvZGUpKTtcblx0XHR9O1xuXHRcdHhoci5vbmVycm9yID0gZnVuY3Rpb24oZXJyb3JFdmVudCkge1xuXHRcdFx0ZXJyb3JIYW5kbGVyKGVycm9yRXZlbnQsICdYSFIgZXJyb3Igb2NjdXJyZWQnLCBudWxsLCA0MDApO1xuXHRcdH1cblx0XHR4aHIub25hYm9ydCA9IGZ1bmN0aW9uKGVycm9yRXZlbnQpIHtcblx0XHRcdGlmKHNlbGYudGltZWRPdXQpIHtcblx0XHRcdFx0ZXJyb3JIYW5kbGVyKGVycm9yRXZlbnQsICdSZXF1ZXN0IGFib3J0ZWQgZHVlIHRvIHJlcXVlc3QgdGltZW91dCBleHBpcmluZycsIG51bGwsIDQwOCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlcnJvckhhbmRsZXIoZXJyb3JFdmVudCwgJ1JlcXVlc3QgY2FuY2VsbGVkJywgbnVsbCwgNDAwKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdHhoci5vbnRpbWVvdXQgPSBmdW5jdGlvbihlcnJvckV2ZW50KSB7XG5cdFx0XHRlcnJvckhhbmRsZXIoZXJyb3JFdmVudCwgJ1JlcXVlc3QgdGltZWQgb3V0JywgbnVsbCwgNDA4KTtcblx0XHR9O1xuXG5cdFx0dmFyIHN0cmVhbWluZyxcblx0XHRcdHN0YXR1c0NvZGUsXG5cdFx0XHRyZXNwb25zZUJvZHksXG5cdFx0XHRjb250ZW50VHlwZSxcblx0XHRcdHN1Y2Nlc3NSZXNwb25zZSxcblx0XHRcdHN0cmVhbVBvcyA9IDAsXG5cdFx0XHR1bnBhY2tlZCA9IGZhbHNlO1xuXG5cdFx0ZnVuY3Rpb24gb25SZXNwb25zZSgpIHtcblx0XHRcdGNsZWFyVGltZW91dCh0aW1lcik7XG5cdFx0XHRzdWNjZXNzUmVzcG9uc2UgPSAoc3RhdHVzQ29kZSA8IDQwMCk7XG5cdFx0XHRpZihzdGF0dXNDb2RlID09IDIwNCkge1xuXHRcdFx0XHRzZWxmLmNvbXBsZXRlKG51bGwsIG51bGwsIG51bGwsIG51bGwsIHN0YXR1c0NvZGUpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRzdHJlYW1pbmcgPSAoc2VsZi5yZXF1ZXN0TW9kZSA9PSBSRVFfUkVDVl9TVFJFQU0gJiYgc3VjY2Vzc1Jlc3BvbnNlICYmIGlzRW5jb2RpbmdDaHVua2VkKHhocikpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG9uRW5kKCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dmFyIGNvbnRlbnRUeXBlID0gZ2V0SGVhZGVyKHhociwgJ2NvbnRlbnQtdHlwZScpLFxuXHRcdFx0XHRcdGhlYWRlcnMsXG5cdFx0XHRcdFx0c2VydmVyLFxuXHRcdFx0XHRcdGpzb24gPSBjb250ZW50VHlwZSA/IChjb250ZW50VHlwZS5pbmRleE9mKCdhcHBsaWNhdGlvbi9qc29uJykgPj0gMCkgOiAoeGhyLnJlc3BvbnNlVHlwZSA9PSAndGV4dCcpO1xuXG5cdFx0XHRcdHJlc3BvbnNlQm9keSA9IGpzb24gPyB4aHIucmVzcG9uc2VUZXh0IDogeGhyLnJlc3BvbnNlO1xuXG5cdFx0XHRcdGlmKGpzb24pIHtcblx0XHRcdFx0XHRyZXNwb25zZUJvZHkgPSBTdHJpbmcocmVzcG9uc2VCb2R5KTtcblx0XHRcdFx0XHRpZihyZXNwb25zZUJvZHkubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRyZXNwb25zZUJvZHkgPSBKU09OLnBhcnNlKHJlc3BvbnNlQm9keSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHVucGFja2VkID0gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmKHJlc3BvbnNlQm9keS5yZXNwb25zZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0LyogdW53cmFwIEpTT04gZW52ZWxvcGUgKi9cblx0XHRcdFx0XHRzdGF0dXNDb2RlID0gcmVzcG9uc2VCb2R5LnN0YXR1c0NvZGU7XG5cdFx0XHRcdFx0c3VjY2Vzc1Jlc3BvbnNlID0gKHN0YXR1c0NvZGUgPCA0MDApO1xuXHRcdFx0XHRcdGhlYWRlcnMgPSByZXNwb25zZUJvZHkuaGVhZGVycztcblx0XHRcdFx0XHRyZXNwb25zZUJvZHkgPSByZXNwb25zZUJvZHkucmVzcG9uc2U7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aGVhZGVycyA9IGdldEhlYWRlcnNBc09iamVjdCh4aHIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdFx0c2VsZi5jb21wbGV0ZShuZXcgRXJyb3JJbmZvKCdNYWxmb3JtZWQgcmVzcG9uc2UgYm9keSBmcm9tIHNlcnZlcjogJyArIGUubWVzc2FnZSwgbnVsbCwgNDAwKSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0LyogSWYgcmVzcG9uc2UgaXMgYW4gYXJyYXksIGl0J3MgYW4gYXJyYXkgb2YgcHJvdG9jb2wgbWVzc2FnZXMgLS0gZXZlbiBpZlxuXHRcdFx0ICogaXMgY29udGFpbnMgYW4gZXJyb3IgYWN0aW9uIChoZW5jZSB0aGUgbm9uc3VjY2VzcyBzdGF0dXNjb2RlKSwgd2UgY2FuXG5cdFx0XHQgKiBjb25zaWRlciB0aGUgcmVxdWVzdCB0byBoYXZlIHN1Y2NlZWRlZCwganVzdCBwYXNzIGl0IG9uIHRvXG5cdFx0XHQgKiBvblByb3RvY29sTWVzc2FnZSB0byBkZWNpZGUgd2hhdCB0byBkbyAqL1xuXHRcdFx0aWYoc3VjY2Vzc1Jlc3BvbnNlIHx8IFV0aWxzLmlzQXJyYXkocmVzcG9uc2VCb2R5KSkge1xuXHRcdFx0XHRzZWxmLmNvbXBsZXRlKG51bGwsIHJlc3BvbnNlQm9keSwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHZhciBlcnIgPSByZXNwb25zZUJvZHkuZXJyb3I7XG5cdFx0XHRpZighZXJyKSB7XG5cdFx0XHRcdGVyciA9IG5ldyBFcnJvckluZm8oJ0Vycm9yIHJlc3BvbnNlIHJlY2VpdmVkIGZyb20gc2VydmVyOiAnICsgc3RhdHVzQ29kZSArICcgYm9keSB3YXM6ICcgKyBVdGlscy5pbnNwZWN0KHJlc3BvbnNlQm9keSksIG51bGwsIHN0YXR1c0NvZGUpO1xuXHRcdFx0fVxuXHRcdFx0c2VsZi5jb21wbGV0ZShlcnIpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG9uUHJvZ3Jlc3MoKSB7XG5cdFx0XHRyZXNwb25zZUJvZHkgPSB4aHIucmVzcG9uc2VUZXh0O1xuXHRcdFx0dmFyIGJvZHlFbmQgPSByZXNwb25zZUJvZHkubGVuZ3RoIC0gMSwgaWR4LCBjaHVuaztcblx0XHRcdHdoaWxlKChzdHJlYW1Qb3MgPCBib2R5RW5kKSAmJiAoaWR4ID0gcmVzcG9uc2VCb2R5LmluZGV4T2YoJ1xcbicsIHN0cmVhbVBvcykpID4gLTEpIHtcblx0XHRcdFx0Y2h1bmsgPSByZXNwb25zZUJvZHkuc2xpY2Uoc3RyZWFtUG9zLCBpZHgpO1xuXHRcdFx0XHRzdHJlYW1Qb3MgPSBpZHggKyAxO1xuXHRcdFx0XHRvbkNodW5rKGNodW5rKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBvbkNodW5rKGNodW5rKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRjaHVuayA9IEpTT04ucGFyc2UoY2h1bmspO1xuXHRcdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRcdHNlbGYuY29tcGxldGUobmV3IEVycm9ySW5mbygnTWFsZm9ybWVkIHJlc3BvbnNlIGJvZHkgZnJvbSBzZXJ2ZXI6ICcgKyBlLm1lc3NhZ2UsIG51bGwsIDQwMCkpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRzZWxmLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25TdHJlYW1FbmQoKSB7XG5cdFx0XHRvblByb2dyZXNzKCk7XG5cdFx0XHRzZWxmLnN0cmVhbUNvbXBsZXRlID0gdHJ1ZTtcblx0XHRcdFV0aWxzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZWxmLmNvbXBsZXRlKCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcmVhZHlTdGF0ZSA9IHhoci5yZWFkeVN0YXRlO1xuXHRcdFx0aWYocmVhZHlTdGF0ZSA8IDMpIHJldHVybjtcblx0XHRcdGlmKHhoci5zdGF0dXMgIT09IDApIHtcblx0XHRcdFx0aWYoc3RhdHVzQ29kZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0c3RhdHVzQ29kZSA9IHhoci5zdGF0dXM7XG5cdFx0XHRcdFx0LyogSUUgcmV0dXJucyAxMjIzIGZvciAyMDQ6IGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzE0NTAgKi9cblx0XHRcdFx0XHRpZihzdGF0dXNDb2RlID09PSAxMjIzKSBzdGF0dXNDb2RlID0gMjA0O1xuXHRcdFx0XHRcdG9uUmVzcG9uc2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZihyZWFkeVN0YXRlID09IDMgJiYgc3RyZWFtaW5nKSB7XG5cdFx0XHRcdFx0b25Qcm9ncmVzcygpO1xuXHRcdFx0XHR9IGVsc2UgaWYocmVhZHlTdGF0ZSA9PSA0KSB7XG5cdFx0XHRcdFx0aWYoc3RyZWFtaW5nKVxuXHRcdFx0XHRcdFx0b25TdHJlYW1FbmQoKTtcblx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRvbkVuZCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHR4aHIuc2VuZChib2R5KTtcblx0fTtcblxuXHRYSFJSZXF1ZXN0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHhociA9IHRoaXMueGhyO1xuXHRcdGlmKHhocikge1xuXHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHhoci5vbmVycm9yID0geGhyLm9uYWJvcnQgPSB4aHIub250aW1lb3V0ID0gbm9vcDtcblx0XHRcdHRoaXMueGhyID0gbnVsbDtcblx0XHRcdHZhciB0aW1lciA9IHRoaXMudGltZXI7XG5cdFx0XHRpZih0aW1lcikge1xuXHRcdFx0XHRjbGVhclRpbWVvdXQodGltZXIpO1xuXHRcdFx0XHR0aGlzLnRpbWVyID0gbnVsbDtcblx0XHRcdH1cblx0XHRcdGlmKCF0aGlzLnJlcXVlc3RDb21wbGV0ZSlcblx0XHRcdFx0eGhyLmFib3J0KCk7XG5cdFx0fVxuXHRcdGRlbGV0ZSBwZW5kaW5nUmVxdWVzdHNbdGhpcy5pZF07XG5cdH07XG5cblx0aWYoUGxhdGZvcm0ueGhyU3VwcG9ydGVkKSB7XG5cdFx0aWYodHlwZW9mIERvbUV2ZW50ID09PSAnb2JqZWN0Jykge1xuXHRcdFx0RG9tRXZlbnQuYWRkVW5sb2FkTGlzdGVuZXIoY2xlYXJQZW5kaW5nUmVxdWVzdHMpO1xuXHRcdH1cblx0XHRpZih0eXBlb2YoSHR0cCkgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRIdHRwLnN1cHBvcnRzQXV0aEhlYWRlcnMgPSB0cnVlO1xuXHRcdFx0SHR0cC5SZXF1ZXN0ID0gZnVuY3Rpb24ocmVzdCwgdXJpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHksIGNhbGxiYWNrKSB7XG5cdFx0XHRcdHZhciByZXEgPSBjcmVhdGVSZXF1ZXN0KHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCBSRVFfU0VORCwgcmVzdCAmJiByZXN0Lm9wdGlvbnMudGltZW91dHMpO1xuXHRcdFx0XHRyZXEub25jZSgnY29tcGxldGUnLCBjYWxsYmFjayk7XG5cdFx0XHRcdHJlcS5leGVjKCk7XG5cdFx0XHRcdHJldHVybiByZXE7XG5cdFx0XHR9O1xuXG5cdFx0XHRIdHRwLmNoZWNrQ29ubmVjdGl2aXR5ID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0XHRcdFx0dmFyIHVwVXJsID0gRGVmYXVsdHMuaW50ZXJuZXRVcFVybDtcblx0XHRcdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX01JQ1JPLCAnKFhIUlJlcXVlc3QpSHR0cC5jaGVja0Nvbm5lY3Rpdml0eSgpJywgJ1NlbmRpbmc7ICcgKyB1cFVybCk7XG5cdFx0XHRcdEh0dHAuUmVxdWVzdChudWxsLCB1cFVybCwgbnVsbCwgbnVsbCwgbnVsbCwgZnVuY3Rpb24oZXJyLCByZXNwb25zZVRleHQpIHtcblx0XHRcdFx0XHR2YXIgcmVzdWx0ID0gKCFlcnIgJiYgcmVzcG9uc2VUZXh0LnJlcGxhY2UoL1xcbi8sICcnKSA9PSAneWVzJyk7XG5cdFx0XHRcdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX01JQ1JPLCAnKFhIUlJlcXVlc3QpSHR0cC5jaGVja0Nvbm5lY3Rpdml0eSgpJywgJ1Jlc3VsdDogJyArIHJlc3VsdCk7XG5cdFx0XHRcdFx0Y2FsbGJhY2sobnVsbCwgcmVzdWx0KTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9O1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBYSFJSZXF1ZXN0O1xufSkoKTtcblxudmFyIFhIUlN0cmVhbWluZ1RyYW5zcG9ydCA9IChmdW5jdGlvbigpIHtcblx0dmFyIHNob3J0TmFtZSA9ICd4aHJfc3RyZWFtaW5nJztcblxuXHQvKiBwdWJsaWMgY29uc3RydWN0b3IgKi9cblx0ZnVuY3Rpb24gWEhSU3RyZWFtaW5nVHJhbnNwb3J0KGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMpIHtcblx0XHRDb21ldFRyYW5zcG9ydC5jYWxsKHRoaXMsIGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMpO1xuXHRcdHRoaXMuc2hvcnROYW1lID0gc2hvcnROYW1lO1xuXHR9XG5cdFV0aWxzLmluaGVyaXRzKFhIUlN0cmVhbWluZ1RyYW5zcG9ydCwgQ29tZXRUcmFuc3BvcnQpO1xuXG5cdFhIUlN0cmVhbWluZ1RyYW5zcG9ydC5pc0F2YWlsYWJsZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBQbGF0Zm9ybS54aHJTdXBwb3J0ZWQgJiYgUGxhdGZvcm0uc3RyZWFtaW5nU3VwcG9ydGVkO1xuXHR9O1xuXG5cdFhIUlN0cmVhbWluZ1RyYW5zcG9ydC50cnlDb25uZWN0ID0gZnVuY3Rpb24oY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcywgY2FsbGJhY2spIHtcblx0XHR2YXIgdHJhbnNwb3J0ID0gbmV3IFhIUlN0cmVhbWluZ1RyYW5zcG9ydChjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zKTtcblx0XHR2YXIgZXJyb3JDYiA9IGZ1bmN0aW9uKGVycikgeyBjYWxsYmFjayh7ZXZlbnQ6IHRoaXMuZXZlbnQsIGVycm9yOiBlcnJ9KTsgfTtcblx0XHR0cmFuc3BvcnQub24oWydmYWlsZWQnLCAnZGlzY29ubmVjdGVkJ10sIGVycm9yQ2IpO1xuXHRcdHRyYW5zcG9ydC5vbigncHJlY29ubmVjdCcsIGZ1bmN0aW9uKCkge1xuXHRcdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX01JTk9SLCAnWEhSU3RyZWFtaW5nVHJhbnNwb3J0LnRyeUNvbm5lY3QoKScsICd2aWFibGUgdHJhbnNwb3J0ICcgKyB0cmFuc3BvcnQpO1xuXHRcdFx0dHJhbnNwb3J0Lm9mZihbJ2ZhaWxlZCcsICdkaXNjb25uZWN0ZWQnXSwgZXJyb3JDYik7XG5cdFx0XHRjYWxsYmFjayhudWxsLCB0cmFuc3BvcnQpO1xuXHRcdH0pO1xuXHRcdHRyYW5zcG9ydC5jb25uZWN0KCk7XG5cdH07XG5cblx0WEhSU3RyZWFtaW5nVHJhbnNwb3J0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAnWEhSU3RyZWFtaW5nVHJhbnNwb3J0OyB1cmk9JyArIHRoaXMuYmFzZVVyaSArICc7IGlzQ29ubmVjdGVkPScgKyB0aGlzLmlzQ29ubmVjdGVkO1xuXHR9O1xuXG5cdFhIUlN0cmVhbWluZ1RyYW5zcG9ydC5wcm90b3R5cGUuY3JlYXRlUmVxdWVzdCA9IFhIUlJlcXVlc3QuY3JlYXRlUmVxdWVzdDtcblxuXHRpZih0eXBlb2YoQ29ubmVjdGlvbk1hbmFnZXIpICE9PSAndW5kZWZpbmVkJyAmJiBYSFJTdHJlYW1pbmdUcmFuc3BvcnQuaXNBdmFpbGFibGUoKSkge1xuXHRcdENvbm5lY3Rpb25NYW5hZ2VyLnN1cHBvcnRlZFRyYW5zcG9ydHNbc2hvcnROYW1lXSA9IFhIUlN0cmVhbWluZ1RyYW5zcG9ydDtcblx0fVxuXG5cdHJldHVybiBYSFJTdHJlYW1pbmdUcmFuc3BvcnQ7XG59KSgpO1xuXG52YXIgWEhSUG9sbGluZ1RyYW5zcG9ydCA9IChmdW5jdGlvbigpIHtcblx0dmFyIHNob3J0TmFtZSA9ICd4aHJfcG9sbGluZyc7XG5cblx0ZnVuY3Rpb24gWEhSUG9sbGluZ1RyYW5zcG9ydChjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zKSB7XG5cdFx0cGFyYW1zLnN0cmVhbSA9IGZhbHNlO1xuXHRcdENvbWV0VHJhbnNwb3J0LmNhbGwodGhpcywgY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcyk7XG5cdFx0dGhpcy5zaG9ydE5hbWUgPSBzaG9ydE5hbWU7XG5cdH1cblx0VXRpbHMuaW5oZXJpdHMoWEhSUG9sbGluZ1RyYW5zcG9ydCwgQ29tZXRUcmFuc3BvcnQpO1xuXG5cdFhIUlBvbGxpbmdUcmFuc3BvcnQuaXNBdmFpbGFibGUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gUGxhdGZvcm0ueGhyU3VwcG9ydGVkO1xuXHR9O1xuXG5cdFhIUlBvbGxpbmdUcmFuc3BvcnQudHJ5Q29ubmVjdCA9IGZ1bmN0aW9uKGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMsIGNhbGxiYWNrKSB7XG5cdFx0dmFyIHRyYW5zcG9ydCA9IG5ldyBYSFJQb2xsaW5nVHJhbnNwb3J0KGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMpO1xuXHRcdHZhciBlcnJvckNiID0gZnVuY3Rpb24oZXJyKSB7IGNhbGxiYWNrKHtldmVudDogdGhpcy5ldmVudCwgZXJyb3I6IGVycn0pOyB9O1xuXHRcdHRyYW5zcG9ydC5vbihbJ2ZhaWxlZCcsICdkaXNjb25uZWN0ZWQnXSwgZXJyb3JDYik7XG5cdFx0dHJhbnNwb3J0Lm9uKCdwcmVjb25uZWN0JywgZnVuY3Rpb24oKSB7XG5cdFx0XHRMb2dnZXIubG9nQWN0aW9uKExvZ2dlci5MT0dfTUlOT1IsICdYSFJQb2xsaW5nVHJhbnNwb3J0LnRyeUNvbm5lY3QoKScsICd2aWFibGUgdHJhbnNwb3J0ICcgKyB0cmFuc3BvcnQpO1xuXHRcdFx0dHJhbnNwb3J0Lm9mZihbJ2ZhaWxlZCcsICdkaXNjb25uZWN0ZWQnXSwgZXJyb3JDYik7XG5cdFx0XHRjYWxsYmFjayhudWxsLCB0cmFuc3BvcnQpO1xuXHRcdH0pO1xuXHRcdHRyYW5zcG9ydC5jb25uZWN0KCk7XG5cdH07XG5cblx0WEhSUG9sbGluZ1RyYW5zcG9ydC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gJ1hIUlBvbGxpbmdUcmFuc3BvcnQ7IHVyaT0nICsgdGhpcy5iYXNlVXJpICsgJzsgaXNDb25uZWN0ZWQ9JyArIHRoaXMuaXNDb25uZWN0ZWQ7XG5cdH07XG5cblx0WEhSUG9sbGluZ1RyYW5zcG9ydC5wcm90b3R5cGUuY3JlYXRlUmVxdWVzdCA9IFhIUlJlcXVlc3QuY3JlYXRlUmVxdWVzdDtcblxuXHRpZih0eXBlb2YoQ29ubmVjdGlvbk1hbmFnZXIpICE9PSAndW5kZWZpbmVkJyAmJiBYSFJQb2xsaW5nVHJhbnNwb3J0LmlzQXZhaWxhYmxlKCkpIHtcblx0XHRDb25uZWN0aW9uTWFuYWdlci5zdXBwb3J0ZWRUcmFuc3BvcnRzW3Nob3J0TmFtZV0gPSBYSFJQb2xsaW5nVHJhbnNwb3J0O1xuXHR9XG5cblx0cmV0dXJuIFhIUlBvbGxpbmdUcmFuc3BvcnQ7XG59KSgpO1xuXG52YXIgSlNPTlBUcmFuc3BvcnQgPSAoZnVuY3Rpb24oKSB7XG5cdHZhciBub29wID0gZnVuY3Rpb24oKSB7fTtcblx0LyogQ2FuJ3QganVzdCB1c2Ugd2luZG93cy5BYmx5LCBhcyB0aGF0IHdvbid0IGV4aXN0IGlmIHVzaW5nIHRoZSBjb21tb25qcyB2ZXJzaW9uLiAqL1xuXHR2YXIgXyA9IHdpbmRvdy5fYWJseWpzX2pzb25wID0ge307XG5cblx0LyogZXhwcmVzcyBzdHJpcHMgb3V0IHBhcmFudGhlc2VzIGZyb20gdGhlIGNhbGxiYWNrIVxuXHQgKiBLbHVkZ2UgdG8gc3RpbGwgYWxvdyBpdHMgcmVzcG9uc2VzIHRvIHdvcmssIHdoaWxlIG5vdCBrZWVwaW5nIHRoZVxuXHQgKiBmdW5jdGlvbiBmb3JtIGZvciBub3JtYWwgdXNlIGFuZCBub3QgY2x1dHRlcmluZyB3aW5kb3cuQWJseVxuXHQgKiBodHRwczovL2dpdGh1Yi5jb20vc3Ryb25nbG9vcC9leHByZXNzL2Jsb2IvbWFzdGVyL2xpYi9yZXNwb25zZS5qcyNMMzA1XG5cdCAqL1xuXHRfLl8gPSBmdW5jdGlvbihpZCkgeyByZXR1cm4gX1snXycgKyBpZF0gfHwgbm9vcDsgfTtcblx0dmFyIGlkQ291bnRlciA9IDE7XG5cdHZhciBpc1N1cHBvcnRlZCA9ICh0eXBlb2YoZG9jdW1lbnQpICE9PSAndW5kZWZpbmVkJyk7XG5cdHZhciBoZWFkID0gaXNTdXBwb3J0ZWQgPyBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdIDogbnVsbDtcblx0dmFyIHNob3J0TmFtZSA9ICdqc29ucCc7XG5cblx0LyogcHVibGljIGNvbnN0cnVjdG9yICovXG5cdGZ1bmN0aW9uIEpTT05QVHJhbnNwb3J0KGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMpIHtcblx0XHRwYXJhbXMuc3RyZWFtID0gZmFsc2U7XG5cdFx0Q29tZXRUcmFuc3BvcnQuY2FsbCh0aGlzLCBjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zKTtcblx0XHR0aGlzLnNob3J0TmFtZSA9IHNob3J0TmFtZTtcblx0fVxuXHRVdGlscy5pbmhlcml0cyhKU09OUFRyYW5zcG9ydCwgQ29tZXRUcmFuc3BvcnQpO1xuXG5cdEpTT05QVHJhbnNwb3J0LmlzQXZhaWxhYmxlID0gZnVuY3Rpb24oKSB7IHJldHVybiBpc1N1cHBvcnRlZDsgfTtcblx0aWYoaXNTdXBwb3J0ZWQpIHtcblx0XHRDb25uZWN0aW9uTWFuYWdlci5zdXBwb3J0ZWRUcmFuc3BvcnRzW3Nob3J0TmFtZV0gPSBKU09OUFRyYW5zcG9ydDtcblx0fVxuXG5cdC8qIGNvbm5lY3Rpdml0eSBjaGVjazsgc2luY2UgdGhpcyBoYXMgYSBoYXJkLWNvZGVkIGNhbGxiYWNrIGlkLFxuXHQgKiB3ZSBqdXN0IG1ha2Ugc3VyZSB0aGF0IHdlIGhhbmRsZSBjb25jdXJyZW50IHJlcXVlc3RzIChidXQgdGhlXG5cdCAqIGNvbm5lY3Rpb25tYW5hZ2VyIHNob3VsZCBlbnN1cmUgdGhpcyBkb2Vzbid0IGhhcHBlbiBhbnl3YXkgKi9cblx0dmFyIGNoZWNrc0luUHJvZ3Jlc3MgPSBudWxsO1xuXHR3aW5kb3cuSlNPTlBUcmFuc3BvcnQgPSBKU09OUFRyYW5zcG9ydFxuXG5cdEpTT05QVHJhbnNwb3J0LnRyeUNvbm5lY3QgPSBmdW5jdGlvbihjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zLCBjYWxsYmFjaykge1xuXHRcdHZhciB0cmFuc3BvcnQgPSBuZXcgSlNPTlBUcmFuc3BvcnQoY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcyk7XG5cdFx0dmFyIGVycm9yQ2IgPSBmdW5jdGlvbihlcnIpIHsgY2FsbGJhY2soe2V2ZW50OiB0aGlzLmV2ZW50LCBlcnJvcjogZXJyfSk7IH07XG5cdFx0dHJhbnNwb3J0Lm9uKFsnZmFpbGVkJywgJ2Rpc2Nvbm5lY3RlZCddLCBlcnJvckNiKTtcblx0XHR0cmFuc3BvcnQub24oJ3ByZWNvbm5lY3QnLCBmdW5jdGlvbigpIHtcblx0XHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19NSU5PUiwgJ0pTT05QVHJhbnNwb3J0LnRyeUNvbm5lY3QoKScsICd2aWFibGUgdHJhbnNwb3J0ICcgKyB0cmFuc3BvcnQpO1xuXHRcdFx0dHJhbnNwb3J0Lm9mZihbJ2ZhaWxlZCcsICdkaXNjb25uZWN0ZWQnXSwgZXJyb3JDYik7XG5cdFx0XHRjYWxsYmFjayhudWxsLCB0cmFuc3BvcnQpO1xuXHRcdH0pO1xuXHRcdHRyYW5zcG9ydC5jb25uZWN0KCk7XG5cdH07XG5cblx0SlNPTlBUcmFuc3BvcnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICdKU09OUFRyYW5zcG9ydDsgdXJpPScgKyB0aGlzLmJhc2VVcmkgKyAnOyBpc0Nvbm5lY3RlZD0nICsgdGhpcy5pc0Nvbm5lY3RlZDtcblx0fTtcblxuXHR2YXIgY3JlYXRlUmVxdWVzdCA9IEpTT05QVHJhbnNwb3J0LnByb3RvdHlwZS5jcmVhdGVSZXF1ZXN0ID0gZnVuY3Rpb24odXJpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHksIHJlcXVlc3RNb2RlLCB0aW1lb3V0cykge1xuXHRcdC8qIEpTT05QIHJlcXVlc3RzIGFyZSB1c2VkIGVpdGhlciB3aXRoIHRoZSBjb250ZXh0IGJlaW5nIGEgcmVhbHRpbWVcblx0XHQgKiB0cmFuc3BvcnQsIG9yIHdpdGggdGltZW91dHMgcGFzc2VkIGluIChmb3Igd2hlbiB1c2VkIGJ5IGEgcmVzdCBjbGllbnQpLFxuXHRcdCAqIG9yIGNvbXBsZXRlbHkgc3RhbmRhbG9uZS4gIFVzZSB0aGUgYXBwcm9wcmlhdGUgdGltZW91dHMgaW4gZWFjaCBjYXNlICovXG5cdFx0dGltZW91dHMgPSAodGhpcyAmJiB0aGlzLnRpbWVvdXRzKSB8fCB0aW1lb3V0cyB8fCBEZWZhdWx0cy5USU1FT1VUUztcblx0XHRyZXR1cm4gbmV3IFJlcXVlc3QodW5kZWZpbmVkLCB1cmksIGhlYWRlcnMsIFV0aWxzLmNvcHkocGFyYW1zKSwgYm9keSwgcmVxdWVzdE1vZGUsIHRpbWVvdXRzKTtcblx0fTtcblxuXHRmdW5jdGlvbiBSZXF1ZXN0KGlkLCB1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSwgcmVxdWVzdE1vZGUsIHRpbWVvdXRzKSB7XG5cdFx0RXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cdFx0aWYoaWQgPT09IHVuZGVmaW5lZCkgaWQgPSBpZENvdW50ZXIrKztcblx0XHR0aGlzLmlkID0gaWQ7XG5cdFx0dGhpcy51cmkgPSB1cmk7XG5cdFx0dGhpcy5wYXJhbXMgPSBwYXJhbXMgfHwge307XG5cdFx0dGhpcy5wYXJhbXMucm5kID0gVXRpbHMucmFuZFN0cigpO1xuXHRcdGlmKGhlYWRlcnMpIHtcblx0XHRcdC8qIEpTT05QIGRvZXNuJ3QgYWxsb3cgaGVhZGVycy4gQ2hlcnJ5LXBpY2sgYSBjb3VwbGUgdG8gdHVybiBpbnRvIHFzIHBhcmFtcyAqL1xuXHRcdFx0aWYoaGVhZGVyc1snWC1BYmx5LVZlcnNpb24nXSkgdGhpcy5wYXJhbXMudiA9IGhlYWRlcnNbJ1gtQWJseS1WZXJzaW9uJ107XG5cdFx0XHRpZihoZWFkZXJzWydYLUFibHktTGliJ10pIHRoaXMucGFyYW1zLmxpYiA9IGhlYWRlcnNbJ1gtQWJseS1MaWInXTtcblx0XHR9XG5cdFx0dGhpcy5ib2R5ID0gYm9keTtcblx0XHR0aGlzLnJlcXVlc3RNb2RlID0gcmVxdWVzdE1vZGU7XG5cdFx0dGhpcy50aW1lb3V0cyA9IHRpbWVvdXRzO1xuXHRcdHRoaXMucmVxdWVzdENvbXBsZXRlID0gZmFsc2U7XG5cdH1cblx0VXRpbHMuaW5oZXJpdHMoUmVxdWVzdCwgRXZlbnRFbWl0dGVyKTtcblxuXHRSZXF1ZXN0LnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGlkID0gdGhpcy5pZCxcblx0XHRcdGJvZHkgPSB0aGlzLmJvZHksXG5cdFx0XHR1cmkgPSB0aGlzLnVyaSxcblx0XHRcdHBhcmFtcyA9IHRoaXMucGFyYW1zLFxuXHRcdFx0c2VsZiA9IHRoaXM7XG5cblx0XHRwYXJhbXMuY2FsbGJhY2sgPSAnX2FibHlqc19qc29ucC5fKCcgKyBpZCArICcpJztcblxuXHRcdHBhcmFtcy5lbnZlbG9wZSA9ICdqc29ucCc7XG5cdFx0aWYoYm9keSlcblx0XHRcdHBhcmFtcy5ib2R5ID0gYm9keTtcblxuXHRcdHZhciBzY3JpcHQgPSB0aGlzLnNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuXHRcdHZhciBzcmMgPSB1cmkgKyBVdGlscy50b1F1ZXJ5U3RyaW5nKHBhcmFtcyk7XG5cdFx0c2NyaXB0LnNyYyA9IHNyYztcblx0XHRpZihzY3JpcHQuc3JjLnNwbGl0KCcvJykuc2xpY2UoLTEpWzBdICE9PSBzcmMuc3BsaXQoJy8nKS5zbGljZSgtMSlbMF0pIHtcblx0XHRcdC8qIFRoZSBzcmMgaGFzIGJlZW4gdHJ1bmNhdGVkLiBDYW4ndCBhYm9ydCwgYnV0IGNhbiBhdCBsZWFzdCBlbWl0IGFuXG5cdFx0XHQgKiBlcnJvciBzbyB0aGUgdXNlciBrbm93cyB3aGF0J3MgZ29uZSB3cm9uZy4gKENhbid0IGNvbXBhcmUgc3RyaW5nc1xuXHRcdFx0ICogZGlyZWN0bHkgYXMgc3JjIG1heSBoYXZlIGEgcG9ydCwgc2NyaXB0LnNyYyB3b24ndCkgKi9cblx0XHRcdExvZ2dlci5sb2dBY3Rpb24oTG9nZ2VyLkxPR19FUlJPUiwgJ0pTT05QIFJlcXVlc3QuZXhlYygpJywgJ1dhcm5pbmc6IHRoZSBicm93c2VyIGFwcGVhcnMgdG8gaGF2ZSB0cnVuY2F0ZWQgdGhlIHNjcmlwdCBVUkkuIFRoaXMgd2lsbCBsaWtlbHkgcmVzdWx0IGluIHRoZSByZXF1ZXN0IGZhaWxpbmcgZHVlIHRvIGFuIHVucGFyc2VhYmxlIGJvZHkgcGFyYW0nKTtcblx0XHR9XG5cdFx0c2NyaXB0LmFzeW5jID0gdHJ1ZTtcblx0XHRzY3JpcHQudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnO1xuXHRcdHNjcmlwdC5jaGFyc2V0ID0gJ1VURi04Jztcblx0XHRzY3JpcHQub25lcnJvciA9IGZ1bmN0aW9uKGVycikge1xuXHRcdFx0c2VsZi5jb21wbGV0ZShuZXcgRXJyb3JJbmZvKCdKU09OUCBzY3JpcHQgZXJyb3IgKGV2ZW50OiAnICsgVXRpbHMuaW5zcGVjdChlcnIpICsgJyknLCBudWxsLCA0MDApKTtcblx0XHR9O1xuXG5cdFx0X1snXycgKyBpZF0gPSBmdW5jdGlvbihtZXNzYWdlKSB7XG5cdFx0XHRpZihtZXNzYWdlLnN0YXR1c0NvZGUpIHtcblx0XHRcdFx0LyogSGFuZGxlIGFzIGVudmVsb3BlZCBqc29ucCwgYXMgYWxsIGpzb25wIHRyYW5zcG9ydCB1c2VzIHNob3VsZCBiZSAqL1xuXHRcdFx0XHR2YXIgcmVzcG9uc2UgPSBtZXNzYWdlLnJlc3BvbnNlO1xuXHRcdFx0XHRpZihtZXNzYWdlLnN0YXR1c0NvZGUgPT0gMjA0KSB7XG5cdFx0XHRcdFx0c2VsZi5jb21wbGV0ZShudWxsLCBudWxsLCBudWxsLCBtZXNzYWdlLnN0YXR1c0NvZGUpO1xuXHRcdFx0XHR9IGVsc2UgaWYoIXJlc3BvbnNlKSB7XG5cdFx0XHRcdFx0c2VsZi5jb21wbGV0ZShuZXcgRXJyb3JJbmZvKCdJbnZhbGlkIHNlcnZlciByZXNwb25zZTogbm8gZW52ZWxvcGUgZGV0ZWN0ZWQnLCBudWxsLCA1MDApKTtcblx0XHRcdFx0fSBlbHNlIGlmKG1lc3NhZ2Uuc3RhdHVzQ29kZSA8IDQwMCB8fCBVdGlscy5pc0FycmF5KHJlc3BvbnNlKSkge1xuXHRcdFx0XHRcdC8qIElmIHJlc3BvbnNlIGlzIGFuIGFycmF5LCBpdCdzIGFuIGFycmF5IG9mIHByb3RvY29sIG1lc3NhZ2VzIC0tIGV2ZW4gaWZcblx0XHRcdFx0XHQgKiBpdCBjb250YWlucyBhbiBlcnJvciBhY3Rpb24gKGhlbmNlIHRoZSBub25zdWNjZXNzIHN0YXR1c2NvZGUpLCB3ZSBjYW5cblx0XHRcdFx0XHQgKiBjb25zaWRlciB0aGUgcmVxdWVzdCB0byBoYXZlIHN1Y2NlZWRlZCwganVzdCBwYXNzIGl0IG9uIHRvXG5cdFx0XHRcdFx0ICogb25Qcm90b2NvbE1lc3NhZ2UgdG8gZGVjaWRlIHdoYXQgdG8gZG8gKi9cblx0XHRcdFx0XHRzZWxmLmNvbXBsZXRlKG51bGwsIHJlc3BvbnNlLCBtZXNzYWdlLmhlYWRlcnMsIG1lc3NhZ2Uuc3RhdHVzQ29kZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFyIGVyciA9IHJlc3BvbnNlLmVycm9yIHx8IG5ldyBFcnJvckluZm8oJ0Vycm9yIHJlc3BvbnNlIHJlY2VpdmVkIGZyb20gc2VydmVyJywgbnVsbCwgbWVzc2FnZS5zdGF0dXNDb2RlKTtcblx0XHRcdFx0XHRzZWxmLmNvbXBsZXRlKGVycik7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8qIEhhbmRsZSBhcyBub24tZW52ZWxvcGVkIC0tIGFzIHdpbGwgYmUgZWcgZnJvbSBhIGN1c3RvbWVyJ3MgYXV0aFVybCBzZXJ2ZXIgKi9cblx0XHRcdFx0c2VsZi5jb21wbGV0ZShudWxsLCBtZXNzYWdlKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0dmFyIHRpbWVvdXQgPSAodGhpcy5yZXF1ZXN0TW9kZSA9PSBDb21ldFRyYW5zcG9ydC5SRVFfU0VORCkgPyB0aGlzLnRpbWVvdXRzLmh0dHBSZXF1ZXN0VGltZW91dCA6IHRoaXMudGltZW91dHMucmVjdlRpbWVvdXQ7XG5cdFx0dGhpcy50aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHNlbGYuYWJvcnQoKTsgfSwgdGltZW91dCk7XG5cdFx0aGVhZC5pbnNlcnRCZWZvcmUoc2NyaXB0LCBoZWFkLmZpcnN0Q2hpbGQpO1xuXHR9O1xuXG5cdFJlcXVlc3QucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24oZXJyLCBib2R5LCBoZWFkZXJzLCBzdGF0dXNDb2RlKSB7XG5cdFx0aGVhZGVycyA9IGhlYWRlcnMgfHwge307XG5cdFx0aWYoIXRoaXMucmVxdWVzdENvbXBsZXRlKSB7XG5cdFx0XHR0aGlzLnJlcXVlc3RDb21wbGV0ZSA9IHRydWU7XG5cdFx0XHR2YXIgY29udGVudFR5cGU7XG5cdFx0XHRpZihib2R5KSB7XG5cdFx0XHRcdGNvbnRlbnRUeXBlID0gKHR5cGVvZihib2R5KSA9PSAnc3RyaW5nJykgPyAndGV4dC9wbGFpbicgOiAnYXBwbGljYXRpb24vanNvbic7XG5cdFx0XHRcdGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddID0gY29udGVudFR5cGU7XG5cdFx0XHRcdHRoaXMuZW1pdCgnZGF0YScsIGJvZHkpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmVtaXQoJ2NvbXBsZXRlJywgZXJyLCBib2R5LCBoZWFkZXJzLCAvKiB1bnBhY2tlZDogKi8gdHJ1ZSwgc3RhdHVzQ29kZSk7XG5cdFx0XHR0aGlzLmRpc3Bvc2UoKTtcblx0XHR9XG5cdH07XG5cblx0UmVxdWVzdC5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmRpc3Bvc2UoKTtcblx0fTtcblxuXHRSZXF1ZXN0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRpbWVyID0gdGhpcy50aW1lcjtcblx0XHRpZih0aW1lcikge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRpbWVyKTtcblx0XHRcdHRoaXMudGltZXIgPSBudWxsO1xuXHRcdH1cblx0XHR2YXIgc2NyaXB0ID0gdGhpcy5zY3JpcHQ7XG5cdFx0aWYoc2NyaXB0LnBhcmVudE5vZGUpIHNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG5cdFx0ZGVsZXRlIF9bdGhpcy5pZF07XG5cdFx0dGhpcy5lbWl0KCdkaXNwb3NlZCcpO1xuXHR9O1xuXG5cdGlmKCFIdHRwLlJlcXVlc3QpIHtcblx0XHRIdHRwLlJlcXVlc3QgPSBmdW5jdGlvbihyZXN0LCB1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSwgY2FsbGJhY2spIHtcblx0XHRcdHZhciByZXEgPSBjcmVhdGVSZXF1ZXN0KHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCBDb21ldFRyYW5zcG9ydC5SRVFfU0VORCwgcmVzdCAmJiByZXN0Lm9wdGlvbnMudGltZW91dHMpO1xuXHRcdFx0cmVxLm9uY2UoJ2NvbXBsZXRlJywgY2FsbGJhY2spO1xuXHRcdFx0VXRpbHMubmV4dFRpY2soZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJlcS5leGVjKCk7XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiByZXE7XG5cdFx0fTtcblxuXHRcdEh0dHAuY2hlY2tDb25uZWN0aXZpdHkgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuXHRcdFx0dmFyIHVwVXJsID0gRGVmYXVsdHMuanNvbnBJbnRlcm5ldFVwVXJsO1xuXG5cdFx0XHRpZihjaGVja3NJblByb2dyZXNzKSB7XG5cdFx0XHRcdGNoZWNrc0luUHJvZ3Jlc3MucHVzaChjYWxsYmFjayk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGNoZWNrc0luUHJvZ3Jlc3MgPSBbY2FsbGJhY2tdO1xuXHRcdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX01JQ1JPLCAnKEpTT05QKUh0dHAuY2hlY2tDb25uZWN0aXZpdHkoKScsICdTZW5kaW5nOyAnICsgdXBVcmwpO1xuXG5cdFx0XHR2YXIgcmVxID0gbmV3IFJlcXVlc3QoJ2lzVGhlSW50ZXJuZXRVcCcsIHVwVXJsLCBudWxsLCBudWxsLCBudWxsLCBDb21ldFRyYW5zcG9ydC5SRVFfU0VORCwgRGVmYXVsdHMuVElNRU9VVFMpO1xuXHRcdFx0cmVxLm9uY2UoJ2NvbXBsZXRlJywgZnVuY3Rpb24oZXJyLCByZXNwb25zZSkge1xuXHRcdFx0XHR2YXIgcmVzdWx0ID0gIWVyciAmJiByZXNwb25zZTtcblx0XHRcdFx0TG9nZ2VyLmxvZ0FjdGlvbihMb2dnZXIuTE9HX01JQ1JPLCAnKEpTT05QKUh0dHAuY2hlY2tDb25uZWN0aXZpdHkoKScsICdSZXN1bHQ6ICcgKyByZXN1bHQpO1xuXHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgY2hlY2tzSW5Qcm9ncmVzcy5sZW5ndGg7IGkrKykgY2hlY2tzSW5Qcm9ncmVzc1tpXShudWxsLCByZXN1bHQpO1xuXHRcdFx0XHRjaGVja3NJblByb2dyZXNzID0gbnVsbDtcblx0XHRcdH0pO1xuXHRcdFx0VXRpbHMubmV4dFRpY2soZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJlcS5leGVjKCk7XG5cdFx0XHR9KTtcblx0XHR9O1xuXHR9XG5cblx0cmV0dXJuIEpTT05QVHJhbnNwb3J0O1xufSkoKTtcblxuQWJseS5tc2dwYWNrID0gbXNncGFjaztcbkFibHkuUmVzdCA9IFJlc3Q7XG5BYmx5LlJlYWx0aW1lID0gUmVhbHRpbWU7XG5SZWFsdGltZS5Db25uZWN0aW9uTWFuYWdlciA9IENvbm5lY3Rpb25NYW5hZ2VyO1xuUmVhbHRpbWUuQnVmZmVyVXRpbHMgPSBSZXN0LkJ1ZmZlclV0aWxzID0gQnVmZmVyVXRpbHM7XG5pZih0eXBlb2YoQ3J5cHRvKSAhPT0gJ3VuZGVmaW5lZCcpIFJlYWx0aW1lLkNyeXB0byA9IFJlc3QuQ3J5cHRvID0gQ3J5cHRvO1xuUmVhbHRpbWUuRGVmYXVsdHMgPSBSZXN0LkRlZmF1bHRzID0gRGVmYXVsdHM7XG5SZWFsdGltZS5IdHRwID0gUmVzdC5IdHRwID0gSHR0cDtcblJlYWx0aW1lLlV0aWxzID0gUmVzdC5VdGlscyA9IFV0aWxzO1xuUmVhbHRpbWUuSHR0cCA9IFJlc3QuSHR0cCA9IEh0dHA7XG5SZWFsdGltZS5NZXNzYWdlID0gUmVzdC5NZXNzYWdlID0gTWVzc2FnZTtcblJlYWx0aW1lLlByZXNlbmNlTWVzc2FnZSA9IFJlc3QuUHJlc2VuY2VNZXNzYWdlID0gUHJlc2VuY2VNZXNzYWdlO1xuUmVhbHRpbWUuUHJvdG9jb2xNZXNzYWdlID0gUmVzdC5Qcm90b2NvbE1lc3NhZ2UgPSBQcm90b2NvbE1lc3NhZ2U7XG5cbm1vZHVsZS5leHBvcnRzID0gQWJseTtcblxuLyogU3lzdGVtSlMgc3VwcG9ydCBmb3IgZGVmYXVsdCBleHBvcnRzIHRvIGJlIGFkZGVkIHRvIHRoZSByb290IG9mIHRoZSBtb2R1bGVcbiAgIGh0dHBzOi8vZ2l0aHViLmNvbS9mcmFua3dhbGxpcy9wbHVnaW4tdHlwZXNjcmlwdC9pc3N1ZXMvMTg1ICovXG5tb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbiIsIiIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlQgIT09IHVuZGVmaW5lZFxuICA/IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gIDogdHlwZWRBcnJheVN1cHBvcnQoKVxuXG4vKlxuICogRXhwb3J0IGtNYXhMZW5ndGggYWZ0ZXIgdHlwZWQgYXJyYXkgc3VwcG9ydCBpcyBkZXRlcm1pbmVkLlxuICovXG5leHBvcnRzLmtNYXhMZW5ndGggPSBrTWF4TGVuZ3RoKClcblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7X19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9fVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIGFyci5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgPyAweDdmZmZmZmZmXG4gICAgOiAweDNmZmZmZmZmXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChrTWF4TGVuZ3RoKCkgPCBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKVxuICB9XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG4gICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gICAgfVxuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZSh0aGlzLCBhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20odGhpcywgYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG4vLyBUT0RPOiBMZWdhY3ksIG5vdCBuZWVkZWQgYW55bW9yZS4gUmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvbi5cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiBmcm9tICh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgcmV0dXJuIGZyb21PYmplY3QodGhhdCwgdmFsdWUpXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20obnVsbCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbiAgQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICYmXG4gICAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgICAvLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jICh0aGF0LCBzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHRoYXQsIHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgIHRoYXRbaV0gPSAwXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImVuY29kaW5nXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIHRoYXQgPSB0aGF0LnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgYXJyYXkuYnl0ZUxlbmd0aCAvLyB0aGlzIHRocm93cyBpZiBgYXJyYXlgIGlzIG5vdCBhIHZhbGlkIEFycmF5QnVmZmVyXG5cbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBhcnJheVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSlcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW4pXG5cbiAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGF0XG4gICAgfVxuXG4gICAgb2JqLmNvcHkodGhhdCwgMCwgMCwgbGVuKVxuICAgIHJldHVybiB0aGF0XG4gIH1cblxuICBpZiAob2JqKSB7XG4gICAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG9iai5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgJ2xlbmd0aCcgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IGlzbmFuKG9iai5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgMClcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmouZGF0YSlcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJylcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGgoKWAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmdcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhlIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgYW5kIGBpcy1idWZmZXJgIChpbiBTYWZhcmkgNS03KSB0byBkZXRlY3Rcbi8vIEJ1ZmZlciBpbnN0YW5jZXMuXG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChpc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmXG4gICAgICAgIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAgIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgKytpKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuICB2YXIgaVxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKGNvZGUgPCAyNTYpIHtcbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IHV0ZjhUb0J5dGVzKG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZykudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gaXNuYW4gKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB2YWwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIHBsYWNlSG9sZGVyc0NvdW50IChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG4gIC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcbiAgLy8gcmVwcmVzZW50IG9uZSBieXRlXG4gIC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuICAvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXG4gIHJldHVybiBiNjRbbGVuIC0gMl0gPT09ICc9JyA/IDIgOiBiNjRbbGVuIC0gMV0gPT09ICc9JyA/IDEgOiAwXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICAvLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbiAgcmV0dXJuIGI2NC5sZW5ndGggKiAzIC8gNCAtIHBsYWNlSG9sZGVyc0NvdW50KGI2NClcbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgaSwgaiwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFyclxuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuICBwbGFjZUhvbGRlcnMgPSBwbGFjZUhvbGRlcnNDb3VudChiNjQpXG5cbiAgYXJyID0gbmV3IEFycihsZW4gKiAzIC8gNCAtIHBsYWNlSG9sZGVycylcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gbGVuIC0gNCA6IGxlblxuXG4gIHZhciBMID0gMFxuXG4gIGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbDsgaSArPSA0LCBqICs9IDMpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICsgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9ICh1aW50OFtpXSA8PCAxNikgKyAodWludDhbaSArIDFdIDw8IDgpICsgKHVpbnQ4W2kgKyAyXSlcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIG91dHB1dCA9ICcnXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKSkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA+PiAyXVxuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdXG4gICAgb3V0cHV0ICs9ICc9PSdcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgKHVpbnQ4W2xlbiAtIDFdKVxuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDEwXVxuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gJz0nXG4gIH1cblxuICBwYXJ0cy5wdXNoKG91dHB1dClcblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cbiIsImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcbiAgaWYgKCFpc051bWJlcihuKSB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzT2JqZWN0KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKSB7XG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50LiAoJyArIGVyICsgJyknKTtcbiAgICAgICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXIpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgICAgY2FzZSAxOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoaGFuZGxlcikpIHtcbiAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICBpZiAodGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKVxuICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGxpc3RlbmVyLmxpc3RlbmVyKSA/XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICBlbHNlIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2VcbiAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07XG5cbiAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkgJiYgIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX21heExpc3RlbmVycykpIHtcbiAgICAgIG0gPSB0aGlzLl9tYXhMaXN0ZW5lcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9XG5cbiAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG4gICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZS50cmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIGluIElFIDEwXG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgdmFyIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBnLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHRoaXMub24odHlwZSwgZyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBlbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWZmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBsaXN0LCBwb3NpdGlvbiwgbGVuZ3RoLCBpO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICBwb3NpdGlvbiA9IC0xO1xuXG4gIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fFxuICAgICAgKGlzRnVuY3Rpb24obGlzdC5saXN0ZW5lcikgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxpc3QpKSB7XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XG4gICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0LnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIga2V5LCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICBpZiAoIXRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAoa2V5IGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcnMpKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICB9IGVsc2UgaWYgKGxpc3RlbmVycykge1xuICAgIC8vIExJRk8gb3JkZXJcbiAgICB3aGlsZSAobGlzdGVuZXJzLmxlbmd0aClcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2xpc3RlbmVycy5sZW5ndGggLSAxXSk7XG4gIH1cbiAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IFtdO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIGVsc2VcbiAgICByZXQgPSB0aGlzLl9ldmVudHNbdHlwZV0uc2xpY2UoKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKHRoaXMuX2V2ZW50cykge1xuICAgIHZhciBldmxpc3RlbmVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oZXZsaXN0ZW5lcikpXG4gICAgICByZXR1cm4gMTtcbiAgICBlbHNlIGlmIChldmxpc3RlbmVyKVxuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICB9XG4gIHJldHVybiAwO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG59O1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiIWZ1bmN0aW9uKGUsdCl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9dCgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW10sdCk6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/ZXhwb3J0cy5QdWJOdWI9dCgpOmUuUHViTnViPXQoKX0odGhpcyxmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihlKXtmdW5jdGlvbiB0KHIpe2lmKG5bcl0pcmV0dXJuIG5bcl0uZXhwb3J0czt2YXIgaT1uW3JdPXtleHBvcnRzOnt9LGlkOnIsbG9hZGVkOiExfTtyZXR1cm4gZVtyXS5jYWxsKGkuZXhwb3J0cyxpLGkuZXhwb3J0cyx0KSxpLmxvYWRlZD0hMCxpLmV4cG9ydHN9dmFyIG49e307cmV0dXJuIHQubT1lLHQuYz1uLHQucD1cIlwiLHQoMCl9KFtmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19ZnVuY3Rpb24gaShlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gbyhlLHQpe2lmKCFlKXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hdHx8XCJvYmplY3RcIiE9dHlwZW9mIHQmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQ/ZTp0fWZ1bmN0aW9uIHMoZSx0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0JiZudWxsIT09dCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIit0eXBlb2YgdCk7ZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh0JiZ0LnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOmUsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksdCYmKE9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3Quc2V0UHJvdG90eXBlT2YoZSx0KTplLl9fcHJvdG9fXz10KX1mdW5jdGlvbiBhKGUpe2lmKCFuYXZpZ2F0b3J8fCFuYXZpZ2F0b3Iuc2VuZEJlYWNvbilyZXR1cm4hMTtuYXZpZ2F0b3Iuc2VuZEJlYWNvbihlKX1PYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgdT1uKDEpLGM9cih1KSxsPW4oNDApLGg9cihsKSxmPW4oNDEpLGQ9cihmKSxwPW4oNDIpLGc9KG4oOCksZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdChlKXtpKHRoaXMsdCk7dmFyIG49ZS5saXN0ZW5Ub0Jyb3dzZXJOZXR3b3JrRXZlbnRzLHI9dm9pZCAwPT09bnx8bjtlLmRiPWQuZGVmYXVsdCxlLnNka0ZhbWlseT1cIldlYlwiLGUubmV0d29ya2luZz1uZXcgaC5kZWZhdWx0KHtnZXQ6cC5nZXQscG9zdDpwLnBvc3Qsc2VuZEJlYWNvbjphfSk7dmFyIHM9byh0aGlzLCh0Ll9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKHQpKS5jYWxsKHRoaXMsZSkpO3JldHVybiByJiYod2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJvZmZsaW5lXCIsZnVuY3Rpb24oKXtzLm5ldHdvcmtEb3duRGV0ZWN0ZWQoKX0pLHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib25saW5lXCIsZnVuY3Rpb24oKXtzLm5ldHdvcmtVcERldGVjdGVkKCl9KSksc31yZXR1cm4gcyh0LGUpLHR9KGMuZGVmYXVsdCkpO3QuZGVmYXVsdD1nLGUuZXhwb3J0cz10LmRlZmF1bHR9LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKGUpe2lmKGUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgdD17fTtpZihudWxsIT1lKWZvcih2YXIgbiBpbiBlKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLG4pJiYodFtuXT1lW25dKTtyZXR1cm4gdC5kZWZhdWx0PWUsdH1mdW5jdGlvbiBpKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX1mdW5jdGlvbiBvKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1PYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcz1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0KXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIHI9dFtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsci5rZXkscil9fXJldHVybiBmdW5jdGlvbih0LG4scil7cmV0dXJuIG4mJmUodC5wcm90b3R5cGUsbiksciYmZSh0LHIpLHR9fSgpLGE9bigyKSx1PWkoYSksYz1uKDcpLGw9aShjKSxoPW4oOSksZj1pKGgpLGQ9bigxMSkscD1pKGQpLGc9bigxMikseT1pKGcpLHY9bigxOCksYj1pKHYpLF89bigxOSksbT1yKF8pLGs9bigyMCksUD1yKGspLFM9bigyMSksTz1yKFMpLHc9bigyMiksVD1yKHcpLEM9bigyMyksTT1yKEMpLHg9bigyNCksRT1yKHgpLE49bigyNSksUj1yKE4pLEs9bigyNiksQT1yKEspLGo9bigyNyksRD1yKGopLEc9bigyOCksVT1yKEcpLEI9bigyOSksST1yKEIpLEg9bigzMCksTD1yKEgpLHE9bigzMSksRj1yKHEpLHo9bigzMiksWD1yKHopLFc9bigzMyksVj1yKFcpLEo9bigzNCksJD1yKEopLFE9bigzNSksWT1yKFEpLFo9bigzNiksZWU9cihaKSx0ZT1uKDM3KSxuZT1yKHRlKSxyZT1uKDM4KSxpZT1yKHJlKSxvZT1uKDE1KSxzZT1yKG9lKSxhZT1uKDM5KSx1ZT1yKGFlKSxjZT1uKDE2KSxsZT1pKGNlKSxoZT1uKDEzKSxmZT1pKGhlKSxkZT0obig4KSxmdW5jdGlvbigpe2Z1bmN0aW9uIGUodCl7dmFyIG49dGhpcztvKHRoaXMsZSk7dmFyIHI9dC5kYixpPXQubmV0d29ya2luZyxzPXRoaXMuX2NvbmZpZz1uZXcgbC5kZWZhdWx0KHtzZXR1cDp0LGRiOnJ9KSxhPW5ldyBmLmRlZmF1bHQoe2NvbmZpZzpzfSk7aS5pbml0KHMpO3ZhciB1PXtjb25maWc6cyxuZXR3b3JraW5nOmksY3J5cHRvOmF9LGM9Yi5kZWZhdWx0LmJpbmQodGhpcyx1LHNlKSxoPWIuZGVmYXVsdC5iaW5kKHRoaXMsdSxVKSxkPWIuZGVmYXVsdC5iaW5kKHRoaXMsdSxMKSxnPWIuZGVmYXVsdC5iaW5kKHRoaXMsdSxYKSx2PWIuZGVmYXVsdC5iaW5kKHRoaXMsdSx1ZSksXz10aGlzLl9saXN0ZW5lck1hbmFnZXI9bmV3IHkuZGVmYXVsdCxrPW5ldyBwLmRlZmF1bHQoe3RpbWVFbmRwb2ludDpjLGxlYXZlRW5kcG9pbnQ6aCxoZWFydGJlYXRFbmRwb2ludDpkLHNldFN0YXRlRW5kcG9pbnQ6ZyxzdWJzY3JpYmVFbmRwb2ludDp2LGNyeXB0bzp1LmNyeXB0byxjb25maWc6dS5jb25maWcsbGlzdGVuZXJNYW5hZ2VyOl99KTt0aGlzLmFkZExpc3RlbmVyPV8uYWRkTGlzdGVuZXIuYmluZChfKSx0aGlzLnJlbW92ZUxpc3RlbmVyPV8ucmVtb3ZlTGlzdGVuZXIuYmluZChfKSx0aGlzLnJlbW92ZUFsbExpc3RlbmVycz1fLnJlbW92ZUFsbExpc3RlbmVycy5iaW5kKF8pLHRoaXMuY2hhbm5lbEdyb3Vwcz17bGlzdEdyb3VwczpiLmRlZmF1bHQuYmluZCh0aGlzLHUsVCksbGlzdENoYW5uZWxzOmIuZGVmYXVsdC5iaW5kKHRoaXMsdSxNKSxhZGRDaGFubmVsczpiLmRlZmF1bHQuYmluZCh0aGlzLHUsbSkscmVtb3ZlQ2hhbm5lbHM6Yi5kZWZhdWx0LmJpbmQodGhpcyx1LFApLGRlbGV0ZUdyb3VwOmIuZGVmYXVsdC5iaW5kKHRoaXMsdSxPKX0sdGhpcy5wdXNoPXthZGRDaGFubmVsczpiLmRlZmF1bHQuYmluZCh0aGlzLHUsRSkscmVtb3ZlQ2hhbm5lbHM6Yi5kZWZhdWx0LmJpbmQodGhpcyx1LFIpLGRlbGV0ZURldmljZTpiLmRlZmF1bHQuYmluZCh0aGlzLHUsRCksbGlzdENoYW5uZWxzOmIuZGVmYXVsdC5iaW5kKHRoaXMsdSxBKX0sdGhpcy5oZXJlTm93PWIuZGVmYXVsdC5iaW5kKHRoaXMsdSxWKSx0aGlzLndoZXJlTm93PWIuZGVmYXVsdC5iaW5kKHRoaXMsdSxJKSx0aGlzLmdldFN0YXRlPWIuZGVmYXVsdC5iaW5kKHRoaXMsdSxGKSx0aGlzLnNldFN0YXRlPWsuYWRhcHRTdGF0ZUNoYW5nZS5iaW5kKGspLHRoaXMuZ3JhbnQ9Yi5kZWZhdWx0LmJpbmQodGhpcyx1LFkpLHRoaXMuYXVkaXQ9Yi5kZWZhdWx0LmJpbmQodGhpcyx1LCQpLHRoaXMucHVibGlzaD1iLmRlZmF1bHQuYmluZCh0aGlzLHUsZWUpLHRoaXMuZmlyZT1mdW5jdGlvbihlLHQpe2UucmVwbGljYXRlPSExLGUuc3RvcmVJbkhpc3Rvcnk9ITEsbi5wdWJsaXNoKGUsdCl9LHRoaXMuaGlzdG9yeT1iLmRlZmF1bHQuYmluZCh0aGlzLHUsbmUpLHRoaXMuZmV0Y2hNZXNzYWdlcz1iLmRlZmF1bHQuYmluZCh0aGlzLHUsaWUpLHRoaXMudGltZT1jLHRoaXMuc3Vic2NyaWJlPWsuYWRhcHRTdWJzY3JpYmVDaGFuZ2UuYmluZChrKSx0aGlzLnVuc3Vic2NyaWJlPWsuYWRhcHRVbnN1YnNjcmliZUNoYW5nZS5iaW5kKGspLHRoaXMuZGlzY29ubmVjdD1rLmRpc2Nvbm5lY3QuYmluZChrKSx0aGlzLnJlY29ubmVjdD1rLnJlY29ubmVjdC5iaW5kKGspLHRoaXMuZGVzdHJveT1mdW5jdGlvbihlKXtrLnVuc3Vic2NyaWJlQWxsKGUpLGsuZGlzY29ubmVjdCgpfSx0aGlzLnN0b3A9dGhpcy5kZXN0cm95LHRoaXMudW5zdWJzY3JpYmVBbGw9ay51bnN1YnNjcmliZUFsbC5iaW5kKGspLHRoaXMuZ2V0U3Vic2NyaWJlZENoYW5uZWxzPWsuZ2V0U3Vic2NyaWJlZENoYW5uZWxzLmJpbmQoayksdGhpcy5nZXRTdWJzY3JpYmVkQ2hhbm5lbEdyb3Vwcz1rLmdldFN1YnNjcmliZWRDaGFubmVsR3JvdXBzLmJpbmQoayksdGhpcy5lbmNyeXB0PWEuZW5jcnlwdC5iaW5kKGEpLHRoaXMuZGVjcnlwdD1hLmRlY3J5cHQuYmluZChhKSx0aGlzLmdldEF1dGhLZXk9dS5jb25maWcuZ2V0QXV0aEtleS5iaW5kKHUuY29uZmlnKSx0aGlzLnNldEF1dGhLZXk9dS5jb25maWcuc2V0QXV0aEtleS5iaW5kKHUuY29uZmlnKSx0aGlzLnNldENpcGhlcktleT11LmNvbmZpZy5zZXRDaXBoZXJLZXkuYmluZCh1LmNvbmZpZyksdGhpcy5nZXRVVUlEPXUuY29uZmlnLmdldFVVSUQuYmluZCh1LmNvbmZpZyksdGhpcy5zZXRVVUlEPXUuY29uZmlnLnNldFVVSUQuYmluZCh1LmNvbmZpZyksdGhpcy5nZXRGaWx0ZXJFeHByZXNzaW9uPXUuY29uZmlnLmdldEZpbHRlckV4cHJlc3Npb24uYmluZCh1LmNvbmZpZyksdGhpcy5zZXRGaWx0ZXJFeHByZXNzaW9uPXUuY29uZmlnLnNldEZpbHRlckV4cHJlc3Npb24uYmluZCh1LmNvbmZpZyl9cmV0dXJuIHMoZSxbe2tleTpcImdldFZlcnNpb25cIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9jb25maWcuZ2V0VmVyc2lvbigpfX0se2tleTpcIm5ldHdvcmtEb3duRGV0ZWN0ZWRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuX2xpc3RlbmVyTWFuYWdlci5hbm5vdW5jZU5ldHdvcmtEb3duKCksdGhpcy5fY29uZmlnLnJlc3RvcmU/dGhpcy5kaXNjb25uZWN0KCk6dGhpcy5kZXN0cm95KCEwKX19LHtrZXk6XCJuZXR3b3JrVXBEZXRlY3RlZFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5fbGlzdGVuZXJNYW5hZ2VyLmFubm91bmNlTmV0d29ya1VwKCksdGhpcy5yZWNvbm5lY3QoKX19XSxbe2tleTpcImdlbmVyYXRlVVVJRFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHUuZGVmYXVsdC52NCgpfX1dKSxlfSgpKTtkZS5PUEVSQVRJT05TPWxlLmRlZmF1bHQsZGUuQ0FURUdPUklFUz1mZS5kZWZhdWx0LHQuZGVmYXVsdD1kZSxlLmV4cG9ydHM9dC5kZWZhdWx0fSxmdW5jdGlvbihlLHQsbil7dmFyIHI9bigzKSxpPW4oNiksbz1pO28udjE9cixvLnY0PWksZS5leHBvcnRzPW99LGZ1bmN0aW9uKGUsdCxuKXtmdW5jdGlvbiByKGUsdCxuKXt2YXIgcj10JiZufHwwLGk9dHx8W107ZT1lfHx7fTt2YXIgcz12b2lkIDAhPT1lLmNsb2Nrc2VxP2UuY2xvY2tzZXE6dSxoPXZvaWQgMCE9PWUubXNlY3M/ZS5tc2VjczoobmV3IERhdGUpLmdldFRpbWUoKSxmPXZvaWQgMCE9PWUubnNlY3M/ZS5uc2VjczpsKzEsZD1oLWMrKGYtbCkvMWU0O2lmKGQ8MCYmdm9pZCAwPT09ZS5jbG9ja3NlcSYmKHM9cysxJjE2MzgzKSwoZDwwfHxoPmMpJiZ2b2lkIDA9PT1lLm5zZWNzJiYoZj0wKSxmPj0xZTQpdGhyb3cgbmV3IEVycm9yKFwidXVpZC52MSgpOiBDYW4ndCBjcmVhdGUgbW9yZSB0aGFuIDEwTSB1dWlkcy9zZWNcIik7Yz1oLGw9Zix1PXMsaCs9MTIyMTkyOTI4ZTU7dmFyIHA9KDFlNCooMjY4NDM1NDU1JmgpK2YpJTQyOTQ5NjcyOTY7aVtyKytdPXA+Pj4yNCYyNTUsaVtyKytdPXA+Pj4xNiYyNTUsaVtyKytdPXA+Pj44JjI1NSxpW3IrK109MjU1JnA7dmFyIGc9aC80Mjk0OTY3Mjk2KjFlNCYyNjg0MzU0NTU7aVtyKytdPWc+Pj44JjI1NSxpW3IrK109MjU1JmcsaVtyKytdPWc+Pj4yNCYxNXwxNixpW3IrK109Zz4+PjE2JjI1NSxpW3IrK109cz4+Pjh8MTI4LGlbcisrXT0yNTUmcztmb3IodmFyIHk9ZS5ub2RlfHxhLHY9MDt2PDY7Kyt2KWlbcit2XT15W3ZdO3JldHVybiB0P3Q6byhpKX12YXIgaT1uKDQpLG89big1KSxzPWkoKSxhPVsxfHNbMF0sc1sxXSxzWzJdLHNbM10sc1s0XSxzWzVdXSx1PTE2MzgzJihzWzZdPDw4fHNbN10pLGM9MCxsPTA7ZS5leHBvcnRzPXJ9LGZ1bmN0aW9uKGUsdCl7KGZ1bmN0aW9uKHQpe3ZhciBuLHI9dC5jcnlwdG98fHQubXNDcnlwdG87aWYociYmci5nZXRSYW5kb21WYWx1ZXMpe3ZhciBpPW5ldyBVaW50OEFycmF5KDE2KTtuPWZ1bmN0aW9uKCl7cmV0dXJuIHIuZ2V0UmFuZG9tVmFsdWVzKGkpLGl9fWlmKCFuKXt2YXIgbz1uZXcgQXJyYXkoMTYpO249ZnVuY3Rpb24oKXtmb3IodmFyIGUsdD0wO3Q8MTY7dCsrKTA9PSgzJnQpJiYoZT00Mjk0OTY3Mjk2Kk1hdGgucmFuZG9tKCkpLG9bdF09ZT4+PigoMyZ0KTw8MykmMjU1O3JldHVybiBvfX1lLmV4cG9ydHM9bn0pLmNhbGwodCxmdW5jdGlvbigpe3JldHVybiB0aGlzfSgpKX0sZnVuY3Rpb24oZSx0KXtmdW5jdGlvbiBuKGUsdCl7dmFyIG49dHx8MCxpPXI7cmV0dXJuIGlbZVtuKytdXStpW2VbbisrXV0raVtlW24rK11dK2lbZVtuKytdXStcIi1cIitpW2VbbisrXV0raVtlW24rK11dK1wiLVwiK2lbZVtuKytdXStpW2VbbisrXV0rXCItXCIraVtlW24rK11dK2lbZVtuKytdXStcIi1cIitpW2VbbisrXV0raVtlW24rK11dK2lbZVtuKytdXStpW2VbbisrXV0raVtlW24rK11dK2lbZVtuKytdXX1mb3IodmFyIHI9W10saT0wO2k8MjU2OysraSlyW2ldPShpKzI1NikudG9TdHJpbmcoMTYpLnN1YnN0cigxKTtlLmV4cG9ydHM9bn0sZnVuY3Rpb24oZSx0LG4pe2Z1bmN0aW9uIHIoZSx0LG4pe3ZhciByPXQmJm58fDA7XCJzdHJpbmdcIj09dHlwZW9mIGUmJih0PVwiYmluYXJ5XCI9PWU/bmV3IEFycmF5KDE2KTpudWxsLGU9bnVsbCksZT1lfHx7fTt2YXIgcz1lLnJhbmRvbXx8KGUucm5nfHxpKSgpO2lmKHNbNl09MTUmc1s2XXw2NCxzWzhdPTYzJnNbOF18MTI4LHQpZm9yKHZhciBhPTA7YTwxNjsrK2EpdFtyK2FdPXNbYV07cmV0dXJuIHR8fG8ocyl9dmFyIGk9big0KSxvPW4oNSk7ZS5leHBvcnRzPXJ9LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1PYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgaT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0KXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIHI9dFtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsci5rZXkscil9fXJldHVybiBmdW5jdGlvbih0LG4scil7cmV0dXJuIG4mJmUodC5wcm90b3R5cGUsbiksciYmZSh0LHIpLHR9fSgpLG89bigyKSxzPWZ1bmN0aW9uKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX0obyksYT0obig4KSxmdW5jdGlvbigpe2Z1bmN0aW9uIGUodCl7dmFyIG49dC5zZXR1cCxpPXQuZGI7cih0aGlzLGUpLHRoaXMuX2RiPWksdGhpcy5pbnN0YW5jZUlkPVwicG4tXCIrcy5kZWZhdWx0LnY0KCksdGhpcy5zZWNyZXRLZXk9bi5zZWNyZXRLZXl8fG4uc2VjcmV0X2tleSx0aGlzLnN1YnNjcmliZUtleT1uLnN1YnNjcmliZUtleXx8bi5zdWJzY3JpYmVfa2V5LHRoaXMucHVibGlzaEtleT1uLnB1Ymxpc2hLZXl8fG4ucHVibGlzaF9rZXksdGhpcy5zZGtGYW1pbHk9bi5zZGtGYW1pbHksdGhpcy5wYXJ0bmVySWQ9bi5wYXJ0bmVySWQsdGhpcy5zZXRBdXRoS2V5KG4uYXV0aEtleSksdGhpcy5zZXRDaXBoZXJLZXkobi5jaXBoZXJLZXkpLHRoaXMuc2V0RmlsdGVyRXhwcmVzc2lvbihuLmZpbHRlckV4cHJlc3Npb24pLHRoaXMub3JpZ2luPW4ub3JpZ2lufHxcInB1YnN1Yi5wdWJudWIuY29tXCIsdGhpcy5zZWN1cmU9bi5zc2x8fCExLHRoaXMucmVzdG9yZT1uLnJlc3RvcmV8fCExLHRoaXMucHJveHk9bi5wcm94eSx0aGlzLmtlZXBBbGl2ZT1uLmtlZXBBbGl2ZSx0aGlzLmtlZXBBbGl2ZVNldHRpbmdzPW4ua2VlcEFsaXZlU2V0dGluZ3MsXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGxvY2F0aW9uJiZcImh0dHBzOlwiPT09bG9jYXRpb24ucHJvdG9jb2wmJih0aGlzLnNlY3VyZT0hMCksdGhpcy5sb2dWZXJib3NpdHk9bi5sb2dWZXJib3NpdHl8fCExLHRoaXMuc3VwcHJlc3NMZWF2ZUV2ZW50cz1uLnN1cHByZXNzTGVhdmVFdmVudHN8fCExLHRoaXMuYW5ub3VuY2VGYWlsZWRIZWFydGJlYXRzPW4uYW5ub3VuY2VGYWlsZWRIZWFydGJlYXRzfHwhMCx0aGlzLmFubm91bmNlU3VjY2Vzc2Z1bEhlYXJ0YmVhdHM9bi5hbm5vdW5jZVN1Y2Nlc3NmdWxIZWFydGJlYXRzfHwhMSx0aGlzLnVzZUluc3RhbmNlSWQ9bi51c2VJbnN0YW5jZUlkfHwhMSx0aGlzLnVzZVJlcXVlc3RJZD1uLnVzZVJlcXVlc3RJZHx8ITEsdGhpcy5yZXF1ZXN0TWVzc2FnZUNvdW50VGhyZXNob2xkPW4ucmVxdWVzdE1lc3NhZ2VDb3VudFRocmVzaG9sZCx0aGlzLnNldFRyYW5zYWN0aW9uVGltZW91dChuLnRyYW5zYWN0aW9uYWxSZXF1ZXN0VGltZW91dHx8MTVlMyksdGhpcy5zZXRTdWJzY3JpYmVUaW1lb3V0KG4uc3Vic2NyaWJlUmVxdWVzdFRpbWVvdXR8fDMxZTQpLHRoaXMuc2V0U2VuZEJlYWNvbkNvbmZpZyhuLnVzZVNlbmRCZWFjb258fCEwKSx0aGlzLnNldFByZXNlbmNlVGltZW91dChuLnByZXNlbmNlVGltZW91dHx8MzAwKSxuLmhlYXJ0YmVhdEludGVydmFsJiZ0aGlzLnNldEhlYXJ0YmVhdEludGVydmFsKG4uaGVhcnRiZWF0SW50ZXJ2YWwpLHRoaXMuc2V0VVVJRCh0aGlzLl9kZWNpZGVVVUlEKG4udXVpZCkpfXJldHVybiBpKGUsW3trZXk6XCJnZXRBdXRoS2V5XCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hdXRoS2V5fX0se2tleTpcInNldEF1dGhLZXlcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5hdXRoS2V5PWUsdGhpc319LHtrZXk6XCJzZXRDaXBoZXJLZXlcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5jaXBoZXJLZXk9ZSx0aGlzfX0se2tleTpcImdldFVVSURcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLlVVSUR9fSx7a2V5Olwic2V0VVVJRFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLl9kYiYmdGhpcy5fZGIuc2V0JiZ0aGlzLl9kYi5zZXQodGhpcy5zdWJzY3JpYmVLZXkrXCJ1dWlkXCIsZSksdGhpcy5VVUlEPWUsdGhpc319LHtrZXk6XCJnZXRGaWx0ZXJFeHByZXNzaW9uXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5maWx0ZXJFeHByZXNzaW9ufX0se2tleTpcInNldEZpbHRlckV4cHJlc3Npb25cIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5maWx0ZXJFeHByZXNzaW9uPWUsdGhpc319LHtrZXk6XCJnZXRQcmVzZW5jZVRpbWVvdXRcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9wcmVzZW5jZVRpbWVvdXR9fSx7a2V5Olwic2V0UHJlc2VuY2VUaW1lb3V0XCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuX3ByZXNlbmNlVGltZW91dD1lLHRoaXMuc2V0SGVhcnRiZWF0SW50ZXJ2YWwodGhpcy5fcHJlc2VuY2VUaW1lb3V0LzItMSksdGhpc319LHtrZXk6XCJnZXRIZWFydGJlYXRJbnRlcnZhbFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2hlYXJ0YmVhdEludGVydmFsfX0se2tleTpcInNldEhlYXJ0YmVhdEludGVydmFsXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuX2hlYXJ0YmVhdEludGVydmFsPWUsdGhpc319LHtrZXk6XCJnZXRTdWJzY3JpYmVUaW1lb3V0XCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc3Vic2NyaWJlUmVxdWVzdFRpbWVvdXR9fSx7a2V5Olwic2V0U3Vic2NyaWJlVGltZW91dFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLl9zdWJzY3JpYmVSZXF1ZXN0VGltZW91dD1lLHRoaXN9fSx7a2V5OlwiZ2V0VHJhbnNhY3Rpb25UaW1lb3V0XCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fdHJhbnNhY3Rpb25hbFJlcXVlc3RUaW1lb3V0fX0se2tleTpcInNldFRyYW5zYWN0aW9uVGltZW91dFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLl90cmFuc2FjdGlvbmFsUmVxdWVzdFRpbWVvdXQ9ZSx0aGlzfX0se2tleTpcImlzU2VuZEJlYWNvbkVuYWJsZWRcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl91c2VTZW5kQmVhY29ufX0se2tleTpcInNldFNlbmRCZWFjb25Db25maWdcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5fdXNlU2VuZEJlYWNvbj1lLHRoaXN9fSx7a2V5OlwiZ2V0VmVyc2lvblwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuXCI0LjguMFwifX0se2tleTpcIl9kZWNpZGVVVUlEXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIGU/ZTp0aGlzLl9kYiYmdGhpcy5fZGIuZ2V0JiZ0aGlzLl9kYi5nZXQodGhpcy5zdWJzY3JpYmVLZXkrXCJ1dWlkXCIpP3RoaXMuX2RiLmdldCh0aGlzLnN1YnNjcmliZUtleStcInV1aWRcIik6XCJwbi1cIitzLmRlZmF1bHQudjQoKX19XSksZX0oKSk7dC5kZWZhdWx0PWEsZS5leHBvcnRzPXQuZGVmYXVsdH0sZnVuY3Rpb24oZSx0KXtcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9e319LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX1mdW5jdGlvbiBpKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1PYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgbz1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0KXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIHI9dFtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsci5rZXkscil9fXJldHVybiBmdW5jdGlvbih0LG4scil7cmV0dXJuIG4mJmUodC5wcm90b3R5cGUsbiksciYmZSh0LHIpLHR9fSgpLHM9big3KSxhPShyKHMpLG4oMTApKSx1PXIoYSksYz1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCl7dmFyIG49dC5jb25maWc7aSh0aGlzLGUpLHRoaXMuX2NvbmZpZz1uLHRoaXMuX2l2PVwiMDEyMzQ1Njc4OTAxMjM0NVwiLHRoaXMuX2FsbG93ZWRLZXlFbmNvZGluZ3M9W1wiaGV4XCIsXCJ1dGY4XCIsXCJiYXNlNjRcIixcImJpbmFyeVwiXSx0aGlzLl9hbGxvd2VkS2V5TGVuZ3Rocz1bMTI4LDI1Nl0sdGhpcy5fYWxsb3dlZE1vZGVzPVtcImVjYlwiLFwiY2JjXCJdLHRoaXMuX2RlZmF1bHRPcHRpb25zPXtlbmNyeXB0S2V5OiEwLGtleUVuY29kaW5nOlwidXRmOFwiLGtleUxlbmd0aDoyNTYsbW9kZTpcImNiY1wifX1yZXR1cm4gbyhlLFt7a2V5OlwiSE1BQ1NIQTI1NlwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiB1LmRlZmF1bHQuSG1hY1NIQTI1NihlLHRoaXMuX2NvbmZpZy5zZWNyZXRLZXkpLnRvU3RyaW5nKHUuZGVmYXVsdC5lbmMuQmFzZTY0KX19LHtrZXk6XCJTSEEyNTZcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdS5kZWZhdWx0LlNIQTI1NihlKS50b1N0cmluZyh1LmRlZmF1bHQuZW5jLkhleCl9fSx7a2V5OlwiX3BhcnNlT3B0aW9uc1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PWV8fHt9O3JldHVybiB0Lmhhc093blByb3BlcnR5KFwiZW5jcnlwdEtleVwiKXx8KHQuZW5jcnlwdEtleT10aGlzLl9kZWZhdWx0T3B0aW9ucy5lbmNyeXB0S2V5KSx0Lmhhc093blByb3BlcnR5KFwia2V5RW5jb2RpbmdcIil8fCh0LmtleUVuY29kaW5nPXRoaXMuX2RlZmF1bHRPcHRpb25zLmtleUVuY29kaW5nKSx0Lmhhc093blByb3BlcnR5KFwia2V5TGVuZ3RoXCIpfHwodC5rZXlMZW5ndGg9dGhpcy5fZGVmYXVsdE9wdGlvbnMua2V5TGVuZ3RoKSx0Lmhhc093blByb3BlcnR5KFwibW9kZVwiKXx8KHQubW9kZT10aGlzLl9kZWZhdWx0T3B0aW9ucy5tb2RlKSx0aGlzLl9hbGxvd2VkS2V5RW5jb2RpbmdzLmluZGV4T2YodC5rZXlFbmNvZGluZy50b0xvd2VyQ2FzZSgpKT09PS0xJiYodC5rZXlFbmNvZGluZz10aGlzLl9kZWZhdWx0T3B0aW9ucy5rZXlFbmNvZGluZyksdGhpcy5fYWxsb3dlZEtleUxlbmd0aHMuaW5kZXhPZihwYXJzZUludCh0LmtleUxlbmd0aCwxMCkpPT09LTEmJih0LmtleUxlbmd0aD10aGlzLl9kZWZhdWx0T3B0aW9ucy5rZXlMZW5ndGgpLHRoaXMuX2FsbG93ZWRNb2Rlcy5pbmRleE9mKHQubW9kZS50b0xvd2VyQ2FzZSgpKT09PS0xJiYodC5tb2RlPXRoaXMuX2RlZmF1bHRPcHRpb25zLm1vZGUpLHR9fSx7a2V5OlwiX2RlY29kZUtleVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7cmV0dXJuXCJiYXNlNjRcIj09PXQua2V5RW5jb2Rpbmc/dS5kZWZhdWx0LmVuYy5CYXNlNjQucGFyc2UoZSk6XCJoZXhcIj09PXQua2V5RW5jb2Rpbmc/dS5kZWZhdWx0LmVuYy5IZXgucGFyc2UoZSk6ZX19LHtrZXk6XCJfZ2V0UGFkZGVkS2V5XCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZT10aGlzLl9kZWNvZGVLZXkoZSx0KSx0LmVuY3J5cHRLZXk/dS5kZWZhdWx0LmVuYy5VdGY4LnBhcnNlKHRoaXMuU0hBMjU2KGUpLnNsaWNlKDAsMzIpKTplfX0se2tleTpcIl9nZXRNb2RlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuXCJlY2JcIj09PWUubW9kZT91LmRlZmF1bHQubW9kZS5FQ0I6dS5kZWZhdWx0Lm1vZGUuQ0JDfX0se2tleTpcIl9nZXRJVlwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVyblwiY2JjXCI9PT1lLm1vZGU/dS5kZWZhdWx0LmVuYy5VdGY4LnBhcnNlKHRoaXMuX2l2KTpudWxsfX0se2tleTpcImVuY3J5cHRcIix2YWx1ZTpmdW5jdGlvbihlLHQsbil7aWYoIXQmJiF0aGlzLl9jb25maWcuY2lwaGVyS2V5KXJldHVybiBlO249dGhpcy5fcGFyc2VPcHRpb25zKG4pO3ZhciByPXRoaXMuX2dldElWKG4pLGk9dGhpcy5fZ2V0TW9kZShuKSxvPXRoaXMuX2dldFBhZGRlZEtleSh0fHx0aGlzLl9jb25maWcuY2lwaGVyS2V5LG4pO3JldHVybiB1LmRlZmF1bHQuQUVTLmVuY3J5cHQoZSxvLHtpdjpyLG1vZGU6aX0pLmNpcGhlcnRleHQudG9TdHJpbmcodS5kZWZhdWx0LmVuYy5CYXNlNjQpfHxlfX0se2tleTpcImRlY3J5cHRcIix2YWx1ZTpmdW5jdGlvbihlLHQsbil7aWYoIXQmJiF0aGlzLl9jb25maWcuY2lwaGVyS2V5KXJldHVybiBlO249dGhpcy5fcGFyc2VPcHRpb25zKG4pO3ZhciByPXRoaXMuX2dldElWKG4pLGk9dGhpcy5fZ2V0TW9kZShuKSxvPXRoaXMuX2dldFBhZGRlZEtleSh0fHx0aGlzLl9jb25maWcuY2lwaGVyS2V5LG4pO3RyeXt2YXIgcz11LmRlZmF1bHQuZW5jLkJhc2U2NC5wYXJzZShlKSxhPXUuZGVmYXVsdC5BRVMuZGVjcnlwdCh7Y2lwaGVydGV4dDpzfSxvLHtpdjpyLG1vZGU6aX0pLnRvU3RyaW5nKHUuZGVmYXVsdC5lbmMuVXRmOCk7cmV0dXJuIEpTT04ucGFyc2UoYSl9Y2F0Y2goZSl7cmV0dXJuIG51bGx9fX1dKSxlfSgpO3QuZGVmYXVsdD1jLGUuZXhwb3J0cz10LmRlZmF1bHR9LGZ1bmN0aW9uKGUsdCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49bnx8ZnVuY3Rpb24oZSx0KXt2YXIgbj17fSxyPW4ubGliPXt9LGk9ZnVuY3Rpb24oKXt9LG89ci5CYXNlPXtleHRlbmQ6ZnVuY3Rpb24oZSl7aS5wcm90b3R5cGU9dGhpczt2YXIgdD1uZXcgaTtyZXR1cm4gZSYmdC5taXhJbihlKSx0Lmhhc093blByb3BlcnR5KFwiaW5pdFwiKXx8KHQuaW5pdD1mdW5jdGlvbigpe3QuJHN1cGVyLmluaXQuYXBwbHkodGhpcyxhcmd1bWVudHMpfSksdC5pbml0LnByb3RvdHlwZT10LHQuJHN1cGVyPXRoaXMsdH0sY3JlYXRlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5leHRlbmQoKTtyZXR1cm4gZS5pbml0LmFwcGx5KGUsYXJndW1lbnRzKSxlfSxpbml0OmZ1bmN0aW9uKCl7fSxtaXhJbjpmdW5jdGlvbihlKXtmb3IodmFyIHQgaW4gZSllLmhhc093blByb3BlcnR5KHQpJiYodGhpc1t0XT1lW3RdKTtlLmhhc093blByb3BlcnR5KFwidG9TdHJpbmdcIikmJih0aGlzLnRvU3RyaW5nPWUudG9TdHJpbmcpfSxjbG9uZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmluaXQucHJvdG90eXBlLmV4dGVuZCh0aGlzKX19LHM9ci5Xb3JkQXJyYXk9by5leHRlbmQoe2luaXQ6ZnVuY3Rpb24oZSx0KXtlPXRoaXMud29yZHM9ZXx8W10sdGhpcy5zaWdCeXRlcz12b2lkIDAhPXQ/dDo0KmUubGVuZ3RofSx0b1N0cmluZzpmdW5jdGlvbihlKXtyZXR1cm4oZXx8dSkuc3RyaW5naWZ5KHRoaXMpfSxjb25jYXQ6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy53b3JkcyxuPWUud29yZHMscj10aGlzLnNpZ0J5dGVzO2lmKGU9ZS5zaWdCeXRlcyx0aGlzLmNsYW1wKCksciU0KWZvcih2YXIgaT0wO2k8ZTtpKyspdFtyK2k+Pj4yXXw9KG5baT4+PjJdPj4+MjQtaSU0KjgmMjU1KTw8MjQtKHIraSklNCo4O2Vsc2UgaWYoNjU1MzU8bi5sZW5ndGgpZm9yKGk9MDtpPGU7aSs9NCl0W3IraT4+PjJdPW5baT4+PjJdO2Vsc2UgdC5wdXNoLmFwcGx5KHQsbik7cmV0dXJuIHRoaXMuc2lnQnl0ZXMrPWUsdGhpc30sY2xhbXA6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLndvcmRzLG49dGhpcy5zaWdCeXRlczt0W24+Pj4yXSY9NDI5NDk2NzI5NTw8MzItbiU0KjgsdC5sZW5ndGg9ZS5jZWlsKG4vNCl9LGNsb25lOmZ1bmN0aW9uKCl7dmFyIGU9by5jbG9uZS5jYWxsKHRoaXMpO3JldHVybiBlLndvcmRzPXRoaXMud29yZHMuc2xpY2UoMCksZX0scmFuZG9tOmZ1bmN0aW9uKHQpe2Zvcih2YXIgbj1bXSxyPTA7cjx0O3IrPTQpbi5wdXNoKDQyOTQ5NjcyOTYqZS5yYW5kb20oKXwwKTtyZXR1cm4gbmV3IHMuaW5pdChuLHQpfX0pLGE9bi5lbmM9e30sdT1hLkhleD17c3RyaW5naWZ5OmZ1bmN0aW9uKGUpe3ZhciB0PWUud29yZHM7ZT1lLnNpZ0J5dGVzO2Zvcih2YXIgbj1bXSxyPTA7cjxlO3IrKyl7dmFyIGk9dFtyPj4+Ml0+Pj4yNC1yJTQqOCYyNTU7bi5wdXNoKChpPj4+NCkudG9TdHJpbmcoMTYpKSxuLnB1c2goKDE1JmkpLnRvU3RyaW5nKDE2KSl9cmV0dXJuIG4uam9pbihcIlwiKX0scGFyc2U6ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PWUubGVuZ3RoLG49W10scj0wO3I8dDtyKz0yKW5bcj4+PjNdfD1wYXJzZUludChlLnN1YnN0cihyLDIpLDE2KTw8MjQtciU4KjQ7cmV0dXJuIG5ldyBzLmluaXQobix0LzIpfX0sYz1hLkxhdGluMT17c3RyaW5naWZ5OmZ1bmN0aW9uKGUpe3ZhciB0PWUud29yZHM7ZT1lLnNpZ0J5dGVzO2Zvcih2YXIgbj1bXSxyPTA7cjxlO3IrKyluLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZSh0W3I+Pj4yXT4+PjI0LXIlNCo4JjI1NSkpO3JldHVybiBuLmpvaW4oXCJcIil9LHBhcnNlOmZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1lLmxlbmd0aCxuPVtdLHI9MDtyPHQ7cisrKW5bcj4+PjJdfD0oMjU1JmUuY2hhckNvZGVBdChyKSk8PDI0LXIlNCo4O3JldHVybiBuZXcgcy5pbml0KG4sdCl9fSxsPWEuVXRmOD17c3RyaW5naWZ5OmZ1bmN0aW9uKGUpe3RyeXtyZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShjLnN0cmluZ2lmeShlKSkpfWNhdGNoKGUpe3Rocm93IEVycm9yKFwiTWFsZm9ybWVkIFVURi04IGRhdGFcIil9fSxwYXJzZTpmdW5jdGlvbihlKXtyZXR1cm4gYy5wYXJzZSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoZSkpKX19LGg9ci5CdWZmZXJlZEJsb2NrQWxnb3JpdGhtPW8uZXh0ZW5kKHtyZXNldDpmdW5jdGlvbigpe3RoaXMuX2RhdGE9bmV3IHMuaW5pdCx0aGlzLl9uRGF0YUJ5dGVzPTB9LF9hcHBlbmQ6ZnVuY3Rpb24oZSl7XCJzdHJpbmdcIj09dHlwZW9mIGUmJihlPWwucGFyc2UoZSkpLHRoaXMuX2RhdGEuY29uY2F0KGUpLHRoaXMuX25EYXRhQnl0ZXMrPWUuc2lnQnl0ZXN9LF9wcm9jZXNzOmZ1bmN0aW9uKHQpe3ZhciBuPXRoaXMuX2RhdGEscj1uLndvcmRzLGk9bi5zaWdCeXRlcyxvPXRoaXMuYmxvY2tTaXplLGE9aS8oNCpvKSxhPXQ/ZS5jZWlsKGEpOmUubWF4KCgwfGEpLXRoaXMuX21pbkJ1ZmZlclNpemUsMCk7aWYodD1hKm8saT1lLm1pbig0KnQsaSksdCl7Zm9yKHZhciB1PTA7dTx0O3UrPW8pdGhpcy5fZG9Qcm9jZXNzQmxvY2socix1KTt1PXIuc3BsaWNlKDAsdCksbi5zaWdCeXRlcy09aX1yZXR1cm4gbmV3IHMuaW5pdCh1LGkpfSxjbG9uZTpmdW5jdGlvbigpe3ZhciBlPW8uY2xvbmUuY2FsbCh0aGlzKTtyZXR1cm4gZS5fZGF0YT10aGlzLl9kYXRhLmNsb25lKCksZX0sX21pbkJ1ZmZlclNpemU6MH0pO3IuSGFzaGVyPWguZXh0ZW5kKHtjZmc6by5leHRlbmQoKSxpbml0OmZ1bmN0aW9uKGUpe3RoaXMuY2ZnPXRoaXMuY2ZnLmV4dGVuZChlKSx0aGlzLnJlc2V0KCl9LHJlc2V0OmZ1bmN0aW9uKCl7aC5yZXNldC5jYWxsKHRoaXMpLHRoaXMuX2RvUmVzZXQoKX0sdXBkYXRlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLl9hcHBlbmQoZSksdGhpcy5fcHJvY2VzcygpLHRoaXN9LGZpbmFsaXplOmZ1bmN0aW9uKGUpe3JldHVybiBlJiZ0aGlzLl9hcHBlbmQoZSksdGhpcy5fZG9GaW5hbGl6ZSgpfSxibG9ja1NpemU6MTYsX2NyZWF0ZUhlbHBlcjpmdW5jdGlvbihlKXtyZXR1cm4gZnVuY3Rpb24odCxuKXtyZXR1cm4gbmV3IGUuaW5pdChuKS5maW5hbGl6ZSh0KX19LF9jcmVhdGVIbWFjSGVscGVyOmZ1bmN0aW9uKGUpe3JldHVybiBmdW5jdGlvbih0LG4pe3JldHVybiBuZXcgZi5ITUFDLmluaXQoZSxuKS5maW5hbGl6ZSh0KX19fSk7dmFyIGY9bi5hbGdvPXt9O3JldHVybiBufShNYXRoKTshZnVuY3Rpb24oZSl7Zm9yKHZhciB0PW4scj10LmxpYixpPXIuV29yZEFycmF5LG89ci5IYXNoZXIscj10LmFsZ28scz1bXSxhPVtdLHU9ZnVuY3Rpb24oZSl7cmV0dXJuIDQyOTQ5NjcyOTYqKGUtKDB8ZSkpfDB9LGM9MixsPTA7NjQ+bDspe3ZhciBoO2U6e2g9Yztmb3IodmFyIGY9ZS5zcXJ0KGgpLGQ9MjtkPD1mO2QrKylpZighKGglZCkpe2g9ITE7YnJlYWsgZX1oPSEwfWgmJig4PmwmJihzW2xdPXUoZS5wb3coYywuNSkpKSxhW2xdPXUoZS5wb3coYywxLzMpKSxsKyspLGMrK312YXIgcD1bXSxyPXIuU0hBMjU2PW8uZXh0ZW5kKHtfZG9SZXNldDpmdW5jdGlvbigpe3RoaXMuX2hhc2g9bmV3IGkuaW5pdChzLnNsaWNlKDApKX0sX2RvUHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBuPXRoaXMuX2hhc2gud29yZHMscj1uWzBdLGk9blsxXSxvPW5bMl0scz1uWzNdLHU9bls0XSxjPW5bNV0sbD1uWzZdLGg9bls3XSxmPTA7NjQ+ZjtmKyspe2lmKDE2PmYpcFtmXT0wfGVbdCtmXTtlbHNle3ZhciBkPXBbZi0xNV0sZz1wW2YtMl07cFtmXT0oKGQ8PDI1fGQ+Pj43KV4oZDw8MTR8ZD4+PjE4KV5kPj4+MykrcFtmLTddKygoZzw8MTV8Zz4+PjE3KV4oZzw8MTN8Zz4+PjE5KV5nPj4+MTApK3BbZi0xNl19ZD1oKygodTw8MjZ8dT4+PjYpXih1PDwyMXx1Pj4+MTEpXih1PDw3fHU+Pj4yNSkpKyh1JmNefnUmbCkrYVtmXStwW2ZdLGc9KChyPDwzMHxyPj4+MileKHI8PDE5fHI+Pj4xMyleKHI8PDEwfHI+Pj4yMikpKyhyJmleciZvXmkmbyksaD1sLGw9YyxjPXUsdT1zK2R8MCxzPW8sbz1pLGk9cixyPWQrZ3wwfW5bMF09blswXStyfDAsblsxXT1uWzFdK2l8MCxuWzJdPW5bMl0rb3wwLG5bM109blszXStzfDAsbls0XT1uWzRdK3V8MCxuWzVdPW5bNV0rY3wwLG5bNl09bls2XStsfDAsbls3XT1uWzddK2h8MH0sX2RvRmluYWxpemU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9kYXRhLG49dC53b3JkcyxyPTgqdGhpcy5fbkRhdGFCeXRlcyxpPTgqdC5zaWdCeXRlcztyZXR1cm4gbltpPj4+NV18PTEyODw8MjQtaSUzMixuWzE0KyhpKzY0Pj4+OTw8NCldPWUuZmxvb3Ioci80Mjk0OTY3Mjk2KSxuWzE1KyhpKzY0Pj4+OTw8NCldPXIsdC5zaWdCeXRlcz00Km4ubGVuZ3RoLHRoaXMuX3Byb2Nlc3MoKSx0aGlzLl9oYXNofSxjbG9uZTpmdW5jdGlvbigpe3ZhciBlPW8uY2xvbmUuY2FsbCh0aGlzKTtyZXR1cm4gZS5faGFzaD10aGlzLl9oYXNoLmNsb25lKCksZX19KTt0LlNIQTI1Nj1vLl9jcmVhdGVIZWxwZXIociksdC5IbWFjU0hBMjU2PW8uX2NyZWF0ZUhtYWNIZWxwZXIocil9KE1hdGgpLGZ1bmN0aW9uKCl7dmFyIGU9bix0PWUuZW5jLlV0Zjg7ZS5hbGdvLkhNQUM9ZS5saWIuQmFzZS5leHRlbmQoe2luaXQ6ZnVuY3Rpb24oZSxuKXtlPXRoaXMuX2hhc2hlcj1uZXcgZS5pbml0LFwic3RyaW5nXCI9PXR5cGVvZiBuJiYobj10LnBhcnNlKG4pKTt2YXIgcj1lLmJsb2NrU2l6ZSxpPTQqcjtuLnNpZ0J5dGVzPmkmJihuPWUuZmluYWxpemUobikpLG4uY2xhbXAoKTtmb3IodmFyIG89dGhpcy5fb0tleT1uLmNsb25lKCkscz10aGlzLl9pS2V5PW4uY2xvbmUoKSxhPW8ud29yZHMsdT1zLndvcmRzLGM9MDtjPHI7YysrKWFbY11ePTE1NDk1NTY4MjgsdVtjXV49OTA5NTIyNDg2O28uc2lnQnl0ZXM9cy5zaWdCeXRlcz1pLHRoaXMucmVzZXQoKX0scmVzZXQ6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLl9oYXNoZXI7ZS5yZXNldCgpLGUudXBkYXRlKHRoaXMuX2lLZXkpfSx1cGRhdGU6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuX2hhc2hlci51cGRhdGUoZSksdGhpc30sZmluYWxpemU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5faGFzaGVyO3JldHVybiBlPXQuZmluYWxpemUoZSksdC5yZXNldCgpLHQuZmluYWxpemUodGhpcy5fb0tleS5jbG9uZSgpLmNvbmNhdChlKSl9fSl9KCksZnVuY3Rpb24oKXt2YXIgZT1uLHQ9ZS5saWIuV29yZEFycmF5O2UuZW5jLkJhc2U2ND17c3RyaW5naWZ5OmZ1bmN0aW9uKGUpe3ZhciB0PWUud29yZHMsbj1lLnNpZ0J5dGVzLHI9dGhpcy5fbWFwO2UuY2xhbXAoKSxlPVtdO2Zvcih2YXIgaT0wO2k8bjtpKz0zKWZvcih2YXIgbz0odFtpPj4+Ml0+Pj4yNC1pJTQqOCYyNTUpPDwxNnwodFtpKzE+Pj4yXT4+PjI0LShpKzEpJTQqOCYyNTUpPDw4fHRbaSsyPj4+Ml0+Pj4yNC0oaSsyKSU0KjgmMjU1LHM9MDs0PnMmJmkrLjc1KnM8bjtzKyspZS5wdXNoKHIuY2hhckF0KG8+Pj42KigzLXMpJjYzKSk7aWYodD1yLmNoYXJBdCg2NCkpZm9yKDtlLmxlbmd0aCU0OyllLnB1c2godCk7cmV0dXJuIGUuam9pbihcIlwiKX0scGFyc2U6ZnVuY3Rpb24oZSl7dmFyIG49ZS5sZW5ndGgscj10aGlzLl9tYXAsaT1yLmNoYXJBdCg2NCk7aSYmLTEhPShpPWUuaW5kZXhPZihpKSkmJihuPWkpO2Zvcih2YXIgaT1bXSxvPTAscz0wO3M8bjtzKyspaWYocyU0KXt2YXIgYT1yLmluZGV4T2YoZS5jaGFyQXQocy0xKSk8PHMlNCoyLHU9ci5pbmRleE9mKGUuY2hhckF0KHMpKT4+PjYtcyU0KjI7aVtvPj4+Ml18PShhfHUpPDwyNC1vJTQqOCxvKyt9cmV0dXJuIHQuY3JlYXRlKGksbyl9LF9tYXA6XCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPVwifX0oKSxmdW5jdGlvbihlKXtmdW5jdGlvbiB0KGUsdCxuLHIsaSxvLHMpe3JldHVybigoZT1lKyh0Jm58fnQmcikraStzKTw8b3xlPj4+MzItbykrdH1mdW5jdGlvbiByKGUsdCxuLHIsaSxvLHMpe3JldHVybigoZT1lKyh0JnJ8biZ+cikraStzKTw8b3xlPj4+MzItbykrdH1mdW5jdGlvbiBpKGUsdCxuLHIsaSxvLHMpe3JldHVybigoZT1lKyh0Xm5ecikraStzKTw8b3xlPj4+MzItbykrdH1mdW5jdGlvbiBvKGUsdCxuLHIsaSxvLHMpe3JldHVybigoZT1lKyhuXih0fH5yKSkraStzKTw8b3xlPj4+MzItbykrdH1mb3IodmFyIHM9bixhPXMubGliLHU9YS5Xb3JkQXJyYXksYz1hLkhhc2hlcixhPXMuYWxnbyxsPVtdLGg9MDs2ND5oO2grKylsW2hdPTQyOTQ5NjcyOTYqZS5hYnMoZS5zaW4oaCsxKSl8MDthPWEuTUQ1PWMuZXh0ZW5kKHtfZG9SZXNldDpmdW5jdGlvbigpe3RoaXMuX2hhc2g9bmV3IHUuaW5pdChbMTczMjU4NDE5Myw0MDIzMjMzNDE3LDI1NjIzODMxMDIsMjcxNzMzODc4XSl9LF9kb1Byb2Nlc3NCbG9jazpmdW5jdGlvbihlLG4pe2Zvcih2YXIgcz0wOzE2PnM7cysrKXt2YXIgYT1uK3MsdT1lW2FdO2VbYV09MTY3MTE5MzUmKHU8PDh8dT4+PjI0KXw0Mjc4MjU1MzYwJih1PDwyNHx1Pj4+OCl9dmFyIHM9dGhpcy5faGFzaC53b3JkcyxhPWVbbiswXSx1PWVbbisxXSxjPWVbbisyXSxoPWVbbiszXSxmPWVbbis0XSxkPWVbbis1XSxwPWVbbis2XSxnPWVbbis3XSx5PWVbbis4XSx2PWVbbis5XSxiPWVbbisxMF0sXz1lW24rMTFdLG09ZVtuKzEyXSxrPWVbbisxM10sUD1lW24rMTRdLFM9ZVtuKzE1XSxPPXNbMF0sdz1zWzFdLFQ9c1syXSxDPXNbM10sTz10KE8sdyxULEMsYSw3LGxbMF0pLEM9dChDLE8sdyxULHUsMTIsbFsxXSksVD10KFQsQyxPLHcsYywxNyxsWzJdKSx3PXQodyxULEMsTyxoLDIyLGxbM10pLE89dChPLHcsVCxDLGYsNyxsWzRdKSxDPXQoQyxPLHcsVCxkLDEyLGxbNV0pLFQ9dChULEMsTyx3LHAsMTcsbFs2XSksdz10KHcsVCxDLE8sZywyMixsWzddKSxPPXQoTyx3LFQsQyx5LDcsbFs4XSksQz10KEMsTyx3LFQsdiwxMixsWzldKSxUPXQoVCxDLE8sdyxiLDE3LGxbMTBdKSx3PXQodyxULEMsTyxfLDIyLGxbMTFdKSxPPXQoTyx3LFQsQyxtLDcsbFsxMl0pLEM9dChDLE8sdyxULGssMTIsbFsxM10pLFQ9dChULEMsTyx3LFAsMTcsbFsxNF0pLHc9dCh3LFQsQyxPLFMsMjIsbFsxNV0pLE89cihPLHcsVCxDLHUsNSxsWzE2XSksQz1yKEMsTyx3LFQscCw5LGxbMTddKSxUPXIoVCxDLE8sdyxfLDE0LGxbMThdKSx3PXIodyxULEMsTyxhLDIwLGxbMTldKSxPPXIoTyx3LFQsQyxkLDUsbFsyMF0pLEM9cihDLE8sdyxULGIsOSxsWzIxXSksVD1yKFQsQyxPLHcsUywxNCxsWzIyXSksdz1yKHcsVCxDLE8sZiwyMCxsWzIzXSksTz1yKE8sdyxULEMsdiw1LGxbMjRdKSxDPXIoQyxPLHcsVCxQLDksbFsyNV0pLFQ9cihULEMsTyx3LGgsMTQsbFsyNl0pLHc9cih3LFQsQyxPLHksMjAsbFsyN10pLE89cihPLHcsVCxDLGssNSxsWzI4XSksQz1yKEMsTyx3LFQsYyw5LGxbMjldKSxUPXIoVCxDLE8sdyxnLDE0LGxbMzBdKSx3PXIodyxULEMsTyxtLDIwLGxbMzFdKSxPPWkoTyx3LFQsQyxkLDQsbFszMl0pLEM9aShDLE8sdyxULHksMTEsbFszM10pLFQ9aShULEMsTyx3LF8sMTYsbFszNF0pLHc9aSh3LFQsQyxPLFAsMjMsbFszNV0pLE89aShPLHcsVCxDLHUsNCxsWzM2XSksQz1pKEMsTyx3LFQsZiwxMSxsWzM3XSksVD1pKFQsQyxPLHcsZywxNixsWzM4XSksdz1pKHcsVCxDLE8sYiwyMyxsWzM5XSksTz1pKE8sdyxULEMsayw0LGxbNDBdKSxDPWkoQyxPLHcsVCxhLDExLGxbNDFdKSxUPWkoVCxDLE8sdyxoLDE2LGxbNDJdKSx3PWkodyxULEMsTyxwLDIzLGxbNDNdKSxPPWkoTyx3LFQsQyx2LDQsbFs0NF0pLEM9aShDLE8sdyxULG0sMTEsbFs0NV0pLFQ9aShULEMsTyx3LFMsMTYsbFs0Nl0pLHc9aSh3LFQsQyxPLGMsMjMsbFs0N10pLE89byhPLHcsVCxDLGEsNixsWzQ4XSksQz1vKEMsTyx3LFQsZywxMCxsWzQ5XSksVD1vKFQsQyxPLHcsUCwxNSxsWzUwXSksdz1vKHcsVCxDLE8sZCwyMSxsWzUxXSksTz1vKE8sdyxULEMsbSw2LGxbNTJdKSxDPW8oQyxPLHcsVCxoLDEwLGxbNTNdKSxUPW8oVCxDLE8sdyxiLDE1LGxbNTRdKSx3PW8odyxULEMsTyx1LDIxLGxbNTVdKSxPPW8oTyx3LFQsQyx5LDYsbFs1Nl0pLEM9byhDLE8sdyxULFMsMTAsbFs1N10pLFQ9byhULEMsTyx3LHAsMTUsbFs1OF0pLHc9byh3LFQsQyxPLGssMjEsbFs1OV0pLE89byhPLHcsVCxDLGYsNixsWzYwXSksQz1vKEMsTyx3LFQsXywxMCxsWzYxXSksVD1vKFQsQyxPLHcsYywxNSxsWzYyXSksdz1vKHcsVCxDLE8sdiwyMSxsWzYzXSk7c1swXT1zWzBdK098MCxzWzFdPXNbMV0rd3wwLHNbMl09c1syXStUfDAsc1szXT1zWzNdK0N8MH0sX2RvRmluYWxpemU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9kYXRhLG49dC53b3JkcyxyPTgqdGhpcy5fbkRhdGFCeXRlcyxpPTgqdC5zaWdCeXRlcztuW2k+Pj41XXw9MTI4PDwyNC1pJTMyO3ZhciBvPWUuZmxvb3Ioci80Mjk0OTY3Mjk2KTtmb3IoblsxNSsoaSs2ND4+Pjk8PDQpXT0xNjcxMTkzNSYobzw8OHxvPj4+MjQpfDQyNzgyNTUzNjAmKG88PDI0fG8+Pj44KSxuWzE0KyhpKzY0Pj4+OTw8NCldPTE2NzExOTM1JihyPDw4fHI+Pj4yNCl8NDI3ODI1NTM2MCYocjw8MjR8cj4+PjgpLHQuc2lnQnl0ZXM9NCoobi5sZW5ndGgrMSksdGhpcy5fcHJvY2VzcygpLHQ9dGhpcy5faGFzaCxuPXQud29yZHMscj0wOzQ+cjtyKyspaT1uW3JdLG5bcl09MTY3MTE5MzUmKGk8PDh8aT4+PjI0KXw0Mjc4MjU1MzYwJihpPDwyNHxpPj4+OCk7cmV0dXJuIHR9LGNsb25lOmZ1bmN0aW9uKCl7dmFyIGU9Yy5jbG9uZS5jYWxsKHRoaXMpO3JldHVybiBlLl9oYXNoPXRoaXMuX2hhc2guY2xvbmUoKSxlfX0pLHMuTUQ1PWMuX2NyZWF0ZUhlbHBlcihhKSxzLkhtYWNNRDU9Yy5fY3JlYXRlSG1hY0hlbHBlcihhKX0oTWF0aCksZnVuY3Rpb24oKXt2YXIgZT1uLHQ9ZS5saWIscj10LkJhc2UsaT10LldvcmRBcnJheSx0PWUuYWxnbyxvPXQuRXZwS0RGPXIuZXh0ZW5kKHtjZmc6ci5leHRlbmQoe2tleVNpemU6NCxoYXNoZXI6dC5NRDUsaXRlcmF0aW9uczoxfSksaW5pdDpmdW5jdGlvbihlKXt0aGlzLmNmZz10aGlzLmNmZy5leHRlbmQoZSl9LGNvbXB1dGU6ZnVuY3Rpb24oZSx0KXtmb3IodmFyIG49dGhpcy5jZmcscj1uLmhhc2hlci5jcmVhdGUoKSxvPWkuY3JlYXRlKCkscz1vLndvcmRzLGE9bi5rZXlTaXplLG49bi5pdGVyYXRpb25zO3MubGVuZ3RoPGE7KXt1JiZyLnVwZGF0ZSh1KTt2YXIgdT1yLnVwZGF0ZShlKS5maW5hbGl6ZSh0KTtyLnJlc2V0KCk7Zm9yKHZhciBjPTE7YzxuO2MrKyl1PXIuZmluYWxpemUodSksci5yZXNldCgpO28uY29uY2F0KHUpfXJldHVybiBvLnNpZ0J5dGVzPTQqYSxvfX0pO2UuRXZwS0RGPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gby5jcmVhdGUobikuY29tcHV0ZShlLHQpfX0oKSxuLmxpYi5DaXBoZXJ8fGZ1bmN0aW9uKGUpe3ZhciB0PW4scj10LmxpYixpPXIuQmFzZSxvPXIuV29yZEFycmF5LHM9ci5CdWZmZXJlZEJsb2NrQWxnb3JpdGhtLGE9dC5lbmMuQmFzZTY0LHU9dC5hbGdvLkV2cEtERixjPXIuQ2lwaGVyPXMuZXh0ZW5kKHtjZmc6aS5leHRlbmQoKSxjcmVhdGVFbmNyeXB0b3I6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5jcmVhdGUodGhpcy5fRU5DX1hGT1JNX01PREUsZSx0KX0sY3JlYXRlRGVjcnlwdG9yOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuY3JlYXRlKHRoaXMuX0RFQ19YRk9STV9NT0RFLGUsdCl9LGluaXQ6ZnVuY3Rpb24oZSx0LG4pe3RoaXMuY2ZnPXRoaXMuY2ZnLmV4dGVuZChuKSx0aGlzLl94Zm9ybU1vZGU9ZSx0aGlzLl9rZXk9dCx0aGlzLnJlc2V0KCl9LHJlc2V0OmZ1bmN0aW9uKCl7cy5yZXNldC5jYWxsKHRoaXMpLHRoaXMuX2RvUmVzZXQoKX0scHJvY2VzczpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5fYXBwZW5kKGUpLHRoaXMuX3Byb2Nlc3MoKX0sZmluYWxpemU6ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJnRoaXMuX2FwcGVuZChlKSx0aGlzLl9kb0ZpbmFsaXplKCl9LGtleVNpemU6NCxpdlNpemU6NCxfRU5DX1hGT1JNX01PREU6MSxfREVDX1hGT1JNX01PREU6MixfY3JlYXRlSGVscGVyOmZ1bmN0aW9uKGUpe3JldHVybntlbmNyeXB0OmZ1bmN0aW9uKHQsbixyKXtyZXR1cm4oXCJzdHJpbmdcIj09dHlwZW9mIG4/ZzpwKS5lbmNyeXB0KGUsdCxuLHIpfSxkZWNyeXB0OmZ1bmN0aW9uKHQsbixyKXtyZXR1cm4oXCJzdHJpbmdcIj09dHlwZW9mIG4/ZzpwKS5kZWNyeXB0KGUsdCxuLHIpfX19fSk7ci5TdHJlYW1DaXBoZXI9Yy5leHRlbmQoe19kb0ZpbmFsaXplOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3Byb2Nlc3MoITApfSxibG9ja1NpemU6MX0pO3ZhciBsPXQubW9kZT17fSxoPWZ1bmN0aW9uKGUsdCxuKXt2YXIgcj10aGlzLl9pdjtyP3RoaXMuX2l2PXZvaWQgMDpyPXRoaXMuX3ByZXZCbG9jaztmb3IodmFyIGk9MDtpPG47aSsrKWVbdCtpXV49cltpXX0sZj0oci5CbG9ja0NpcGhlck1vZGU9aS5leHRlbmQoe2NyZWF0ZUVuY3J5cHRvcjpmdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLkVuY3J5cHRvci5jcmVhdGUoZSx0KX0sY3JlYXRlRGVjcnlwdG9yOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuRGVjcnlwdG9yLmNyZWF0ZShlLHQpfSxpbml0OmZ1bmN0aW9uKGUsdCl7dGhpcy5fY2lwaGVyPWUsdGhpcy5faXY9dH19KSkuZXh0ZW5kKCk7Zi5FbmNyeXB0b3I9Zi5leHRlbmQoe3Byb2Nlc3NCbG9jazpmdW5jdGlvbihlLHQpe3ZhciBuPXRoaXMuX2NpcGhlcixyPW4uYmxvY2tTaXplO2guY2FsbCh0aGlzLGUsdCxyKSxuLmVuY3J5cHRCbG9jayhlLHQpLHRoaXMuX3ByZXZCbG9jaz1lLnNsaWNlKHQsdCtyKX19KSxmLkRlY3J5cHRvcj1mLmV4dGVuZCh7cHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcy5fY2lwaGVyLHI9bi5ibG9ja1NpemUsaT1lLnNsaWNlKHQsdCtyKTtuLmRlY3J5cHRCbG9jayhlLHQpLGguY2FsbCh0aGlzLGUsdCxyKSx0aGlzLl9wcmV2QmxvY2s9aX19KSxsPWwuQ0JDPWYsZj0odC5wYWQ9e30pLlBrY3M3PXtwYWQ6ZnVuY3Rpb24oZSx0KXtmb3IodmFyIG49NCp0LG49bi1lLnNpZ0J5dGVzJW4scj1uPDwyNHxuPDwxNnxuPDw4fG4saT1bXSxzPTA7czxuO3MrPTQpaS5wdXNoKHIpO249by5jcmVhdGUoaSxuKSxlLmNvbmNhdChuKX0sdW5wYWQ6ZnVuY3Rpb24oZSl7ZS5zaWdCeXRlcy09MjU1JmUud29yZHNbZS5zaWdCeXRlcy0xPj4+Ml19fSxyLkJsb2NrQ2lwaGVyPWMuZXh0ZW5kKHtjZmc6Yy5jZmcuZXh0ZW5kKHttb2RlOmwscGFkZGluZzpmfSkscmVzZXQ6ZnVuY3Rpb24oKXtjLnJlc2V0LmNhbGwodGhpcyk7dmFyIGU9dGhpcy5jZmcsdD1lLml2LGU9ZS5tb2RlO2lmKHRoaXMuX3hmb3JtTW9kZT09dGhpcy5fRU5DX1hGT1JNX01PREUpdmFyIG49ZS5jcmVhdGVFbmNyeXB0b3I7ZWxzZSBuPWUuY3JlYXRlRGVjcnlwdG9yLHRoaXMuX21pbkJ1ZmZlclNpemU9MTt0aGlzLl9tb2RlPW4uY2FsbChlLHRoaXMsdCYmdC53b3Jkcyl9LF9kb1Byb2Nlc3NCbG9jazpmdW5jdGlvbihlLHQpe3RoaXMuX21vZGUucHJvY2Vzc0Jsb2NrKGUsdCl9LF9kb0ZpbmFsaXplOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5jZmcucGFkZGluZztpZih0aGlzLl94Zm9ybU1vZGU9PXRoaXMuX0VOQ19YRk9STV9NT0RFKXtlLnBhZCh0aGlzLl9kYXRhLHRoaXMuYmxvY2tTaXplKTt2YXIgdD10aGlzLl9wcm9jZXNzKCEwKX1lbHNlIHQ9dGhpcy5fcHJvY2VzcyghMCksZS51bnBhZCh0KTtyZXR1cm4gdH0sYmxvY2tTaXplOjR9KTt2YXIgZD1yLkNpcGhlclBhcmFtcz1pLmV4dGVuZCh7aW5pdDpmdW5jdGlvbihlKXt0aGlzLm1peEluKGUpfSx0b1N0cmluZzpmdW5jdGlvbihlKXtyZXR1cm4oZXx8dGhpcy5mb3JtYXR0ZXIpLnN0cmluZ2lmeSh0aGlzKX19KSxsPSh0LmZvcm1hdD17fSkuT3BlblNTTD17c3RyaW5naWZ5OmZ1bmN0aW9uKGUpe3ZhciB0PWUuY2lwaGVydGV4dDtyZXR1cm4gZT1lLnNhbHQsKGU/by5jcmVhdGUoWzEzOTg4OTM2ODQsMTcwMTA3NjgzMV0pLmNvbmNhdChlKS5jb25jYXQodCk6dCkudG9TdHJpbmcoYSl9LHBhcnNlOmZ1bmN0aW9uKGUpe2U9YS5wYXJzZShlKTt2YXIgdD1lLndvcmRzO2lmKDEzOTg4OTM2ODQ9PXRbMF0mJjE3MDEwNzY4MzE9PXRbMV0pe3ZhciBuPW8uY3JlYXRlKHQuc2xpY2UoMiw0KSk7dC5zcGxpY2UoMCw0KSxlLnNpZ0J5dGVzLT0xNn1yZXR1cm4gZC5jcmVhdGUoe2NpcGhlcnRleHQ6ZSxzYWx0Om59KX19LHA9ci5TZXJpYWxpemFibGVDaXBoZXI9aS5leHRlbmQoe2NmZzppLmV4dGVuZCh7Zm9ybWF0Omx9KSxlbmNyeXB0OmZ1bmN0aW9uKGUsdCxuLHIpe3I9dGhpcy5jZmcuZXh0ZW5kKHIpO3ZhciBpPWUuY3JlYXRlRW5jcnlwdG9yKG4scik7cmV0dXJuIHQ9aS5maW5hbGl6ZSh0KSxpPWkuY2ZnLGQuY3JlYXRlKHtjaXBoZXJ0ZXh0OnQsa2V5Om4saXY6aS5pdixhbGdvcml0aG06ZSxtb2RlOmkubW9kZSxwYWRkaW5nOmkucGFkZGluZyxibG9ja1NpemU6ZS5ibG9ja1NpemUsZm9ybWF0dGVyOnIuZm9ybWF0fSl9LGRlY3J5cHQ6ZnVuY3Rpb24oZSx0LG4scil7cmV0dXJuIHI9dGhpcy5jZmcuZXh0ZW5kKHIpLHQ9dGhpcy5fcGFyc2UodCxyLmZvcm1hdCksZS5jcmVhdGVEZWNyeXB0b3IobixyKS5maW5hbGl6ZSh0LmNpcGhlcnRleHQpfSxfcGFyc2U6ZnVuY3Rpb24oZSx0KXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgZT90LnBhcnNlKGUsdGhpcyk6ZX19KSx0PSh0LmtkZj17fSkuT3BlblNTTD17ZXhlY3V0ZTpmdW5jdGlvbihlLHQsbixyKXtyZXR1cm4gcnx8KHI9by5yYW5kb20oOCkpLGU9dS5jcmVhdGUoe2tleVNpemU6dCtufSkuY29tcHV0ZShlLHIpLG49by5jcmVhdGUoZS53b3Jkcy5zbGljZSh0KSw0Km4pLGUuc2lnQnl0ZXM9NCp0LGQuY3JlYXRlKHtrZXk6ZSxpdjpuLHNhbHQ6cn0pfX0sZz1yLlBhc3N3b3JkQmFzZWRDaXBoZXI9cC5leHRlbmQoe2NmZzpwLmNmZy5leHRlbmQoe2tkZjp0fSksZW5jcnlwdDpmdW5jdGlvbihlLHQsbixyKXtyZXR1cm4gcj10aGlzLmNmZy5leHRlbmQociksbj1yLmtkZi5leGVjdXRlKG4sZS5rZXlTaXplLGUuaXZTaXplKSxyLml2PW4uaXYsZT1wLmVuY3J5cHQuY2FsbCh0aGlzLGUsdCxuLmtleSxyKSxlLm1peEluKG4pLGV9LGRlY3J5cHQ6ZnVuY3Rpb24oZSx0LG4scil7cmV0dXJuIHI9dGhpcy5jZmcuZXh0ZW5kKHIpLHQ9dGhpcy5fcGFyc2UodCxyLmZvcm1hdCksbj1yLmtkZi5leGVjdXRlKG4sZS5rZXlTaXplLGUuaXZTaXplLHQuc2FsdCksci5pdj1uLml2LHAuZGVjcnlwdC5jYWxsKHRoaXMsZSx0LG4ua2V5LHIpfX0pfSgpLGZ1bmN0aW9uKCl7Zm9yKHZhciBlPW4sdD1lLmxpYi5CbG9ja0NpcGhlcixyPWUuYWxnbyxpPVtdLG89W10scz1bXSxhPVtdLHU9W10sYz1bXSxsPVtdLGg9W10sZj1bXSxkPVtdLHA9W10sZz0wOzI1Nj5nO2crKylwW2ddPTEyOD5nP2c8PDE6Zzw8MV4yODM7Zm9yKHZhciB5PTAsdj0wLGc9MDsyNTY+ZztnKyspe3ZhciBiPXZedjw8MV52PDwyXnY8PDNedjw8NCxiPWI+Pj44XjI1NSZiXjk5O2lbeV09YixvW2JdPXk7dmFyIF89cFt5XSxtPXBbX10saz1wW21dLFA9MjU3KnBbYl1eMTY4NDMwMDgqYjtzW3ldPVA8PDI0fFA+Pj44LGFbeV09UDw8MTZ8UD4+PjE2LHVbeV09UDw8OHxQPj4+MjQsY1t5XT1QLFA9MTY4NDMwMDkqa142NTUzNyptXjI1NypfXjE2ODQzMDA4KnksbFtiXT1QPDwyNHxQPj4+OCxoW2JdPVA8PDE2fFA+Pj4xNixmW2JdPVA8PDh8UD4+PjI0LGRbYl09UCx5Pyh5PV9ecFtwW3Bba15fXV1dLHZePXBbcFt2XV0pOnk9dj0xfXZhciBTPVswLDEsMiw0LDgsMTYsMzIsNjQsMTI4LDI3LDU0XSxyPXIuQUVTPXQuZXh0ZW5kKHtfZG9SZXNldDpmdW5jdGlvbigpe2Zvcih2YXIgZT10aGlzLl9rZXksdD1lLndvcmRzLG49ZS5zaWdCeXRlcy80LGU9NCooKHRoaXMuX25Sb3VuZHM9bis2KSsxKSxyPXRoaXMuX2tleVNjaGVkdWxlPVtdLG89MDtvPGU7bysrKWlmKG88bilyW29dPXRbb107ZWxzZXt2YXIgcz1yW28tMV07byVuPzY8biYmND09byVuJiYocz1pW3M+Pj4yNF08PDI0fGlbcz4+PjE2JjI1NV08PDE2fGlbcz4+PjgmMjU1XTw8OHxpWzI1NSZzXSk6KHM9czw8OHxzPj4+MjQscz1pW3M+Pj4yNF08PDI0fGlbcz4+PjE2JjI1NV08PDE2fGlbcz4+PjgmMjU1XTw8OHxpWzI1NSZzXSxzXj1TW28vbnwwXTw8MjQpLHJbb109cltvLW5dXnN9Zm9yKHQ9dGhpcy5faW52S2V5U2NoZWR1bGU9W10sbj0wO248ZTtuKyspbz1lLW4scz1uJTQ/cltvXTpyW28tNF0sdFtuXT00Pm58fDQ+PW8/czpsW2lbcz4+PjI0XV1eaFtpW3M+Pj4xNiYyNTVdXV5mW2lbcz4+PjgmMjU1XV1eZFtpWzI1NSZzXV19LGVuY3J5cHRCbG9jazpmdW5jdGlvbihlLHQpe3RoaXMuX2RvQ3J5cHRCbG9jayhlLHQsdGhpcy5fa2V5U2NoZWR1bGUscyxhLHUsYyxpKX0sZGVjcnlwdEJsb2NrOmZ1bmN0aW9uKGUsdCl7dmFyIG49ZVt0KzFdO2VbdCsxXT1lW3QrM10sZVt0KzNdPW4sdGhpcy5fZG9DcnlwdEJsb2NrKGUsdCx0aGlzLl9pbnZLZXlTY2hlZHVsZSxsLGgsZixkLG8pLG49ZVt0KzFdLGVbdCsxXT1lW3QrM10sZVt0KzNdPW59LF9kb0NyeXB0QmxvY2s6ZnVuY3Rpb24oZSx0LG4scixpLG8scyxhKXtmb3IodmFyIHU9dGhpcy5fblJvdW5kcyxjPWVbdF1eblswXSxsPWVbdCsxXV5uWzFdLGg9ZVt0KzJdXm5bMl0sZj1lW3QrM11eblszXSxkPTQscD0xO3A8dTtwKyspdmFyIGc9cltjPj4+MjRdXmlbbD4+PjE2JjI1NV1eb1toPj4+OCYyNTVdXnNbMjU1JmZdXm5bZCsrXSx5PXJbbD4+PjI0XV5pW2g+Pj4xNiYyNTVdXm9bZj4+PjgmMjU1XV5zWzI1NSZjXV5uW2QrK10sdj1yW2g+Pj4yNF1eaVtmPj4+MTYmMjU1XV5vW2M+Pj44JjI1NV1ec1syNTUmbF1ebltkKytdLGY9cltmPj4+MjRdXmlbYz4+PjE2JjI1NV1eb1tsPj4+OCYyNTVdXnNbMjU1JmhdXm5bZCsrXSxjPWcsbD15LGg9djtnPShhW2M+Pj4yNF08PDI0fGFbbD4+PjE2JjI1NV08PDE2fGFbaD4+PjgmMjU1XTw8OHxhWzI1NSZmXSlebltkKytdLHk9KGFbbD4+PjI0XTw8MjR8YVtoPj4+MTYmMjU1XTw8MTZ8YVtmPj4+OCYyNTVdPDw4fGFbMjU1JmNdKV5uW2QrK10sdj0oYVtoPj4+MjRdPDwyNHxhW2Y+Pj4xNiYyNTVdPDwxNnxhW2M+Pj44JjI1NV08PDh8YVsyNTUmbF0pXm5bZCsrXSxmPShhW2Y+Pj4yNF08PDI0fGFbYz4+PjE2JjI1NV08PDE2fGFbbD4+PjgmMjU1XTw8OHxhWzI1NSZoXSlebltkKytdLGVbdF09ZyxlW3QrMV09eSxlW3QrMl09dixlW3QrM109Zn0sa2V5U2l6ZTo4fSk7ZS5BRVM9dC5fY3JlYXRlSGVscGVyKHIpfSgpLG4ubW9kZS5FQ0I9ZnVuY3Rpb24oKXt2YXIgZT1uLmxpYi5CbG9ja0NpcGhlck1vZGUuZXh0ZW5kKCk7cmV0dXJuIGUuRW5jcnlwdG9yPWUuZXh0ZW5kKHtwcm9jZXNzQmxvY2s6ZnVuY3Rpb24oZSx0KXt0aGlzLl9jaXBoZXIuZW5jcnlwdEJsb2NrKGUsdCl9fSksZS5EZWNyeXB0b3I9ZS5leHRlbmQoe3Byb2Nlc3NCbG9jazpmdW5jdGlvbihlLHQpe3RoaXMuX2NpcGhlci5kZWNyeXB0QmxvY2soZSx0KX19KSxlfSgpLGUuZXhwb3J0cz1ufSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19ZnVuY3Rpb24gaShlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG89ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciByPXRbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIua2V5LHIpfX1yZXR1cm4gZnVuY3Rpb24odCxuLHIpe3JldHVybiBuJiZlKHQucHJvdG90eXBlLG4pLHImJmUodCxyKSx0fX0oKSxzPW4oOSksYT0ocihzKSxuKDcpKSx1PShyKGEpLG4oMTIpKSxjPShyKHUpLG4oMTQpKSxsPXIoYyksaD1uKDE3KSxmPXIoaCksZD0obig4KSxuKDEzKSkscD1yKGQpLGc9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHQpe3ZhciBuPXQuc3Vic2NyaWJlRW5kcG9pbnQscj10LmxlYXZlRW5kcG9pbnQsbz10LmhlYXJ0YmVhdEVuZHBvaW50LHM9dC5zZXRTdGF0ZUVuZHBvaW50LGE9dC50aW1lRW5kcG9pbnQsdT10LmNvbmZpZyxjPXQuY3J5cHRvLGg9dC5saXN0ZW5lck1hbmFnZXI7aSh0aGlzLGUpLHRoaXMuX2xpc3RlbmVyTWFuYWdlcj1oLHRoaXMuX2NvbmZpZz11LHRoaXMuX2xlYXZlRW5kcG9pbnQ9cix0aGlzLl9oZWFydGJlYXRFbmRwb2ludD1vLHRoaXMuX3NldFN0YXRlRW5kcG9pbnQ9cyx0aGlzLl9zdWJzY3JpYmVFbmRwb2ludD1uLHRoaXMuX2NyeXB0bz1jLHRoaXMuX2NoYW5uZWxzPXt9LHRoaXMuX3ByZXNlbmNlQ2hhbm5lbHM9e30sdGhpcy5fY2hhbm5lbEdyb3Vwcz17fSx0aGlzLl9wcmVzZW5jZUNoYW5uZWxHcm91cHM9e30sdGhpcy5fcGVuZGluZ0NoYW5uZWxTdWJzY3JpcHRpb25zPVtdLHRoaXMuX3BlbmRpbmdDaGFubmVsR3JvdXBTdWJzY3JpcHRpb25zPVtdLHRoaXMuX2N1cnJlbnRUaW1ldG9rZW49MCx0aGlzLl9sYXN0VGltZXRva2VuPTAsdGhpcy5fc3Vic2NyaXB0aW9uU3RhdHVzQW5ub3VuY2VkPSExLHRoaXMuX3JlY29ubmVjdGlvbk1hbmFnZXI9bmV3IGwuZGVmYXVsdCh7dGltZUVuZHBvaW50OmF9KX1yZXR1cm4gbyhlLFt7a2V5OlwiYWRhcHRTdGF0ZUNoYW5nZVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcyxyPWUuc3RhdGUsaT1lLmNoYW5uZWxzLG89dm9pZCAwPT09aT9bXTppLHM9ZS5jaGFubmVsR3JvdXBzLGE9dm9pZCAwPT09cz9bXTpzO3JldHVybiBvLmZvckVhY2goZnVuY3Rpb24oZSl7ZSBpbiBuLl9jaGFubmVscyYmKG4uX2NoYW5uZWxzW2VdLnN0YXRlPXIpfSksYS5mb3JFYWNoKGZ1bmN0aW9uKGUpe2UgaW4gbi5fY2hhbm5lbEdyb3VwcyYmKG4uX2NoYW5uZWxHcm91cHNbZV0uc3RhdGU9cil9KSx0aGlzLl9zZXRTdGF0ZUVuZHBvaW50KHtzdGF0ZTpyLGNoYW5uZWxzOm8sY2hhbm5lbEdyb3VwczphfSx0KX19LHtrZXk6XCJhZGFwdFN1YnNjcmliZUNoYW5nZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMsbj1lLnRpbWV0b2tlbixyPWUuY2hhbm5lbHMsaT12b2lkIDA9PT1yP1tdOnIsbz1lLmNoYW5uZWxHcm91cHMscz12b2lkIDA9PT1vP1tdOm8sYT1lLndpdGhQcmVzZW5jZSx1PXZvaWQgMCE9PWEmJmE7aWYoIXRoaXMuX2NvbmZpZy5zdWJzY3JpYmVLZXl8fFwiXCI9PT10aGlzLl9jb25maWcuc3Vic2NyaWJlS2V5KXJldHVybiB2b2lkKGNvbnNvbGUmJmNvbnNvbGUubG9nJiZjb25zb2xlLmxvZyhcInN1YnNjcmliZSBrZXkgbWlzc2luZzsgYWJvcnRpbmcgc3Vic2NyaWJlXCIpKTtuJiYodGhpcy5fbGFzdFRpbWV0b2tlbj10aGlzLl9jdXJyZW50VGltZXRva2VuLHRoaXMuX2N1cnJlbnRUaW1ldG9rZW49biksaS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3QuX2NoYW5uZWxzW2VdPXtzdGF0ZTp7fX0sdSYmKHQuX3ByZXNlbmNlQ2hhbm5lbHNbZV09e30pLHQuX3BlbmRpbmdDaGFubmVsU3Vic2NyaXB0aW9ucy5wdXNoKGUpfSkscy5mb3JFYWNoKGZ1bmN0aW9uKGUpe3QuX2NoYW5uZWxHcm91cHNbZV09e3N0YXRlOnt9fSx1JiYodC5fcHJlc2VuY2VDaGFubmVsR3JvdXBzW2VdPXt9KSx0Ll9wZW5kaW5nQ2hhbm5lbEdyb3VwU3Vic2NyaXB0aW9ucy5wdXNoKGUpfSksdGhpcy5fc3Vic2NyaXB0aW9uU3RhdHVzQW5ub3VuY2VkPSExLHRoaXMucmVjb25uZWN0KCl9fSx7a2V5OlwiYWRhcHRVbnN1YnNjcmliZUNoYW5nZVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcyxyPWUuY2hhbm5lbHMsaT12b2lkIDA9PT1yP1tdOnIsbz1lLmNoYW5uZWxHcm91cHMscz12b2lkIDA9PT1vP1tdOm87aS5mb3JFYWNoKGZ1bmN0aW9uKGUpe2UgaW4gbi5fY2hhbm5lbHMmJmRlbGV0ZSBuLl9jaGFubmVsc1tlXSxlIGluIG4uX3ByZXNlbmNlQ2hhbm5lbHMmJmRlbGV0ZSBuLl9wcmVzZW5jZUNoYW5uZWxzW2VdfSkscy5mb3JFYWNoKGZ1bmN0aW9uKGUpe2UgaW4gbi5fY2hhbm5lbEdyb3VwcyYmZGVsZXRlIG4uX2NoYW5uZWxHcm91cHNbZV0sZSBpbiBuLl9wcmVzZW5jZUNoYW5uZWxHcm91cHMmJmRlbGV0ZSBuLl9jaGFubmVsR3JvdXBzW2VdfSksdGhpcy5fY29uZmlnLnN1cHByZXNzTGVhdmVFdmVudHMhPT0hMXx8dHx8dGhpcy5fbGVhdmVFbmRwb2ludCh7Y2hhbm5lbHM6aSxjaGFubmVsR3JvdXBzOnN9LGZ1bmN0aW9uKGUpe2UuYWZmZWN0ZWRDaGFubmVscz1pLGUuYWZmZWN0ZWRDaGFubmVsR3JvdXBzPXMsZS5jdXJyZW50VGltZXRva2VuPW4uX2N1cnJlbnRUaW1ldG9rZW4sXG5lLmxhc3RUaW1ldG9rZW49bi5fbGFzdFRpbWV0b2tlbixuLl9saXN0ZW5lck1hbmFnZXIuYW5ub3VuY2VTdGF0dXMoZSl9KSwwPT09T2JqZWN0LmtleXModGhpcy5fY2hhbm5lbHMpLmxlbmd0aCYmMD09PU9iamVjdC5rZXlzKHRoaXMuX3ByZXNlbmNlQ2hhbm5lbHMpLmxlbmd0aCYmMD09PU9iamVjdC5rZXlzKHRoaXMuX2NoYW5uZWxHcm91cHMpLmxlbmd0aCYmMD09PU9iamVjdC5rZXlzKHRoaXMuX3ByZXNlbmNlQ2hhbm5lbEdyb3VwcykubGVuZ3RoJiYodGhpcy5fbGFzdFRpbWV0b2tlbj0wLHRoaXMuX2N1cnJlbnRUaW1ldG9rZW49MCx0aGlzLl9yZWdpb249bnVsbCx0aGlzLl9yZWNvbm5lY3Rpb25NYW5hZ2VyLnN0b3BQb2xsaW5nKCkpLHRoaXMucmVjb25uZWN0KCl9fSx7a2V5OlwidW5zdWJzY3JpYmVBbGxcIix2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLmFkYXB0VW5zdWJzY3JpYmVDaGFuZ2Uoe2NoYW5uZWxzOnRoaXMuZ2V0U3Vic2NyaWJlZENoYW5uZWxzKCksY2hhbm5lbEdyb3Vwczp0aGlzLmdldFN1YnNjcmliZWRDaGFubmVsR3JvdXBzKCl9LGUpfX0se2tleTpcImdldFN1YnNjcmliZWRDaGFubmVsc1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX2NoYW5uZWxzKX19LHtrZXk6XCJnZXRTdWJzY3JpYmVkQ2hhbm5lbEdyb3Vwc1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX2NoYW5uZWxHcm91cHMpfX0se2tleTpcInJlY29ubmVjdFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5fc3RhcnRTdWJzY3JpYmVMb29wKCksdGhpcy5fcmVnaXN0ZXJIZWFydGJlYXRUaW1lcigpfX0se2tleTpcImRpc2Nvbm5lY3RcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuX3N0b3BTdWJzY3JpYmVMb29wKCksdGhpcy5fc3RvcEhlYXJ0YmVhdFRpbWVyKCksdGhpcy5fcmVjb25uZWN0aW9uTWFuYWdlci5zdG9wUG9sbGluZygpfX0se2tleTpcIl9yZWdpc3RlckhlYXJ0YmVhdFRpbWVyXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLl9zdG9wSGVhcnRiZWF0VGltZXIoKSx0aGlzLl9wZXJmb3JtSGVhcnRiZWF0TG9vcCgpLHRoaXMuX2hlYXJ0YmVhdFRpbWVyPXNldEludGVydmFsKHRoaXMuX3BlcmZvcm1IZWFydGJlYXRMb29wLmJpbmQodGhpcyksMWUzKnRoaXMuX2NvbmZpZy5nZXRIZWFydGJlYXRJbnRlcnZhbCgpKX19LHtrZXk6XCJfc3RvcEhlYXJ0YmVhdFRpbWVyXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLl9oZWFydGJlYXRUaW1lciYmKGNsZWFySW50ZXJ2YWwodGhpcy5faGVhcnRiZWF0VGltZXIpLHRoaXMuX2hlYXJ0YmVhdFRpbWVyPW51bGwpfX0se2tleTpcIl9wZXJmb3JtSGVhcnRiZWF0TG9vcFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcyx0PU9iamVjdC5rZXlzKHRoaXMuX2NoYW5uZWxzKSxuPU9iamVjdC5rZXlzKHRoaXMuX2NoYW5uZWxHcm91cHMpLHI9e307aWYoMCE9PXQubGVuZ3RofHwwIT09bi5sZW5ndGgpe3QuZm9yRWFjaChmdW5jdGlvbih0KXt2YXIgbj1lLl9jaGFubmVsc1t0XS5zdGF0ZTtPYmplY3Qua2V5cyhuKS5sZW5ndGgmJihyW3RdPW4pfSksbi5mb3JFYWNoKGZ1bmN0aW9uKHQpe3ZhciBuPWUuX2NoYW5uZWxHcm91cHNbdF0uc3RhdGU7T2JqZWN0LmtleXMobikubGVuZ3RoJiYoclt0XT1uKX0pO3ZhciBpPWZ1bmN0aW9uKHQpe3QuZXJyb3ImJmUuX2NvbmZpZy5hbm5vdW5jZUZhaWxlZEhlYXJ0YmVhdHMmJmUuX2xpc3RlbmVyTWFuYWdlci5hbm5vdW5jZVN0YXR1cyh0KSwhdC5lcnJvciYmZS5fY29uZmlnLmFubm91bmNlU3VjY2Vzc2Z1bEhlYXJ0YmVhdHMmJmUuX2xpc3RlbmVyTWFuYWdlci5hbm5vdW5jZVN0YXR1cyh0KX07dGhpcy5faGVhcnRiZWF0RW5kcG9pbnQoe2NoYW5uZWxzOnQsY2hhbm5lbEdyb3VwczpuLHN0YXRlOnJ9LGkuYmluZCh0aGlzKSl9fX0se2tleTpcIl9zdGFydFN1YnNjcmliZUxvb3BcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuX3N0b3BTdWJzY3JpYmVMb29wKCk7dmFyIGU9W10sdD1bXTtpZihPYmplY3Qua2V5cyh0aGlzLl9jaGFubmVscykuZm9yRWFjaChmdW5jdGlvbih0KXtyZXR1cm4gZS5wdXNoKHQpfSksT2JqZWN0LmtleXModGhpcy5fcHJlc2VuY2VDaGFubmVscykuZm9yRWFjaChmdW5jdGlvbih0KXtyZXR1cm4gZS5wdXNoKHQrXCItcG5wcmVzXCIpfSksT2JqZWN0LmtleXModGhpcy5fY2hhbm5lbEdyb3VwcykuZm9yRWFjaChmdW5jdGlvbihlKXtyZXR1cm4gdC5wdXNoKGUpfSksT2JqZWN0LmtleXModGhpcy5fcHJlc2VuY2VDaGFubmVsR3JvdXBzKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiB0LnB1c2goZStcIi1wbnByZXNcIil9KSwwIT09ZS5sZW5ndGh8fDAhPT10Lmxlbmd0aCl7dmFyIG49e2NoYW5uZWxzOmUsY2hhbm5lbEdyb3Vwczp0LHRpbWV0b2tlbjp0aGlzLl9jdXJyZW50VGltZXRva2VuLGZpbHRlckV4cHJlc3Npb246dGhpcy5fY29uZmlnLmZpbHRlckV4cHJlc3Npb24scmVnaW9uOnRoaXMuX3JlZ2lvbn07dGhpcy5fc3Vic2NyaWJlQ2FsbD10aGlzLl9zdWJzY3JpYmVFbmRwb2ludChuLHRoaXMuX3Byb2Nlc3NTdWJzY3JpYmVSZXNwb25zZS5iaW5kKHRoaXMpKX19fSx7a2V5OlwiX3Byb2Nlc3NTdWJzY3JpYmVSZXNwb25zZVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztpZihlLmVycm9yKXJldHVybiB2b2lkKGUuY2F0ZWdvcnk9PT1wLmRlZmF1bHQuUE5UaW1lb3V0Q2F0ZWdvcnk/dGhpcy5fc3RhcnRTdWJzY3JpYmVMb29wKCk6ZS5jYXRlZ29yeT09PXAuZGVmYXVsdC5QTk5ldHdvcmtJc3N1ZXNDYXRlZ29yeT8odGhpcy5kaXNjb25uZWN0KCksdGhpcy5fcmVjb25uZWN0aW9uTWFuYWdlci5vblJlY29ubmVjdGlvbihmdW5jdGlvbigpe24ucmVjb25uZWN0KCksbi5fc3Vic2NyaXB0aW9uU3RhdHVzQW5ub3VuY2VkPSEwO3ZhciB0PXtjYXRlZ29yeTpwLmRlZmF1bHQuUE5SZWNvbm5lY3RlZENhdGVnb3J5LG9wZXJhdGlvbjplLm9wZXJhdGlvbixsYXN0VGltZXRva2VuOm4uX2xhc3RUaW1ldG9rZW4sY3VycmVudFRpbWV0b2tlbjpuLl9jdXJyZW50VGltZXRva2VufTtuLl9saXN0ZW5lck1hbmFnZXIuYW5ub3VuY2VTdGF0dXModCl9KSx0aGlzLl9yZWNvbm5lY3Rpb25NYW5hZ2VyLnN0YXJ0UG9sbGluZygpLHRoaXMuX2xpc3RlbmVyTWFuYWdlci5hbm5vdW5jZVN0YXR1cyhlKSk6dGhpcy5fbGlzdGVuZXJNYW5hZ2VyLmFubm91bmNlU3RhdHVzKGUpKTtpZih0aGlzLl9sYXN0VGltZXRva2VuPXRoaXMuX2N1cnJlbnRUaW1ldG9rZW4sdGhpcy5fY3VycmVudFRpbWV0b2tlbj10Lm1ldGFkYXRhLnRpbWV0b2tlbiwhdGhpcy5fc3Vic2NyaXB0aW9uU3RhdHVzQW5ub3VuY2VkKXt2YXIgcj17fTtyLmNhdGVnb3J5PXAuZGVmYXVsdC5QTkNvbm5lY3RlZENhdGVnb3J5LHIub3BlcmF0aW9uPWUub3BlcmF0aW9uLHIuYWZmZWN0ZWRDaGFubmVscz10aGlzLl9wZW5kaW5nQ2hhbm5lbFN1YnNjcmlwdGlvbnMsci5hZmZlY3RlZENoYW5uZWxHcm91cHM9dGhpcy5fcGVuZGluZ0NoYW5uZWxHcm91cFN1YnNjcmlwdGlvbnMsci5sYXN0VGltZXRva2VuPXRoaXMuX2xhc3RUaW1ldG9rZW4sci5jdXJyZW50VGltZXRva2VuPXRoaXMuX2N1cnJlbnRUaW1ldG9rZW4sdGhpcy5fc3Vic2NyaXB0aW9uU3RhdHVzQW5ub3VuY2VkPSEwLHRoaXMuX2xpc3RlbmVyTWFuYWdlci5hbm5vdW5jZVN0YXR1cyhyKSx0aGlzLl9wZW5kaW5nQ2hhbm5lbFN1YnNjcmlwdGlvbnM9W10sdGhpcy5fcGVuZGluZ0NoYW5uZWxHcm91cFN1YnNjcmlwdGlvbnM9W119dmFyIGk9dC5tZXNzYWdlc3x8W10sbz10aGlzLl9jb25maWcucmVxdWVzdE1lc3NhZ2VDb3VudFRocmVzaG9sZDtpZihvJiZpLmxlbmd0aD49byl7dmFyIHM9e307cy5jYXRlZ29yeT1wLmRlZmF1bHQuUE5SZXF1ZXN0TWVzc2FnZUNvdW50RXhjZWVkZWRDYXRlZ29yeSxzLm9wZXJhdGlvbj1lLm9wZXJhdGlvbix0aGlzLl9saXN0ZW5lck1hbmFnZXIuYW5ub3VuY2VTdGF0dXMocyl9aS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciB0PWUuY2hhbm5lbCxyPWUuc3Vic2NyaXB0aW9uTWF0Y2gsaT1lLnB1Ymxpc2hNZXRhRGF0YTtpZih0PT09ciYmKHI9bnVsbCksZi5kZWZhdWx0LmVuZHNXaXRoKGUuY2hhbm5lbCxcIi1wbnByZXNcIikpe3ZhciBvPXt9O28uY2hhbm5lbD1udWxsLG8uc3Vic2NyaXB0aW9uPW51bGwsby5hY3R1YWxDaGFubmVsPW51bGwhPXI/dDpudWxsLG8uc3Vic2NyaWJlZENoYW5uZWw9bnVsbCE9cj9yOnQsdCYmKG8uY2hhbm5lbD10LnN1YnN0cmluZygwLHQubGFzdEluZGV4T2YoXCItcG5wcmVzXCIpKSksciYmKG8uc3Vic2NyaXB0aW9uPXIuc3Vic3RyaW5nKDAsci5sYXN0SW5kZXhPZihcIi1wbnByZXNcIikpKSxvLmFjdGlvbj1lLnBheWxvYWQuYWN0aW9uLG8uc3RhdGU9ZS5wYXlsb2FkLmRhdGEsby50aW1ldG9rZW49aS5wdWJsaXNoVGltZXRva2VuLG8ub2NjdXBhbmN5PWUucGF5bG9hZC5vY2N1cGFuY3ksby51dWlkPWUucGF5bG9hZC51dWlkLG8udGltZXN0YW1wPWUucGF5bG9hZC50aW1lc3RhbXAsZS5wYXlsb2FkLmpvaW4mJihvLmpvaW49ZS5wYXlsb2FkLmpvaW4pLGUucGF5bG9hZC5sZWF2ZSYmKG8ubGVhdmU9ZS5wYXlsb2FkLmxlYXZlKSxlLnBheWxvYWQudGltZW91dCYmKG8udGltZW91dD1lLnBheWxvYWQudGltZW91dCksbi5fbGlzdGVuZXJNYW5hZ2VyLmFubm91bmNlUHJlc2VuY2Uobyl9ZWxzZXt2YXIgcz17fTtzLmNoYW5uZWw9bnVsbCxzLnN1YnNjcmlwdGlvbj1udWxsLHMuYWN0dWFsQ2hhbm5lbD1udWxsIT1yP3Q6bnVsbCxzLnN1YnNjcmliZWRDaGFubmVsPW51bGwhPXI/cjp0LHMuY2hhbm5lbD10LHMuc3Vic2NyaXB0aW9uPXIscy50aW1ldG9rZW49aS5wdWJsaXNoVGltZXRva2VuLHMucHVibGlzaGVyPWUuaXNzdWluZ0NsaWVudElkLG4uX2NvbmZpZy5jaXBoZXJLZXk/cy5tZXNzYWdlPW4uX2NyeXB0by5kZWNyeXB0KGUucGF5bG9hZCk6cy5tZXNzYWdlPWUucGF5bG9hZCxuLl9saXN0ZW5lck1hbmFnZXIuYW5ub3VuY2VNZXNzYWdlKHMpfX0pLHRoaXMuX3JlZ2lvbj10Lm1ldGFkYXRhLnJlZ2lvbix0aGlzLl9zdGFydFN1YnNjcmliZUxvb3AoKX19LHtrZXk6XCJfc3RvcFN1YnNjcmliZUxvb3BcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuX3N1YnNjcmliZUNhbGwmJih0aGlzLl9zdWJzY3JpYmVDYWxsLmFib3J0KCksdGhpcy5fc3Vic2NyaWJlQ2FsbD1udWxsKX19XSksZX0oKTt0LmRlZmF1bHQ9ZyxlLmV4cG9ydHM9dC5kZWZhdWx0fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcihlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIGk9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciByPXRbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIua2V5LHIpfX1yZXR1cm4gZnVuY3Rpb24odCxuLHIpe3JldHVybiBuJiZlKHQucHJvdG90eXBlLG4pLHImJmUodCxyKSx0fX0oKSxvPShuKDgpLG4oMTMpKSxzPWZ1bmN0aW9uKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX0obyksYT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXtyKHRoaXMsZSksdGhpcy5fbGlzdGVuZXJzPVtdfXJldHVybiBpKGUsW3trZXk6XCJhZGRMaXN0ZW5lclwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMuX2xpc3RlbmVycy5wdXNoKGUpfX0se2tleTpcInJlbW92ZUxpc3RlbmVyXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9W107dGhpcy5fbGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24obil7biE9PWUmJnQucHVzaChuKX0pLHRoaXMuX2xpc3RlbmVycz10fX0se2tleTpcInJlbW92ZUFsbExpc3RlbmVyc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5fbGlzdGVuZXJzPVtdfX0se2tleTpcImFubm91bmNlUHJlc2VuY2VcIix2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLl9saXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbih0KXt0LnByZXNlbmNlJiZ0LnByZXNlbmNlKGUpfSl9fSx7a2V5OlwiYW5ub3VuY2VTdGF0dXNcIix2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLl9saXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbih0KXt0LnN0YXR1cyYmdC5zdGF0dXMoZSl9KX19LHtrZXk6XCJhbm5vdW5jZU1lc3NhZ2VcIix2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLl9saXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbih0KXt0Lm1lc3NhZ2UmJnQubWVzc2FnZShlKX0pfX0se2tleTpcImFubm91bmNlTmV0d29ya1VwXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT17fTtlLmNhdGVnb3J5PXMuZGVmYXVsdC5QTk5ldHdvcmtVcENhdGVnb3J5LHRoaXMuYW5ub3VuY2VTdGF0dXMoZSl9fSx7a2V5OlwiYW5ub3VuY2VOZXR3b3JrRG93blwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9e307ZS5jYXRlZ29yeT1zLmRlZmF1bHQuUE5OZXR3b3JrRG93bkNhdGVnb3J5LHRoaXMuYW5ub3VuY2VTdGF0dXMoZSl9fV0pLGV9KCk7dC5kZWZhdWx0PWEsZS5leHBvcnRzPXQuZGVmYXVsdH0sZnVuY3Rpb24oZSx0KXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmRlZmF1bHQ9e1BOTmV0d29ya1VwQ2F0ZWdvcnk6XCJQTk5ldHdvcmtVcENhdGVnb3J5XCIsUE5OZXR3b3JrRG93bkNhdGVnb3J5OlwiUE5OZXR3b3JrRG93bkNhdGVnb3J5XCIsUE5OZXR3b3JrSXNzdWVzQ2F0ZWdvcnk6XCJQTk5ldHdvcmtJc3N1ZXNDYXRlZ29yeVwiLFBOVGltZW91dENhdGVnb3J5OlwiUE5UaW1lb3V0Q2F0ZWdvcnlcIixQTkJhZFJlcXVlc3RDYXRlZ29yeTpcIlBOQmFkUmVxdWVzdENhdGVnb3J5XCIsUE5BY2Nlc3NEZW5pZWRDYXRlZ29yeTpcIlBOQWNjZXNzRGVuaWVkQ2F0ZWdvcnlcIixQTlVua25vd25DYXRlZ29yeTpcIlBOVW5rbm93bkNhdGVnb3J5XCIsUE5SZWNvbm5lY3RlZENhdGVnb3J5OlwiUE5SZWNvbm5lY3RlZENhdGVnb3J5XCIsUE5Db25uZWN0ZWRDYXRlZ29yeTpcIlBOQ29ubmVjdGVkQ2F0ZWdvcnlcIixQTlJlcXVlc3RNZXNzYWdlQ291bnRFeGNlZWRlZENhdGVnb3J5OlwiUE5SZXF1ZXN0TWVzc2FnZUNvdW50RXhjZWVkZWRDYXRlZ29yeVwifSxlLmV4cG9ydHM9dC5kZWZhdWx0fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcihlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIGk9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciByPXRbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIua2V5LHIpfX1yZXR1cm4gZnVuY3Rpb24odCxuLHIpe3JldHVybiBuJiZlKHQucHJvdG90eXBlLG4pLHImJmUodCxyKSx0fX0oKSxvPW4oMTUpLHM9KGZ1bmN0aW9uKGUpe2UmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fShvKSxuKDgpLGZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0KXt2YXIgbj10LnRpbWVFbmRwb2ludDtyKHRoaXMsZSksdGhpcy5fdGltZUVuZHBvaW50PW59cmV0dXJuIGkoZSxbe2tleTpcIm9uUmVjb25uZWN0aW9uXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5fcmVjb25uZWN0aW9uQ2FsbGJhY2s9ZX19LHtrZXk6XCJzdGFydFBvbGxpbmdcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuX3RpbWVUaW1lcj1zZXRJbnRlcnZhbCh0aGlzLl9wZXJmb3JtVGltZUxvb3AuYmluZCh0aGlzKSwzZTMpfX0se2tleTpcInN0b3BQb2xsaW5nXCIsdmFsdWU6ZnVuY3Rpb24oKXtjbGVhckludGVydmFsKHRoaXMuX3RpbWVUaW1lcil9fSx7a2V5OlwiX3BlcmZvcm1UaW1lTG9vcFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpczt0aGlzLl90aW1lRW5kcG9pbnQoZnVuY3Rpb24odCl7dC5lcnJvcnx8KGNsZWFySW50ZXJ2YWwoZS5fdGltZVRpbWVyKSxlLl9yZWNvbm5lY3Rpb25DYWxsYmFjaygpKX0pfX1dKSxlfSgpKTt0LmRlZmF1bHQ9cyxlLmV4cG9ydHM9dC5kZWZhdWx0fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcigpe3JldHVybiBoLmRlZmF1bHQuUE5UaW1lT3BlcmF0aW9ufWZ1bmN0aW9uIGkoKXtyZXR1cm5cIi90aW1lLzBcIn1mdW5jdGlvbiBvKGUpe3JldHVybiBlLmNvbmZpZy5nZXRUcmFuc2FjdGlvblRpbWVvdXQoKX1mdW5jdGlvbiBzKCl7cmV0dXJue319ZnVuY3Rpb24gYSgpe3JldHVybiExfWZ1bmN0aW9uIHUoZSx0KXtyZXR1cm57dGltZXRva2VuOnRbMF19fWZ1bmN0aW9uIGMoKXt9T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5nZXRPcGVyYXRpb249cix0LmdldFVSTD1pLHQuZ2V0UmVxdWVzdFRpbWVvdXQ9byx0LnByZXBhcmVQYXJhbXM9cyx0LmlzQXV0aFN1cHBvcnRlZD1hLHQuaGFuZGxlUmVzcG9uc2U9dSx0LnZhbGlkYXRlUGFyYW1zPWM7dmFyIGw9KG4oOCksbigxNikpLGg9ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fShsKX0sZnVuY3Rpb24oZSx0KXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmRlZmF1bHQ9e1BOVGltZU9wZXJhdGlvbjpcIlBOVGltZU9wZXJhdGlvblwiLFBOSGlzdG9yeU9wZXJhdGlvbjpcIlBOSGlzdG9yeU9wZXJhdGlvblwiLFBORmV0Y2hNZXNzYWdlc09wZXJhdGlvbjpcIlBORmV0Y2hNZXNzYWdlc09wZXJhdGlvblwiLFBOU3Vic2NyaWJlT3BlcmF0aW9uOlwiUE5TdWJzY3JpYmVPcGVyYXRpb25cIixQTlVuc3Vic2NyaWJlT3BlcmF0aW9uOlwiUE5VbnN1YnNjcmliZU9wZXJhdGlvblwiLFBOUHVibGlzaE9wZXJhdGlvbjpcIlBOUHVibGlzaE9wZXJhdGlvblwiLFBOUHVzaE5vdGlmaWNhdGlvbkVuYWJsZWRDaGFubmVsc09wZXJhdGlvbjpcIlBOUHVzaE5vdGlmaWNhdGlvbkVuYWJsZWRDaGFubmVsc09wZXJhdGlvblwiLFBOUmVtb3ZlQWxsUHVzaE5vdGlmaWNhdGlvbnNPcGVyYXRpb246XCJQTlJlbW92ZUFsbFB1c2hOb3RpZmljYXRpb25zT3BlcmF0aW9uXCIsUE5XaGVyZU5vd09wZXJhdGlvbjpcIlBOV2hlcmVOb3dPcGVyYXRpb25cIixQTlNldFN0YXRlT3BlcmF0aW9uOlwiUE5TZXRTdGF0ZU9wZXJhdGlvblwiLFBOSGVyZU5vd09wZXJhdGlvbjpcIlBOSGVyZU5vd09wZXJhdGlvblwiLFBOR2V0U3RhdGVPcGVyYXRpb246XCJQTkdldFN0YXRlT3BlcmF0aW9uXCIsUE5IZWFydGJlYXRPcGVyYXRpb246XCJQTkhlYXJ0YmVhdE9wZXJhdGlvblwiLFBOQ2hhbm5lbEdyb3Vwc09wZXJhdGlvbjpcIlBOQ2hhbm5lbEdyb3Vwc09wZXJhdGlvblwiLFBOUmVtb3ZlR3JvdXBPcGVyYXRpb246XCJQTlJlbW92ZUdyb3VwT3BlcmF0aW9uXCIsUE5DaGFubmVsc0Zvckdyb3VwT3BlcmF0aW9uOlwiUE5DaGFubmVsc0Zvckdyb3VwT3BlcmF0aW9uXCIsUE5BZGRDaGFubmVsc1RvR3JvdXBPcGVyYXRpb246XCJQTkFkZENoYW5uZWxzVG9Hcm91cE9wZXJhdGlvblwiLFBOUmVtb3ZlQ2hhbm5lbHNGcm9tR3JvdXBPcGVyYXRpb246XCJQTlJlbW92ZUNoYW5uZWxzRnJvbUdyb3VwT3BlcmF0aW9uXCIsUE5BY2Nlc3NNYW5hZ2VyR3JhbnQ6XCJQTkFjY2Vzc01hbmFnZXJHcmFudFwiLFBOQWNjZXNzTWFuYWdlckF1ZGl0OlwiUE5BY2Nlc3NNYW5hZ2VyQXVkaXRcIn0sZS5leHBvcnRzPXQuZGVmYXVsdH0sZnVuY3Rpb24oZSx0KXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBuKGUpe3ZhciB0PVtdO3JldHVybiBPYmplY3Qua2V5cyhlKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiB0LnB1c2goZSl9KSx0fWZ1bmN0aW9uIHIoZSl7cmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChlKS5yZXBsYWNlKC9bIX4qJygpXS9nLGZ1bmN0aW9uKGUpe3JldHVyblwiJVwiK2UuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKX0pfWZ1bmN0aW9uIGkoZSl7cmV0dXJuIG4oZSkuc29ydCgpfWZ1bmN0aW9uIG8oZSl7cmV0dXJuIGkoZSkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0K1wiPVwiK3IoZVt0XSl9KS5qb2luKFwiJlwiKX1mdW5jdGlvbiBzKGUsdCl7cmV0dXJuIGUuaW5kZXhPZih0LHRoaXMubGVuZ3RoLXQubGVuZ3RoKSE9PS0xfWZ1bmN0aW9uIGEoKXt2YXIgZT12b2lkIDAsdD12b2lkIDA7cmV0dXJue3Byb21pc2U6bmV3IFByb21pc2UoZnVuY3Rpb24obixyKXtlPW4sdD1yfSkscmVqZWN0OnQsZnVsZmlsbDplfX1lLmV4cG9ydHM9e3NpZ25QYW1Gcm9tUGFyYW1zOm8sZW5kc1dpdGg6cyxjcmVhdGVQcm9taXNlOmEsZW5jb2RlU3RyaW5nOnJ9fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19ZnVuY3Rpb24gaShlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gbyhlLHQpe2lmKCFlKXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hdHx8XCJvYmplY3RcIiE9dHlwZW9mIHQmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQ/ZTp0fWZ1bmN0aW9uIHMoZSx0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0JiZudWxsIT09dCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIit0eXBlb2YgdCk7ZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh0JiZ0LnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOmUsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksdCYmKE9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3Quc2V0UHJvdG90eXBlT2YoZSx0KTplLl9fcHJvdG9fXz10KX1mdW5jdGlvbiBhKGUsdCl7cmV0dXJuIGUudHlwZT10LGUuZXJyb3I9ITAsZX1mdW5jdGlvbiB1KGUpe3JldHVybiBhKHttZXNzYWdlOmV9LFwidmFsaWRhdGlvbkVycm9yXCIpfWZ1bmN0aW9uIGMoZSx0LG4pe3JldHVybiBlLnVzZVBvc3QmJmUudXNlUG9zdCh0LG4pP2UucG9zdFVSTCh0LG4pOmUuZ2V0VVJMKHQsbil9ZnVuY3Rpb24gbChlKXt2YXIgdD1cIlB1Yk51Yi1KUy1cIitlLnNka0ZhbWlseTtyZXR1cm4gZS5wYXJ0bmVySWQmJih0Kz1cIi1cIitlLnBhcnRuZXJJZCksdCs9XCIvXCIrZS5nZXRWZXJzaW9uKCl9ZnVuY3Rpb24gaChlLHQsbil7dmFyIHI9ZS5jb25maWcsaT1lLmNyeXB0bztuLnRpbWVzdGFtcD1NYXRoLmZsb29yKChuZXcgRGF0ZSkuZ2V0VGltZSgpLzFlMyk7dmFyIG89ci5zdWJzY3JpYmVLZXkrXCJcXG5cIityLnB1Ymxpc2hLZXkrXCJcXG5cIit0K1wiXFxuXCI7bys9Zy5kZWZhdWx0LnNpZ25QYW1Gcm9tUGFyYW1zKG4pO3ZhciBzPWkuSE1BQ1NIQTI1NihvKTtzPXMucmVwbGFjZSgvXFwrL2csXCItXCIpLHM9cy5yZXBsYWNlKC9cXC8vZyxcIl9cIiksbi5zaWduYXR1cmU9c31PYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmRlZmF1bHQ9ZnVuY3Rpb24oZSx0KXt2YXIgbj1lLm5ldHdvcmtpbmcscj1lLmNvbmZpZyxpPW51bGwsbz1udWxsLHM9e307dC5nZXRPcGVyYXRpb24oKT09PWIuZGVmYXVsdC5QTlRpbWVPcGVyYXRpb258fHQuZ2V0T3BlcmF0aW9uKCk9PT1iLmRlZmF1bHQuUE5DaGFubmVsR3JvdXBzT3BlcmF0aW9uP2k9YXJndW1lbnRzLmxlbmd0aDw9Mj92b2lkIDA6YXJndW1lbnRzWzJdOihzPWFyZ3VtZW50cy5sZW5ndGg8PTI/dm9pZCAwOmFyZ3VtZW50c1syXSxpPWFyZ3VtZW50cy5sZW5ndGg8PTM/dm9pZCAwOmFyZ3VtZW50c1szXSksXCJ1bmRlZmluZWRcIj09dHlwZW9mIFByb21pc2V8fGl8fChvPWcuZGVmYXVsdC5jcmVhdGVQcm9taXNlKCkpO3ZhciBhPXQudmFsaWRhdGVQYXJhbXMoZSxzKTtpZighYSl7dmFyIGY9dC5wcmVwYXJlUGFyYW1zKGUscykscD1jKHQsZSxzKSx5PXZvaWQgMCx2PXt1cmw6cCxvcGVyYXRpb246dC5nZXRPcGVyYXRpb24oKSx0aW1lb3V0OnQuZ2V0UmVxdWVzdFRpbWVvdXQoZSl9O2YudXVpZD1yLlVVSUQsZi5wbnNkaz1sKHIpLHIudXNlSW5zdGFuY2VJZCYmKGYuaW5zdGFuY2VpZD1yLmluc3RhbmNlSWQpLHIudXNlUmVxdWVzdElkJiYoZi5yZXF1ZXN0aWQ9ZC5kZWZhdWx0LnY0KCkpLHQuaXNBdXRoU3VwcG9ydGVkKCkmJnIuZ2V0QXV0aEtleSgpJiYoZi5hdXRoPXIuZ2V0QXV0aEtleSgpKSxyLnNlY3JldEtleSYmaChlLHAsZik7dmFyIG09ZnVuY3Rpb24obixyKXtpZihuLmVycm9yKXJldHVybiB2b2lkKGk/aShuKTpvJiZvLnJlamVjdChuZXcgXyhcIlB1Yk51YiBjYWxsIGZhaWxlZCwgY2hlY2sgc3RhdHVzIGZvciBkZXRhaWxzXCIsbikpKTt2YXIgYT10LmhhbmRsZVJlc3BvbnNlKGUscixzKTtpP2kobixhKTpvJiZvLmZ1bGZpbGwoYSl9O2lmKHQudXNlUG9zdCYmdC51c2VQb3N0KGUscykpe3ZhciBrPXQucG9zdFBheWxvYWQoZSxzKTt5PW4uUE9TVChmLGssdixtKX1lbHNlIHk9bi5HRVQoZix2LG0pO3JldHVybiB0LmdldE9wZXJhdGlvbigpPT09Yi5kZWZhdWx0LlBOU3Vic2NyaWJlT3BlcmF0aW9uP3k6bz9vLnByb21pc2U6dm9pZCAwfXJldHVybiBpP2kodShhKSk6bz8oby5yZWplY3QobmV3IF8oXCJWYWxpZGF0aW9uIGZhaWxlZCwgY2hlY2sgc3RhdHVzIGZvciBkZXRhaWxzXCIsdShhKSkpLG8ucHJvbWlzZSk6dm9pZCAwfTt2YXIgZj1uKDIpLGQ9cihmKSxwPShuKDgpLG4oMTcpKSxnPXIocCkseT1uKDcpLHY9KHIoeSksbigxNikpLGI9cih2KSxfPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoZSxuKXtpKHRoaXMsdCk7dmFyIHI9byh0aGlzLCh0Ll9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKHQpKS5jYWxsKHRoaXMsZSkpO3JldHVybiByLm5hbWU9ci5jb25zdHJ1Y3Rvci5uYW1lLHIuc3RhdHVzPW4sci5tZXNzYWdlPWUscn1yZXR1cm4gcyh0LGUpLHR9KEVycm9yKTtlLmV4cG9ydHM9dC5kZWZhdWx0fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19ZnVuY3Rpb24gaSgpe3JldHVybiBmLmRlZmF1bHQuUE5BZGRDaGFubmVsc1RvR3JvdXBPcGVyYXRpb259ZnVuY3Rpb24gbyhlLHQpe3ZhciBuPXQuY2hhbm5lbHMscj10LmNoYW5uZWxHcm91cCxpPWUuY29uZmlnO3JldHVybiByP24mJjAhPT1uLmxlbmd0aD9pLnN1YnNjcmliZUtleT92b2lkIDA6XCJNaXNzaW5nIFN1YnNjcmliZSBLZXlcIjpcIk1pc3NpbmcgQ2hhbm5lbHNcIjpcIk1pc3NpbmcgQ2hhbm5lbCBHcm91cFwifWZ1bmN0aW9uIHMoZSx0KXt2YXIgbj10LmNoYW5uZWxHcm91cDtyZXR1cm5cIi92MS9jaGFubmVsLXJlZ2lzdHJhdGlvbi9zdWIta2V5L1wiK2UuY29uZmlnLnN1YnNjcmliZUtleStcIi9jaGFubmVsLWdyb3VwL1wiK3AuZGVmYXVsdC5lbmNvZGVTdHJpbmcobil9ZnVuY3Rpb24gYShlKXtyZXR1cm4gZS5jb25maWcuZ2V0VHJhbnNhY3Rpb25UaW1lb3V0KCl9ZnVuY3Rpb24gdSgpe3JldHVybiEwfWZ1bmN0aW9uIGMoZSx0KXt2YXIgbj10LmNoYW5uZWxzO3JldHVybnthZGQ6KHZvaWQgMD09PW4/W106bikuam9pbihcIixcIil9fWZ1bmN0aW9uIGwoKXtyZXR1cm57fX1PYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmdldE9wZXJhdGlvbj1pLHQudmFsaWRhdGVQYXJhbXM9byx0LmdldFVSTD1zLHQuZ2V0UmVxdWVzdFRpbWVvdXQ9YSx0LmlzQXV0aFN1cHBvcnRlZD11LHQucHJlcGFyZVBhcmFtcz1jLHQuaGFuZGxlUmVzcG9uc2U9bDt2YXIgaD0obig4KSxuKDE2KSksZj1yKGgpLGQ9bigxNykscD1yKGQpfSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19ZnVuY3Rpb24gaSgpe3JldHVybiBmLmRlZmF1bHQuUE5SZW1vdmVDaGFubmVsc0Zyb21Hcm91cE9wZXJhdGlvbn1mdW5jdGlvbiBvKGUsdCl7dmFyIG49dC5jaGFubmVscyxyPXQuY2hhbm5lbEdyb3VwLGk9ZS5jb25maWc7cmV0dXJuIHI/biYmMCE9PW4ubGVuZ3RoP2kuc3Vic2NyaWJlS2V5P3ZvaWQgMDpcIk1pc3NpbmcgU3Vic2NyaWJlIEtleVwiOlwiTWlzc2luZyBDaGFubmVsc1wiOlwiTWlzc2luZyBDaGFubmVsIEdyb3VwXCJ9ZnVuY3Rpb24gcyhlLHQpe3ZhciBuPXQuY2hhbm5lbEdyb3VwO3JldHVyblwiL3YxL2NoYW5uZWwtcmVnaXN0cmF0aW9uL3N1Yi1rZXkvXCIrZS5jb25maWcuc3Vic2NyaWJlS2V5K1wiL2NoYW5uZWwtZ3JvdXAvXCIrcC5kZWZhdWx0LmVuY29kZVN0cmluZyhuKX1mdW5jdGlvbiBhKGUpe3JldHVybiBlLmNvbmZpZy5nZXRUcmFuc2FjdGlvblRpbWVvdXQoKX1mdW5jdGlvbiB1KCl7cmV0dXJuITB9ZnVuY3Rpb24gYyhlLHQpe3ZhciBuPXQuY2hhbm5lbHM7cmV0dXJue3JlbW92ZToodm9pZCAwPT09bj9bXTpuKS5qb2luKFwiLFwiKX19ZnVuY3Rpb24gbCgpe3JldHVybnt9fU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZ2V0T3BlcmF0aW9uPWksdC52YWxpZGF0ZVBhcmFtcz1vLHQuZ2V0VVJMPXMsdC5nZXRSZXF1ZXN0VGltZW91dD1hLHQuaXNBdXRoU3VwcG9ydGVkPXUsdC5wcmVwYXJlUGFyYW1zPWMsdC5oYW5kbGVSZXNwb25zZT1sO3ZhciBoPShuKDgpLG4oMTYpKSxmPXIoaCksZD1uKDE3KSxwPXIoZCl9LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX1mdW5jdGlvbiBpKCl7cmV0dXJuIGYuZGVmYXVsdC5QTlJlbW92ZUdyb3VwT3BlcmF0aW9ufWZ1bmN0aW9uIG8oZSx0KXt2YXIgbj10LmNoYW5uZWxHcm91cCxyPWUuY29uZmlnO3JldHVybiBuP3Iuc3Vic2NyaWJlS2V5P3ZvaWQgMDpcIk1pc3NpbmcgU3Vic2NyaWJlIEtleVwiOlwiTWlzc2luZyBDaGFubmVsIEdyb3VwXCJ9ZnVuY3Rpb24gcyhlLHQpe3ZhciBuPXQuY2hhbm5lbEdyb3VwO3JldHVyblwiL3YxL2NoYW5uZWwtcmVnaXN0cmF0aW9uL3N1Yi1rZXkvXCIrZS5jb25maWcuc3Vic2NyaWJlS2V5K1wiL2NoYW5uZWwtZ3JvdXAvXCIrcC5kZWZhdWx0LmVuY29kZVN0cmluZyhuKStcIi9yZW1vdmVcIn1mdW5jdGlvbiBhKCl7cmV0dXJuITB9ZnVuY3Rpb24gdShlKXtyZXR1cm4gZS5jb25maWcuZ2V0VHJhbnNhY3Rpb25UaW1lb3V0KCl9ZnVuY3Rpb24gYygpe3JldHVybnt9fWZ1bmN0aW9uIGwoKXtyZXR1cm57fX1PYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmdldE9wZXJhdGlvbj1pLHQudmFsaWRhdGVQYXJhbXM9byx0LmdldFVSTD1zLHQuaXNBdXRoU3VwcG9ydGVkPWEsdC5nZXRSZXF1ZXN0VGltZW91dD11LHQucHJlcGFyZVBhcmFtcz1jLHQuaGFuZGxlUmVzcG9uc2U9bDt2YXIgaD0obig4KSxuKDE2KSksZj1yKGgpLGQ9bigxNykscD1yKGQpfSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcigpe3JldHVybiBoLmRlZmF1bHQuUE5DaGFubmVsR3JvdXBzT3BlcmF0aW9ufWZ1bmN0aW9uIGkoZSl7aWYoIWUuY29uZmlnLnN1YnNjcmliZUtleSlyZXR1cm5cIk1pc3NpbmcgU3Vic2NyaWJlIEtleVwifWZ1bmN0aW9uIG8oZSl7cmV0dXJuXCIvdjEvY2hhbm5lbC1yZWdpc3RyYXRpb24vc3ViLWtleS9cIitlLmNvbmZpZy5zdWJzY3JpYmVLZXkrXCIvY2hhbm5lbC1ncm91cFwifWZ1bmN0aW9uIHMoZSl7cmV0dXJuIGUuY29uZmlnLmdldFRyYW5zYWN0aW9uVGltZW91dCgpfWZ1bmN0aW9uIGEoKXtyZXR1cm4hMH1mdW5jdGlvbiB1KCl7cmV0dXJue319ZnVuY3Rpb24gYyhlLHQpe3JldHVybntncm91cHM6dC5wYXlsb2FkLmdyb3Vwc319T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5nZXRPcGVyYXRpb249cix0LnZhbGlkYXRlUGFyYW1zPWksdC5nZXRVUkw9byx0LmdldFJlcXVlc3RUaW1lb3V0PXMsdC5pc0F1dGhTdXBwb3J0ZWQ9YSx0LnByZXBhcmVQYXJhbXM9dSx0LmhhbmRsZVJlc3BvbnNlPWM7dmFyIGw9KG4oOCksbigxNikpLGg9ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fShsKX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIoZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fWZ1bmN0aW9uIGkoKXtyZXR1cm4gZi5kZWZhdWx0LlBOQ2hhbm5lbHNGb3JHcm91cE9wZXJhdGlvbn1mdW5jdGlvbiBvKGUsdCl7dmFyIG49dC5jaGFubmVsR3JvdXAscj1lLmNvbmZpZztyZXR1cm4gbj9yLnN1YnNjcmliZUtleT92b2lkIDA6XCJNaXNzaW5nIFN1YnNjcmliZSBLZXlcIjpcIk1pc3NpbmcgQ2hhbm5lbCBHcm91cFwifWZ1bmN0aW9uIHMoZSx0KXt2YXIgbj10LmNoYW5uZWxHcm91cDtyZXR1cm5cIi92MS9jaGFubmVsLXJlZ2lzdHJhdGlvbi9zdWIta2V5L1wiK2UuY29uZmlnLnN1YnNjcmliZUtleStcIi9jaGFubmVsLWdyb3VwL1wiK3AuZGVmYXVsdC5lbmNvZGVTdHJpbmcobil9ZnVuY3Rpb24gYShlKXtyZXR1cm4gZS5jb25maWcuZ2V0VHJhbnNhY3Rpb25UaW1lb3V0KCl9ZnVuY3Rpb24gdSgpe3JldHVybiEwfWZ1bmN0aW9uIGMoKXtyZXR1cm57fX1mdW5jdGlvbiBsKGUsdCl7cmV0dXJue2NoYW5uZWxzOnQucGF5bG9hZC5jaGFubmVsc319T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5nZXRPcGVyYXRpb249aSx0LnZhbGlkYXRlUGFyYW1zPW8sdC5nZXRVUkw9cyx0LmdldFJlcXVlc3RUaW1lb3V0PWEsdC5pc0F1dGhTdXBwb3J0ZWQ9dSx0LnByZXBhcmVQYXJhbXM9Yyx0LmhhbmRsZVJlc3BvbnNlPWw7dmFyIGg9KG4oOCksbigxNikpLGY9cihoKSxkPW4oMTcpLHA9cihkKX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIoKXtyZXR1cm4gaC5kZWZhdWx0LlBOUHVzaE5vdGlmaWNhdGlvbkVuYWJsZWRDaGFubmVsc09wZXJhdGlvbn1mdW5jdGlvbiBpKGUsdCl7dmFyIG49dC5kZXZpY2Uscj10LnB1c2hHYXRld2F5LGk9dC5jaGFubmVscyxvPWUuY29uZmlnO3JldHVybiBuP3I/aSYmMCE9PWkubGVuZ3RoP28uc3Vic2NyaWJlS2V5P3ZvaWQgMDpcIk1pc3NpbmcgU3Vic2NyaWJlIEtleVwiOlwiTWlzc2luZyBDaGFubmVsc1wiOlwiTWlzc2luZyBHVyBUeXBlIChwdXNoR2F0ZXdheTogZ2NtIG9yIGFwbnMpXCI6XCJNaXNzaW5nIERldmljZSBJRCAoZGV2aWNlKVwifWZ1bmN0aW9uIG8oZSx0KXt2YXIgbj10LmRldmljZTtyZXR1cm5cIi92MS9wdXNoL3N1Yi1rZXkvXCIrZS5jb25maWcuc3Vic2NyaWJlS2V5K1wiL2RldmljZXMvXCIrbn1mdW5jdGlvbiBzKGUpe3JldHVybiBlLmNvbmZpZy5nZXRUcmFuc2FjdGlvblRpbWVvdXQoKX1mdW5jdGlvbiBhKCl7cmV0dXJuITB9ZnVuY3Rpb24gdShlLHQpe3ZhciBuPXQucHVzaEdhdGV3YXkscj10LmNoYW5uZWxzO3JldHVybnt0eXBlOm4sYWRkOih2b2lkIDA9PT1yP1tdOnIpLmpvaW4oXCIsXCIpfX1mdW5jdGlvbiBjKCl7cmV0dXJue319T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5nZXRPcGVyYXRpb249cix0LnZhbGlkYXRlUGFyYW1zPWksdC5nZXRVUkw9byx0LmdldFJlcXVlc3RUaW1lb3V0PXMsdC5pc0F1dGhTdXBwb3J0ZWQ9YSx0LnByZXBhcmVQYXJhbXM9dSx0LmhhbmRsZVJlc3BvbnNlPWM7dmFyIGw9KG4oOCksbigxNikpLGg9ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fShsKX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIoKXtyZXR1cm4gaC5kZWZhdWx0LlBOUHVzaE5vdGlmaWNhdGlvbkVuYWJsZWRDaGFubmVsc09wZXJhdGlvbn1mdW5jdGlvbiBpKGUsdCl7dmFyIG49dC5kZXZpY2Uscj10LnB1c2hHYXRld2F5LGk9dC5jaGFubmVscyxvPWUuY29uZmlnO3JldHVybiBuP3I/aSYmMCE9PWkubGVuZ3RoP28uc3Vic2NyaWJlS2V5P3ZvaWQgMDpcIk1pc3NpbmcgU3Vic2NyaWJlIEtleVwiOlwiTWlzc2luZyBDaGFubmVsc1wiOlwiTWlzc2luZyBHVyBUeXBlIChwdXNoR2F0ZXdheTogZ2NtIG9yIGFwbnMpXCI6XCJNaXNzaW5nIERldmljZSBJRCAoZGV2aWNlKVwifWZ1bmN0aW9uIG8oZSx0KXt2YXIgbj10LmRldmljZTtyZXR1cm5cIi92MS9wdXNoL3N1Yi1rZXkvXCIrZS5jb25maWcuc3Vic2NyaWJlS2V5K1wiL2RldmljZXMvXCIrbn1mdW5jdGlvbiBzKGUpe3JldHVybiBlLmNvbmZpZy5nZXRUcmFuc2FjdGlvblRpbWVvdXQoKX1mdW5jdGlvbiBhKCl7cmV0dXJuITB9ZnVuY3Rpb24gdShlLHQpe3ZhciBuPXQucHVzaEdhdGV3YXkscj10LmNoYW5uZWxzO3JldHVybnt0eXBlOm4scmVtb3ZlOih2b2lkIDA9PT1yP1tdOnIpLmpvaW4oXCIsXCIpfX1mdW5jdGlvbiBjKCl7cmV0dXJue319T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5nZXRPcGVyYXRpb249cix0LnZhbGlkYXRlUGFyYW1zPWksdC5nZXRVUkw9byx0LmdldFJlcXVlc3RUaW1lb3V0PXMsdC5pc0F1dGhTdXBwb3J0ZWQ9YSx0LnByZXBhcmVQYXJhbXM9dSx0LmhhbmRsZVJlc3BvbnNlPWM7dmFyIGw9KG4oOCksbigxNikpLGg9ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fShsKX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIoKXtyZXR1cm4gaC5kZWZhdWx0LlBOUHVzaE5vdGlmaWNhdGlvbkVuYWJsZWRDaGFubmVsc09wZXJhdGlvbn1mdW5jdGlvbiBpKGUsdCl7dmFyIG49dC5kZXZpY2Uscj10LnB1c2hHYXRld2F5LGk9ZS5jb25maWc7cmV0dXJuIG4/cj9pLnN1YnNjcmliZUtleT92b2lkIDA6XCJNaXNzaW5nIFN1YnNjcmliZSBLZXlcIjpcIk1pc3NpbmcgR1cgVHlwZSAocHVzaEdhdGV3YXk6IGdjbSBvciBhcG5zKVwiOlwiTWlzc2luZyBEZXZpY2UgSUQgKGRldmljZSlcIn1mdW5jdGlvbiBvKGUsdCl7dmFyIG49dC5kZXZpY2U7cmV0dXJuXCIvdjEvcHVzaC9zdWIta2V5L1wiK2UuY29uZmlnLnN1YnNjcmliZUtleStcIi9kZXZpY2VzL1wiK259ZnVuY3Rpb24gcyhlKXtyZXR1cm4gZS5jb25maWcuZ2V0VHJhbnNhY3Rpb25UaW1lb3V0KCl9ZnVuY3Rpb24gYSgpe3JldHVybiEwfWZ1bmN0aW9uIHUoZSx0KXtyZXR1cm57dHlwZTp0LnB1c2hHYXRld2F5fX1mdW5jdGlvbiBjKGUsdCl7cmV0dXJue2NoYW5uZWxzOnR9fU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZ2V0T3BlcmF0aW9uPXIsdC52YWxpZGF0ZVBhcmFtcz1pLHQuZ2V0VVJMPW8sdC5nZXRSZXF1ZXN0VGltZW91dD1zLHQuaXNBdXRoU3VwcG9ydGVkPWEsdC5wcmVwYXJlUGFyYW1zPXUsdC5oYW5kbGVSZXNwb25zZT1jO3ZhciBsPShuKDgpLG4oMTYpKSxoPWZ1bmN0aW9uKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX0obCl9LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKCl7cmV0dXJuIGguZGVmYXVsdC5QTlJlbW92ZUFsbFB1c2hOb3RpZmljYXRpb25zT3BlcmF0aW9ufWZ1bmN0aW9uIGkoZSx0KXt2YXIgbj10LmRldmljZSxyPXQucHVzaEdhdGV3YXksaT1lLmNvbmZpZztyZXR1cm4gbj9yP2kuc3Vic2NyaWJlS2V5P3ZvaWQgMDpcIk1pc3NpbmcgU3Vic2NyaWJlIEtleVwiOlwiTWlzc2luZyBHVyBUeXBlIChwdXNoR2F0ZXdheTogZ2NtIG9yIGFwbnMpXCI6XCJNaXNzaW5nIERldmljZSBJRCAoZGV2aWNlKVwifWZ1bmN0aW9uIG8oZSx0KXt2YXIgbj10LmRldmljZTtyZXR1cm5cIi92MS9wdXNoL3N1Yi1rZXkvXCIrZS5jb25maWcuc3Vic2NyaWJlS2V5K1wiL2RldmljZXMvXCIrbitcIi9yZW1vdmVcIn1mdW5jdGlvbiBzKGUpe3JldHVybiBlLmNvbmZpZy5nZXRUcmFuc2FjdGlvblRpbWVvdXQoKX1mdW5jdGlvbiBhKCl7cmV0dXJuITB9ZnVuY3Rpb24gdShlLHQpe3JldHVybnt0eXBlOnQucHVzaEdhdGV3YXl9fWZ1bmN0aW9uIGMoKXtyZXR1cm57fX1PYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmdldE9wZXJhdGlvbj1yLHQudmFsaWRhdGVQYXJhbXM9aSx0LmdldFVSTD1vLHQuZ2V0UmVxdWVzdFRpbWVvdXQ9cyx0LmlzQXV0aFN1cHBvcnRlZD1hLHQucHJlcGFyZVBhcmFtcz11LHQuaGFuZGxlUmVzcG9uc2U9Yzt2YXIgbD0obig4KSxuKDE2KSksaD1mdW5jdGlvbihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19KGwpfSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19ZnVuY3Rpb24gaSgpe3JldHVybiBmLmRlZmF1bHQuUE5VbnN1YnNjcmliZU9wZXJhdGlvbn1mdW5jdGlvbiBvKGUpe2lmKCFlLmNvbmZpZy5zdWJzY3JpYmVLZXkpcmV0dXJuXCJNaXNzaW5nIFN1YnNjcmliZSBLZXlcIn1mdW5jdGlvbiBzKGUsdCl7dmFyIG49ZS5jb25maWcscj10LmNoYW5uZWxzLGk9dm9pZCAwPT09cj9bXTpyLG89aS5sZW5ndGg+MD9pLmpvaW4oXCIsXCIpOlwiLFwiO3JldHVyblwiL3YyL3ByZXNlbmNlL3N1Yi1rZXkvXCIrbi5zdWJzY3JpYmVLZXkrXCIvY2hhbm5lbC9cIitwLmRlZmF1bHQuZW5jb2RlU3RyaW5nKG8pK1wiL2xlYXZlXCJ9ZnVuY3Rpb24gYShlKXtyZXR1cm4gZS5jb25maWcuZ2V0VHJhbnNhY3Rpb25UaW1lb3V0KCl9ZnVuY3Rpb24gdSgpe3JldHVybiEwfWZ1bmN0aW9uIGMoZSx0KXt2YXIgbj10LmNoYW5uZWxHcm91cHMscj12b2lkIDA9PT1uP1tdOm4saT17fTtyZXR1cm4gci5sZW5ndGg+MCYmKGlbXCJjaGFubmVsLWdyb3VwXCJdPXIuam9pbihcIixcIikpLGl9ZnVuY3Rpb24gbCgpe3JldHVybnt9fU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZ2V0T3BlcmF0aW9uPWksdC52YWxpZGF0ZVBhcmFtcz1vLHQuZ2V0VVJMPXMsdC5nZXRSZXF1ZXN0VGltZW91dD1hLHQuaXNBdXRoU3VwcG9ydGVkPXUsdC5wcmVwYXJlUGFyYW1zPWMsdC5oYW5kbGVSZXNwb25zZT1sO3ZhciBoPShuKDgpLG4oMTYpKSxmPXIoaCksZD1uKDE3KSxwPXIoZCl9LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKCl7cmV0dXJuIGguZGVmYXVsdC5QTldoZXJlTm93T3BlcmF0aW9ufWZ1bmN0aW9uIGkoZSl7aWYoIWUuY29uZmlnLnN1YnNjcmliZUtleSlyZXR1cm5cIk1pc3NpbmcgU3Vic2NyaWJlIEtleVwifWZ1bmN0aW9uIG8oZSx0KXt2YXIgbj1lLmNvbmZpZyxyPXQudXVpZCxpPXZvaWQgMD09PXI/bi5VVUlEOnI7cmV0dXJuXCIvdjIvcHJlc2VuY2Uvc3ViLWtleS9cIituLnN1YnNjcmliZUtleStcIi91dWlkL1wiK2l9ZnVuY3Rpb24gcyhlKXtyZXR1cm4gZS5jb25maWcuZ2V0VHJhbnNhY3Rpb25UaW1lb3V0KCl9ZnVuY3Rpb24gYSgpe3JldHVybiEwfWZ1bmN0aW9uIHUoKXtyZXR1cm57fX1mdW5jdGlvbiBjKGUsdCl7cmV0dXJue2NoYW5uZWxzOnQucGF5bG9hZC5jaGFubmVsc319T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5nZXRPcGVyYXRpb249cix0LnZhbGlkYXRlUGFyYW1zPWksdC5nZXRVUkw9byx0LmdldFJlcXVlc3RUaW1lb3V0PXMsdC5pc0F1dGhTdXBwb3J0ZWQ9YSx0LnByZXBhcmVQYXJhbXM9dSx0LmhhbmRsZVJlc3BvbnNlPWM7dmFyIGw9KG4oOCksbigxNikpLGg9ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fShsKX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIoZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fWZ1bmN0aW9uIGkoKXtyZXR1cm4gZi5kZWZhdWx0LlBOSGVhcnRiZWF0T3BlcmF0aW9ufWZ1bmN0aW9uIG8oZSl7aWYoIWUuY29uZmlnLnN1YnNjcmliZUtleSlyZXR1cm5cIk1pc3NpbmcgU3Vic2NyaWJlIEtleVwifWZ1bmN0aW9uIHMoZSx0KXt2YXIgbj1lLmNvbmZpZyxyPXQuY2hhbm5lbHMsaT12b2lkIDA9PT1yP1tdOnIsbz1pLmxlbmd0aD4wP2kuam9pbihcIixcIik6XCIsXCI7cmV0dXJuXCIvdjIvcHJlc2VuY2Uvc3ViLWtleS9cIituLnN1YnNjcmliZUtleStcIi9jaGFubmVsL1wiK3AuZGVmYXVsdC5lbmNvZGVTdHJpbmcobykrXCIvaGVhcnRiZWF0XCJ9ZnVuY3Rpb24gYSgpe3JldHVybiEwfWZ1bmN0aW9uIHUoZSl7cmV0dXJuIGUuY29uZmlnLmdldFRyYW5zYWN0aW9uVGltZW91dCgpfWZ1bmN0aW9uIGMoZSx0KXt2YXIgbj10LmNoYW5uZWxHcm91cHMscj12b2lkIDA9PT1uP1tdOm4saT10LnN0YXRlLG89dm9pZCAwPT09aT97fTppLHM9ZS5jb25maWcsYT17fTtyZXR1cm4gci5sZW5ndGg+MCYmKGFbXCJjaGFubmVsLWdyb3VwXCJdPXIuam9pbihcIixcIikpLGEuc3RhdGU9SlNPTi5zdHJpbmdpZnkobyksYS5oZWFydGJlYXQ9cy5nZXRQcmVzZW5jZVRpbWVvdXQoKSxhfWZ1bmN0aW9uIGwoKXtyZXR1cm57fX1PYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmdldE9wZXJhdGlvbj1pLHQudmFsaWRhdGVQYXJhbXM9byx0LmdldFVSTD1zLHQuaXNBdXRoU3VwcG9ydGVkPWEsdC5nZXRSZXF1ZXN0VGltZW91dD11LHQucHJlcGFyZVBhcmFtcz1jLHQuaGFuZGxlUmVzcG9uc2U9bDt2YXIgaD0obig4KSxuKDE2KSksZj1yKGgpLGQ9bigxNykscD1yKGQpfSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19ZnVuY3Rpb24gaSgpe3JldHVybiBmLmRlZmF1bHQuUE5HZXRTdGF0ZU9wZXJhdGlvbn1mdW5jdGlvbiBvKGUpe2lmKCFlLmNvbmZpZy5zdWJzY3JpYmVLZXkpcmV0dXJuXCJNaXNzaW5nIFN1YnNjcmliZSBLZXlcIn1mdW5jdGlvbiBzKGUsdCl7dmFyIG49ZS5jb25maWcscj10LnV1aWQsaT12b2lkIDA9PT1yP24uVVVJRDpyLG89dC5jaGFubmVscyxzPXZvaWQgMD09PW8/W106byxhPXMubGVuZ3RoPjA/cy5qb2luKFwiLFwiKTpcIixcIjtyZXR1cm5cIi92Mi9wcmVzZW5jZS9zdWIta2V5L1wiK24uc3Vic2NyaWJlS2V5K1wiL2NoYW5uZWwvXCIrcC5kZWZhdWx0LmVuY29kZVN0cmluZyhhKStcIi91dWlkL1wiK2l9ZnVuY3Rpb24gYShlKXtyZXR1cm4gZS5jb25maWcuZ2V0VHJhbnNhY3Rpb25UaW1lb3V0KCl9ZnVuY3Rpb24gdSgpe3JldHVybiEwfWZ1bmN0aW9uIGMoZSx0KXt2YXIgbj10LmNoYW5uZWxHcm91cHMscj12b2lkIDA9PT1uP1tdOm4saT17fTtyZXR1cm4gci5sZW5ndGg+MCYmKGlbXCJjaGFubmVsLWdyb3VwXCJdPXIuam9pbihcIixcIikpLGl9ZnVuY3Rpb24gbChlLHQsbil7dmFyIHI9bi5jaGFubmVscyxpPXZvaWQgMD09PXI/W106cixvPW4uY2hhbm5lbEdyb3VwcyxzPXZvaWQgMD09PW8/W106byxhPXt9O3JldHVybiAxPT09aS5sZW5ndGgmJjA9PT1zLmxlbmd0aD9hW2lbMF1dPXQucGF5bG9hZDphPXQucGF5bG9hZCx7Y2hhbm5lbHM6YX19T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5nZXRPcGVyYXRpb249aSx0LnZhbGlkYXRlUGFyYW1zPW8sdC5nZXRVUkw9cyx0LmdldFJlcXVlc3RUaW1lb3V0PWEsdC5pc0F1dGhTdXBwb3J0ZWQ9dSx0LnByZXBhcmVQYXJhbXM9Yyx0LmhhbmRsZVJlc3BvbnNlPWw7dmFyIGg9KG4oOCksbigxNikpLGY9cihoKSxkPW4oMTcpLHA9cihkKX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIoZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fWZ1bmN0aW9uIGkoKXtyZXR1cm4gZi5kZWZhdWx0LlBOU2V0U3RhdGVPcGVyYXRpb259ZnVuY3Rpb24gbyhlLHQpe3ZhciBuPWUuY29uZmlnLHI9dC5zdGF0ZSxpPXQuY2hhbm5lbHMsbz12b2lkIDA9PT1pP1tdOmkscz10LmNoYW5uZWxHcm91cHMsYT12b2lkIDA9PT1zP1tdOnM7cmV0dXJuIHI/bi5zdWJzY3JpYmVLZXk/MD09PW8ubGVuZ3RoJiYwPT09YS5sZW5ndGg/XCJQbGVhc2UgcHJvdmlkZSBhIGxpc3Qgb2YgY2hhbm5lbHMgYW5kL29yIGNoYW5uZWwtZ3JvdXBzXCI6dm9pZCAwOlwiTWlzc2luZyBTdWJzY3JpYmUgS2V5XCI6XCJNaXNzaW5nIFN0YXRlXCJ9ZnVuY3Rpb24gcyhlLHQpe3ZhciBuPWUuY29uZmlnLHI9dC5jaGFubmVscyxpPXZvaWQgMD09PXI/W106cixvPWkubGVuZ3RoPjA/aS5qb2luKFwiLFwiKTpcIixcIjtyZXR1cm5cIi92Mi9wcmVzZW5jZS9zdWIta2V5L1wiK24uc3Vic2NyaWJlS2V5K1wiL2NoYW5uZWwvXCIrcC5kZWZhdWx0LmVuY29kZVN0cmluZyhvKStcIi91dWlkL1wiK24uVVVJRCtcIi9kYXRhXCJ9ZnVuY3Rpb24gYShlKXtyZXR1cm4gZS5jb25maWcuZ2V0VHJhbnNhY3Rpb25UaW1lb3V0KCl9ZnVuY3Rpb24gdSgpe3JldHVybiEwfWZ1bmN0aW9uIGMoZSx0KXt2YXIgbj10LnN0YXRlLHI9dC5jaGFubmVsR3JvdXBzLGk9dm9pZCAwPT09cj9bXTpyLG89e307cmV0dXJuIG8uc3RhdGU9SlNPTi5zdHJpbmdpZnkobiksaS5sZW5ndGg+MCYmKG9bXCJjaGFubmVsLWdyb3VwXCJdPWkuam9pbihcIixcIikpLG99ZnVuY3Rpb24gbChlLHQpe3JldHVybntzdGF0ZTp0LnBheWxvYWR9fU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZ2V0T3BlcmF0aW9uPWksdC52YWxpZGF0ZVBhcmFtcz1vLHQuZ2V0VVJMPXMsdC5nZXRSZXF1ZXN0VGltZW91dD1hLHQuaXNBdXRoU3VwcG9ydGVkPXUsdC5wcmVwYXJlUGFyYW1zPWMsdC5oYW5kbGVSZXNwb25zZT1sO3ZhciBoPShuKDgpLG4oMTYpKSxmPXIoaCksZD1uKDE3KSxwPXIoZCl9LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX1mdW5jdGlvbiBpKCl7cmV0dXJuIGYuZGVmYXVsdC5QTkhlcmVOb3dPcGVyYXRpb259ZnVuY3Rpb24gbyhlKXtpZighZS5jb25maWcuc3Vic2NyaWJlS2V5KXJldHVyblwiTWlzc2luZyBTdWJzY3JpYmUgS2V5XCJ9ZnVuY3Rpb24gcyhlLHQpe3ZhciBuPWUuY29uZmlnLHI9dC5jaGFubmVscyxpPXZvaWQgMD09PXI/W106cixvPXQuY2hhbm5lbEdyb3VwcyxzPXZvaWQgMD09PW8/W106byxhPVwiL3YyL3ByZXNlbmNlL3N1Yi1rZXkvXCIrbi5zdWJzY3JpYmVLZXk7aWYoaS5sZW5ndGg+MHx8cy5sZW5ndGg+MCl7dmFyIHU9aS5sZW5ndGg+MD9pLmpvaW4oXCIsXCIpOlwiLFwiO2ErPVwiL2NoYW5uZWwvXCIrcC5kZWZhdWx0LmVuY29kZVN0cmluZyh1KX1yZXR1cm4gYX1mdW5jdGlvbiBhKGUpe3JldHVybiBlLmNvbmZpZy5nZXRUcmFuc2FjdGlvblRpbWVvdXQoKX1mdW5jdGlvbiB1KCl7cmV0dXJuITB9ZnVuY3Rpb24gYyhlLHQpe3ZhciBuPXQuY2hhbm5lbEdyb3VwcyxyPXZvaWQgMD09PW4/W106bixpPXQuaW5jbHVkZVVVSURzLG89dm9pZCAwPT09aXx8aSxzPXQuaW5jbHVkZVN0YXRlLGE9dm9pZCAwIT09cyYmcyx1PXt9O3JldHVybiBvfHwodS5kaXNhYmxlX3V1aWRzPTEpLGEmJih1LnN0YXRlPTEpLHIubGVuZ3RoPjAmJih1W1wiY2hhbm5lbC1ncm91cFwiXT1yLmpvaW4oXCIsXCIpKSx1fWZ1bmN0aW9uIGwoZSx0LG4pe3ZhciByPW4uY2hhbm5lbHMsaT12b2lkIDA9PT1yP1tdOnIsbz1uLmNoYW5uZWxHcm91cHMscz12b2lkIDA9PT1vP1tdOm8sYT1uLmluY2x1ZGVVVUlEcyx1PXZvaWQgMD09PWF8fGEsYz1uLmluY2x1ZGVTdGF0ZSxsPXZvaWQgMCE9PWMmJmM7cmV0dXJuIGkubGVuZ3RoPjF8fHMubGVuZ3RoPjB8fDA9PT1zLmxlbmd0aCYmMD09PWkubGVuZ3RoP2Z1bmN0aW9uKCl7dmFyIGU9e307cmV0dXJuIGUudG90YWxDaGFubmVscz10LnBheWxvYWQudG90YWxfY2hhbm5lbHMsZS50b3RhbE9jY3VwYW5jeT10LnBheWxvYWQudG90YWxfb2NjdXBhbmN5LGUuY2hhbm5lbHM9e30sT2JqZWN0LmtleXModC5wYXlsb2FkLmNoYW5uZWxzKS5mb3JFYWNoKGZ1bmN0aW9uKG4pe3ZhciByPXQucGF5bG9hZC5jaGFubmVsc1tuXSxpPVtdO3JldHVybiBlLmNoYW5uZWxzW25dPXtvY2N1cGFudHM6aSxuYW1lOm4sb2NjdXBhbmN5OnIub2NjdXBhbmN5fSx1JiZyLnV1aWRzLmZvckVhY2goZnVuY3Rpb24oZSl7bD9pLnB1c2goe3N0YXRlOmUuc3RhdGUsdXVpZDplLnV1aWR9KTppLnB1c2goe3N0YXRlOm51bGwsdXVpZDplfSl9KSxlfSksZX0oKTpmdW5jdGlvbigpe3ZhciBlPXt9LG49W107cmV0dXJuIGUudG90YWxDaGFubmVscz0xLGUudG90YWxPY2N1cGFuY3k9dC5vY2N1cGFuY3ksZS5jaGFubmVscz17fSxlLmNoYW5uZWxzW2lbMF1dPXtvY2N1cGFudHM6bixuYW1lOmlbMF0sb2NjdXBhbmN5OnQub2NjdXBhbmN5fSx1JiZ0LnV1aWRzLmZvckVhY2goZnVuY3Rpb24oZSl7bD9uLnB1c2goe3N0YXRlOmUuc3RhdGUsdXVpZDplLnV1aWR9KTpuLnB1c2goe3N0YXRlOm51bGwsdXVpZDplfSl9KSxlfSgpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZ2V0T3BlcmF0aW9uPWksdC52YWxpZGF0ZVBhcmFtcz1vLHQuZ2V0VVJMPXMsdC5nZXRSZXF1ZXN0VGltZW91dD1hLHQuaXNBdXRoU3VwcG9ydGVkPXUsdC5wcmVwYXJlUGFyYW1zPWMsdC5oYW5kbGVSZXNwb25zZT1sO3ZhciBoPShuKDgpLG4oMTYpKSxmPXIoaCksZD1uKDE3KSxwPXIoZCl9LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKCl7cmV0dXJuIGguZGVmYXVsdC5QTkFjY2Vzc01hbmFnZXJBdWRpdH1mdW5jdGlvbiBpKGUpe2lmKCFlLmNvbmZpZy5zdWJzY3JpYmVLZXkpcmV0dXJuXCJNaXNzaW5nIFN1YnNjcmliZSBLZXlcIn1mdW5jdGlvbiBvKGUpe3JldHVyblwiL3YyL2F1dGgvYXVkaXQvc3ViLWtleS9cIitlLmNvbmZpZy5zdWJzY3JpYmVLZXl9ZnVuY3Rpb24gcyhlKXtyZXR1cm4gZS5jb25maWcuZ2V0VHJhbnNhY3Rpb25UaW1lb3V0KCl9ZnVuY3Rpb24gYSgpe3JldHVybiExfWZ1bmN0aW9uIHUoZSx0KXt2YXIgbj10LmNoYW5uZWwscj10LmNoYW5uZWxHcm91cCxpPXQuYXV0aEtleXMsbz12b2lkIDA9PT1pP1tdOmkscz17fTtyZXR1cm4gbiYmKHMuY2hhbm5lbD1uKSxyJiYoc1tcImNoYW5uZWwtZ3JvdXBcIl09ciksby5sZW5ndGg+MCYmKHMuYXV0aD1vLmpvaW4oXCIsXCIpKSxzfWZ1bmN0aW9uIGMoZSx0KXtyZXR1cm4gdC5wYXlsb2FkfU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZ2V0T3BlcmF0aW9uPXIsdC52YWxpZGF0ZVBhcmFtcz1pLHQuZ2V0VVJMPW8sdC5nZXRSZXF1ZXN0VGltZW91dD1zLHQuaXNBdXRoU3VwcG9ydGVkPWEsdC5wcmVwYXJlUGFyYW1zPXUsdC5oYW5kbGVSZXNwb25zZT1jO3ZhciBsPShuKDgpLG4oMTYpKSxoPWZ1bmN0aW9uKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX0obCl9LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKCl7cmV0dXJuIGguZGVmYXVsdC5QTkFjY2Vzc01hbmFnZXJHcmFudH1mdW5jdGlvbiBpKGUpe3ZhciB0PWUuY29uZmlnO3JldHVybiB0LnN1YnNjcmliZUtleT90LnB1Ymxpc2hLZXk/dC5zZWNyZXRLZXk/dm9pZCAwOlwiTWlzc2luZyBTZWNyZXQgS2V5XCI6XCJNaXNzaW5nIFB1Ymxpc2ggS2V5XCI6XCJNaXNzaW5nIFN1YnNjcmliZSBLZXlcIn1mdW5jdGlvbiBvKGUpe3JldHVyblwiL3YyL2F1dGgvZ3JhbnQvc3ViLWtleS9cIitlLmNvbmZpZy5zdWJzY3JpYmVLZXl9ZnVuY3Rpb24gcyhlKXtyZXR1cm4gZS5jb25maWcuZ2V0VHJhbnNhY3Rpb25UaW1lb3V0KCl9ZnVuY3Rpb24gYSgpe3JldHVybiExfWZ1bmN0aW9uIHUoZSx0KXt2YXIgbj10LmNoYW5uZWxzLHI9dm9pZCAwPT09bj9bXTpuLGk9dC5jaGFubmVsR3JvdXBzLG89dm9pZCAwPT09aT9bXTppLHM9dC50dGwsYT10LnJlYWQsdT12b2lkIDAhPT1hJiZhLGM9dC53cml0ZSxsPXZvaWQgMCE9PWMmJmMsaD10Lm1hbmFnZSxmPXZvaWQgMCE9PWgmJmgsZD10LmF1dGhLZXlzLHA9dm9pZCAwPT09ZD9bXTpkLGc9e307cmV0dXJuIGcucj11P1wiMVwiOlwiMFwiLGcudz1sP1wiMVwiOlwiMFwiLGcubT1mP1wiMVwiOlwiMFwiLHIubGVuZ3RoPjAmJihnLmNoYW5uZWw9ci5qb2luKFwiLFwiKSksby5sZW5ndGg+MCYmKGdbXCJjaGFubmVsLWdyb3VwXCJdPW8uam9pbihcIixcIikpLHAubGVuZ3RoPjAmJihnLmF1dGg9cC5qb2luKFwiLFwiKSksKHN8fDA9PT1zKSYmKGcudHRsPXMpLGd9ZnVuY3Rpb24gYygpe3JldHVybnt9fU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZ2V0T3BlcmF0aW9uPXIsdC52YWxpZGF0ZVBhcmFtcz1pLHQuZ2V0VVJMPW8sdC5nZXRSZXF1ZXN0VGltZW91dD1zLHQuaXNBdXRoU3VwcG9ydGVkPWEsdC5wcmVwYXJlUGFyYW1zPXUsdC5oYW5kbGVSZXNwb25zZT1jO3ZhciBsPShuKDgpLG4oMTYpKSxoPWZ1bmN0aW9uKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX0obCl9LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX1mdW5jdGlvbiBpKGUsdCl7dmFyIG49ZS5jcnlwdG8scj1lLmNvbmZpZyxpPUpTT04uc3RyaW5naWZ5KHQpO3JldHVybiByLmNpcGhlcktleSYmKGk9bi5lbmNyeXB0KGkpLGk9SlNPTi5zdHJpbmdpZnkoaSkpLGl9ZnVuY3Rpb24gbygpe3JldHVybiB2LmRlZmF1bHQuUE5QdWJsaXNoT3BlcmF0aW9ufWZ1bmN0aW9uIHMoZSx0KXt2YXIgbj1lLmNvbmZpZyxyPXQubWVzc2FnZTtyZXR1cm4gdC5jaGFubmVsP3I/bi5zdWJzY3JpYmVLZXk/dm9pZCAwOlwiTWlzc2luZyBTdWJzY3JpYmUgS2V5XCI6XCJNaXNzaW5nIE1lc3NhZ2VcIjpcIk1pc3NpbmcgQ2hhbm5lbFwifWZ1bmN0aW9uIGEoZSx0KXt2YXIgbj10LnNlbmRCeVBvc3Q7cmV0dXJuIHZvaWQgMCE9PW4mJm59ZnVuY3Rpb24gdShlLHQpe3ZhciBuPWUuY29uZmlnLHI9dC5jaGFubmVsLG89dC5tZXNzYWdlLHM9aShlLG8pO3JldHVyblwiL3B1Ymxpc2gvXCIrbi5wdWJsaXNoS2V5K1wiL1wiK24uc3Vic2NyaWJlS2V5K1wiLzAvXCIrXy5kZWZhdWx0LmVuY29kZVN0cmluZyhyKStcIi8wL1wiK18uZGVmYXVsdC5lbmNvZGVTdHJpbmcocyl9ZnVuY3Rpb24gYyhlLHQpe3ZhciBuPWUuY29uZmlnLHI9dC5jaGFubmVsO3JldHVyblwiL3B1Ymxpc2gvXCIrbi5wdWJsaXNoS2V5K1wiL1wiK24uc3Vic2NyaWJlS2V5K1wiLzAvXCIrXy5kZWZhdWx0LmVuY29kZVN0cmluZyhyKStcIi8wXCJ9ZnVuY3Rpb24gbChlKXtyZXR1cm4gZS5jb25maWcuZ2V0VHJhbnNhY3Rpb25UaW1lb3V0KCl9ZnVuY3Rpb24gaCgpe3JldHVybiEwfWZ1bmN0aW9uIGYoZSx0KXtyZXR1cm4gaShlLHQubWVzc2FnZSl9ZnVuY3Rpb24gZChlLHQpe3ZhciBuPXQubWV0YSxyPXQucmVwbGljYXRlLGk9dm9pZCAwPT09cnx8cixvPXQuc3RvcmVJbkhpc3Rvcnkscz10LnR0bCxhPXt9O3JldHVybiBudWxsIT1vJiYoYS5zdG9yZT1vP1wiMVwiOlwiMFwiKSxzJiYoYS50dGw9cyksaT09PSExJiYoYS5ub3JlcD1cInRydWVcIiksbiYmXCJvYmplY3RcIj09PSh2b2lkIDA9PT1uP1widW5kZWZpbmVkXCI6ZyhuKSkmJihhLm1ldGE9SlNPTi5zdHJpbmdpZnkobikpLGF9ZnVuY3Rpb24gcChlLHQpe3JldHVybnt0aW1ldG9rZW46dFsyXX19T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIGc9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKGUpe3JldHVybiB0eXBlb2YgZX06ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmZS5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmZSE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgZX07dC5nZXRPcGVyYXRpb249byx0LnZhbGlkYXRlUGFyYW1zPXMsdC51c2VQb3N0PWEsdC5nZXRVUkw9dSx0LnBvc3RVUkw9Yyx0LmdldFJlcXVlc3RUaW1lb3V0PWwsdC5pc0F1dGhTdXBwb3J0ZWQ9aCx0LnBvc3RQYXlsb2FkPWYsdC5wcmVwYXJlUGFyYW1zPWQsdC5oYW5kbGVSZXNwb25zZT1wO3ZhciB5PShuKDgpLG4oMTYpKSx2PXIoeSksYj1uKDE3KSxfPXIoYil9LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX1mdW5jdGlvbiBpKGUsdCl7dmFyIG49ZS5jb25maWcscj1lLmNyeXB0bztpZighbi5jaXBoZXJLZXkpcmV0dXJuIHQ7dHJ5e3JldHVybiByLmRlY3J5cHQodCl9Y2F0Y2goZSl7cmV0dXJuIHR9fWZ1bmN0aW9uIG8oKXtyZXR1cm4gZC5kZWZhdWx0LlBOSGlzdG9yeU9wZXJhdGlvbn1mdW5jdGlvbiBzKGUsdCl7dmFyIG49dC5jaGFubmVsLHI9ZS5jb25maWc7cmV0dXJuIG4/ci5zdWJzY3JpYmVLZXk/dm9pZCAwOlwiTWlzc2luZyBTdWJzY3JpYmUgS2V5XCI6XCJNaXNzaW5nIGNoYW5uZWxcIn1mdW5jdGlvbiBhKGUsdCl7dmFyIG49dC5jaGFubmVsO3JldHVyblwiL3YyL2hpc3Rvcnkvc3ViLWtleS9cIitlLmNvbmZpZy5zdWJzY3JpYmVLZXkrXCIvY2hhbm5lbC9cIitnLmRlZmF1bHQuZW5jb2RlU3RyaW5nKG4pfWZ1bmN0aW9uIHUoZSl7cmV0dXJuIGUuY29uZmlnLmdldFRyYW5zYWN0aW9uVGltZW91dCgpfWZ1bmN0aW9uIGMoKXtyZXR1cm4hMH1mdW5jdGlvbiBsKGUsdCl7dmFyIG49dC5zdGFydCxyPXQuZW5kLGk9dC5yZXZlcnNlLG89dC5jb3VudCxzPXZvaWQgMD09PW8/MTAwOm8sYT10LnN0cmluZ2lmaWVkVGltZVRva2VuLHU9dm9pZCAwIT09YSYmYSxjPXtpbmNsdWRlX3Rva2VuOlwidHJ1ZVwifTtyZXR1cm4gYy5jb3VudD1zLG4mJihjLnN0YXJ0PW4pLHImJihjLmVuZD1yKSx1JiYoYy5zdHJpbmdfbWVzc2FnZV90b2tlbj1cInRydWVcIiksbnVsbCE9aSYmKGMucmV2ZXJzZT1pLnRvU3RyaW5nKCkpLGN9ZnVuY3Rpb24gaChlLHQpe3ZhciBuPXttZXNzYWdlczpbXSxzdGFydFRpbWVUb2tlbjp0WzFdLGVuZFRpbWVUb2tlbjp0WzJdfTtyZXR1cm4gdFswXS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3ZhciByPXt0aW1ldG9rZW46dC50aW1ldG9rZW4sZW50cnk6aShlLHQubWVzc2FnZSl9O24ubWVzc2FnZXMucHVzaChyKX0pLG59T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5nZXRPcGVyYXRpb249byx0LnZhbGlkYXRlUGFyYW1zPXMsdC5nZXRVUkw9YSx0LmdldFJlcXVlc3RUaW1lb3V0PXUsdC5pc0F1dGhTdXBwb3J0ZWQ9Yyx0LnByZXBhcmVQYXJhbXM9bCx0LmhhbmRsZVJlc3BvbnNlPWg7dmFyIGY9KG4oOCksbigxNikpLGQ9cihmKSxwPW4oMTcpLGc9cihwKX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIoZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fWZ1bmN0aW9uIGkoZSx0KXt2YXIgbj1lLmNvbmZpZyxyPWUuY3J5cHRvO2lmKCFuLmNpcGhlcktleSlyZXR1cm4gdDt0cnl7cmV0dXJuIHIuZGVjcnlwdCh0KX1jYXRjaChlKXtyZXR1cm4gdH19ZnVuY3Rpb24gbygpe3JldHVybiBkLmRlZmF1bHQuUE5GZXRjaE1lc3NhZ2VzT3BlcmF0aW9ufWZ1bmN0aW9uIHMoZSx0KXt2YXIgbj10LmNoYW5uZWxzLHI9ZS5jb25maWc7cmV0dXJuIG4mJjAhPT1uLmxlbmd0aD9yLnN1YnNjcmliZUtleT92b2lkIDA6XCJNaXNzaW5nIFN1YnNjcmliZSBLZXlcIjpcIk1pc3NpbmcgY2hhbm5lbHNcIn1mdW5jdGlvbiBhKGUsdCl7dmFyIG49dC5jaGFubmVscyxyPXZvaWQgMD09PW4/W106bixpPWUuY29uZmlnLG89ci5sZW5ndGg+MD9yLmpvaW4oXCIsXCIpOlwiLFwiO3JldHVyblwiL3YzL2hpc3Rvcnkvc3ViLWtleS9cIitpLnN1YnNjcmliZUtleStcIi9jaGFubmVsL1wiK2cuZGVmYXVsdC5lbmNvZGVTdHJpbmcobyl9ZnVuY3Rpb24gdShlKXtyZXR1cm4gZS5jb25maWcuZ2V0VHJhbnNhY3Rpb25UaW1lb3V0KCl9ZnVuY3Rpb24gYygpe3JldHVybiEwfWZ1bmN0aW9uIGwoZSx0KXt2YXIgbj10LnN0YXJ0LHI9dC5lbmQsaT10LmNvdW50LG89e307cmV0dXJuIGkmJihvLm1heD1pKSxuJiYoby5zdGFydD1uKSxyJiYoby5lbmQ9ciksb31mdW5jdGlvbiBoKGUsdCl7dmFyIG49e2NoYW5uZWxzOnt9fVxuO3JldHVybiBPYmplY3Qua2V5cyh0LmNoYW5uZWxzfHx7fSkuZm9yRWFjaChmdW5jdGlvbihyKXtuLmNoYW5uZWxzW3JdPVtdLCh0LmNoYW5uZWxzW3JdfHxbXSkuZm9yRWFjaChmdW5jdGlvbih0KXt2YXIgbz17fTtvLmNoYW5uZWw9cixvLnN1YnNjcmlwdGlvbj1udWxsLG8udGltZXRva2VuPXQudGltZXRva2VuLG8ubWVzc2FnZT1pKGUsdC5tZXNzYWdlKSxuLmNoYW5uZWxzW3JdLnB1c2gobyl9KX0pLG59T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5nZXRPcGVyYXRpb249byx0LnZhbGlkYXRlUGFyYW1zPXMsdC5nZXRVUkw9YSx0LmdldFJlcXVlc3RUaW1lb3V0PXUsdC5pc0F1dGhTdXBwb3J0ZWQ9Yyx0LnByZXBhcmVQYXJhbXM9bCx0LmhhbmRsZVJlc3BvbnNlPWg7dmFyIGY9KG4oOCksbigxNikpLGQ9cihmKSxwPW4oMTcpLGc9cihwKX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIoZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fWZ1bmN0aW9uIGkoKXtyZXR1cm4gZi5kZWZhdWx0LlBOU3Vic2NyaWJlT3BlcmF0aW9ufWZ1bmN0aW9uIG8oZSl7aWYoIWUuY29uZmlnLnN1YnNjcmliZUtleSlyZXR1cm5cIk1pc3NpbmcgU3Vic2NyaWJlIEtleVwifWZ1bmN0aW9uIHMoZSx0KXt2YXIgbj1lLmNvbmZpZyxyPXQuY2hhbm5lbHMsaT12b2lkIDA9PT1yP1tdOnIsbz1pLmxlbmd0aD4wP2kuam9pbihcIixcIik6XCIsXCI7cmV0dXJuXCIvdjIvc3Vic2NyaWJlL1wiK24uc3Vic2NyaWJlS2V5K1wiL1wiK3AuZGVmYXVsdC5lbmNvZGVTdHJpbmcobykrXCIvMFwifWZ1bmN0aW9uIGEoZSl7cmV0dXJuIGUuY29uZmlnLmdldFN1YnNjcmliZVRpbWVvdXQoKX1mdW5jdGlvbiB1KCl7cmV0dXJuITB9ZnVuY3Rpb24gYyhlLHQpe3ZhciBuPWUuY29uZmlnLHI9dC5jaGFubmVsR3JvdXBzLGk9dm9pZCAwPT09cj9bXTpyLG89dC50aW1ldG9rZW4scz10LmZpbHRlckV4cHJlc3Npb24sYT10LnJlZ2lvbix1PXtoZWFydGJlYXQ6bi5nZXRQcmVzZW5jZVRpbWVvdXQoKX07cmV0dXJuIGkubGVuZ3RoPjAmJih1W1wiY2hhbm5lbC1ncm91cFwiXT1pLmpvaW4oXCIsXCIpKSxzJiZzLmxlbmd0aD4wJiYodVtcImZpbHRlci1leHByXCJdPXMpLG8mJih1LnR0PW8pLGEmJih1LnRyPWEpLHV9ZnVuY3Rpb24gbChlLHQpe3ZhciBuPVtdO3QubS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciB0PXtwdWJsaXNoVGltZXRva2VuOmUucC50LHJlZ2lvbjplLnAucn0scj17c2hhcmQ6cGFyc2VJbnQoZS5hLDEwKSxzdWJzY3JpcHRpb25NYXRjaDplLmIsY2hhbm5lbDplLmMscGF5bG9hZDplLmQsZmxhZ3M6ZS5mLGlzc3VpbmdDbGllbnRJZDplLmksc3Vic2NyaWJlS2V5OmUuayxvcmlnaW5hdGlvblRpbWV0b2tlbjplLm8scHVibGlzaE1ldGFEYXRhOnR9O24ucHVzaChyKX0pO3ZhciByPXt0aW1ldG9rZW46dC50LnQscmVnaW9uOnQudC5yfTtyZXR1cm57bWVzc2FnZXM6bixtZXRhZGF0YTpyfX1PYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmdldE9wZXJhdGlvbj1pLHQudmFsaWRhdGVQYXJhbXM9byx0LmdldFVSTD1zLHQuZ2V0UmVxdWVzdFRpbWVvdXQ9YSx0LmlzQXV0aFN1cHBvcnRlZD11LHQucHJlcGFyZVBhcmFtcz1jLHQuaGFuZGxlUmVzcG9uc2U9bDt2YXIgaD0obig4KSxuKDE2KSksZj1yKGgpLGQ9bigxNykscD1yKGQpfSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19ZnVuY3Rpb24gaShlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG89ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciByPXRbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIua2V5LHIpfX1yZXR1cm4gZnVuY3Rpb24odCxuLHIpe3JldHVybiBuJiZlKHQucHJvdG90eXBlLG4pLHImJmUodCxyKSx0fX0oKSxzPW4oNyksYT0ocihzKSxuKDEzKSksdT1yKGEpLGM9KG4oOCksZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHQpe3ZhciBuPXRoaXM7aSh0aGlzLGUpLHRoaXMuX21vZHVsZXM9e30sT2JqZWN0LmtleXModCkuZm9yRWFjaChmdW5jdGlvbihlKXtuLl9tb2R1bGVzW2VdPXRbZV0uYmluZChuKX0pfXJldHVybiBvKGUsW3trZXk6XCJpbml0XCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5fY29uZmlnPWUsdGhpcy5fbWF4U3ViRG9tYWluPTIwLHRoaXMuX2N1cnJlbnRTdWJEb21haW49TWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKnRoaXMuX21heFN1YkRvbWFpbiksdGhpcy5fcHJvdmlkZWRGUUROPSh0aGlzLl9jb25maWcuc2VjdXJlP1wiaHR0cHM6Ly9cIjpcImh0dHA6Ly9cIikrdGhpcy5fY29uZmlnLm9yaWdpbix0aGlzLl9jb3JlUGFyYW1zPXt9LHRoaXMuc2hpZnRTdGFuZGFyZE9yaWdpbigpfX0se2tleTpcIm5leHRPcmlnaW5cIix2YWx1ZTpmdW5jdGlvbigpe2lmKHRoaXMuX3Byb3ZpZGVkRlFETi5pbmRleE9mKFwicHVic3ViLlwiKT09PS0xKXJldHVybiB0aGlzLl9wcm92aWRlZEZRRE47dmFyIGU9dm9pZCAwO3JldHVybiB0aGlzLl9jdXJyZW50U3ViRG9tYWluPXRoaXMuX2N1cnJlbnRTdWJEb21haW4rMSx0aGlzLl9jdXJyZW50U3ViRG9tYWluPj10aGlzLl9tYXhTdWJEb21haW4mJih0aGlzLl9jdXJyZW50U3ViRG9tYWluPTEpLGU9dGhpcy5fY3VycmVudFN1YkRvbWFpbi50b1N0cmluZygpLHRoaXMuX3Byb3ZpZGVkRlFETi5yZXBsYWNlKFwicHVic3ViXCIsXCJwc1wiK2UpfX0se2tleTpcInNoaWZ0U3RhbmRhcmRPcmlnaW5cIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdJiZhcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuX3N0YW5kYXJkT3JpZ2luPXRoaXMubmV4dE9yaWdpbihlKSx0aGlzLl9zdGFuZGFyZE9yaWdpbn19LHtrZXk6XCJnZXRTdGFuZGFyZE9yaWdpblwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3N0YW5kYXJkT3JpZ2lufX0se2tleTpcIlBPU1RcIix2YWx1ZTpmdW5jdGlvbihlLHQsbixyKXtyZXR1cm4gdGhpcy5fbW9kdWxlcy5wb3N0KGUsdCxuLHIpfX0se2tleTpcIkdFVFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gdGhpcy5fbW9kdWxlcy5nZXQoZSx0LG4pfX0se2tleTpcIl9kZXRlY3RFcnJvckNhdGVnb3J5XCIsdmFsdWU6ZnVuY3Rpb24oZSl7aWYoXCJFTk9URk9VTkRcIj09PWUuY29kZSlyZXR1cm4gdS5kZWZhdWx0LlBOTmV0d29ya0lzc3Vlc0NhdGVnb3J5O2lmKFwiRUNPTk5SRUZVU0VEXCI9PT1lLmNvZGUpcmV0dXJuIHUuZGVmYXVsdC5QTk5ldHdvcmtJc3N1ZXNDYXRlZ29yeTtpZihcIkVDT05OUkVTRVRcIj09PWUuY29kZSlyZXR1cm4gdS5kZWZhdWx0LlBOTmV0d29ya0lzc3Vlc0NhdGVnb3J5O2lmKFwiRUFJX0FHQUlOXCI9PT1lLmNvZGUpcmV0dXJuIHUuZGVmYXVsdC5QTk5ldHdvcmtJc3N1ZXNDYXRlZ29yeTtpZigwPT09ZS5zdGF0dXN8fGUuaGFzT3duUHJvcGVydHkoXCJzdGF0dXNcIikmJnZvaWQgMD09PWUuc3RhdHVzKXJldHVybiB1LmRlZmF1bHQuUE5OZXR3b3JrSXNzdWVzQ2F0ZWdvcnk7aWYoZS50aW1lb3V0KXJldHVybiB1LmRlZmF1bHQuUE5UaW1lb3V0Q2F0ZWdvcnk7aWYoZS5yZXNwb25zZSl7aWYoZS5yZXNwb25zZS5iYWRSZXF1ZXN0KXJldHVybiB1LmRlZmF1bHQuUE5CYWRSZXF1ZXN0Q2F0ZWdvcnk7aWYoZS5yZXNwb25zZS5mb3JiaWRkZW4pcmV0dXJuIHUuZGVmYXVsdC5QTkFjY2Vzc0RlbmllZENhdGVnb3J5fXJldHVybiB1LmRlZmF1bHQuUE5Vbmtub3duQ2F0ZWdvcnl9fV0pLGV9KCkpO3QuZGVmYXVsdD1jLGUuZXhwb3J0cz10LmRlZmF1bHR9LGZ1bmN0aW9uKGUsdCl7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5kZWZhdWx0PXtnZXQ6ZnVuY3Rpb24oZSl7dHJ5e3JldHVybiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShlKX1jYXRjaChlKXtyZXR1cm4gbnVsbH19LHNldDpmdW5jdGlvbihlLHQpe3RyeXtyZXR1cm4gbG9jYWxTdG9yYWdlLnNldEl0ZW0oZSx0KX1jYXRjaChlKXtyZXR1cm4gbnVsbH19fSxlLmV4cG9ydHM9dC5kZWZhdWx0fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcihlKXt2YXIgdD0obmV3IERhdGUpLmdldFRpbWUoKSxuPShuZXcgRGF0ZSkudG9JU09TdHJpbmcoKSxyPWZ1bmN0aW9uKCl7cmV0dXJuIGNvbnNvbGUmJmNvbnNvbGUubG9nP2NvbnNvbGU6d2luZG93JiZ3aW5kb3cuY29uc29sZSYmd2luZG93LmNvbnNvbGUubG9nP3dpbmRvdy5jb25zb2xlOmNvbnNvbGV9KCk7ci5sb2coXCI8PDw8PFwiKSxyLmxvZyhcIltcIituK1wiXVwiLFwiXFxuXCIsZS51cmwsXCJcXG5cIixlLnFzKSxyLmxvZyhcIi0tLS0tXCIpLGUub24oXCJyZXNwb25zZVwiLGZ1bmN0aW9uKG4pe3ZhciBpPShuZXcgRGF0ZSkuZ2V0VGltZSgpLG89aS10LHM9KG5ldyBEYXRlKS50b0lTT1N0cmluZygpO3IubG9nKFwiPj4+Pj4+XCIpLHIubG9nKFwiW1wiK3MrXCIgLyBcIitvK1wiXVwiLFwiXFxuXCIsZS51cmwsXCJcXG5cIixlLnFzLFwiXFxuXCIsbi50ZXh0KSxyLmxvZyhcIi0tLS0tXCIpfSl9ZnVuY3Rpb24gaShlLHQsbil7dmFyIGk9dGhpcztyZXR1cm4gdGhpcy5fY29uZmlnLmxvZ1ZlcmJvc2l0eSYmKGU9ZS51c2UocikpLHRoaXMuX2NvbmZpZy5wcm94eSYmdGhpcy5fbW9kdWxlcy5wcm94eSYmKGU9dGhpcy5fbW9kdWxlcy5wcm94eS5jYWxsKHRoaXMsZSkpLHRoaXMuX2NvbmZpZy5rZWVwQWxpdmUmJnRoaXMuX21vZHVsZXMua2VlcEFsaXZlJiYoZT10aGlzLl9tb2R1bGUua2VlcEFsaXZlKGUpKSxlLnRpbWVvdXQodC50aW1lb3V0KS5lbmQoZnVuY3Rpb24oZSxyKXt2YXIgbz17fTtpZihvLmVycm9yPW51bGwhPT1lLG8ub3BlcmF0aW9uPXQub3BlcmF0aW9uLHImJnIuc3RhdHVzJiYoby5zdGF0dXNDb2RlPXIuc3RhdHVzKSxlKXJldHVybiBvLmVycm9yRGF0YT1lLG8uY2F0ZWdvcnk9aS5fZGV0ZWN0RXJyb3JDYXRlZ29yeShlKSxuKG8sbnVsbCk7dmFyIHM9SlNPTi5wYXJzZShyLnRleHQpO3JldHVybiBuKG8scyl9KX1mdW5jdGlvbiBvKGUsdCxuKXt2YXIgcj11LmRlZmF1bHQuZ2V0KHRoaXMuZ2V0U3RhbmRhcmRPcmlnaW4oKSt0LnVybCkucXVlcnkoZSk7cmV0dXJuIGkuY2FsbCh0aGlzLHIsdCxuKX1mdW5jdGlvbiBzKGUsdCxuLHIpe3ZhciBvPXUuZGVmYXVsdC5wb3N0KHRoaXMuZ2V0U3RhbmRhcmRPcmlnaW4oKStuLnVybCkucXVlcnkoZSkuc2VuZCh0KTtyZXR1cm4gaS5jYWxsKHRoaXMsbyxuLHIpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZ2V0PW8sdC5wb3N0PXM7dmFyIGE9big0MyksdT1mdW5jdGlvbihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19KGEpO24oOCl9LGZ1bmN0aW9uKGUsdCxuKXtmdW5jdGlvbiByKCl7fWZ1bmN0aW9uIGkoZSl7aWYoIXYoZSkpcmV0dXJuIGU7dmFyIHQ9W107Zm9yKHZhciBuIGluIGUpbyh0LG4sZVtuXSk7cmV0dXJuIHQuam9pbihcIiZcIil9ZnVuY3Rpb24gbyhlLHQsbil7aWYobnVsbCE9bilpZihBcnJheS5pc0FycmF5KG4pKW4uZm9yRWFjaChmdW5jdGlvbihuKXtvKGUsdCxuKX0pO2Vsc2UgaWYodihuKSlmb3IodmFyIHIgaW4gbilvKGUsdCtcIltcIityK1wiXVwiLG5bcl0pO2Vsc2UgZS5wdXNoKGVuY29kZVVSSUNvbXBvbmVudCh0KStcIj1cIitlbmNvZGVVUklDb21wb25lbnQobikpO2Vsc2UgbnVsbD09PW4mJmUucHVzaChlbmNvZGVVUklDb21wb25lbnQodCkpfWZ1bmN0aW9uIHMoZSl7Zm9yKHZhciB0LG4scj17fSxpPWUuc3BsaXQoXCImXCIpLG89MCxzPWkubGVuZ3RoO288czsrK28pdD1pW29dLG49dC5pbmRleE9mKFwiPVwiKSxuPT0tMT9yW2RlY29kZVVSSUNvbXBvbmVudCh0KV09XCJcIjpyW2RlY29kZVVSSUNvbXBvbmVudCh0LnNsaWNlKDAsbikpXT1kZWNvZGVVUklDb21wb25lbnQodC5zbGljZShuKzEpKTtyZXR1cm4gcn1mdW5jdGlvbiBhKGUpe3ZhciB0LG4scixpLG89ZS5zcGxpdCgvXFxyP1xcbi8pLHM9e307by5wb3AoKTtmb3IodmFyIGE9MCx1PW8ubGVuZ3RoO2E8dTsrK2Epbj1vW2FdLHQ9bi5pbmRleE9mKFwiOlwiKSxyPW4uc2xpY2UoMCx0KS50b0xvd2VyQ2FzZSgpLGk9XyhuLnNsaWNlKHQrMSkpLHNbcl09aTtyZXR1cm4gc31mdW5jdGlvbiB1KGUpe3JldHVybi9bXFwvK11qc29uXFxiLy50ZXN0KGUpfWZ1bmN0aW9uIGMoZSl7cmV0dXJuIGUuc3BsaXQoLyAqOyAqLykuc2hpZnQoKX1mdW5jdGlvbiBsKGUpe3JldHVybiBlLnNwbGl0KC8gKjsgKi8pLnJlZHVjZShmdW5jdGlvbihlLHQpe3ZhciBuPXQuc3BsaXQoLyAqPSAqLykscj1uLnNoaWZ0KCksaT1uLnNoaWZ0KCk7cmV0dXJuIHImJmkmJihlW3JdPWkpLGV9LHt9KX1mdW5jdGlvbiBoKGUsdCl7dD10fHx7fSx0aGlzLnJlcT1lLHRoaXMueGhyPXRoaXMucmVxLnhocix0aGlzLnRleHQ9XCJIRUFEXCIhPXRoaXMucmVxLm1ldGhvZCYmKFwiXCI9PT10aGlzLnhoci5yZXNwb25zZVR5cGV8fFwidGV4dFwiPT09dGhpcy54aHIucmVzcG9uc2VUeXBlKXx8dm9pZCAwPT09dGhpcy54aHIucmVzcG9uc2VUeXBlP3RoaXMueGhyLnJlc3BvbnNlVGV4dDpudWxsLHRoaXMuc3RhdHVzVGV4dD10aGlzLnJlcS54aHIuc3RhdHVzVGV4dCx0aGlzLl9zZXRTdGF0dXNQcm9wZXJ0aWVzKHRoaXMueGhyLnN0YXR1cyksdGhpcy5oZWFkZXI9dGhpcy5oZWFkZXJzPWEodGhpcy54aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpLHRoaXMuaGVhZGVyW1wiY29udGVudC10eXBlXCJdPXRoaXMueGhyLmdldFJlc3BvbnNlSGVhZGVyKFwiY29udGVudC10eXBlXCIpLHRoaXMuX3NldEhlYWRlclByb3BlcnRpZXModGhpcy5oZWFkZXIpLHRoaXMuYm9keT1cIkhFQURcIiE9dGhpcy5yZXEubWV0aG9kP3RoaXMuX3BhcnNlQm9keSh0aGlzLnRleHQ/dGhpcy50ZXh0OnRoaXMueGhyLnJlc3BvbnNlKTpudWxsfWZ1bmN0aW9uIGYoZSx0KXt2YXIgbj10aGlzO3RoaXMuX3F1ZXJ5PXRoaXMuX3F1ZXJ5fHxbXSx0aGlzLm1ldGhvZD1lLHRoaXMudXJsPXQsdGhpcy5oZWFkZXI9e30sdGhpcy5faGVhZGVyPXt9LHRoaXMub24oXCJlbmRcIixmdW5jdGlvbigpe3ZhciBlPW51bGwsdD1udWxsO3RyeXt0PW5ldyBoKG4pfWNhdGNoKHQpe3JldHVybiBlPW5ldyBFcnJvcihcIlBhcnNlciBpcyB1bmFibGUgdG8gcGFyc2UgdGhlIHJlc3BvbnNlXCIpLGUucGFyc2U9ITAsZS5vcmlnaW5hbD10LGUucmF3UmVzcG9uc2U9bi54aHImJm4ueGhyLnJlc3BvbnNlVGV4dD9uLnhoci5yZXNwb25zZVRleHQ6bnVsbCxlLnN0YXR1c0NvZGU9bi54aHImJm4ueGhyLnN0YXR1cz9uLnhoci5zdGF0dXM6bnVsbCxuLmNhbGxiYWNrKGUpfW4uZW1pdChcInJlc3BvbnNlXCIsdCk7dmFyIHI7dHJ5eyh0LnN0YXR1czwyMDB8fHQuc3RhdHVzPj0zMDApJiYocj1uZXcgRXJyb3IodC5zdGF0dXNUZXh0fHxcIlVuc3VjY2Vzc2Z1bCBIVFRQIHJlc3BvbnNlXCIpLHIub3JpZ2luYWw9ZSxyLnJlc3BvbnNlPXQsci5zdGF0dXM9dC5zdGF0dXMpfWNhdGNoKGUpe3I9ZX1yP24uY2FsbGJhY2socix0KTpuLmNhbGxiYWNrKG51bGwsdCl9KX1mdW5jdGlvbiBkKGUsdCl7dmFyIG49YihcIkRFTEVURVwiLGUpO3JldHVybiB0JiZuLmVuZCh0KSxufXZhciBwO1widW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/cD13aW5kb3c6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGY/cD1zZWxmOihjb25zb2xlLndhcm4oXCJVc2luZyBicm93c2VyLW9ubHkgdmVyc2lvbiBvZiBzdXBlcmFnZW50IGluIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpLHA9dGhpcyk7dmFyIGc9big0NCkseT1uKDQ1KSx2PW4oNDYpLGI9ZS5leHBvcnRzPW4oNDcpLmJpbmQobnVsbCxmKTtiLmdldFhIUj1mdW5jdGlvbigpe2lmKCEoIXAuWE1MSHR0cFJlcXVlc3R8fHAubG9jYXRpb24mJlwiZmlsZTpcIj09cC5sb2NhdGlvbi5wcm90b2NvbCYmcC5BY3RpdmVYT2JqZWN0KSlyZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0O3RyeXtyZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoXCJNaWNyb3NvZnQuWE1MSFRUUFwiKX1jYXRjaChlKXt9dHJ5e3JldHVybiBuZXcgQWN0aXZlWE9iamVjdChcIk1zeG1sMi5YTUxIVFRQLjYuMFwiKX1jYXRjaChlKXt9dHJ5e3JldHVybiBuZXcgQWN0aXZlWE9iamVjdChcIk1zeG1sMi5YTUxIVFRQLjMuMFwiKX1jYXRjaChlKXt9dHJ5e3JldHVybiBuZXcgQWN0aXZlWE9iamVjdChcIk1zeG1sMi5YTUxIVFRQXCIpfWNhdGNoKGUpe310aHJvdyBFcnJvcihcIkJyb3dzZXItb25seSB2ZXJpc29uIG9mIHN1cGVyYWdlbnQgY291bGQgbm90IGZpbmQgWEhSXCIpfTt2YXIgXz1cIlwiLnRyaW0/ZnVuY3Rpb24oZSl7cmV0dXJuIGUudHJpbSgpfTpmdW5jdGlvbihlKXtyZXR1cm4gZS5yZXBsYWNlKC8oXlxccyp8XFxzKiQpL2csXCJcIil9O2Iuc2VyaWFsaXplT2JqZWN0PWksYi5wYXJzZVN0cmluZz1zLGIudHlwZXM9e2h0bWw6XCJ0ZXh0L2h0bWxcIixqc29uOlwiYXBwbGljYXRpb24vanNvblwiLHhtbDpcImFwcGxpY2F0aW9uL3htbFwiLHVybGVuY29kZWQ6XCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIixmb3JtOlwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIsXCJmb3JtLWRhdGFcIjpcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwifSxiLnNlcmlhbGl6ZT17XCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIjppLFwiYXBwbGljYXRpb24vanNvblwiOkpTT04uc3RyaW5naWZ5fSxiLnBhcnNlPXtcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiOnMsXCJhcHBsaWNhdGlvbi9qc29uXCI6SlNPTi5wYXJzZX0saC5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmhlYWRlcltlLnRvTG93ZXJDYXNlKCldfSxoLnByb3RvdHlwZS5fc2V0SGVhZGVyUHJvcGVydGllcz1mdW5jdGlvbihlKXt2YXIgdD10aGlzLmhlYWRlcltcImNvbnRlbnQtdHlwZVwiXXx8XCJcIjt0aGlzLnR5cGU9Yyh0KTt2YXIgbj1sKHQpO2Zvcih2YXIgciBpbiBuKXRoaXNbcl09bltyXX0saC5wcm90b3R5cGUuX3BhcnNlQm9keT1mdW5jdGlvbihlKXt2YXIgdD1iLnBhcnNlW3RoaXMudHlwZV07cmV0dXJuIXQmJnUodGhpcy50eXBlKSYmKHQ9Yi5wYXJzZVtcImFwcGxpY2F0aW9uL2pzb25cIl0pLHQmJmUmJihlLmxlbmd0aHx8ZSBpbnN0YW5jZW9mIE9iamVjdCk/dChlKTpudWxsfSxoLnByb3RvdHlwZS5fc2V0U3RhdHVzUHJvcGVydGllcz1mdW5jdGlvbihlKXsxMjIzPT09ZSYmKGU9MjA0KTt2YXIgdD1lLzEwMHwwO3RoaXMuc3RhdHVzPXRoaXMuc3RhdHVzQ29kZT1lLHRoaXMuc3RhdHVzVHlwZT10LHRoaXMuaW5mbz0xPT10LHRoaXMub2s9Mj09dCx0aGlzLmNsaWVudEVycm9yPTQ9PXQsdGhpcy5zZXJ2ZXJFcnJvcj01PT10LHRoaXMuZXJyb3I9KDQ9PXR8fDU9PXQpJiZ0aGlzLnRvRXJyb3IoKSx0aGlzLmFjY2VwdGVkPTIwMj09ZSx0aGlzLm5vQ29udGVudD0yMDQ9PWUsdGhpcy5iYWRSZXF1ZXN0PTQwMD09ZSx0aGlzLnVuYXV0aG9yaXplZD00MDE9PWUsdGhpcy5ub3RBY2NlcHRhYmxlPTQwNj09ZSx0aGlzLm5vdEZvdW5kPTQwND09ZSx0aGlzLmZvcmJpZGRlbj00MDM9PWV9LGgucHJvdG90eXBlLnRvRXJyb3I9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnJlcSx0PWUubWV0aG9kLG49ZS51cmwscj1cImNhbm5vdCBcIit0K1wiIFwiK24rXCIgKFwiK3RoaXMuc3RhdHVzK1wiKVwiLGk9bmV3IEVycm9yKHIpO3JldHVybiBpLnN0YXR1cz10aGlzLnN0YXR1cyxpLm1ldGhvZD10LGkudXJsPW4saX0sYi5SZXNwb25zZT1oLGcoZi5wcm90b3R5cGUpO2Zvcih2YXIgbSBpbiB5KWYucHJvdG90eXBlW21dPXlbbV07Zi5wcm90b3R5cGUudHlwZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5zZXQoXCJDb250ZW50LVR5cGVcIixiLnR5cGVzW2VdfHxlKSx0aGlzfSxmLnByb3RvdHlwZS5yZXNwb25zZVR5cGU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuX3Jlc3BvbnNlVHlwZT1lLHRoaXN9LGYucHJvdG90eXBlLmFjY2VwdD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5zZXQoXCJBY2NlcHRcIixiLnR5cGVzW2VdfHxlKSx0aGlzfSxmLnByb3RvdHlwZS5hdXRoPWZ1bmN0aW9uKGUsdCxuKXtzd2l0Y2gobnx8KG49e3R5cGU6XCJiYXNpY1wifSksbi50eXBlKXtjYXNlXCJiYXNpY1wiOnZhciByPWJ0b2EoZStcIjpcIit0KTt0aGlzLnNldChcIkF1dGhvcml6YXRpb25cIixcIkJhc2ljIFwiK3IpO2JyZWFrO2Nhc2VcImF1dG9cIjp0aGlzLnVzZXJuYW1lPWUsdGhpcy5wYXNzd29yZD10fXJldHVybiB0aGlzfSxmLnByb3RvdHlwZS5xdWVyeT1mdW5jdGlvbihlKXtyZXR1cm5cInN0cmluZ1wiIT10eXBlb2YgZSYmKGU9aShlKSksZSYmdGhpcy5fcXVlcnkucHVzaChlKSx0aGlzfSxmLnByb3RvdHlwZS5hdHRhY2g9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiB0aGlzLl9nZXRGb3JtRGF0YSgpLmFwcGVuZChlLHQsbnx8dC5uYW1lKSx0aGlzfSxmLnByb3RvdHlwZS5fZ2V0Rm9ybURhdGE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZm9ybURhdGF8fCh0aGlzLl9mb3JtRGF0YT1uZXcgcC5Gb3JtRGF0YSksdGhpcy5fZm9ybURhdGF9LGYucHJvdG90eXBlLmNhbGxiYWNrPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcy5fY2FsbGJhY2s7dGhpcy5jbGVhclRpbWVvdXQoKSxuKGUsdCl9LGYucHJvdG90eXBlLmNyb3NzRG9tYWluRXJyb3I9ZnVuY3Rpb24oKXt2YXIgZT1uZXcgRXJyb3IoXCJSZXF1ZXN0IGhhcyBiZWVuIHRlcm1pbmF0ZWRcXG5Qb3NzaWJsZSBjYXVzZXM6IHRoZSBuZXR3b3JrIGlzIG9mZmxpbmUsIE9yaWdpbiBpcyBub3QgYWxsb3dlZCBieSBBY2Nlc3MtQ29udHJvbC1BbGxvdy1PcmlnaW4sIHRoZSBwYWdlIGlzIGJlaW5nIHVubG9hZGVkLCBldGMuXCIpO2UuY3Jvc3NEb21haW49ITAsZS5zdGF0dXM9dGhpcy5zdGF0dXMsZS5tZXRob2Q9dGhpcy5tZXRob2QsZS51cmw9dGhpcy51cmwsdGhpcy5jYWxsYmFjayhlKX0sZi5wcm90b3R5cGUuX3RpbWVvdXRFcnJvcj1mdW5jdGlvbigpe3ZhciBlPXRoaXMuX3RpbWVvdXQsdD1uZXcgRXJyb3IoXCJ0aW1lb3V0IG9mIFwiK2UrXCJtcyBleGNlZWRlZFwiKTt0LnRpbWVvdXQ9ZSx0aGlzLmNhbGxiYWNrKHQpfSxmLnByb3RvdHlwZS5fYXBwZW5kUXVlcnlTdHJpbmc9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLl9xdWVyeS5qb2luKFwiJlwiKTtlJiYodGhpcy51cmwrPX50aGlzLnVybC5pbmRleE9mKFwiP1wiKT9cIiZcIitlOlwiP1wiK2UpfSxmLnByb3RvdHlwZS5lbmQ9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcyxuPXRoaXMueGhyPWIuZ2V0WEhSKCksaT10aGlzLl90aW1lb3V0LG89dGhpcy5fZm9ybURhdGF8fHRoaXMuX2RhdGE7dGhpcy5fY2FsbGJhY2s9ZXx8cixuLm9ucmVhZHlzdGF0ZWNoYW5nZT1mdW5jdGlvbigpe2lmKDQ9PW4ucmVhZHlTdGF0ZSl7dmFyIGU7dHJ5e2U9bi5zdGF0dXN9Y2F0Y2godCl7ZT0wfWlmKDA9PWUpe2lmKHQudGltZWRvdXQpcmV0dXJuIHQuX3RpbWVvdXRFcnJvcigpO2lmKHQuX2Fib3J0ZWQpcmV0dXJuO3JldHVybiB0LmNyb3NzRG9tYWluRXJyb3IoKX10LmVtaXQoXCJlbmRcIil9fTt2YXIgcz1mdW5jdGlvbihlLG4pe24udG90YWw+MCYmKG4ucGVyY2VudD1uLmxvYWRlZC9uLnRvdGFsKjEwMCksbi5kaXJlY3Rpb249ZSx0LmVtaXQoXCJwcm9ncmVzc1wiLG4pfTtpZih0aGlzLmhhc0xpc3RlbmVycyhcInByb2dyZXNzXCIpKXRyeXtuLm9ucHJvZ3Jlc3M9cy5iaW5kKG51bGwsXCJkb3dubG9hZFwiKSxuLnVwbG9hZCYmKG4udXBsb2FkLm9ucHJvZ3Jlc3M9cy5iaW5kKG51bGwsXCJ1cGxvYWRcIikpfWNhdGNoKGUpe31pZihpJiYhdGhpcy5fdGltZXImJih0aGlzLl90aW1lcj1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dC50aW1lZG91dD0hMCx0LmFib3J0KCl9LGkpKSx0aGlzLl9hcHBlbmRRdWVyeVN0cmluZygpLHRoaXMudXNlcm5hbWUmJnRoaXMucGFzc3dvcmQ/bi5vcGVuKHRoaXMubWV0aG9kLHRoaXMudXJsLCEwLHRoaXMudXNlcm5hbWUsdGhpcy5wYXNzd29yZCk6bi5vcGVuKHRoaXMubWV0aG9kLHRoaXMudXJsLCEwKSx0aGlzLl93aXRoQ3JlZGVudGlhbHMmJihuLndpdGhDcmVkZW50aWFscz0hMCksXCJHRVRcIiE9dGhpcy5tZXRob2QmJlwiSEVBRFwiIT10aGlzLm1ldGhvZCYmXCJzdHJpbmdcIiE9dHlwZW9mIG8mJiF0aGlzLl9pc0hvc3Qobykpe3ZhciBhPXRoaXMuX2hlYWRlcltcImNvbnRlbnQtdHlwZVwiXSxjPXRoaXMuX3NlcmlhbGl6ZXJ8fGIuc2VyaWFsaXplW2E/YS5zcGxpdChcIjtcIilbMF06XCJcIl07IWMmJnUoYSkmJihjPWIuc2VyaWFsaXplW1wiYXBwbGljYXRpb24vanNvblwiXSksYyYmKG89YyhvKSl9Zm9yKHZhciBsIGluIHRoaXMuaGVhZGVyKW51bGwhPXRoaXMuaGVhZGVyW2xdJiZuLnNldFJlcXVlc3RIZWFkZXIobCx0aGlzLmhlYWRlcltsXSk7cmV0dXJuIHRoaXMuX3Jlc3BvbnNlVHlwZSYmKG4ucmVzcG9uc2VUeXBlPXRoaXMuX3Jlc3BvbnNlVHlwZSksdGhpcy5lbWl0KFwicmVxdWVzdFwiLHRoaXMpLG4uc2VuZCh2b2lkIDAhPT1vP286bnVsbCksdGhpc30sYi5SZXF1ZXN0PWYsYi5nZXQ9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPWIoXCJHRVRcIixlKTtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiB0JiYobj10LHQ9bnVsbCksdCYmci5xdWVyeSh0KSxuJiZyLmVuZChuKSxyfSxiLmhlYWQ9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPWIoXCJIRUFEXCIsZSk7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgdCYmKG49dCx0PW51bGwpLHQmJnIuc2VuZCh0KSxuJiZyLmVuZChuKSxyfSxiLm9wdGlvbnM9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPWIoXCJPUFRJT05TXCIsZSk7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgdCYmKG49dCx0PW51bGwpLHQmJnIuc2VuZCh0KSxuJiZyLmVuZChuKSxyfSxiLmRlbD1kLGIuZGVsZXRlPWQsYi5wYXRjaD1mdW5jdGlvbihlLHQsbil7dmFyIHI9YihcIlBBVENIXCIsZSk7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgdCYmKG49dCx0PW51bGwpLHQmJnIuc2VuZCh0KSxuJiZyLmVuZChuKSxyfSxiLnBvc3Q9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPWIoXCJQT1NUXCIsZSk7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgdCYmKG49dCx0PW51bGwpLHQmJnIuc2VuZCh0KSxuJiZyLmVuZChuKSxyfSxiLnB1dD1mdW5jdGlvbihlLHQsbil7dmFyIHI9YihcIlBVVFwiLGUpO3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIHQmJihuPXQsdD1udWxsKSx0JiZyLnNlbmQodCksbiYmci5lbmQobikscn19LGZ1bmN0aW9uKGUsdCxuKXtmdW5jdGlvbiByKGUpe2lmKGUpcmV0dXJuIGkoZSl9ZnVuY3Rpb24gaShlKXtmb3IodmFyIHQgaW4gci5wcm90b3R5cGUpZVt0XT1yLnByb3RvdHlwZVt0XTtyZXR1cm4gZX1lLmV4cG9ydHM9cixyLnByb3RvdHlwZS5vbj1yLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuX2NhbGxiYWNrcz10aGlzLl9jYWxsYmFja3N8fHt9LCh0aGlzLl9jYWxsYmFja3NbXCIkXCIrZV09dGhpcy5fY2FsbGJhY2tzW1wiJFwiK2VdfHxbXSkucHVzaCh0KSx0aGlzfSxyLnByb3RvdHlwZS5vbmNlPWZ1bmN0aW9uKGUsdCl7ZnVuY3Rpb24gbigpe3RoaXMub2ZmKGUsbiksdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9cmV0dXJuIG4uZm49dCx0aGlzLm9uKGUsbiksdGhpc30sci5wcm90b3R5cGUub2ZmPXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyPXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycz1yLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyPWZ1bmN0aW9uKGUsdCl7aWYodGhpcy5fY2FsbGJhY2tzPXRoaXMuX2NhbGxiYWNrc3x8e30sMD09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5fY2FsbGJhY2tzPXt9LHRoaXM7dmFyIG49dGhpcy5fY2FsbGJhY2tzW1wiJFwiK2VdO2lmKCFuKXJldHVybiB0aGlzO2lmKDE9PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbXCIkXCIrZV0sdGhpcztmb3IodmFyIHIsaT0wO2k8bi5sZW5ndGg7aSsrKWlmKChyPW5baV0pPT09dHx8ci5mbj09PXQpe24uc3BsaWNlKGksMSk7YnJlYWt9cmV0dXJuIHRoaXN9LHIucHJvdG90eXBlLmVtaXQ9ZnVuY3Rpb24oZSl7dGhpcy5fY2FsbGJhY2tzPXRoaXMuX2NhbGxiYWNrc3x8e307dmFyIHQ9W10uc2xpY2UuY2FsbChhcmd1bWVudHMsMSksbj10aGlzLl9jYWxsYmFja3NbXCIkXCIrZV07aWYobil7bj1uLnNsaWNlKDApO2Zvcih2YXIgcj0wLGk9bi5sZW5ndGg7cjxpOysrciluW3JdLmFwcGx5KHRoaXMsdCl9cmV0dXJuIHRoaXN9LHIucHJvdG90eXBlLmxpc3RlbmVycz1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5fY2FsbGJhY2tzPXRoaXMuX2NhbGxiYWNrc3x8e30sdGhpcy5fY2FsbGJhY2tzW1wiJFwiK2VdfHxbXX0sci5wcm90b3R5cGUuaGFzTGlzdGVuZXJzPWZ1bmN0aW9uKGUpe3JldHVybiEhdGhpcy5saXN0ZW5lcnMoZSkubGVuZ3RofX0sZnVuY3Rpb24oZSx0LG4pe3ZhciByPW4oNDYpO3QuY2xlYXJUaW1lb3V0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3RpbWVvdXQ9MCxjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpLHRoaXN9LHQucGFyc2U9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuX3BhcnNlcj1lLHRoaXN9LHQuc2VyaWFsaXplPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLl9zZXJpYWxpemVyPWUsdGhpc30sdC50aW1lb3V0PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLl90aW1lb3V0PWUsdGhpc30sdC50aGVuPWZ1bmN0aW9uKGUsdCl7aWYoIXRoaXMuX2Z1bGxmaWxsZWRQcm9taXNlKXt2YXIgbj10aGlzO3RoaXMuX2Z1bGxmaWxsZWRQcm9taXNlPW5ldyBQcm9taXNlKGZ1bmN0aW9uKGUsdCl7bi5lbmQoZnVuY3Rpb24obixyKXtuP3Qobik6ZShyKX0pfSl9cmV0dXJuIHRoaXMuX2Z1bGxmaWxsZWRQcm9taXNlLnRoZW4oZSx0KX0sdC5jYXRjaD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50aGVuKHZvaWQgMCxlKX0sdC51c2U9ZnVuY3Rpb24oZSl7cmV0dXJuIGUodGhpcyksdGhpc30sdC5nZXQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuX2hlYWRlcltlLnRvTG93ZXJDYXNlKCldfSx0LmdldEhlYWRlcj10LmdldCx0LnNldD1mdW5jdGlvbihlLHQpe2lmKHIoZSkpe2Zvcih2YXIgbiBpbiBlKXRoaXMuc2V0KG4sZVtuXSk7cmV0dXJuIHRoaXN9cmV0dXJuIHRoaXMuX2hlYWRlcltlLnRvTG93ZXJDYXNlKCldPXQsdGhpcy5oZWFkZXJbZV09dCx0aGlzfSx0LnVuc2V0PWZ1bmN0aW9uKGUpe3JldHVybiBkZWxldGUgdGhpcy5faGVhZGVyW2UudG9Mb3dlckNhc2UoKV0sZGVsZXRlIHRoaXMuaGVhZGVyW2VdLHRoaXN9LHQuZmllbGQ9ZnVuY3Rpb24oZSx0KXtpZihudWxsPT09ZXx8dm9pZCAwPT09ZSl0aHJvdyBuZXcgRXJyb3IoXCIuZmllbGQobmFtZSwgdmFsKSBuYW1lIGNhbiBub3QgYmUgZW1wdHlcIik7aWYocihlKSl7Zm9yKHZhciBuIGluIGUpdGhpcy5maWVsZChuLGVbbl0pO3JldHVybiB0aGlzfWlmKG51bGw9PT10fHx2b2lkIDA9PT10KXRocm93IG5ldyBFcnJvcihcIi5maWVsZChuYW1lLCB2YWwpIHZhbCBjYW4gbm90IGJlIGVtcHR5XCIpO3JldHVybiB0aGlzLl9nZXRGb3JtRGF0YSgpLmFwcGVuZChlLHQpLHRoaXN9LHQuYWJvcnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fYWJvcnRlZD90aGlzOih0aGlzLl9hYm9ydGVkPSEwLHRoaXMueGhyJiZ0aGlzLnhoci5hYm9ydCgpLHRoaXMucmVxJiZ0aGlzLnJlcS5hYm9ydCgpLHRoaXMuY2xlYXJUaW1lb3V0KCksdGhpcy5lbWl0KFwiYWJvcnRcIiksdGhpcyl9LHQud2l0aENyZWRlbnRpYWxzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3dpdGhDcmVkZW50aWFscz0hMCx0aGlzfSx0LnJlZGlyZWN0cz1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5fbWF4UmVkaXJlY3RzPWUsdGhpc30sdC50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm57bWV0aG9kOnRoaXMubWV0aG9kLHVybDp0aGlzLnVybCxkYXRhOnRoaXMuX2RhdGEsaGVhZGVyczp0aGlzLl9oZWFkZXJ9fSx0Ll9pc0hvc3Q9ZnVuY3Rpb24oZSl7c3dpdGNoKHt9LnRvU3RyaW5nLmNhbGwoZSkpe2Nhc2VcIltvYmplY3QgRmlsZV1cIjpjYXNlXCJbb2JqZWN0IEJsb2JdXCI6Y2FzZVwiW29iamVjdCBGb3JtRGF0YV1cIjpyZXR1cm4hMDtkZWZhdWx0OnJldHVybiExfX0sdC5zZW5kPWZ1bmN0aW9uKGUpe3ZhciB0PXIoZSksbj10aGlzLl9oZWFkZXJbXCJjb250ZW50LXR5cGVcIl07aWYodCYmcih0aGlzLl9kYXRhKSlmb3IodmFyIGkgaW4gZSl0aGlzLl9kYXRhW2ldPWVbaV07ZWxzZVwic3RyaW5nXCI9PXR5cGVvZiBlPyhufHx0aGlzLnR5cGUoXCJmb3JtXCIpLG49dGhpcy5faGVhZGVyW1wiY29udGVudC10eXBlXCJdLHRoaXMuX2RhdGE9XCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIj09bj90aGlzLl9kYXRhP3RoaXMuX2RhdGErXCImXCIrZTplOih0aGlzLl9kYXRhfHxcIlwiKStlKTp0aGlzLl9kYXRhPWU7cmV0dXJuIXR8fHRoaXMuX2lzSG9zdChlKT90aGlzOihufHx0aGlzLnR5cGUoXCJqc29uXCIpLHRoaXMpfX0sZnVuY3Rpb24oZSx0KXtmdW5jdGlvbiBuKGUpe3JldHVybiBudWxsIT09ZSYmXCJvYmplY3RcIj09dHlwZW9mIGV9ZS5leHBvcnRzPW59LGZ1bmN0aW9uKGUsdCl7ZnVuY3Rpb24gbihlLHQsbil7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2Ygbj9uZXcgZShcIkdFVFwiLHQpLmVuZChuKToyPT1hcmd1bWVudHMubGVuZ3RoP25ldyBlKFwiR0VUXCIsdCk6bmV3IGUodCxuKX1lLmV4cG9ydHM9bn1dKX0pOyIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciB1cmwgPSByZXF1aXJlKCcuL3VybCcpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJ3NvY2tldC5pby1wYXJzZXInKTtcbnZhciBNYW5hZ2VyID0gcmVxdWlyZSgnLi9tYW5hZ2VyJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NrZXQuaW8tY2xpZW50Jyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gbG9va3VwO1xuXG4vKipcbiAqIE1hbmFnZXJzIGNhY2hlLlxuICovXG5cbnZhciBjYWNoZSA9IGV4cG9ydHMubWFuYWdlcnMgPSB7fTtcblxuLyoqXG4gKiBMb29rcyB1cCBhbiBleGlzdGluZyBgTWFuYWdlcmAgZm9yIG11bHRpcGxleGluZy5cbiAqIElmIHRoZSB1c2VyIHN1bW1vbnM6XG4gKlxuICogICBgaW8oJ2h0dHA6Ly9sb2NhbGhvc3QvYScpO2BcbiAqICAgYGlvKCdodHRwOi8vbG9jYWxob3N0L2InKTtgXG4gKlxuICogV2UgcmV1c2UgdGhlIGV4aXN0aW5nIGluc3RhbmNlIGJhc2VkIG9uIHNhbWUgc2NoZW1lL3BvcnQvaG9zdCxcbiAqIGFuZCB3ZSBpbml0aWFsaXplIHNvY2tldHMgZm9yIGVhY2ggbmFtZXNwYWNlLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbG9va3VwICh1cmksIG9wdHMpIHtcbiAgaWYgKHR5cGVvZiB1cmkgPT09ICdvYmplY3QnKSB7XG4gICAgb3B0cyA9IHVyaTtcbiAgICB1cmkgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICB2YXIgcGFyc2VkID0gdXJsKHVyaSk7XG4gIHZhciBzb3VyY2UgPSBwYXJzZWQuc291cmNlO1xuICB2YXIgaWQgPSBwYXJzZWQuaWQ7XG4gIHZhciBwYXRoID0gcGFyc2VkLnBhdGg7XG4gIHZhciBzYW1lTmFtZXNwYWNlID0gY2FjaGVbaWRdICYmIHBhdGggaW4gY2FjaGVbaWRdLm5zcHM7XG4gIHZhciBuZXdDb25uZWN0aW9uID0gb3B0cy5mb3JjZU5ldyB8fCBvcHRzWydmb3JjZSBuZXcgY29ubmVjdGlvbiddIHx8XG4gICAgICAgICAgICAgICAgICAgICAgZmFsc2UgPT09IG9wdHMubXVsdGlwbGV4IHx8IHNhbWVOYW1lc3BhY2U7XG5cbiAgdmFyIGlvO1xuXG4gIGlmIChuZXdDb25uZWN0aW9uKSB7XG4gICAgZGVidWcoJ2lnbm9yaW5nIHNvY2tldCBjYWNoZSBmb3IgJXMnLCBzb3VyY2UpO1xuICAgIGlvID0gTWFuYWdlcihzb3VyY2UsIG9wdHMpO1xuICB9IGVsc2Uge1xuICAgIGlmICghY2FjaGVbaWRdKSB7XG4gICAgICBkZWJ1ZygnbmV3IGlvIGluc3RhbmNlIGZvciAlcycsIHNvdXJjZSk7XG4gICAgICBjYWNoZVtpZF0gPSBNYW5hZ2VyKHNvdXJjZSwgb3B0cyk7XG4gICAgfVxuICAgIGlvID0gY2FjaGVbaWRdO1xuICB9XG4gIGlmIChwYXJzZWQucXVlcnkgJiYgIW9wdHMucXVlcnkpIHtcbiAgICBvcHRzLnF1ZXJ5ID0gcGFyc2VkLnF1ZXJ5O1xuICB9IGVsc2UgaWYgKG9wdHMgJiYgJ29iamVjdCcgPT09IHR5cGVvZiBvcHRzLnF1ZXJ5KSB7XG4gICAgb3B0cy5xdWVyeSA9IGVuY29kZVF1ZXJ5U3RyaW5nKG9wdHMucXVlcnkpO1xuICB9XG4gIHJldHVybiBpby5zb2NrZXQocGFyc2VkLnBhdGgsIG9wdHMpO1xufVxuLyoqXG4gKiAgSGVscGVyIG1ldGhvZCB0byBwYXJzZSBxdWVyeSBvYmplY3RzIHRvIHN0cmluZy5cbiAqIEBwYXJhbSB7b2JqZWN0fSBxdWVyeVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZW5jb2RlUXVlcnlTdHJpbmcgKG9iaikge1xuICB2YXIgc3RyID0gW107XG4gIGZvciAodmFyIHAgaW4gb2JqKSB7XG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwKSkge1xuICAgICAgc3RyLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KHApICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KG9ialtwXSkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyLmpvaW4oJyYnKTtcbn1cbi8qKlxuICogUHJvdG9jb2wgdmVyc2lvbi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMucHJvdG9jb2wgPSBwYXJzZXIucHJvdG9jb2w7XG5cbi8qKlxuICogYGNvbm5lY3RgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmlcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5jb25uZWN0ID0gbG9va3VwO1xuXG4vKipcbiAqIEV4cG9zZSBjb25zdHJ1Y3RvcnMgZm9yIHN0YW5kYWxvbmUgYnVpbGQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLk1hbmFnZXIgPSByZXF1aXJlKCcuL21hbmFnZXInKTtcbmV4cG9ydHMuU29ja2V0ID0gcmVxdWlyZSgnLi9zb2NrZXQnKTtcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBlaW8gPSByZXF1aXJlKCdlbmdpbmUuaW8tY2xpZW50Jyk7XG52YXIgU29ja2V0ID0gcmVxdWlyZSgnLi9zb2NrZXQnKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciBwYXJzZXIgPSByZXF1aXJlKCdzb2NrZXQuaW8tcGFyc2VyJyk7XG52YXIgb24gPSByZXF1aXJlKCcuL29uJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1iaW5kJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NrZXQuaW8tY2xpZW50Om1hbmFnZXInKTtcbnZhciBpbmRleE9mID0gcmVxdWlyZSgnaW5kZXhvZicpO1xudmFyIEJhY2tvZmYgPSByZXF1aXJlKCdiYWNrbzInKTtcblxuLyoqXG4gKiBJRTYrIGhhc093blByb3BlcnR5XG4gKi9cblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hbmFnZXI7XG5cbi8qKlxuICogYE1hbmFnZXJgIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBlbmdpbmUgaW5zdGFuY2Ugb3IgZW5naW5lIHVyaS9vcHRzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBNYW5hZ2VyICh1cmksIG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1hbmFnZXIpKSByZXR1cm4gbmV3IE1hbmFnZXIodXJpLCBvcHRzKTtcbiAgaWYgKHVyaSAmJiAoJ29iamVjdCcgPT09IHR5cGVvZiB1cmkpKSB7XG4gICAgb3B0cyA9IHVyaTtcbiAgICB1cmkgPSB1bmRlZmluZWQ7XG4gIH1cbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgb3B0cy5wYXRoID0gb3B0cy5wYXRoIHx8ICcvc29ja2V0LmlvJztcbiAgdGhpcy5uc3BzID0ge307XG4gIHRoaXMuc3VicyA9IFtdO1xuICB0aGlzLm9wdHMgPSBvcHRzO1xuICB0aGlzLnJlY29ubmVjdGlvbihvcHRzLnJlY29ubmVjdGlvbiAhPT0gZmFsc2UpO1xuICB0aGlzLnJlY29ubmVjdGlvbkF0dGVtcHRzKG9wdHMucmVjb25uZWN0aW9uQXR0ZW1wdHMgfHwgSW5maW5pdHkpO1xuICB0aGlzLnJlY29ubmVjdGlvbkRlbGF5KG9wdHMucmVjb25uZWN0aW9uRGVsYXkgfHwgMTAwMCk7XG4gIHRoaXMucmVjb25uZWN0aW9uRGVsYXlNYXgob3B0cy5yZWNvbm5lY3Rpb25EZWxheU1heCB8fCA1MDAwKTtcbiAgdGhpcy5yYW5kb21pemF0aW9uRmFjdG9yKG9wdHMucmFuZG9taXphdGlvbkZhY3RvciB8fCAwLjUpO1xuICB0aGlzLmJhY2tvZmYgPSBuZXcgQmFja29mZih7XG4gICAgbWluOiB0aGlzLnJlY29ubmVjdGlvbkRlbGF5KCksXG4gICAgbWF4OiB0aGlzLnJlY29ubmVjdGlvbkRlbGF5TWF4KCksXG4gICAgaml0dGVyOiB0aGlzLnJhbmRvbWl6YXRpb25GYWN0b3IoKVxuICB9KTtcbiAgdGhpcy50aW1lb3V0KG51bGwgPT0gb3B0cy50aW1lb3V0ID8gMjAwMDAgOiBvcHRzLnRpbWVvdXQpO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgdGhpcy51cmkgPSB1cmk7XG4gIHRoaXMuY29ubmVjdGluZyA9IFtdO1xuICB0aGlzLmxhc3RQaW5nID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IGZhbHNlO1xuICB0aGlzLnBhY2tldEJ1ZmZlciA9IFtdO1xuICB0aGlzLmVuY29kZXIgPSBuZXcgcGFyc2VyLkVuY29kZXIoKTtcbiAgdGhpcy5kZWNvZGVyID0gbmV3IHBhcnNlci5EZWNvZGVyKCk7XG4gIHRoaXMuYXV0b0Nvbm5lY3QgPSBvcHRzLmF1dG9Db25uZWN0ICE9PSBmYWxzZTtcbiAgaWYgKHRoaXMuYXV0b0Nvbm5lY3QpIHRoaXMub3BlbigpO1xufVxuXG4vKipcbiAqIFByb3BhZ2F0ZSBnaXZlbiBldmVudCB0byBzb2NrZXRzIGFuZCBlbWl0IG9uIGB0aGlzYFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLmVtaXRBbGwgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICBmb3IgKHZhciBuc3AgaW4gdGhpcy5uc3BzKSB7XG4gICAgaWYgKGhhcy5jYWxsKHRoaXMubnNwcywgbnNwKSkge1xuICAgICAgdGhpcy5uc3BzW25zcF0uZW1pdC5hcHBseSh0aGlzLm5zcHNbbnNwXSwgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogVXBkYXRlIGBzb2NrZXQuaWRgIG9mIGFsbCBzb2NrZXRzXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUudXBkYXRlU29ja2V0SWRzID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBuc3AgaW4gdGhpcy5uc3BzKSB7XG4gICAgaWYgKGhhcy5jYWxsKHRoaXMubnNwcywgbnNwKSkge1xuICAgICAgdGhpcy5uc3BzW25zcF0uaWQgPSB0aGlzLmVuZ2luZS5pZDtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKE1hbmFnZXIucHJvdG90eXBlKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBgcmVjb25uZWN0aW9uYCBjb25maWcuXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSB0cnVlL2ZhbHNlIGlmIGl0IHNob3VsZCBhdXRvbWF0aWNhbGx5IHJlY29ubmVjdFxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb24gPSBmdW5jdGlvbiAodikge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb247XG4gIHRoaXMuX3JlY29ubmVjdGlvbiA9ICEhdjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHJlY29ubmVjdGlvbiBhdHRlbXB0cyBjb25maWcuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1heCByZWNvbm5lY3Rpb24gYXR0ZW1wdHMgYmVmb3JlIGdpdmluZyB1cFxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb25BdHRlbXB0cyA9IGZ1bmN0aW9uICh2KSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzO1xuICB0aGlzLl9yZWNvbm5lY3Rpb25BdHRlbXB0cyA9IHY7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBkZWxheSBiZXR3ZWVuIHJlY29ubmVjdGlvbnMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5XG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbkRlbGF5ID0gZnVuY3Rpb24gKHYpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uRGVsYXk7XG4gIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5ID0gdjtcbiAgdGhpcy5iYWNrb2ZmICYmIHRoaXMuYmFja29mZi5zZXRNaW4odik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuTWFuYWdlci5wcm90b3R5cGUucmFuZG9taXphdGlvbkZhY3RvciA9IGZ1bmN0aW9uICh2KSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JhbmRvbWl6YXRpb25GYWN0b3I7XG4gIHRoaXMuX3JhbmRvbWl6YXRpb25GYWN0b3IgPSB2O1xuICB0aGlzLmJhY2tvZmYgJiYgdGhpcy5iYWNrb2ZmLnNldEppdHRlcih2KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIG1heGltdW0gZGVsYXkgYmV0d2VlbiByZWNvbm5lY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheVxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb25EZWxheU1heCA9IGZ1bmN0aW9uICh2KSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5TWF4O1xuICB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheU1heCA9IHY7XG4gIHRoaXMuYmFja29mZiAmJiB0aGlzLmJhY2tvZmYuc2V0TWF4KHYpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgY29ubmVjdGlvbiB0aW1lb3V0LiBgZmFsc2VgIHRvIGRpc2FibGVcbiAqXG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnRpbWVvdXQgPSBmdW5jdGlvbiAodikge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl90aW1lb3V0O1xuICB0aGlzLl90aW1lb3V0ID0gdjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFN0YXJ0cyB0cnlpbmcgdG8gcmVjb25uZWN0IGlmIHJlY29ubmVjdGlvbiBpcyBlbmFibGVkIGFuZCB3ZSBoYXZlIG5vdFxuICogc3RhcnRlZCByZWNvbm5lY3RpbmcgeWV0XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUubWF5YmVSZWNvbm5lY3RPbk9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIC8vIE9ubHkgdHJ5IHRvIHJlY29ubmVjdCBpZiBpdCdzIHRoZSBmaXJzdCB0aW1lIHdlJ3JlIGNvbm5lY3RpbmdcbiAgaWYgKCF0aGlzLnJlY29ubmVjdGluZyAmJiB0aGlzLl9yZWNvbm5lY3Rpb24gJiYgdGhpcy5iYWNrb2ZmLmF0dGVtcHRzID09PSAwKSB7XG4gICAgLy8ga2VlcHMgcmVjb25uZWN0aW9uIGZyb20gZmlyaW5nIHR3aWNlIGZvciB0aGUgc2FtZSByZWNvbm5lY3Rpb24gbG9vcFxuICAgIHRoaXMucmVjb25uZWN0KCk7XG4gIH1cbn07XG5cbi8qKlxuICogU2V0cyB0aGUgY3VycmVudCB0cmFuc3BvcnQgYHNvY2tldGAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9uYWwsIGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9wZW4gPVxuTWFuYWdlci5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uIChmbiwgb3B0cykge1xuICBkZWJ1ZygncmVhZHlTdGF0ZSAlcycsIHRoaXMucmVhZHlTdGF0ZSk7XG4gIGlmICh+dGhpcy5yZWFkeVN0YXRlLmluZGV4T2YoJ29wZW4nKSkgcmV0dXJuIHRoaXM7XG5cbiAgZGVidWcoJ29wZW5pbmcgJXMnLCB0aGlzLnVyaSk7XG4gIHRoaXMuZW5naW5lID0gZWlvKHRoaXMudXJpLCB0aGlzLm9wdHMpO1xuICB2YXIgc29ja2V0ID0gdGhpcy5lbmdpbmU7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW5pbmcnO1xuICB0aGlzLnNraXBSZWNvbm5lY3QgPSBmYWxzZTtcblxuICAvLyBlbWl0IGBvcGVuYFxuICB2YXIgb3BlblN1YiA9IG9uKHNvY2tldCwgJ29wZW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5vbm9wZW4oKTtcbiAgICBmbiAmJiBmbigpO1xuICB9KTtcblxuICAvLyBlbWl0IGBjb25uZWN0X2Vycm9yYFxuICB2YXIgZXJyb3JTdWIgPSBvbihzb2NrZXQsICdlcnJvcicsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGVidWcoJ2Nvbm5lY3RfZXJyb3InKTtcbiAgICBzZWxmLmNsZWFudXAoKTtcbiAgICBzZWxmLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgICBzZWxmLmVtaXRBbGwoJ2Nvbm5lY3RfZXJyb3InLCBkYXRhKTtcbiAgICBpZiAoZm4pIHtcbiAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ0Nvbm5lY3Rpb24gZXJyb3InKTtcbiAgICAgIGVyci5kYXRhID0gZGF0YTtcbiAgICAgIGZuKGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE9ubHkgZG8gdGhpcyBpZiB0aGVyZSBpcyBubyBmbiB0byBoYW5kbGUgdGhlIGVycm9yXG4gICAgICBzZWxmLm1heWJlUmVjb25uZWN0T25PcGVuKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBlbWl0IGBjb25uZWN0X3RpbWVvdXRgXG4gIGlmIChmYWxzZSAhPT0gdGhpcy5fdGltZW91dCkge1xuICAgIHZhciB0aW1lb3V0ID0gdGhpcy5fdGltZW91dDtcbiAgICBkZWJ1ZygnY29ubmVjdCBhdHRlbXB0IHdpbGwgdGltZW91dCBhZnRlciAlZCcsIHRpbWVvdXQpO1xuXG4gICAgLy8gc2V0IHRpbWVyXG4gICAgdmFyIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBkZWJ1ZygnY29ubmVjdCBhdHRlbXB0IHRpbWVkIG91dCBhZnRlciAlZCcsIHRpbWVvdXQpO1xuICAgICAgb3BlblN1Yi5kZXN0cm95KCk7XG4gICAgICBzb2NrZXQuY2xvc2UoKTtcbiAgICAgIHNvY2tldC5lbWl0KCdlcnJvcicsICd0aW1lb3V0Jyk7XG4gICAgICBzZWxmLmVtaXRBbGwoJ2Nvbm5lY3RfdGltZW91dCcsIHRpbWVvdXQpO1xuICAgIH0sIHRpbWVvdXQpO1xuXG4gICAgdGhpcy5zdWJzLnB1c2goe1xuICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdGhpcy5zdWJzLnB1c2gob3BlblN1Yik7XG4gIHRoaXMuc3Vicy5wdXNoKGVycm9yU3ViKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IG9wZW4uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25vcGVuID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1Zygnb3BlbicpO1xuXG4gIC8vIGNsZWFyIG9sZCBzdWJzXG4gIHRoaXMuY2xlYW51cCgpO1xuXG4gIC8vIG1hcmsgYXMgb3BlblxuICB0aGlzLnJlYWR5U3RhdGUgPSAnb3Blbic7XG4gIHRoaXMuZW1pdCgnb3BlbicpO1xuXG4gIC8vIGFkZCBuZXcgc3Vic1xuICB2YXIgc29ja2V0ID0gdGhpcy5lbmdpbmU7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2RhdGEnLCBiaW5kKHRoaXMsICdvbmRhdGEnKSkpO1xuICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdwaW5nJywgYmluZCh0aGlzLCAnb25waW5nJykpKTtcbiAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAncG9uZycsIGJpbmQodGhpcywgJ29ucG9uZycpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2Vycm9yJywgYmluZCh0aGlzLCAnb25lcnJvcicpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2Nsb3NlJywgYmluZCh0aGlzLCAnb25jbG9zZScpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHRoaXMuZGVjb2RlciwgJ2RlY29kZWQnLCBiaW5kKHRoaXMsICdvbmRlY29kZWQnKSkpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhIHBpbmcuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25waW5nID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmxhc3RQaW5nID0gbmV3IERhdGUoKTtcbiAgdGhpcy5lbWl0QWxsKCdwaW5nJyk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGEgcGFja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9ucG9uZyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0QWxsKCdwb25nJywgbmV3IERhdGUoKSAtIHRoaXMubGFzdFBpbmcpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2l0aCBkYXRhLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9uZGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuZGVjb2Rlci5hZGQoZGF0YSk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIHBhcnNlciBmdWxseSBkZWNvZGVzIGEgcGFja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9uZGVjb2RlZCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgdGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzb2NrZXQgZXJyb3IuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgZGVidWcoJ2Vycm9yJywgZXJyKTtcbiAgdGhpcy5lbWl0QWxsKCdlcnJvcicsIGVycik7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgc29ja2V0IGZvciB0aGUgZ2l2ZW4gYG5zcGAuXG4gKlxuICogQHJldHVybiB7U29ja2V0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5zb2NrZXQgPSBmdW5jdGlvbiAobnNwLCBvcHRzKSB7XG4gIHZhciBzb2NrZXQgPSB0aGlzLm5zcHNbbnNwXTtcbiAgaWYgKCFzb2NrZXQpIHtcbiAgICBzb2NrZXQgPSBuZXcgU29ja2V0KHRoaXMsIG5zcCwgb3B0cyk7XG4gICAgdGhpcy5uc3BzW25zcF0gPSBzb2NrZXQ7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNvY2tldC5vbignY29ubmVjdGluZycsIG9uQ29ubmVjdGluZyk7XG4gICAgc29ja2V0Lm9uKCdjb25uZWN0JywgZnVuY3Rpb24gKCkge1xuICAgICAgc29ja2V0LmlkID0gc2VsZi5lbmdpbmUuaWQ7XG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5hdXRvQ29ubmVjdCkge1xuICAgICAgLy8gbWFudWFsbHkgY2FsbCBoZXJlIHNpbmNlIGNvbm5lY3RpbmcgZXZuZXQgaXMgZmlyZWQgYmVmb3JlIGxpc3RlbmluZ1xuICAgICAgb25Db25uZWN0aW5nKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25Db25uZWN0aW5nICgpIHtcbiAgICBpZiAoIX5pbmRleE9mKHNlbGYuY29ubmVjdGluZywgc29ja2V0KSkge1xuICAgICAgc2VsZi5jb25uZWN0aW5nLnB1c2goc29ja2V0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc29ja2V0O1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhIHNvY2tldCBjbG9zZS5cbiAqXG4gKiBAcGFyYW0ge1NvY2tldH0gc29ja2V0XG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChzb2NrZXQpIHtcbiAgdmFyIGluZGV4ID0gaW5kZXhPZih0aGlzLmNvbm5lY3RpbmcsIHNvY2tldCk7XG4gIGlmICh+aW5kZXgpIHRoaXMuY29ubmVjdGluZy5zcGxpY2UoaW5kZXgsIDEpO1xuICBpZiAodGhpcy5jb25uZWN0aW5nLmxlbmd0aCkgcmV0dXJuO1xuXG4gIHRoaXMuY2xvc2UoKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgZGVidWcoJ3dyaXRpbmcgcGFja2V0ICVqJywgcGFja2V0KTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAocGFja2V0LnF1ZXJ5ICYmIHBhY2tldC50eXBlID09PSAwKSBwYWNrZXQubnNwICs9ICc/JyArIHBhY2tldC5xdWVyeTtcblxuICBpZiAoIXNlbGYuZW5jb2RpbmcpIHtcbiAgICAvLyBlbmNvZGUsIHRoZW4gd3JpdGUgdG8gZW5naW5lIHdpdGggcmVzdWx0XG4gICAgc2VsZi5lbmNvZGluZyA9IHRydWU7XG4gICAgdGhpcy5lbmNvZGVyLmVuY29kZShwYWNrZXQsIGZ1bmN0aW9uIChlbmNvZGVkUGFja2V0cykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmNvZGVkUGFja2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzZWxmLmVuZ2luZS53cml0ZShlbmNvZGVkUGFja2V0c1tpXSwgcGFja2V0Lm9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgc2VsZi5lbmNvZGluZyA9IGZhbHNlO1xuICAgICAgc2VsZi5wcm9jZXNzUGFja2V0UXVldWUoKTtcbiAgICB9KTtcbiAgfSBlbHNlIHsgLy8gYWRkIHBhY2tldCB0byB0aGUgcXVldWVcbiAgICBzZWxmLnBhY2tldEJ1ZmZlci5wdXNoKHBhY2tldCk7XG4gIH1cbn07XG5cbi8qKlxuICogSWYgcGFja2V0IGJ1ZmZlciBpcyBub24tZW1wdHksIGJlZ2lucyBlbmNvZGluZyB0aGVcbiAqIG5leHQgcGFja2V0IGluIGxpbmUuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucHJvY2Vzc1BhY2tldFF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5wYWNrZXRCdWZmZXIubGVuZ3RoID4gMCAmJiAhdGhpcy5lbmNvZGluZykge1xuICAgIHZhciBwYWNrID0gdGhpcy5wYWNrZXRCdWZmZXIuc2hpZnQoKTtcbiAgICB0aGlzLnBhY2tldChwYWNrKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhbiB1cCB0cmFuc3BvcnQgc3Vic2NyaXB0aW9ucyBhbmQgcGFja2V0IGJ1ZmZlci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5jbGVhbnVwID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygnY2xlYW51cCcpO1xuXG4gIHZhciBzdWJzTGVuZ3RoID0gdGhpcy5zdWJzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJzTGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc3ViID0gdGhpcy5zdWJzLnNoaWZ0KCk7XG4gICAgc3ViLmRlc3Ryb3koKTtcbiAgfVxuXG4gIHRoaXMucGFja2V0QnVmZmVyID0gW107XG4gIHRoaXMuZW5jb2RpbmcgPSBmYWxzZTtcbiAgdGhpcy5sYXN0UGluZyA9IG51bGw7XG5cbiAgdGhpcy5kZWNvZGVyLmRlc3Ryb3koKTtcbn07XG5cbi8qKlxuICogQ2xvc2UgdGhlIGN1cnJlbnQgc29ja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLmNsb3NlID1cbk1hbmFnZXIucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdkaXNjb25uZWN0Jyk7XG4gIHRoaXMuc2tpcFJlY29ubmVjdCA9IHRydWU7XG4gIHRoaXMucmVjb25uZWN0aW5nID0gZmFsc2U7XG4gIGlmICgnb3BlbmluZycgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIC8vIGBvbmNsb3NlYCB3aWxsIG5vdCBmaXJlIGJlY2F1c2VcbiAgICAvLyBhbiBvcGVuIGV2ZW50IG5ldmVyIGhhcHBlbmVkXG4gICAgdGhpcy5jbGVhbnVwKCk7XG4gIH1cbiAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICBpZiAodGhpcy5lbmdpbmUpIHRoaXMuZW5naW5lLmNsb3NlKCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGVuZ2luZSBjbG9zZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbmNsb3NlID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICBkZWJ1Zygnb25jbG9zZScpO1xuXG4gIHRoaXMuY2xlYW51cCgpO1xuICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gIHRoaXMuZW1pdCgnY2xvc2UnLCByZWFzb24pO1xuXG4gIGlmICh0aGlzLl9yZWNvbm5lY3Rpb24gJiYgIXRoaXMuc2tpcFJlY29ubmVjdCkge1xuICAgIHRoaXMucmVjb25uZWN0KCk7XG4gIH1cbn07XG5cbi8qKlxuICogQXR0ZW1wdCBhIHJlY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnJlY29ubmVjdGluZyB8fCB0aGlzLnNraXBSZWNvbm5lY3QpIHJldHVybiB0aGlzO1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAodGhpcy5iYWNrb2ZmLmF0dGVtcHRzID49IHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzKSB7XG4gICAgZGVidWcoJ3JlY29ubmVjdCBmYWlsZWQnKTtcbiAgICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgICB0aGlzLmVtaXRBbGwoJ3JlY29ubmVjdF9mYWlsZWQnKTtcbiAgICB0aGlzLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHZhciBkZWxheSA9IHRoaXMuYmFja29mZi5kdXJhdGlvbigpO1xuICAgIGRlYnVnKCd3aWxsIHdhaXQgJWRtcyBiZWZvcmUgcmVjb25uZWN0IGF0dGVtcHQnLCBkZWxheSk7XG5cbiAgICB0aGlzLnJlY29ubmVjdGluZyA9IHRydWU7XG4gICAgdmFyIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2VsZi5za2lwUmVjb25uZWN0KSByZXR1cm47XG5cbiAgICAgIGRlYnVnKCdhdHRlbXB0aW5nIHJlY29ubmVjdCcpO1xuICAgICAgc2VsZi5lbWl0QWxsKCdyZWNvbm5lY3RfYXR0ZW1wdCcsIHNlbGYuYmFja29mZi5hdHRlbXB0cyk7XG4gICAgICBzZWxmLmVtaXRBbGwoJ3JlY29ubmVjdGluZycsIHNlbGYuYmFja29mZi5hdHRlbXB0cyk7XG5cbiAgICAgIC8vIGNoZWNrIGFnYWluIGZvciB0aGUgY2FzZSBzb2NrZXQgY2xvc2VkIGluIGFib3ZlIGV2ZW50c1xuICAgICAgaWYgKHNlbGYuc2tpcFJlY29ubmVjdCkgcmV0dXJuO1xuXG4gICAgICBzZWxmLm9wZW4oZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgZGVidWcoJ3JlY29ubmVjdCBhdHRlbXB0IGVycm9yJyk7XG4gICAgICAgICAgc2VsZi5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICBzZWxmLnJlY29ubmVjdCgpO1xuICAgICAgICAgIHNlbGYuZW1pdEFsbCgncmVjb25uZWN0X2Vycm9yJywgZXJyLmRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlYnVnKCdyZWNvbm5lY3Qgc3VjY2VzcycpO1xuICAgICAgICAgIHNlbGYub25yZWNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSwgZGVsYXkpO1xuXG4gICAgdGhpcy5zdWJzLnB1c2goe1xuICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHN1Y2Nlc3NmdWwgcmVjb25uZWN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9ucmVjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYXR0ZW1wdCA9IHRoaXMuYmFja29mZi5hdHRlbXB0cztcbiAgdGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gIHRoaXMudXBkYXRlU29ja2V0SWRzKCk7XG4gIHRoaXMuZW1pdEFsbCgncmVjb25uZWN0JywgYXR0ZW1wdCk7XG59O1xuIiwiXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gb247XG5cbi8qKlxuICogSGVscGVyIGZvciBzdWJzY3JpcHRpb25zLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEV2ZW50RW1pdHRlcn0gb2JqIHdpdGggYEVtaXR0ZXJgIG1peGluIG9yIGBFdmVudEVtaXR0ZXJgXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gb24gKG9iaiwgZXYsIGZuKSB7XG4gIG9iai5vbihldiwgZm4pO1xuICByZXR1cm4ge1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgIG9iai5yZW1vdmVMaXN0ZW5lcihldiwgZm4pO1xuICAgIH1cbiAgfTtcbn1cbiIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBwYXJzZXIgPSByZXF1aXJlKCdzb2NrZXQuaW8tcGFyc2VyJyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgdG9BcnJheSA9IHJlcXVpcmUoJ3RvLWFycmF5Jyk7XG52YXIgb24gPSByZXF1aXJlKCcuL29uJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1iaW5kJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NrZXQuaW8tY2xpZW50OnNvY2tldCcpO1xudmFyIGhhc0JpbiA9IHJlcXVpcmUoJ2hhcy1iaW5hcnknKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBTb2NrZXQ7XG5cbi8qKlxuICogSW50ZXJuYWwgZXZlbnRzIChibGFja2xpc3RlZCkuXG4gKiBUaGVzZSBldmVudHMgY2FuJ3QgYmUgZW1pdHRlZCBieSB0aGUgdXNlci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG52YXIgZXZlbnRzID0ge1xuICBjb25uZWN0OiAxLFxuICBjb25uZWN0X2Vycm9yOiAxLFxuICBjb25uZWN0X3RpbWVvdXQ6IDEsXG4gIGNvbm5lY3Rpbmc6IDEsXG4gIGRpc2Nvbm5lY3Q6IDEsXG4gIGVycm9yOiAxLFxuICByZWNvbm5lY3Q6IDEsXG4gIHJlY29ubmVjdF9hdHRlbXB0OiAxLFxuICByZWNvbm5lY3RfZmFpbGVkOiAxLFxuICByZWNvbm5lY3RfZXJyb3I6IDEsXG4gIHJlY29ubmVjdGluZzogMSxcbiAgcGluZzogMSxcbiAgcG9uZzogMVxufTtcblxuLyoqXG4gKiBTaG9ydGN1dCB0byBgRW1pdHRlciNlbWl0YC5cbiAqL1xuXG52YXIgZW1pdCA9IEVtaXR0ZXIucHJvdG90eXBlLmVtaXQ7XG5cbi8qKlxuICogYFNvY2tldGAgY29uc3RydWN0b3IuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBTb2NrZXQgKGlvLCBuc3AsIG9wdHMpIHtcbiAgdGhpcy5pbyA9IGlvO1xuICB0aGlzLm5zcCA9IG5zcDtcbiAgdGhpcy5qc29uID0gdGhpczsgLy8gY29tcGF0XG4gIHRoaXMuaWRzID0gMDtcbiAgdGhpcy5hY2tzID0ge307XG4gIHRoaXMucmVjZWl2ZUJ1ZmZlciA9IFtdO1xuICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcbiAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgdGhpcy5kaXNjb25uZWN0ZWQgPSB0cnVlO1xuICBpZiAob3B0cyAmJiBvcHRzLnF1ZXJ5KSB7XG4gICAgdGhpcy5xdWVyeSA9IG9wdHMucXVlcnk7XG4gIH1cbiAgaWYgKHRoaXMuaW8uYXV0b0Nvbm5lY3QpIHRoaXMub3BlbigpO1xufVxuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihTb2NrZXQucHJvdG90eXBlKTtcblxuLyoqXG4gKiBTdWJzY3JpYmUgdG8gb3BlbiwgY2xvc2UgYW5kIHBhY2tldCBldmVudHNcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnN1YkV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuc3VicykgcmV0dXJuO1xuXG4gIHZhciBpbyA9IHRoaXMuaW87XG4gIHRoaXMuc3VicyA9IFtcbiAgICBvbihpbywgJ29wZW4nLCBiaW5kKHRoaXMsICdvbm9wZW4nKSksXG4gICAgb24oaW8sICdwYWNrZXQnLCBiaW5kKHRoaXMsICdvbnBhY2tldCcpKSxcbiAgICBvbihpbywgJ2Nsb3NlJywgYmluZCh0aGlzLCAnb25jbG9zZScpKVxuICBdO1xufTtcblxuLyoqXG4gKiBcIk9wZW5zXCIgdGhlIHNvY2tldC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUub3BlbiA9XG5Tb2NrZXQucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmNvbm5lY3RlZCkgcmV0dXJuIHRoaXM7XG5cbiAgdGhpcy5zdWJFdmVudHMoKTtcbiAgdGhpcy5pby5vcGVuKCk7IC8vIGVuc3VyZSBvcGVuXG4gIGlmICgnb3BlbicgPT09IHRoaXMuaW8ucmVhZHlTdGF0ZSkgdGhpcy5vbm9wZW4oKTtcbiAgdGhpcy5lbWl0KCdjb25uZWN0aW5nJyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZW5kcyBhIGBtZXNzYWdlYCBldmVudC5cbiAqXG4gKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcbiAgYXJncy51bnNoaWZ0KCdtZXNzYWdlJyk7XG4gIHRoaXMuZW1pdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE92ZXJyaWRlIGBlbWl0YC5cbiAqIElmIHRoZSBldmVudCBpcyBpbiBgZXZlbnRzYCwgaXQncyBlbWl0dGVkIG5vcm1hbGx5LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBuYW1lXG4gKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gKGV2KSB7XG4gIGlmIChldmVudHMuaGFzT3duUHJvcGVydHkoZXYpKSB7XG4gICAgZW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cyk7XG4gIHZhciBwYXJzZXJUeXBlID0gcGFyc2VyLkVWRU5UOyAvLyBkZWZhdWx0XG4gIGlmIChoYXNCaW4oYXJncykpIHsgcGFyc2VyVHlwZSA9IHBhcnNlci5CSU5BUllfRVZFTlQ7IH0gLy8gYmluYXJ5XG4gIHZhciBwYWNrZXQgPSB7IHR5cGU6IHBhcnNlclR5cGUsIGRhdGE6IGFyZ3MgfTtcblxuICBwYWNrZXQub3B0aW9ucyA9IHt9O1xuICBwYWNrZXQub3B0aW9ucy5jb21wcmVzcyA9ICF0aGlzLmZsYWdzIHx8IGZhbHNlICE9PSB0aGlzLmZsYWdzLmNvbXByZXNzO1xuXG4gIC8vIGV2ZW50IGFjayBjYWxsYmFja1xuICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSkge1xuICAgIGRlYnVnKCdlbWl0dGluZyBwYWNrZXQgd2l0aCBhY2sgaWQgJWQnLCB0aGlzLmlkcyk7XG4gICAgdGhpcy5hY2tzW3RoaXMuaWRzXSA9IGFyZ3MucG9wKCk7XG4gICAgcGFja2V0LmlkID0gdGhpcy5pZHMrKztcbiAgfVxuXG4gIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgIHRoaXMucGFja2V0KHBhY2tldCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5zZW5kQnVmZmVyLnB1c2gocGFja2V0KTtcbiAgfVxuXG4gIGRlbGV0ZSB0aGlzLmZsYWdzO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZW5kcyBhIHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgcGFja2V0Lm5zcCA9IHRoaXMubnNwO1xuICB0aGlzLmlvLnBhY2tldChwYWNrZXQpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBlbmdpbmUgYG9wZW5gLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25vcGVuID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygndHJhbnNwb3J0IGlzIG9wZW4gLSBjb25uZWN0aW5nJyk7XG5cbiAgLy8gd3JpdGUgY29ubmVjdCBwYWNrZXQgaWYgbmVjZXNzYXJ5XG4gIGlmICgnLycgIT09IHRoaXMubnNwKSB7XG4gICAgaWYgKHRoaXMucXVlcnkpIHtcbiAgICAgIHRoaXMucGFja2V0KHt0eXBlOiBwYXJzZXIuQ09OTkVDVCwgcXVlcnk6IHRoaXMucXVlcnl9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wYWNrZXQoe3R5cGU6IHBhcnNlci5DT05ORUNUfSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGVuZ2luZSBgY2xvc2VgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSByZWFzb25cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25jbG9zZSA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgZGVidWcoJ2Nsb3NlICglcyknLCByZWFzb24pO1xuICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICB0aGlzLmRpc2Nvbm5lY3RlZCA9IHRydWU7XG4gIGRlbGV0ZSB0aGlzLmlkO1xuICB0aGlzLmVtaXQoJ2Rpc2Nvbm5lY3QnLCByZWFzb24pO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2l0aCBzb2NrZXQgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25wYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIGlmIChwYWNrZXQubnNwICE9PSB0aGlzLm5zcCkgcmV0dXJuO1xuXG4gIHN3aXRjaCAocGFja2V0LnR5cGUpIHtcbiAgICBjYXNlIHBhcnNlci5DT05ORUNUOlxuICAgICAgdGhpcy5vbmNvbm5lY3QoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuRVZFTlQ6XG4gICAgICB0aGlzLm9uZXZlbnQocGFja2V0KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuQklOQVJZX0VWRU5UOlxuICAgICAgdGhpcy5vbmV2ZW50KHBhY2tldCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkFDSzpcbiAgICAgIHRoaXMub25hY2socGFja2V0KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuQklOQVJZX0FDSzpcbiAgICAgIHRoaXMub25hY2socGFja2V0KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuRElTQ09OTkVDVDpcbiAgICAgIHRoaXMub25kaXNjb25uZWN0KCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkVSUk9SOlxuICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIHBhY2tldC5kYXRhKTtcbiAgICAgIGJyZWFrO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGEgc2VydmVyIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25ldmVudCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgdmFyIGFyZ3MgPSBwYWNrZXQuZGF0YSB8fCBbXTtcbiAgZGVidWcoJ2VtaXR0aW5nIGV2ZW50ICVqJywgYXJncyk7XG5cbiAgaWYgKG51bGwgIT0gcGFja2V0LmlkKSB7XG4gICAgZGVidWcoJ2F0dGFjaGluZyBhY2sgY2FsbGJhY2sgdG8gZXZlbnQnKTtcbiAgICBhcmdzLnB1c2godGhpcy5hY2socGFja2V0LmlkKSk7XG4gIH1cblxuICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICBlbWl0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucmVjZWl2ZUJ1ZmZlci5wdXNoKGFyZ3MpO1xuICB9XG59O1xuXG4vKipcbiAqIFByb2R1Y2VzIGFuIGFjayBjYWxsYmFjayB0byBlbWl0IHdpdGggYW4gZXZlbnQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5hY2sgPSBmdW5jdGlvbiAoaWQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgc2VudCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIC8vIHByZXZlbnQgZG91YmxlIGNhbGxiYWNrc1xuICAgIGlmIChzZW50KSByZXR1cm47XG4gICAgc2VudCA9IHRydWU7XG4gICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cyk7XG4gICAgZGVidWcoJ3NlbmRpbmcgYWNrICVqJywgYXJncyk7XG5cbiAgICB2YXIgdHlwZSA9IGhhc0JpbihhcmdzKSA/IHBhcnNlci5CSU5BUllfQUNLIDogcGFyc2VyLkFDSztcbiAgICBzZWxmLnBhY2tldCh7XG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgaWQ6IGlkLFxuICAgICAgZGF0YTogYXJnc1xuICAgIH0pO1xuICB9O1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhIHNlcnZlciBhY2tub3dsZWdlbWVudC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uYWNrID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICB2YXIgYWNrID0gdGhpcy5hY2tzW3BhY2tldC5pZF07XG4gIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgYWNrKSB7XG4gICAgZGVidWcoJ2NhbGxpbmcgYWNrICVzIHdpdGggJWonLCBwYWNrZXQuaWQsIHBhY2tldC5kYXRhKTtcbiAgICBhY2suYXBwbHkodGhpcywgcGFja2V0LmRhdGEpO1xuICAgIGRlbGV0ZSB0aGlzLmFja3NbcGFja2V0LmlkXTtcbiAgfSBlbHNlIHtcbiAgICBkZWJ1ZygnYmFkIGFjayAlcycsIHBhY2tldC5pZCk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gc2VydmVyIGNvbm5lY3QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuY29ubmVjdGVkID0gdHJ1ZTtcbiAgdGhpcy5kaXNjb25uZWN0ZWQgPSBmYWxzZTtcbiAgdGhpcy5lbWl0KCdjb25uZWN0Jyk7XG4gIHRoaXMuZW1pdEJ1ZmZlcmVkKCk7XG59O1xuXG4vKipcbiAqIEVtaXQgYnVmZmVyZWQgZXZlbnRzIChyZWNlaXZlZCBhbmQgZW1pdHRlZCkuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5lbWl0QnVmZmVyZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5yZWNlaXZlQnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgZW1pdC5hcHBseSh0aGlzLCB0aGlzLnJlY2VpdmVCdWZmZXJbaV0pO1xuICB9XG4gIHRoaXMucmVjZWl2ZUJ1ZmZlciA9IFtdO1xuXG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLnNlbmRCdWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLnBhY2tldCh0aGlzLnNlbmRCdWZmZXJbaV0pO1xuICB9XG4gIHRoaXMuc2VuZEJ1ZmZlciA9IFtdO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzZXJ2ZXIgZGlzY29ubmVjdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ3NlcnZlciBkaXNjb25uZWN0ICglcyknLCB0aGlzLm5zcCk7XG4gIHRoaXMuZGVzdHJveSgpO1xuICB0aGlzLm9uY2xvc2UoJ2lvIHNlcnZlciBkaXNjb25uZWN0Jyk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGZvcmNlZCBjbGllbnQvc2VydmVyIHNpZGUgZGlzY29ubmVjdGlvbnMsXG4gKiB0aGlzIG1ldGhvZCBlbnN1cmVzIHRoZSBtYW5hZ2VyIHN0b3BzIHRyYWNraW5nIHVzIGFuZFxuICogdGhhdCByZWNvbm5lY3Rpb25zIGRvbid0IGdldCB0cmlnZ2VyZWQgZm9yIHRoaXMuXG4gKlxuICogQGFwaSBwcml2YXRlLlxuICovXG5cblNvY2tldC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuc3Vicykge1xuICAgIC8vIGNsZWFuIHN1YnNjcmlwdGlvbnMgdG8gYXZvaWQgcmVjb25uZWN0aW9uc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zdWJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLnN1YnNbaV0uZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLnN1YnMgPSBudWxsO1xuICB9XG5cbiAgdGhpcy5pby5kZXN0cm95KHRoaXMpO1xufTtcblxuLyoqXG4gKiBEaXNjb25uZWN0cyB0aGUgc29ja2V0IG1hbnVhbGx5LlxuICpcbiAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmNsb3NlID1cblNvY2tldC5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgZGVidWcoJ3BlcmZvcm1pbmcgZGlzY29ubmVjdCAoJXMpJywgdGhpcy5uc3ApO1xuICAgIHRoaXMucGFja2V0KHsgdHlwZTogcGFyc2VyLkRJU0NPTk5FQ1QgfSk7XG4gIH1cblxuICAvLyByZW1vdmUgc29ja2V0IGZyb20gcG9vbFxuICB0aGlzLmRlc3Ryb3koKTtcblxuICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICAvLyBmaXJlIGV2ZW50c1xuICAgIHRoaXMub25jbG9zZSgnaW8gY2xpZW50IGRpc2Nvbm5lY3QnKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgY29tcHJlc3MgZmxhZy5cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlmIGB0cnVlYCwgY29tcHJlc3NlcyB0aGUgc2VuZGluZyBkYXRhXG4gKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5jb21wcmVzcyA9IGZ1bmN0aW9uIChjb21wcmVzcykge1xuICB0aGlzLmZsYWdzID0gdGhpcy5mbGFncyB8fCB7fTtcbiAgdGhpcy5mbGFncy5jb21wcmVzcyA9IGNvbXByZXNzO1xuICByZXR1cm4gdGhpcztcbn07XG4iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgcGFyc2V1cmkgPSByZXF1aXJlKCdwYXJzZXVyaScpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2V0LmlvLWNsaWVudDp1cmwnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHVybDtcblxuLyoqXG4gKiBVUkwgcGFyc2VyLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7T2JqZWN0fSBBbiBvYmplY3QgbWVhbnQgdG8gbWltaWMgd2luZG93LmxvY2F0aW9uLlxuICogICAgICAgICAgICAgICAgIERlZmF1bHRzIHRvIHdpbmRvdy5sb2NhdGlvbi5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gdXJsICh1cmksIGxvYykge1xuICB2YXIgb2JqID0gdXJpO1xuXG4gIC8vIGRlZmF1bHQgdG8gd2luZG93LmxvY2F0aW9uXG4gIGxvYyA9IGxvYyB8fCBnbG9iYWwubG9jYXRpb247XG4gIGlmIChudWxsID09IHVyaSkgdXJpID0gbG9jLnByb3RvY29sICsgJy8vJyArIGxvYy5ob3N0O1xuXG4gIC8vIHJlbGF0aXZlIHBhdGggc3VwcG9ydFxuICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB1cmkpIHtcbiAgICBpZiAoJy8nID09PSB1cmkuY2hhckF0KDApKSB7XG4gICAgICBpZiAoJy8nID09PSB1cmkuY2hhckF0KDEpKSB7XG4gICAgICAgIHVyaSA9IGxvYy5wcm90b2NvbCArIHVyaTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVyaSA9IGxvYy5ob3N0ICsgdXJpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghL14oaHR0cHM/fHdzcz8pOlxcL1xcLy8udGVzdCh1cmkpKSB7XG4gICAgICBkZWJ1ZygncHJvdG9jb2wtbGVzcyB1cmwgJXMnLCB1cmkpO1xuICAgICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgbG9jKSB7XG4gICAgICAgIHVyaSA9IGxvYy5wcm90b2NvbCArICcvLycgKyB1cmk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cmkgPSAnaHR0cHM6Ly8nICsgdXJpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHBhcnNlXG4gICAgZGVidWcoJ3BhcnNlICVzJywgdXJpKTtcbiAgICBvYmogPSBwYXJzZXVyaSh1cmkpO1xuICB9XG5cbiAgLy8gbWFrZSBzdXJlIHdlIHRyZWF0IGBsb2NhbGhvc3Q6ODBgIGFuZCBgbG9jYWxob3N0YCBlcXVhbGx5XG4gIGlmICghb2JqLnBvcnQpIHtcbiAgICBpZiAoL14oaHR0cHx3cykkLy50ZXN0KG9iai5wcm90b2NvbCkpIHtcbiAgICAgIG9iai5wb3J0ID0gJzgwJztcbiAgICB9IGVsc2UgaWYgKC9eKGh0dHB8d3MpcyQvLnRlc3Qob2JqLnByb3RvY29sKSkge1xuICAgICAgb2JqLnBvcnQgPSAnNDQzJztcbiAgICB9XG4gIH1cblxuICBvYmoucGF0aCA9IG9iai5wYXRoIHx8ICcvJztcblxuICB2YXIgaXB2NiA9IG9iai5ob3N0LmluZGV4T2YoJzonKSAhPT0gLTE7XG4gIHZhciBob3N0ID0gaXB2NiA/ICdbJyArIG9iai5ob3N0ICsgJ10nIDogb2JqLmhvc3Q7XG5cbiAgLy8gZGVmaW5lIHVuaXF1ZSBpZFxuICBvYmouaWQgPSBvYmoucHJvdG9jb2wgKyAnOi8vJyArIGhvc3QgKyAnOicgKyBvYmoucG9ydDtcbiAgLy8gZGVmaW5lIGhyZWZcbiAgb2JqLmhyZWYgPSBvYmoucHJvdG9jb2wgKyAnOi8vJyArIGhvc3QgKyAobG9jICYmIGxvYy5wb3J0ID09PSBvYmoucG9ydCA/ICcnIDogKCc6JyArIG9iai5wb3J0KSk7XG5cbiAgcmV0dXJuIG9iajtcbn1cbiIsIlxuLyoqXG4gKiBFeHBvc2UgYEJhY2tvZmZgLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gQmFja29mZjtcblxuLyoqXG4gKiBJbml0aWFsaXplIGJhY2tvZmYgdGltZXIgd2l0aCBgb3B0c2AuXG4gKlxuICogLSBgbWluYCBpbml0aWFsIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIFsxMDBdXG4gKiAtIGBtYXhgIG1heCB0aW1lb3V0IFsxMDAwMF1cbiAqIC0gYGppdHRlcmAgWzBdXG4gKiAtIGBmYWN0b3JgIFsyXVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEJhY2tvZmYob3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgdGhpcy5tcyA9IG9wdHMubWluIHx8IDEwMDtcbiAgdGhpcy5tYXggPSBvcHRzLm1heCB8fCAxMDAwMDtcbiAgdGhpcy5mYWN0b3IgPSBvcHRzLmZhY3RvciB8fCAyO1xuICB0aGlzLmppdHRlciA9IG9wdHMuaml0dGVyID4gMCAmJiBvcHRzLmppdHRlciA8PSAxID8gb3B0cy5qaXR0ZXIgOiAwO1xuICB0aGlzLmF0dGVtcHRzID0gMDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGJhY2tvZmYgZHVyYXRpb24uXG4gKlxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5kdXJhdGlvbiA9IGZ1bmN0aW9uKCl7XG4gIHZhciBtcyA9IHRoaXMubXMgKiBNYXRoLnBvdyh0aGlzLmZhY3RvciwgdGhpcy5hdHRlbXB0cysrKTtcbiAgaWYgKHRoaXMuaml0dGVyKSB7XG4gICAgdmFyIHJhbmQgPSAgTWF0aC5yYW5kb20oKTtcbiAgICB2YXIgZGV2aWF0aW9uID0gTWF0aC5mbG9vcihyYW5kICogdGhpcy5qaXR0ZXIgKiBtcyk7XG4gICAgbXMgPSAoTWF0aC5mbG9vcihyYW5kICogMTApICYgMSkgPT0gMCAgPyBtcyAtIGRldmlhdGlvbiA6IG1zICsgZGV2aWF0aW9uO1xuICB9XG4gIHJldHVybiBNYXRoLm1pbihtcywgdGhpcy5tYXgpIHwgMDtcbn07XG5cbi8qKlxuICogUmVzZXQgdGhlIG51bWJlciBvZiBhdHRlbXB0cy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5hdHRlbXB0cyA9IDA7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgbWluaW11bSBkdXJhdGlvblxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUuc2V0TWluID0gZnVuY3Rpb24obWluKXtcbiAgdGhpcy5tcyA9IG1pbjtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBtYXhpbXVtIGR1cmF0aW9uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5zZXRNYXggPSBmdW5jdGlvbihtYXgpe1xuICB0aGlzLm1heCA9IG1heDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBqaXR0ZXJcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLnNldEppdHRlciA9IGZ1bmN0aW9uKGppdHRlcil7XG4gIHRoaXMuaml0dGVyID0gaml0dGVyO1xufTtcblxuIiwiLyoqXG4gKiBTbGljZSByZWZlcmVuY2UuXG4gKi9cblxudmFyIHNsaWNlID0gW10uc2xpY2U7XG5cbi8qKlxuICogQmluZCBgb2JqYCB0byBgZm5gLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7RnVuY3Rpb258U3RyaW5nfSBmbiBvciBzdHJpbmdcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgZm4pe1xuICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIGZuKSBmbiA9IG9ialtmbl07XG4gIGlmICgnZnVuY3Rpb24nICE9IHR5cGVvZiBmbikgdGhyb3cgbmV3IEVycm9yKCdiaW5kKCkgcmVxdWlyZXMgYSBmdW5jdGlvbicpO1xuICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIGZuLmFwcGx5KG9iaiwgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gIH1cbn07XG4iLCJcclxuLyoqXHJcbiAqIEV4cG9zZSBgRW1pdHRlcmAuXHJcbiAqL1xyXG5cclxuaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgbW9kdWxlLmV4cG9ydHMgPSBFbWl0dGVyO1xyXG59XHJcblxyXG4vKipcclxuICogSW5pdGlhbGl6ZSBhIG5ldyBgRW1pdHRlcmAuXHJcbiAqXHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gRW1pdHRlcihvYmopIHtcclxuICBpZiAob2JqKSByZXR1cm4gbWl4aW4ob2JqKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBNaXhpbiB0aGUgZW1pdHRlciBwcm9wZXJ0aWVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXHJcbiAqIEByZXR1cm4ge09iamVjdH1cclxuICogQGFwaSBwcml2YXRlXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gbWl4aW4ob2JqKSB7XHJcbiAgZm9yICh2YXIga2V5IGluIEVtaXR0ZXIucHJvdG90eXBlKSB7XHJcbiAgICBvYmpba2V5XSA9IEVtaXR0ZXIucHJvdG90eXBlW2tleV07XHJcbiAgfVxyXG4gIHJldHVybiBvYmo7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBMaXN0ZW4gb24gdGhlIGdpdmVuIGBldmVudGAgd2l0aCBgZm5gLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5vbiA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuICAodGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW10pXHJcbiAgICAucHVzaChmbik7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogQWRkcyBhbiBgZXZlbnRgIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBpbnZva2VkIGEgc2luZ2xlXHJcbiAqIHRpbWUgdGhlbiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihldmVudCwgZm4pe1xyXG4gIGZ1bmN0aW9uIG9uKCkge1xyXG4gICAgdGhpcy5vZmYoZXZlbnQsIG9uKTtcclxuICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgfVxyXG5cclxuICBvbi5mbiA9IGZuO1xyXG4gIHRoaXMub24oZXZlbnQsIG9uKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZW1vdmUgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBgZXZlbnRgIG9yIGFsbFxyXG4gKiByZWdpc3RlcmVkIGNhbGxiYWNrcy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUub2ZmID1cclxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcblxyXG4gIC8vIGFsbFxyXG4gIGlmICgwID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvLyBzcGVjaWZpYyBldmVudFxyXG4gIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xyXG4gIGlmICghY2FsbGJhY2tzKSByZXR1cm4gdGhpcztcclxuXHJcbiAgLy8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xyXG4gIGlmICgxID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvLyByZW1vdmUgc3BlY2lmaWMgaGFuZGxlclxyXG4gIHZhciBjYjtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xyXG4gICAgY2IgPSBjYWxsYmFja3NbaV07XHJcbiAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xyXG4gICAgICBjYWxsYmFja3Muc3BsaWNlKGksIDEpO1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogRW1pdCBgZXZlbnRgIHdpdGggdGhlIGdpdmVuIGFyZ3MuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge01peGVkfSAuLi5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oZXZlbnQpe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxyXG4gICAgLCBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xyXG5cclxuICBpZiAoY2FsbGJhY2tzKSB7XHJcbiAgICBjYWxsYmFja3MgPSBjYWxsYmFja3Muc2xpY2UoMCk7XHJcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XHJcbiAgICAgIGNhbGxiYWNrc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybiBhcnJheSBvZiBjYWxsYmFja3MgZm9yIGBldmVudGAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcmV0dXJuIHtBcnJheX1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG4gIHJldHVybiB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIHRoaXMgZW1pdHRlciBoYXMgYGV2ZW50YCBoYW5kbGVycy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUuaGFzTGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xyXG4gIHJldHVybiAhISB0aGlzLmxpc3RlbmVycyhldmVudCkubGVuZ3RoO1xyXG59O1xyXG4iLCJcbi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2RlYnVnJyk7XG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZVxuICAgICAgICAgICAgICAgJiYgJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZS5zdG9yYWdlXG4gICAgICAgICAgICAgICAgICA/IGNocm9tZS5zdG9yYWdlLmxvY2FsXG4gICAgICAgICAgICAgICAgICA6IGxvY2Fsc3RvcmFnZSgpO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFtcbiAgJ2xpZ2h0c2VhZ3JlZW4nLFxuICAnZm9yZXN0Z3JlZW4nLFxuICAnZ29sZGVucm9kJyxcbiAgJ2RvZGdlcmJsdWUnLFxuICAnZGFya29yY2hpZCcsXG4gICdjcmltc29uJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG4gIC8vIGlzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG4gIC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXG4gIHJldHVybiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiAnV2Via2l0QXBwZWFyYW5jZScgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlKSB8fFxuICAgIC8vIGlzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcbiAgICAod2luZG93LmNvbnNvbGUgJiYgKGNvbnNvbGUuZmlyZWJ1ZyB8fCAoY29uc29sZS5leGNlcHRpb24gJiYgY29uc29sZS50YWJsZSkpKSB8fFxuICAgIC8vIGlzIGZpcmVmb3ggPj0gdjMxP1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuICAgIChuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSk7XG59XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24odikge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVyci5tZXNzYWdlO1xuICB9XG59O1xuXG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncygpIHtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciB1c2VDb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblxuICBhcmdzWzBdID0gKHVzZUNvbG9ycyA/ICclYycgOiAnJylcbiAgICArIHRoaXMubmFtZXNwYWNlXG4gICAgKyAodXNlQ29sb3JzID8gJyAlYycgOiAnICcpXG4gICAgKyBhcmdzWzBdXG4gICAgKyAodXNlQ29sb3JzID8gJyVjICcgOiAnICcpXG4gICAgKyAnKycgKyBleHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cbiAgaWYgKCF1c2VDb2xvcnMpIHJldHVybiBhcmdzO1xuXG4gIHZhciBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcbiAgYXJncyA9IFthcmdzWzBdLCBjLCAnY29sb3I6IGluaGVyaXQnXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncywgMSkpO1xuXG4gIC8vIHRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG4gIC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cbiAgLy8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0QyA9IDA7XG4gIGFyZ3NbMF0ucmVwbGFjZSgvJVthLXolXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIGlmICgnJSUnID09PSBtYXRjaCkgcmV0dXJuO1xuICAgIGluZGV4Kys7XG4gICAgaWYgKCclYycgPT09IG1hdGNoKSB7XG4gICAgICAvLyB3ZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcbiAgICAgIC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG4gICAgICBsYXN0QyA9IGluZGV4O1xuICAgIH1cbiAgfSk7XG5cbiAgYXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xuICByZXR1cm4gYXJncztcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUubG9nYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBsb2coKSB7XG4gIC8vIHRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4LzksIHdoZXJlXG4gIC8vIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXG4gIHJldHVybiAnb2JqZWN0JyA9PT0gdHlwZW9mIGNvbnNvbGVcbiAgICAmJiBjb25zb2xlLmxvZ1xuICAgICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlLCBhcmd1bWVudHMpO1xufVxuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcbiAgdHJ5IHtcbiAgICBpZiAobnVsbCA9PSBuYW1lc3BhY2VzKSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLmRlYnVnID0gbmFtZXNwYWNlcztcbiAgICB9XG4gIH0gY2F0Y2goZSkge31cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2FkKCkge1xuICB2YXIgcjtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZXhwb3J0cy5zdG9yYWdlLmRlYnVnO1xuICB9IGNhdGNoKGUpIHt9XG5cbiAgLy8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuICBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuREVCVUc7XG4gIH1cbn1cblxuLyoqXG4gKiBFbmFibGUgbmFtZXNwYWNlcyBsaXN0ZWQgaW4gYGxvY2FsU3RvcmFnZS5kZWJ1Z2AgaW5pdGlhbGx5LlxuICovXG5cbmV4cG9ydHMuZW5hYmxlKGxvYWQoKSk7XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCl7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG4iLCJcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZGVidWcuZGVidWcgPSBkZWJ1ZztcbmV4cG9ydHMuY29lcmNlID0gY29lcmNlO1xuZXhwb3J0cy5kaXNhYmxlID0gZGlzYWJsZTtcbmV4cG9ydHMuZW5hYmxlID0gZW5hYmxlO1xuZXhwb3J0cy5lbmFibGVkID0gZW5hYmxlZDtcbmV4cG9ydHMuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuXG4vKipcbiAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuICovXG5cbmV4cG9ydHMubmFtZXMgPSBbXTtcbmV4cG9ydHMuc2tpcHMgPSBbXTtcblxuLyoqXG4gKiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG4gKlxuICogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXJjYXNlZCBsZXR0ZXIsIGkuZS4gXCJuXCIuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzID0ge307XG5cbi8qKlxuICogUHJldmlvdXNseSBhc3NpZ25lZCBjb2xvci5cbiAqL1xuXG52YXIgcHJldkNvbG9yID0gMDtcblxuLyoqXG4gKiBQcmV2aW91cyBsb2cgdGltZXN0YW1wLlxuICovXG5cbnZhciBwcmV2VGltZTtcblxuLyoqXG4gKiBTZWxlY3QgYSBjb2xvci5cbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzZWxlY3RDb2xvcigpIHtcbiAgcmV0dXJuIGV4cG9ydHMuY29sb3JzW3ByZXZDb2xvcisrICUgZXhwb3J0cy5jb2xvcnMubGVuZ3RoXTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGVidWcobmFtZXNwYWNlKSB7XG5cbiAgLy8gZGVmaW5lIHRoZSBgZGlzYWJsZWRgIHZlcnNpb25cbiAgZnVuY3Rpb24gZGlzYWJsZWQoKSB7XG4gIH1cbiAgZGlzYWJsZWQuZW5hYmxlZCA9IGZhbHNlO1xuXG4gIC8vIGRlZmluZSB0aGUgYGVuYWJsZWRgIHZlcnNpb25cbiAgZnVuY3Rpb24gZW5hYmxlZCgpIHtcblxuICAgIHZhciBzZWxmID0gZW5hYmxlZDtcblxuICAgIC8vIHNldCBgZGlmZmAgdGltZXN0YW1wXG4gICAgdmFyIGN1cnIgPSArbmV3IERhdGUoKTtcbiAgICB2YXIgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuICAgIHNlbGYuZGlmZiA9IG1zO1xuICAgIHNlbGYucHJldiA9IHByZXZUaW1lO1xuICAgIHNlbGYuY3VyciA9IGN1cnI7XG4gICAgcHJldlRpbWUgPSBjdXJyO1xuXG4gICAgLy8gYWRkIHRoZSBgY29sb3JgIGlmIG5vdCBzZXRcbiAgICBpZiAobnVsbCA9PSBzZWxmLnVzZUNvbG9ycykgc2VsZi51c2VDb2xvcnMgPSBleHBvcnRzLnVzZUNvbG9ycygpO1xuICAgIGlmIChudWxsID09IHNlbGYuY29sb3IgJiYgc2VsZi51c2VDb2xvcnMpIHNlbGYuY29sb3IgPSBzZWxlY3RDb2xvcigpO1xuXG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGFyZ3NbMF0gPSBleHBvcnRzLmNvZXJjZShhcmdzWzBdKTtcblxuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIGFyZ3NbMF0pIHtcbiAgICAgIC8vIGFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVvXG4gICAgICBhcmdzID0gWyclbyddLmNvbmNhdChhcmdzKTtcbiAgICB9XG5cbiAgICAvLyBhcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgYXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16JV0pL2csIGZ1bmN0aW9uKG1hdGNoLCBmb3JtYXQpIHtcbiAgICAgIC8vIGlmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcbiAgICAgIGlmIChtYXRjaCA9PT0gJyUlJykgcmV0dXJuIG1hdGNoO1xuICAgICAgaW5kZXgrKztcbiAgICAgIHZhciBmb3JtYXR0ZXIgPSBleHBvcnRzLmZvcm1hdHRlcnNbZm9ybWF0XTtcbiAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZm9ybWF0dGVyKSB7XG4gICAgICAgIHZhciB2YWwgPSBhcmdzW2luZGV4XTtcbiAgICAgICAgbWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG4gICAgICAgIC8vIG5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcbiAgICAgICAgYXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBpbmRleC0tO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuXG4gICAgLy8gYXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmdcbiAgICBhcmdzID0gZXhwb3J0cy5mb3JtYXRBcmdzLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXG4gICAgdmFyIGxvZ0ZuID0gZW5hYmxlZC5sb2cgfHwgZXhwb3J0cy5sb2cgfHwgY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbiAgICBsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgfVxuICBlbmFibGVkLmVuYWJsZWQgPSB0cnVlO1xuXG4gIHZhciBmbiA9IGV4cG9ydHMuZW5hYmxlZChuYW1lc3BhY2UpID8gZW5hYmxlZCA6IGRpc2FibGVkO1xuXG4gIGZuLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcblxuICByZXR1cm4gZm47XG59XG5cbi8qKlxuICogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuICogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuICBleHBvcnRzLnNhdmUobmFtZXNwYWNlcyk7XG5cbiAgdmFyIHNwbGl0ID0gKG5hbWVzcGFjZXMgfHwgJycpLnNwbGl0KC9bXFxzLF0rLyk7XG4gIHZhciBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmICghc3BsaXRbaV0pIGNvbnRpbnVlOyAvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuICAgIG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9bXFxcXF4kKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJykucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcbiAgICBpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG4gICAgICBleHBvcnRzLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkaXNhYmxlKCkge1xuICBleHBvcnRzLmVuYWJsZSgnJyk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcbiAgdmFyIGksIGxlbjtcbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ29lcmNlIGB2YWxgLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICogQHJldHVybiB7TWl4ZWR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb2VyY2UodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikgcmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcbiAgcmV0dXJuIHZhbDtcbn1cbiIsIi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDBcbnZhciBtID0gcyAqIDYwXG52YXIgaCA9IG0gKiA2MFxudmFyIGQgPSBoICogMjRcbnZhciB5ID0gZCAqIDM2NS4yNVxuXG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbFxuICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gcGFyc2UodmFsKVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzTmFOKHZhbCkgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/XG5cdFx0XHRmbXRMb25nKHZhbCkgOlxuXHRcdFx0Zm10U2hvcnQodmFsKVxuICB9XG4gIHRocm93IG5ldyBFcnJvcigndmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD0nICsgSlNPTi5zdHJpbmdpZnkodmFsKSlcbn1cblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9IFN0cmluZyhzdHIpXG4gIGlmIChzdHIubGVuZ3RoID4gMTAwMDApIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgbWF0Y2ggPSAvXigoPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKHN0cilcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSlcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKVxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHlcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkXG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoXG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtaW5zJzpcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtXG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzXG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG4gIGlmIChtcyA+PSBkKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJ1xuICB9XG4gIGlmIChtcyA+PSBoKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJ1xuICB9XG4gIGlmIChtcyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJ1xuICB9XG4gIGlmIChtcyA+PSBzKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJ1xuICB9XG4gIHJldHVybiBtcyArICdtcydcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgcmV0dXJuIHBsdXJhbChtcywgZCwgJ2RheScpIHx8XG4gICAgcGx1cmFsKG1zLCBoLCAnaG91cicpIHx8XG4gICAgcGx1cmFsKG1zLCBtLCAnbWludXRlJykgfHxcbiAgICBwbHVyYWwobXMsIHMsICdzZWNvbmQnKSB8fFxuICAgIG1zICsgJyBtcydcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG4sIG5hbWUpIHtcbiAgaWYgKG1zIDwgbikge1xuICAgIHJldHVyblxuICB9XG4gIGlmIChtcyA8IG4gKiAxLjUpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihtcyAvIG4pICsgJyAnICsgbmFtZVxuICB9XG4gIHJldHVybiBNYXRoLmNlaWwobXMgLyBuKSArICcgJyArIG5hbWUgKyAncydcbn1cbiIsIlxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9pbmRleCcpO1xuIiwiXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vc29ja2V0Jyk7XG5cbi8qKlxuICogRXhwb3J0cyBwYXJzZXJcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICpcbiAqL1xubW9kdWxlLmV4cG9ydHMucGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xuIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciB0cmFuc3BvcnRzID0gcmVxdWlyZSgnLi90cmFuc3BvcnRzL2luZGV4Jyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbmdpbmUuaW8tY2xpZW50OnNvY2tldCcpO1xudmFyIGluZGV4ID0gcmVxdWlyZSgnaW5kZXhvZicpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcbnZhciBwYXJzZXVyaSA9IHJlcXVpcmUoJ3BhcnNldXJpJyk7XG52YXIgcGFyc2Vqc29uID0gcmVxdWlyZSgncGFyc2Vqc29uJyk7XG52YXIgcGFyc2VxcyA9IHJlcXVpcmUoJ3BhcnNlcXMnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNvY2tldDtcblxuLyoqXG4gKiBTb2NrZXQgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSB1cmkgb3Igb3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gU29ja2V0ICh1cmksIG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNvY2tldCkpIHJldHVybiBuZXcgU29ja2V0KHVyaSwgb3B0cyk7XG5cbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgaWYgKHVyaSAmJiAnb2JqZWN0JyA9PT0gdHlwZW9mIHVyaSkge1xuICAgIG9wdHMgPSB1cmk7XG4gICAgdXJpID0gbnVsbDtcbiAgfVxuXG4gIGlmICh1cmkpIHtcbiAgICB1cmkgPSBwYXJzZXVyaSh1cmkpO1xuICAgIG9wdHMuaG9zdG5hbWUgPSB1cmkuaG9zdDtcbiAgICBvcHRzLnNlY3VyZSA9IHVyaS5wcm90b2NvbCA9PT0gJ2h0dHBzJyB8fCB1cmkucHJvdG9jb2wgPT09ICd3c3MnO1xuICAgIG9wdHMucG9ydCA9IHVyaS5wb3J0O1xuICAgIGlmICh1cmkucXVlcnkpIG9wdHMucXVlcnkgPSB1cmkucXVlcnk7XG4gIH0gZWxzZSBpZiAob3B0cy5ob3N0KSB7XG4gICAgb3B0cy5ob3N0bmFtZSA9IHBhcnNldXJpKG9wdHMuaG9zdCkuaG9zdDtcbiAgfVxuXG4gIHRoaXMuc2VjdXJlID0gbnVsbCAhPSBvcHRzLnNlY3VyZSA/IG9wdHMuc2VjdXJlXG4gICAgOiAoZ2xvYmFsLmxvY2F0aW9uICYmICdodHRwczonID09PSBsb2NhdGlvbi5wcm90b2NvbCk7XG5cbiAgaWYgKG9wdHMuaG9zdG5hbWUgJiYgIW9wdHMucG9ydCkge1xuICAgIC8vIGlmIG5vIHBvcnQgaXMgc3BlY2lmaWVkIG1hbnVhbGx5LCB1c2UgdGhlIHByb3RvY29sIGRlZmF1bHRcbiAgICBvcHRzLnBvcnQgPSB0aGlzLnNlY3VyZSA/ICc0NDMnIDogJzgwJztcbiAgfVxuXG4gIHRoaXMuYWdlbnQgPSBvcHRzLmFnZW50IHx8IGZhbHNlO1xuICB0aGlzLmhvc3RuYW1lID0gb3B0cy5ob3N0bmFtZSB8fFxuICAgIChnbG9iYWwubG9jYXRpb24gPyBsb2NhdGlvbi5ob3N0bmFtZSA6ICdsb2NhbGhvc3QnKTtcbiAgdGhpcy5wb3J0ID0gb3B0cy5wb3J0IHx8IChnbG9iYWwubG9jYXRpb24gJiYgbG9jYXRpb24ucG9ydFxuICAgICAgPyBsb2NhdGlvbi5wb3J0XG4gICAgICA6ICh0aGlzLnNlY3VyZSA/IDQ0MyA6IDgwKSk7XG4gIHRoaXMucXVlcnkgPSBvcHRzLnF1ZXJ5IHx8IHt9O1xuICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB0aGlzLnF1ZXJ5KSB0aGlzLnF1ZXJ5ID0gcGFyc2Vxcy5kZWNvZGUodGhpcy5xdWVyeSk7XG4gIHRoaXMudXBncmFkZSA9IGZhbHNlICE9PSBvcHRzLnVwZ3JhZGU7XG4gIHRoaXMucGF0aCA9IChvcHRzLnBhdGggfHwgJy9lbmdpbmUuaW8nKS5yZXBsYWNlKC9cXC8kLywgJycpICsgJy8nO1xuICB0aGlzLmZvcmNlSlNPTlAgPSAhIW9wdHMuZm9yY2VKU09OUDtcbiAgdGhpcy5qc29ucCA9IGZhbHNlICE9PSBvcHRzLmpzb25wO1xuICB0aGlzLmZvcmNlQmFzZTY0ID0gISFvcHRzLmZvcmNlQmFzZTY0O1xuICB0aGlzLmVuYWJsZXNYRFIgPSAhIW9wdHMuZW5hYmxlc1hEUjtcbiAgdGhpcy50aW1lc3RhbXBQYXJhbSA9IG9wdHMudGltZXN0YW1wUGFyYW0gfHwgJ3QnO1xuICB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzID0gb3B0cy50aW1lc3RhbXBSZXF1ZXN0cztcbiAgdGhpcy50cmFuc3BvcnRzID0gb3B0cy50cmFuc3BvcnRzIHx8IFsncG9sbGluZycsICd3ZWJzb2NrZXQnXTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJyc7XG4gIHRoaXMud3JpdGVCdWZmZXIgPSBbXTtcbiAgdGhpcy5wcmV2QnVmZmVyTGVuID0gMDtcbiAgdGhpcy5wb2xpY3lQb3J0ID0gb3B0cy5wb2xpY3lQb3J0IHx8IDg0MztcbiAgdGhpcy5yZW1lbWJlclVwZ3JhZGUgPSBvcHRzLnJlbWVtYmVyVXBncmFkZSB8fCBmYWxzZTtcbiAgdGhpcy5iaW5hcnlUeXBlID0gbnVsbDtcbiAgdGhpcy5vbmx5QmluYXJ5VXBncmFkZXMgPSBvcHRzLm9ubHlCaW5hcnlVcGdyYWRlcztcbiAgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSA9IGZhbHNlICE9PSBvcHRzLnBlck1lc3NhZ2VEZWZsYXRlID8gKG9wdHMucGVyTWVzc2FnZURlZmxhdGUgfHwge30pIDogZmFsc2U7XG5cbiAgaWYgKHRydWUgPT09IHRoaXMucGVyTWVzc2FnZURlZmxhdGUpIHRoaXMucGVyTWVzc2FnZURlZmxhdGUgPSB7fTtcbiAgaWYgKHRoaXMucGVyTWVzc2FnZURlZmxhdGUgJiYgbnVsbCA9PSB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlLnRocmVzaG9sZCkge1xuICAgIHRoaXMucGVyTWVzc2FnZURlZmxhdGUudGhyZXNob2xkID0gMTAyNDtcbiAgfVxuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLnBmeCA9IG9wdHMucGZ4IHx8IG51bGw7XG4gIHRoaXMua2V5ID0gb3B0cy5rZXkgfHwgbnVsbDtcbiAgdGhpcy5wYXNzcGhyYXNlID0gb3B0cy5wYXNzcGhyYXNlIHx8IG51bGw7XG4gIHRoaXMuY2VydCA9IG9wdHMuY2VydCB8fCBudWxsO1xuICB0aGlzLmNhID0gb3B0cy5jYSB8fCBudWxsO1xuICB0aGlzLmNpcGhlcnMgPSBvcHRzLmNpcGhlcnMgfHwgbnVsbDtcbiAgdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQgPSBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IG9wdHMucmVqZWN0VW5hdXRob3JpemVkO1xuICB0aGlzLmZvcmNlTm9kZSA9ICEhb3B0cy5mb3JjZU5vZGU7XG5cbiAgLy8gb3RoZXIgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgdmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG4gIGlmIChmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCkge1xuICAgIGlmIChvcHRzLmV4dHJhSGVhZGVycyAmJiBPYmplY3Qua2V5cyhvcHRzLmV4dHJhSGVhZGVycykubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5leHRyYUhlYWRlcnMgPSBvcHRzLmV4dHJhSGVhZGVycztcbiAgICB9XG5cbiAgICBpZiAob3B0cy5sb2NhbEFkZHJlc3MpIHtcbiAgICAgIHRoaXMubG9jYWxBZGRyZXNzID0gb3B0cy5sb2NhbEFkZHJlc3M7XG4gICAgfVxuICB9XG5cbiAgLy8gc2V0IG9uIGhhbmRzaGFrZVxuICB0aGlzLmlkID0gbnVsbDtcbiAgdGhpcy51cGdyYWRlcyA9IG51bGw7XG4gIHRoaXMucGluZ0ludGVydmFsID0gbnVsbDtcbiAgdGhpcy5waW5nVGltZW91dCA9IG51bGw7XG5cbiAgLy8gc2V0IG9uIGhlYXJ0YmVhdFxuICB0aGlzLnBpbmdJbnRlcnZhbFRpbWVyID0gbnVsbDtcbiAgdGhpcy5waW5nVGltZW91dFRpbWVyID0gbnVsbDtcblxuICB0aGlzLm9wZW4oKTtcbn1cblxuU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihTb2NrZXQucHJvdG90eXBlKTtcblxuLyoqXG4gKiBQcm90b2NvbCB2ZXJzaW9uLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvY29sID0gcGFyc2VyLnByb3RvY29sOyAvLyB0aGlzIGlzIGFuIGludFxuXG4vKipcbiAqIEV4cG9zZSBkZXBzIGZvciBsZWdhY3kgY29tcGF0aWJpbGl0eVxuICogYW5kIHN0YW5kYWxvbmUgYnJvd3NlciBhY2Nlc3MuXG4gKi9cblxuU29ja2V0LlNvY2tldCA9IFNvY2tldDtcblNvY2tldC5UcmFuc3BvcnQgPSByZXF1aXJlKCcuL3RyYW5zcG9ydCcpO1xuU29ja2V0LnRyYW5zcG9ydHMgPSByZXF1aXJlKCcuL3RyYW5zcG9ydHMvaW5kZXgnKTtcblNvY2tldC5wYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG5cbi8qKlxuICogQ3JlYXRlcyB0cmFuc3BvcnQgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRyYW5zcG9ydCBuYW1lXG4gKiBAcmV0dXJuIHtUcmFuc3BvcnR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmNyZWF0ZVRyYW5zcG9ydCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGRlYnVnKCdjcmVhdGluZyB0cmFuc3BvcnQgXCIlc1wiJywgbmFtZSk7XG4gIHZhciBxdWVyeSA9IGNsb25lKHRoaXMucXVlcnkpO1xuXG4gIC8vIGFwcGVuZCBlbmdpbmUuaW8gcHJvdG9jb2wgaWRlbnRpZmllclxuICBxdWVyeS5FSU8gPSBwYXJzZXIucHJvdG9jb2w7XG5cbiAgLy8gdHJhbnNwb3J0IG5hbWVcbiAgcXVlcnkudHJhbnNwb3J0ID0gbmFtZTtcblxuICAvLyBzZXNzaW9uIGlkIGlmIHdlIGFscmVhZHkgaGF2ZSBvbmVcbiAgaWYgKHRoaXMuaWQpIHF1ZXJ5LnNpZCA9IHRoaXMuaWQ7XG5cbiAgdmFyIHRyYW5zcG9ydCA9IG5ldyB0cmFuc3BvcnRzW25hbWVdKHtcbiAgICBhZ2VudDogdGhpcy5hZ2VudCxcbiAgICBob3N0bmFtZTogdGhpcy5ob3N0bmFtZSxcbiAgICBwb3J0OiB0aGlzLnBvcnQsXG4gICAgc2VjdXJlOiB0aGlzLnNlY3VyZSxcbiAgICBwYXRoOiB0aGlzLnBhdGgsXG4gICAgcXVlcnk6IHF1ZXJ5LFxuICAgIGZvcmNlSlNPTlA6IHRoaXMuZm9yY2VKU09OUCxcbiAgICBqc29ucDogdGhpcy5qc29ucCxcbiAgICBmb3JjZUJhc2U2NDogdGhpcy5mb3JjZUJhc2U2NCxcbiAgICBlbmFibGVzWERSOiB0aGlzLmVuYWJsZXNYRFIsXG4gICAgdGltZXN0YW1wUmVxdWVzdHM6IHRoaXMudGltZXN0YW1wUmVxdWVzdHMsXG4gICAgdGltZXN0YW1wUGFyYW06IHRoaXMudGltZXN0YW1wUGFyYW0sXG4gICAgcG9saWN5UG9ydDogdGhpcy5wb2xpY3lQb3J0LFxuICAgIHNvY2tldDogdGhpcyxcbiAgICBwZng6IHRoaXMucGZ4LFxuICAgIGtleTogdGhpcy5rZXksXG4gICAgcGFzc3BocmFzZTogdGhpcy5wYXNzcGhyYXNlLFxuICAgIGNlcnQ6IHRoaXMuY2VydCxcbiAgICBjYTogdGhpcy5jYSxcbiAgICBjaXBoZXJzOiB0aGlzLmNpcGhlcnMsXG4gICAgcmVqZWN0VW5hdXRob3JpemVkOiB0aGlzLnJlamVjdFVuYXV0aG9yaXplZCxcbiAgICBwZXJNZXNzYWdlRGVmbGF0ZTogdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSxcbiAgICBleHRyYUhlYWRlcnM6IHRoaXMuZXh0cmFIZWFkZXJzLFxuICAgIGZvcmNlTm9kZTogdGhpcy5mb3JjZU5vZGUsXG4gICAgbG9jYWxBZGRyZXNzOiB0aGlzLmxvY2FsQWRkcmVzc1xuICB9KTtcblxuICByZXR1cm4gdHJhbnNwb3J0O1xufTtcblxuZnVuY3Rpb24gY2xvbmUgKG9iaikge1xuICB2YXIgbyA9IHt9O1xuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgIG9baV0gPSBvYmpbaV07XG4gICAgfVxuICB9XG4gIHJldHVybiBvO1xufVxuXG4vKipcbiAqIEluaXRpYWxpemVzIHRyYW5zcG9ydCB0byB1c2UgYW5kIHN0YXJ0cyBwcm9iZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuU29ja2V0LnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdHJhbnNwb3J0O1xuICBpZiAodGhpcy5yZW1lbWJlclVwZ3JhZGUgJiYgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyAmJiB0aGlzLnRyYW5zcG9ydHMuaW5kZXhPZignd2Vic29ja2V0JykgIT09IC0xKSB7XG4gICAgdHJhbnNwb3J0ID0gJ3dlYnNvY2tldCc7XG4gIH0gZWxzZSBpZiAoMCA9PT0gdGhpcy50cmFuc3BvcnRzLmxlbmd0aCkge1xuICAgIC8vIEVtaXQgZXJyb3Igb24gbmV4dCB0aWNrIHNvIGl0IGNhbiBiZSBsaXN0ZW5lZCB0b1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCAnTm8gdHJhbnNwb3J0cyBhdmFpbGFibGUnKTtcbiAgICB9LCAwKTtcbiAgICByZXR1cm47XG4gIH0gZWxzZSB7XG4gICAgdHJhbnNwb3J0ID0gdGhpcy50cmFuc3BvcnRzWzBdO1xuICB9XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuaW5nJztcblxuICAvLyBSZXRyeSB3aXRoIHRoZSBuZXh0IHRyYW5zcG9ydCBpZiB0aGUgdHJhbnNwb3J0IGlzIGRpc2FibGVkIChqc29ucDogZmFsc2UpXG4gIHRyeSB7XG4gICAgdHJhbnNwb3J0ID0gdGhpcy5jcmVhdGVUcmFuc3BvcnQodHJhbnNwb3J0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRoaXMudHJhbnNwb3J0cy5zaGlmdCgpO1xuICAgIHRoaXMub3BlbigpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRyYW5zcG9ydC5vcGVuKCk7XG4gIHRoaXMuc2V0VHJhbnNwb3J0KHRyYW5zcG9ydCk7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGN1cnJlbnQgdHJhbnNwb3J0LiBEaXNhYmxlcyB0aGUgZXhpc3Rpbmcgb25lIChpZiBhbnkpLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuc2V0VHJhbnNwb3J0ID0gZnVuY3Rpb24gKHRyYW5zcG9ydCkge1xuICBkZWJ1Zygnc2V0dGluZyB0cmFuc3BvcnQgJXMnLCB0cmFuc3BvcnQubmFtZSk7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAodGhpcy50cmFuc3BvcnQpIHtcbiAgICBkZWJ1ZygnY2xlYXJpbmcgZXhpc3RpbmcgdHJhbnNwb3J0ICVzJywgdGhpcy50cmFuc3BvcnQubmFtZSk7XG4gICAgdGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIH1cblxuICAvLyBzZXQgdXAgdHJhbnNwb3J0XG4gIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuXG4gIC8vIHNldCB1cCB0cmFuc3BvcnQgbGlzdGVuZXJzXG4gIHRyYW5zcG9ydFxuICAub24oJ2RyYWluJywgZnVuY3Rpb24gKCkge1xuICAgIHNlbGYub25EcmFpbigpO1xuICB9KVxuICAub24oJ3BhY2tldCcsIGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgICBzZWxmLm9uUGFja2V0KHBhY2tldCk7XG4gIH0pXG4gIC5vbignZXJyb3InLCBmdW5jdGlvbiAoZSkge1xuICAgIHNlbGYub25FcnJvcihlKTtcbiAgfSlcbiAgLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLm9uQ2xvc2UoJ3RyYW5zcG9ydCBjbG9zZScpO1xuICB9KTtcbn07XG5cbi8qKlxuICogUHJvYmVzIGEgdHJhbnNwb3J0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0cmFuc3BvcnQgbmFtZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5wcm9iZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGRlYnVnKCdwcm9iaW5nIHRyYW5zcG9ydCBcIiVzXCInLCBuYW1lKTtcbiAgdmFyIHRyYW5zcG9ydCA9IHRoaXMuY3JlYXRlVHJhbnNwb3J0KG5hbWUsIHsgcHJvYmU6IDEgfSk7XG4gIHZhciBmYWlsZWQgPSBmYWxzZTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBvblRyYW5zcG9ydE9wZW4gKCkge1xuICAgIGlmIChzZWxmLm9ubHlCaW5hcnlVcGdyYWRlcykge1xuICAgICAgdmFyIHVwZ3JhZGVMb3Nlc0JpbmFyeSA9ICF0aGlzLnN1cHBvcnRzQmluYXJ5ICYmIHNlbGYudHJhbnNwb3J0LnN1cHBvcnRzQmluYXJ5O1xuICAgICAgZmFpbGVkID0gZmFpbGVkIHx8IHVwZ3JhZGVMb3Nlc0JpbmFyeTtcbiAgICB9XG4gICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuXG4gICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgb3BlbmVkJywgbmFtZSk7XG4gICAgdHJhbnNwb3J0LnNlbmQoW3sgdHlwZTogJ3BpbmcnLCBkYXRhOiAncHJvYmUnIH1dKTtcbiAgICB0cmFuc3BvcnQub25jZSgncGFja2V0JywgZnVuY3Rpb24gKG1zZykge1xuICAgICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuICAgICAgaWYgKCdwb25nJyA9PT0gbXNnLnR5cGUgJiYgJ3Byb2JlJyA9PT0gbXNnLmRhdGEpIHtcbiAgICAgICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgcG9uZycsIG5hbWUpO1xuICAgICAgICBzZWxmLnVwZ3JhZGluZyA9IHRydWU7XG4gICAgICAgIHNlbGYuZW1pdCgndXBncmFkaW5nJywgdHJhbnNwb3J0KTtcbiAgICAgICAgaWYgKCF0cmFuc3BvcnQpIHJldHVybjtcbiAgICAgICAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9ICd3ZWJzb2NrZXQnID09PSB0cmFuc3BvcnQubmFtZTtcblxuICAgICAgICBkZWJ1ZygncGF1c2luZyBjdXJyZW50IHRyYW5zcG9ydCBcIiVzXCInLCBzZWxmLnRyYW5zcG9ydC5uYW1lKTtcbiAgICAgICAgc2VsZi50cmFuc3BvcnQucGF1c2UoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChmYWlsZWQpIHJldHVybjtcbiAgICAgICAgICBpZiAoJ2Nsb3NlZCcgPT09IHNlbGYucmVhZHlTdGF0ZSkgcmV0dXJuO1xuICAgICAgICAgIGRlYnVnKCdjaGFuZ2luZyB0cmFuc3BvcnQgYW5kIHNlbmRpbmcgdXBncmFkZSBwYWNrZXQnKTtcblxuICAgICAgICAgIGNsZWFudXAoKTtcblxuICAgICAgICAgIHNlbGYuc2V0VHJhbnNwb3J0KHRyYW5zcG9ydCk7XG4gICAgICAgICAgdHJhbnNwb3J0LnNlbmQoW3sgdHlwZTogJ3VwZ3JhZGUnIH1dKTtcbiAgICAgICAgICBzZWxmLmVtaXQoJ3VwZ3JhZGUnLCB0cmFuc3BvcnQpO1xuICAgICAgICAgIHRyYW5zcG9ydCA9IG51bGw7XG4gICAgICAgICAgc2VsZi51cGdyYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICBzZWxmLmZsdXNoKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgZmFpbGVkJywgbmFtZSk7XG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ3Byb2JlIGVycm9yJyk7XG4gICAgICAgIGVyci50cmFuc3BvcnQgPSB0cmFuc3BvcnQubmFtZTtcbiAgICAgICAgc2VsZi5lbWl0KCd1cGdyYWRlRXJyb3InLCBlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZnJlZXplVHJhbnNwb3J0ICgpIHtcbiAgICBpZiAoZmFpbGVkKSByZXR1cm47XG5cbiAgICAvLyBBbnkgY2FsbGJhY2sgY2FsbGVkIGJ5IHRyYW5zcG9ydCBzaG91bGQgYmUgaWdub3JlZCBzaW5jZSBub3dcbiAgICBmYWlsZWQgPSB0cnVlO1xuXG4gICAgY2xlYW51cCgpO1xuXG4gICAgdHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgdHJhbnNwb3J0ID0gbnVsbDtcbiAgfVxuXG4gIC8vIEhhbmRsZSBhbnkgZXJyb3IgdGhhdCBoYXBwZW5zIHdoaWxlIHByb2JpbmdcbiAgZnVuY3Rpb24gb25lcnJvciAoZXJyKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdwcm9iZSBlcnJvcjogJyArIGVycik7XG4gICAgZXJyb3IudHJhbnNwb3J0ID0gdHJhbnNwb3J0Lm5hbWU7XG5cbiAgICBmcmVlemVUcmFuc3BvcnQoKTtcblxuICAgIGRlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIGZhaWxlZCBiZWNhdXNlIG9mIGVycm9yOiAlcycsIG5hbWUsIGVycik7XG5cbiAgICBzZWxmLmVtaXQoJ3VwZ3JhZGVFcnJvcicsIGVycm9yKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVHJhbnNwb3J0Q2xvc2UgKCkge1xuICAgIG9uZXJyb3IoJ3RyYW5zcG9ydCBjbG9zZWQnKTtcbiAgfVxuXG4gIC8vIFdoZW4gdGhlIHNvY2tldCBpcyBjbG9zZWQgd2hpbGUgd2UncmUgcHJvYmluZ1xuICBmdW5jdGlvbiBvbmNsb3NlICgpIHtcbiAgICBvbmVycm9yKCdzb2NrZXQgY2xvc2VkJyk7XG4gIH1cblxuICAvLyBXaGVuIHRoZSBzb2NrZXQgaXMgdXBncmFkZWQgd2hpbGUgd2UncmUgcHJvYmluZ1xuICBmdW5jdGlvbiBvbnVwZ3JhZGUgKHRvKSB7XG4gICAgaWYgKHRyYW5zcG9ydCAmJiB0by5uYW1lICE9PSB0cmFuc3BvcnQubmFtZSkge1xuICAgICAgZGVidWcoJ1wiJXNcIiB3b3JrcyAtIGFib3J0aW5nIFwiJXNcIicsIHRvLm5hbWUsIHRyYW5zcG9ydC5uYW1lKTtcbiAgICAgIGZyZWV6ZVRyYW5zcG9ydCgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlbW92ZSBhbGwgbGlzdGVuZXJzIG9uIHRoZSB0cmFuc3BvcnQgYW5kIG9uIHNlbGZcbiAgZnVuY3Rpb24gY2xlYW51cCAoKSB7XG4gICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKCdvcGVuJywgb25UcmFuc3BvcnRPcGVuKTtcbiAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uVHJhbnNwb3J0Q2xvc2UpO1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcigndXBncmFkaW5nJywgb251cGdyYWRlKTtcbiAgfVxuXG4gIHRyYW5zcG9ydC5vbmNlKCdvcGVuJywgb25UcmFuc3BvcnRPcGVuKTtcbiAgdHJhbnNwb3J0Lm9uY2UoJ2Vycm9yJywgb25lcnJvcik7XG4gIHRyYW5zcG9ydC5vbmNlKCdjbG9zZScsIG9uVHJhbnNwb3J0Q2xvc2UpO1xuXG4gIHRoaXMub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcbiAgdGhpcy5vbmNlKCd1cGdyYWRpbmcnLCBvbnVwZ3JhZGUpO1xuXG4gIHRyYW5zcG9ydC5vcGVuKCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIGNvbm5lY3Rpb24gaXMgZGVlbWVkIG9wZW4uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ3NvY2tldCBvcGVuJyk7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuJztcbiAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9ICd3ZWJzb2NrZXQnID09PSB0aGlzLnRyYW5zcG9ydC5uYW1lO1xuICB0aGlzLmVtaXQoJ29wZW4nKTtcbiAgdGhpcy5mbHVzaCgpO1xuXG4gIC8vIHdlIGNoZWNrIGZvciBgcmVhZHlTdGF0ZWAgaW4gY2FzZSBhbiBgb3BlbmBcbiAgLy8gbGlzdGVuZXIgYWxyZWFkeSBjbG9zZWQgdGhlIHNvY2tldFxuICBpZiAoJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUgJiYgdGhpcy51cGdyYWRlICYmIHRoaXMudHJhbnNwb3J0LnBhdXNlKSB7XG4gICAgZGVidWcoJ3N0YXJ0aW5nIHVwZ3JhZGUgcHJvYmVzJyk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLnVwZ3JhZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdGhpcy5wcm9iZSh0aGlzLnVwZ3JhZGVzW2ldKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogSGFuZGxlcyBhIHBhY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uUGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICBpZiAoJ29wZW5pbmcnID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUgfHxcbiAgICAgICdjbG9zaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgZGVidWcoJ3NvY2tldCByZWNlaXZlOiB0eXBlIFwiJXNcIiwgZGF0YSBcIiVzXCInLCBwYWNrZXQudHlwZSwgcGFja2V0LmRhdGEpO1xuXG4gICAgdGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xuXG4gICAgLy8gU29ja2V0IGlzIGxpdmUgLSBhbnkgcGFja2V0IGNvdW50c1xuICAgIHRoaXMuZW1pdCgnaGVhcnRiZWF0Jyk7XG5cbiAgICBzd2l0Y2ggKHBhY2tldC50eXBlKSB7XG4gICAgICBjYXNlICdvcGVuJzpcbiAgICAgICAgdGhpcy5vbkhhbmRzaGFrZShwYXJzZWpzb24ocGFja2V0LmRhdGEpKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3BvbmcnOlxuICAgICAgICB0aGlzLnNldFBpbmcoKTtcbiAgICAgICAgdGhpcy5lbWl0KCdwb25nJyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ3NlcnZlciBlcnJvcicpO1xuICAgICAgICBlcnIuY29kZSA9IHBhY2tldC5kYXRhO1xuICAgICAgICB0aGlzLm9uRXJyb3IoZXJyKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ21lc3NhZ2UnOlxuICAgICAgICB0aGlzLmVtaXQoJ2RhdGEnLCBwYWNrZXQuZGF0YSk7XG4gICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIHBhY2tldC5kYXRhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRlYnVnKCdwYWNrZXQgcmVjZWl2ZWQgd2l0aCBzb2NrZXQgcmVhZHlTdGF0ZSBcIiVzXCInLCB0aGlzLnJlYWR5U3RhdGUpO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGhhbmRzaGFrZSBjb21wbGV0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYW5kc2hha2Ugb2JqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uSGFuZHNoYWtlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdGhpcy5lbWl0KCdoYW5kc2hha2UnLCBkYXRhKTtcbiAgdGhpcy5pZCA9IGRhdGEuc2lkO1xuICB0aGlzLnRyYW5zcG9ydC5xdWVyeS5zaWQgPSBkYXRhLnNpZDtcbiAgdGhpcy51cGdyYWRlcyA9IHRoaXMuZmlsdGVyVXBncmFkZXMoZGF0YS51cGdyYWRlcyk7XG4gIHRoaXMucGluZ0ludGVydmFsID0gZGF0YS5waW5nSW50ZXJ2YWw7XG4gIHRoaXMucGluZ1RpbWVvdXQgPSBkYXRhLnBpbmdUaW1lb3V0O1xuICB0aGlzLm9uT3BlbigpO1xuICAvLyBJbiBjYXNlIG9wZW4gaGFuZGxlciBjbG9zZXMgc29ja2V0XG4gIGlmICgnY2xvc2VkJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSByZXR1cm47XG4gIHRoaXMuc2V0UGluZygpO1xuXG4gIC8vIFByb2xvbmcgbGl2ZW5lc3Mgb2Ygc29ja2V0IG9uIGhlYXJ0YmVhdFxuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdoZWFydGJlYXQnLCB0aGlzLm9uSGVhcnRiZWF0KTtcbiAgdGhpcy5vbignaGVhcnRiZWF0JywgdGhpcy5vbkhlYXJ0YmVhdCk7XG59O1xuXG4vKipcbiAqIFJlc2V0cyBwaW5nIHRpbWVvdXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkhlYXJ0YmVhdCA9IGZ1bmN0aW9uICh0aW1lb3V0KSB7XG4gIGNsZWFyVGltZW91dCh0aGlzLnBpbmdUaW1lb3V0VGltZXIpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNlbGYucGluZ1RpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGlmICgnY2xvc2VkJyA9PT0gc2VsZi5yZWFkeVN0YXRlKSByZXR1cm47XG4gICAgc2VsZi5vbkNsb3NlKCdwaW5nIHRpbWVvdXQnKTtcbiAgfSwgdGltZW91dCB8fCAoc2VsZi5waW5nSW50ZXJ2YWwgKyBzZWxmLnBpbmdUaW1lb3V0KSk7XG59O1xuXG4vKipcbiAqIFBpbmdzIHNlcnZlciBldmVyeSBgdGhpcy5waW5nSW50ZXJ2YWxgIGFuZCBleHBlY3RzIHJlc3BvbnNlXG4gKiB3aXRoaW4gYHRoaXMucGluZ1RpbWVvdXRgIG9yIGNsb3NlcyBjb25uZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuc2V0UGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBjbGVhclRpbWVvdXQoc2VsZi5waW5nSW50ZXJ2YWxUaW1lcik7XG4gIHNlbGYucGluZ0ludGVydmFsVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1Zygnd3JpdGluZyBwaW5nIHBhY2tldCAtIGV4cGVjdGluZyBwb25nIHdpdGhpbiAlc21zJywgc2VsZi5waW5nVGltZW91dCk7XG4gICAgc2VsZi5waW5nKCk7XG4gICAgc2VsZi5vbkhlYXJ0YmVhdChzZWxmLnBpbmdUaW1lb3V0KTtcbiAgfSwgc2VsZi5waW5nSW50ZXJ2YWwpO1xufTtcblxuLyoqXG4qIFNlbmRzIGEgcGluZyBwYWNrZXQuXG4qXG4qIEBhcGkgcHJpdmF0ZVxuKi9cblxuU29ja2V0LnByb3RvdHlwZS5waW5nID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuc2VuZFBhY2tldCgncGluZycsIGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLmVtaXQoJ3BpbmcnKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIENhbGxlZCBvbiBgZHJhaW5gIGV2ZW50XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkRyYWluID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLndyaXRlQnVmZmVyLnNwbGljZSgwLCB0aGlzLnByZXZCdWZmZXJMZW4pO1xuXG4gIC8vIHNldHRpbmcgcHJldkJ1ZmZlckxlbiA9IDAgaXMgdmVyeSBpbXBvcnRhbnRcbiAgLy8gZm9yIGV4YW1wbGUsIHdoZW4gdXBncmFkaW5nLCB1cGdyYWRlIHBhY2tldCBpcyBzZW50IG92ZXIsXG4gIC8vIGFuZCBhIG5vbnplcm8gcHJldkJ1ZmZlckxlbiBjb3VsZCBjYXVzZSBwcm9ibGVtcyBvbiBgZHJhaW5gXG4gIHRoaXMucHJldkJ1ZmZlckxlbiA9IDA7XG5cbiAgaWYgKDAgPT09IHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKSB7XG4gICAgdGhpcy5lbWl0KCdkcmFpbicpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZmx1c2goKTtcbiAgfVxufTtcblxuLyoqXG4gKiBGbHVzaCB3cml0ZSBidWZmZXJzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnY2xvc2VkJyAhPT0gdGhpcy5yZWFkeVN0YXRlICYmIHRoaXMudHJhbnNwb3J0LndyaXRhYmxlICYmXG4gICAgIXRoaXMudXBncmFkaW5nICYmIHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKSB7XG4gICAgZGVidWcoJ2ZsdXNoaW5nICVkIHBhY2tldHMgaW4gc29ja2V0JywgdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpO1xuICAgIHRoaXMudHJhbnNwb3J0LnNlbmQodGhpcy53cml0ZUJ1ZmZlcik7XG4gICAgLy8ga2VlcCB0cmFjayBvZiBjdXJyZW50IGxlbmd0aCBvZiB3cml0ZUJ1ZmZlclxuICAgIC8vIHNwbGljZSB3cml0ZUJ1ZmZlciBhbmQgY2FsbGJhY2tCdWZmZXIgb24gYGRyYWluYFxuICAgIHRoaXMucHJldkJ1ZmZlckxlbiA9IHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoO1xuICAgIHRoaXMuZW1pdCgnZmx1c2gnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTZW5kcyBhIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuICogQHJldHVybiB7U29ja2V0fSBmb3IgY2hhaW5pbmcuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUud3JpdGUgPVxuU29ja2V0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKG1zZywgb3B0aW9ucywgZm4pIHtcbiAgdGhpcy5zZW5kUGFja2V0KCdtZXNzYWdlJywgbXNnLCBvcHRpb25zLCBmbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZW5kcyBhIHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFja2V0IHR5cGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24uXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnNlbmRQYWNrZXQgPSBmdW5jdGlvbiAodHlwZSwgZGF0YSwgb3B0aW9ucywgZm4pIHtcbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBkYXRhKSB7XG4gICAgZm4gPSBkYXRhO1xuICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIG9wdGlvbnMpIHtcbiAgICBmbiA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH1cblxuICBpZiAoJ2Nsb3NpbmcnID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ2Nsb3NlZCcgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLmNvbXByZXNzID0gZmFsc2UgIT09IG9wdGlvbnMuY29tcHJlc3M7XG5cbiAgdmFyIHBhY2tldCA9IHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIGRhdGE6IGRhdGEsXG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9O1xuICB0aGlzLmVtaXQoJ3BhY2tldENyZWF0ZScsIHBhY2tldCk7XG4gIHRoaXMud3JpdGVCdWZmZXIucHVzaChwYWNrZXQpO1xuICBpZiAoZm4pIHRoaXMub25jZSgnZmx1c2gnLCBmbik7XG4gIHRoaXMuZmx1c2goKTtcbn07XG5cbi8qKlxuICogQ2xvc2VzIHRoZSBjb25uZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnb3BlbmluZycgPT09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zaW5nJztcblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmICh0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCkge1xuICAgICAgdGhpcy5vbmNlKCdkcmFpbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMudXBncmFkaW5nKSB7XG4gICAgICAgICAgd2FpdEZvclVwZ3JhZGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudXBncmFkaW5nKSB7XG4gICAgICB3YWl0Rm9yVXBncmFkZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbG9zZSgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb3NlICgpIHtcbiAgICBzZWxmLm9uQ2xvc2UoJ2ZvcmNlZCBjbG9zZScpO1xuICAgIGRlYnVnKCdzb2NrZXQgY2xvc2luZyAtIHRlbGxpbmcgdHJhbnNwb3J0IHRvIGNsb3NlJyk7XG4gICAgc2VsZi50cmFuc3BvcnQuY2xvc2UoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFudXBBbmRDbG9zZSAoKSB7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcigndXBncmFkZScsIGNsZWFudXBBbmRDbG9zZSk7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcigndXBncmFkZUVycm9yJywgY2xlYW51cEFuZENsb3NlKTtcbiAgICBjbG9zZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gd2FpdEZvclVwZ3JhZGUgKCkge1xuICAgIC8vIHdhaXQgZm9yIHVwZ3JhZGUgdG8gZmluaXNoIHNpbmNlIHdlIGNhbid0IHNlbmQgcGFja2V0cyB3aGlsZSBwYXVzaW5nIGEgdHJhbnNwb3J0XG4gICAgc2VsZi5vbmNlKCd1cGdyYWRlJywgY2xlYW51cEFuZENsb3NlKTtcbiAgICBzZWxmLm9uY2UoJ3VwZ3JhZGVFcnJvcicsIGNsZWFudXBBbmRDbG9zZSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGVycm9yXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICBkZWJ1Zygnc29ja2V0IGVycm9yICVqJywgZXJyKTtcbiAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgdGhpcy5vbkNsb3NlKCd0cmFuc3BvcnQgZXJyb3InLCBlcnIpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgY2xvc2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24gKHJlYXNvbiwgZGVzYykge1xuICBpZiAoJ29wZW5pbmcnID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ2Nsb3NpbmcnID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICBkZWJ1Zygnc29ja2V0IGNsb3NlIHdpdGggcmVhc29uOiBcIiVzXCInLCByZWFzb24pO1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIGNsZWFyIHRpbWVyc1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnBpbmdJbnRlcnZhbFRpbWVyKTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5waW5nVGltZW91dFRpbWVyKTtcblxuICAgIC8vIHN0b3AgZXZlbnQgZnJvbSBmaXJpbmcgYWdhaW4gZm9yIHRyYW5zcG9ydFxuICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygnY2xvc2UnKTtcblxuICAgIC8vIGVuc3VyZSB0cmFuc3BvcnQgd29uJ3Qgc3RheSBvcGVuXG4gICAgdGhpcy50cmFuc3BvcnQuY2xvc2UoKTtcblxuICAgIC8vIGlnbm9yZSBmdXJ0aGVyIHRyYW5zcG9ydCBjb21tdW5pY2F0aW9uXG4gICAgdGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG5cbiAgICAvLyBzZXQgcmVhZHkgc3RhdGVcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcblxuICAgIC8vIGNsZWFyIHNlc3Npb24gaWRcbiAgICB0aGlzLmlkID0gbnVsbDtcblxuICAgIC8vIGVtaXQgY2xvc2UgZXZlbnRcbiAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgcmVhc29uLCBkZXNjKTtcblxuICAgIC8vIGNsZWFuIGJ1ZmZlcnMgYWZ0ZXIsIHNvIHVzZXJzIGNhbiBzdGlsbFxuICAgIC8vIGdyYWIgdGhlIGJ1ZmZlcnMgb24gYGNsb3NlYCBldmVudFxuICAgIHNlbGYud3JpdGVCdWZmZXIgPSBbXTtcbiAgICBzZWxmLnByZXZCdWZmZXJMZW4gPSAwO1xuICB9XG59O1xuXG4vKipcbiAqIEZpbHRlcnMgdXBncmFkZXMsIHJldHVybmluZyBvbmx5IHRob3NlIG1hdGNoaW5nIGNsaWVudCB0cmFuc3BvcnRzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHNlcnZlciB1cGdyYWRlc1xuICogQGFwaSBwcml2YXRlXG4gKlxuICovXG5cblNvY2tldC5wcm90b3R5cGUuZmlsdGVyVXBncmFkZXMgPSBmdW5jdGlvbiAodXBncmFkZXMpIHtcbiAgdmFyIGZpbHRlcmVkVXBncmFkZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGogPSB1cGdyYWRlcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICBpZiAofmluZGV4KHRoaXMudHJhbnNwb3J0cywgdXBncmFkZXNbaV0pKSBmaWx0ZXJlZFVwZ3JhZGVzLnB1c2godXBncmFkZXNbaV0pO1xuICB9XG4gIHJldHVybiBmaWx0ZXJlZFVwZ3JhZGVzO1xufTtcbiIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgcGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNwb3J0O1xuXG4vKipcbiAqIFRyYW5zcG9ydCBhYnN0cmFjdCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIFRyYW5zcG9ydCAob3B0cykge1xuICB0aGlzLnBhdGggPSBvcHRzLnBhdGg7XG4gIHRoaXMuaG9zdG5hbWUgPSBvcHRzLmhvc3RuYW1lO1xuICB0aGlzLnBvcnQgPSBvcHRzLnBvcnQ7XG4gIHRoaXMuc2VjdXJlID0gb3B0cy5zZWN1cmU7XG4gIHRoaXMucXVlcnkgPSBvcHRzLnF1ZXJ5O1xuICB0aGlzLnRpbWVzdGFtcFBhcmFtID0gb3B0cy50aW1lc3RhbXBQYXJhbTtcbiAgdGhpcy50aW1lc3RhbXBSZXF1ZXN0cyA9IG9wdHMudGltZXN0YW1wUmVxdWVzdHM7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICcnO1xuICB0aGlzLmFnZW50ID0gb3B0cy5hZ2VudCB8fCBmYWxzZTtcbiAgdGhpcy5zb2NrZXQgPSBvcHRzLnNvY2tldDtcbiAgdGhpcy5lbmFibGVzWERSID0gb3B0cy5lbmFibGVzWERSO1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLnBmeCA9IG9wdHMucGZ4O1xuICB0aGlzLmtleSA9IG9wdHMua2V5O1xuICB0aGlzLnBhc3NwaHJhc2UgPSBvcHRzLnBhc3NwaHJhc2U7XG4gIHRoaXMuY2VydCA9IG9wdHMuY2VydDtcbiAgdGhpcy5jYSA9IG9wdHMuY2E7XG4gIHRoaXMuY2lwaGVycyA9IG9wdHMuY2lwaGVycztcbiAgdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQgPSBvcHRzLnJlamVjdFVuYXV0aG9yaXplZDtcbiAgdGhpcy5mb3JjZU5vZGUgPSBvcHRzLmZvcmNlTm9kZTtcblxuICAvLyBvdGhlciBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLmV4dHJhSGVhZGVycyA9IG9wdHMuZXh0cmFIZWFkZXJzO1xuICB0aGlzLmxvY2FsQWRkcmVzcyA9IG9wdHMubG9jYWxBZGRyZXNzO1xufVxuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihUcmFuc3BvcnQucHJvdG90eXBlKTtcblxuLyoqXG4gKiBFbWl0cyBhbiBlcnJvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtUcmFuc3BvcnR9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiAobXNnLCBkZXNjKSB7XG4gIHZhciBlcnIgPSBuZXcgRXJyb3IobXNnKTtcbiAgZXJyLnR5cGUgPSAnVHJhbnNwb3J0RXJyb3InO1xuICBlcnIuZGVzY3JpcHRpb24gPSBkZXNjO1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE9wZW5zIHRoZSB0cmFuc3BvcnQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnY2xvc2VkJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8ICcnID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSAnb3BlbmluZyc7XG4gICAgdGhpcy5kb09wZW4oKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDbG9zZXMgdGhlIHRyYW5zcG9ydC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICBpZiAoJ29wZW5pbmcnID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICB0aGlzLmRvQ2xvc2UoKTtcbiAgICB0aGlzLm9uQ2xvc2UoKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZW5kcyBtdWx0aXBsZSBwYWNrZXRzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHBhY2tldHNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChwYWNrZXRzKSB7XG4gIGlmICgnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHRoaXMud3JpdGUocGFja2V0cyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgbm90IG9wZW4nKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBvcGVuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vbk9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuJztcbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG4gIHRoaXMuZW1pdCgnb3BlbicpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2l0aCBkYXRhLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHZhciBwYWNrZXQgPSBwYXJzZXIuZGVjb2RlUGFja2V0KGRhdGEsIHRoaXMuc29ja2V0LmJpbmFyeVR5cGUpO1xuICB0aGlzLm9uUGFja2V0KHBhY2tldCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aXRoIGEgZGVjb2RlZCBwYWNrZXQuXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vblBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgdGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBjbG9zZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICB0aGlzLmVtaXQoJ2Nsb3NlJyk7XG59O1xuIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzXG4gKi9cblxudmFyIFhNTEh0dHBSZXF1ZXN0ID0gcmVxdWlyZSgneG1saHR0cHJlcXVlc3Qtc3NsJyk7XG52YXIgWEhSID0gcmVxdWlyZSgnLi9wb2xsaW5nLXhocicpO1xudmFyIEpTT05QID0gcmVxdWlyZSgnLi9wb2xsaW5nLWpzb25wJyk7XG52YXIgd2Vic29ja2V0ID0gcmVxdWlyZSgnLi93ZWJzb2NrZXQnKTtcblxuLyoqXG4gKiBFeHBvcnQgdHJhbnNwb3J0cy5cbiAqL1xuXG5leHBvcnRzLnBvbGxpbmcgPSBwb2xsaW5nO1xuZXhwb3J0cy53ZWJzb2NrZXQgPSB3ZWJzb2NrZXQ7XG5cbi8qKlxuICogUG9sbGluZyB0cmFuc3BvcnQgcG9seW1vcnBoaWMgY29uc3RydWN0b3IuXG4gKiBEZWNpZGVzIG9uIHhociB2cyBqc29ucCBiYXNlZCBvbiBmZWF0dXJlIGRldGVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwb2xsaW5nIChvcHRzKSB7XG4gIHZhciB4aHI7XG4gIHZhciB4ZCA9IGZhbHNlO1xuICB2YXIgeHMgPSBmYWxzZTtcbiAgdmFyIGpzb25wID0gZmFsc2UgIT09IG9wdHMuanNvbnA7XG5cbiAgaWYgKGdsb2JhbC5sb2NhdGlvbikge1xuICAgIHZhciBpc1NTTCA9ICdodHRwczonID09PSBsb2NhdGlvbi5wcm90b2NvbDtcbiAgICB2YXIgcG9ydCA9IGxvY2F0aW9uLnBvcnQ7XG5cbiAgICAvLyBzb21lIHVzZXIgYWdlbnRzIGhhdmUgZW1wdHkgYGxvY2F0aW9uLnBvcnRgXG4gICAgaWYgKCFwb3J0KSB7XG4gICAgICBwb3J0ID0gaXNTU0wgPyA0NDMgOiA4MDtcbiAgICB9XG5cbiAgICB4ZCA9IG9wdHMuaG9zdG5hbWUgIT09IGxvY2F0aW9uLmhvc3RuYW1lIHx8IHBvcnQgIT09IG9wdHMucG9ydDtcbiAgICB4cyA9IG9wdHMuc2VjdXJlICE9PSBpc1NTTDtcbiAgfVxuXG4gIG9wdHMueGRvbWFpbiA9IHhkO1xuICBvcHRzLnhzY2hlbWUgPSB4cztcbiAgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KG9wdHMpO1xuXG4gIGlmICgnb3BlbicgaW4geGhyICYmICFvcHRzLmZvcmNlSlNPTlApIHtcbiAgICByZXR1cm4gbmV3IFhIUihvcHRzKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWpzb25wKSB0aHJvdyBuZXcgRXJyb3IoJ0pTT05QIGRpc2FibGVkJyk7XG4gICAgcmV0dXJuIG5ldyBKU09OUChvcHRzKTtcbiAgfVxufVxuIiwiXG4vKipcbiAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG4gKi9cblxudmFyIFBvbGxpbmcgPSByZXF1aXJlKCcuL3BvbGxpbmcnKTtcbnZhciBpbmhlcml0ID0gcmVxdWlyZSgnY29tcG9uZW50LWluaGVyaXQnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEpTT05QUG9sbGluZztcblxuLyoqXG4gKiBDYWNoZWQgcmVndWxhciBleHByZXNzaW9ucy5cbiAqL1xuXG52YXIgck5ld2xpbmUgPSAvXFxuL2c7XG52YXIgckVzY2FwZWROZXdsaW5lID0gL1xcXFxuL2c7XG5cbi8qKlxuICogR2xvYmFsIEpTT05QIGNhbGxiYWNrcy5cbiAqL1xuXG52YXIgY2FsbGJhY2tzO1xuXG4vKipcbiAqIE5vb3AuXG4gKi9cblxuZnVuY3Rpb24gZW1wdHkgKCkgeyB9XG5cbi8qKlxuICogSlNPTlAgUG9sbGluZyBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cy5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gSlNPTlBQb2xsaW5nIChvcHRzKSB7XG4gIFBvbGxpbmcuY2FsbCh0aGlzLCBvcHRzKTtcblxuICB0aGlzLnF1ZXJ5ID0gdGhpcy5xdWVyeSB8fCB7fTtcblxuICAvLyBkZWZpbmUgZ2xvYmFsIGNhbGxiYWNrcyBhcnJheSBpZiBub3QgcHJlc2VudFxuICAvLyB3ZSBkbyB0aGlzIGhlcmUgKGxhemlseSkgdG8gYXZvaWQgdW5uZWVkZWQgZ2xvYmFsIHBvbGx1dGlvblxuICBpZiAoIWNhbGxiYWNrcykge1xuICAgIC8vIHdlIG5lZWQgdG8gY29uc2lkZXIgbXVsdGlwbGUgZW5naW5lcyBpbiB0aGUgc2FtZSBwYWdlXG4gICAgaWYgKCFnbG9iYWwuX19fZWlvKSBnbG9iYWwuX19fZWlvID0gW107XG4gICAgY2FsbGJhY2tzID0gZ2xvYmFsLl9fX2VpbztcbiAgfVxuXG4gIC8vIGNhbGxiYWNrIGlkZW50aWZpZXJcbiAgdGhpcy5pbmRleCA9IGNhbGxiYWNrcy5sZW5ndGg7XG5cbiAgLy8gYWRkIGNhbGxiYWNrIHRvIGpzb25wIGdsb2JhbFxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uIChtc2cpIHtcbiAgICBzZWxmLm9uRGF0YShtc2cpO1xuICB9KTtcblxuICAvLyBhcHBlbmQgdG8gcXVlcnkgc3RyaW5nXG4gIHRoaXMucXVlcnkuaiA9IHRoaXMuaW5kZXg7XG5cbiAgLy8gcHJldmVudCBzcHVyaW91cyBlcnJvcnMgZnJvbSBiZWluZyBlbWl0dGVkIHdoZW4gdGhlIHdpbmRvdyBpcyB1bmxvYWRlZFxuICBpZiAoZ2xvYmFsLmRvY3VtZW50ICYmIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChzZWxmLnNjcmlwdCkgc2VsZi5zY3JpcHQub25lcnJvciA9IGVtcHR5O1xuICAgIH0sIGZhbHNlKTtcbiAgfVxufVxuXG4vKipcbiAqIEluaGVyaXRzIGZyb20gUG9sbGluZy5cbiAqL1xuXG5pbmhlcml0KEpTT05QUG9sbGluZywgUG9sbGluZyk7XG5cbi8qXG4gKiBKU09OUCBvbmx5IHN1cHBvcnRzIGJpbmFyeSBhcyBiYXNlNjQgZW5jb2RlZCBzdHJpbmdzXG4gKi9cblxuSlNPTlBQb2xsaW5nLnByb3RvdHlwZS5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuXG4vKipcbiAqIENsb3NlcyB0aGUgc29ja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkpTT05QUG9sbGluZy5wcm90b3R5cGUuZG9DbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuc2NyaXB0KSB7XG4gICAgdGhpcy5zY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnNjcmlwdCk7XG4gICAgdGhpcy5zY3JpcHQgPSBudWxsO1xuICB9XG5cbiAgaWYgKHRoaXMuZm9ybSkge1xuICAgIHRoaXMuZm9ybS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZm9ybSk7XG4gICAgdGhpcy5mb3JtID0gbnVsbDtcbiAgICB0aGlzLmlmcmFtZSA9IG51bGw7XG4gIH1cblxuICBQb2xsaW5nLnByb3RvdHlwZS5kb0Nsb3NlLmNhbGwodGhpcyk7XG59O1xuXG4vKipcbiAqIFN0YXJ0cyBhIHBvbGwgY3ljbGUuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuSlNPTlBQb2xsaW5nLnByb3RvdHlwZS5kb1BvbGwgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuXG4gIGlmICh0aGlzLnNjcmlwdCkge1xuICAgIHRoaXMuc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zY3JpcHQpO1xuICAgIHRoaXMuc2NyaXB0ID0gbnVsbDtcbiAgfVxuXG4gIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gIHNjcmlwdC5zcmMgPSB0aGlzLnVyaSgpO1xuICBzY3JpcHQub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgc2VsZi5vbkVycm9yKCdqc29ucCBwb2xsIGVycm9yJywgZSk7XG4gIH07XG5cbiAgdmFyIGluc2VydEF0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpWzBdO1xuICBpZiAoaW5zZXJ0QXQpIHtcbiAgICBpbnNlcnRBdC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzY3JpcHQsIGluc2VydEF0KTtcbiAgfSBlbHNlIHtcbiAgICAoZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5ib2R5KS5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICB9XG4gIHRoaXMuc2NyaXB0ID0gc2NyaXB0O1xuXG4gIHZhciBpc1VBZ2Vja28gPSAndW5kZWZpbmVkJyAhPT0gdHlwZW9mIG5hdmlnYXRvciAmJiAvZ2Vja28vaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4gIGlmIChpc1VBZ2Vja28pIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgICB9LCAxMDApO1xuICB9XG59O1xuXG4vKipcbiAqIFdyaXRlcyB3aXRoIGEgaGlkZGVuIGlmcmFtZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YSB0byBzZW5kXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsZWQgdXBvbiBmbHVzaC5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkpTT05QUG9sbGluZy5wcm90b3R5cGUuZG9Xcml0ZSA9IGZ1bmN0aW9uIChkYXRhLCBmbikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKCF0aGlzLmZvcm0pIHtcbiAgICB2YXIgZm9ybSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Zvcm0nKTtcbiAgICB2YXIgYXJlYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XG4gICAgdmFyIGlkID0gdGhpcy5pZnJhbWVJZCA9ICdlaW9faWZyYW1lXycgKyB0aGlzLmluZGV4O1xuICAgIHZhciBpZnJhbWU7XG5cbiAgICBmb3JtLmNsYXNzTmFtZSA9ICdzb2NrZXRpbyc7XG4gICAgZm9ybS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgZm9ybS5zdHlsZS50b3AgPSAnLTEwMDBweCc7XG4gICAgZm9ybS5zdHlsZS5sZWZ0ID0gJy0xMDAwcHgnO1xuICAgIGZvcm0udGFyZ2V0ID0gaWQ7XG4gICAgZm9ybS5tZXRob2QgPSAnUE9TVCc7XG4gICAgZm9ybS5zZXRBdHRyaWJ1dGUoJ2FjY2VwdC1jaGFyc2V0JywgJ3V0Zi04Jyk7XG4gICAgYXJlYS5uYW1lID0gJ2QnO1xuICAgIGZvcm0uYXBwZW5kQ2hpbGQoYXJlYSk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmb3JtKTtcblxuICAgIHRoaXMuZm9ybSA9IGZvcm07XG4gICAgdGhpcy5hcmVhID0gYXJlYTtcbiAgfVxuXG4gIHRoaXMuZm9ybS5hY3Rpb24gPSB0aGlzLnVyaSgpO1xuXG4gIGZ1bmN0aW9uIGNvbXBsZXRlICgpIHtcbiAgICBpbml0SWZyYW1lKCk7XG4gICAgZm4oKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRJZnJhbWUgKCkge1xuICAgIGlmIChzZWxmLmlmcmFtZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2VsZi5mb3JtLnJlbW92ZUNoaWxkKHNlbGYuaWZyYW1lKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgc2VsZi5vbkVycm9yKCdqc29ucCBwb2xsaW5nIGlmcmFtZSByZW1vdmFsIGVycm9yJywgZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIGllNiBkeW5hbWljIGlmcmFtZXMgd2l0aCB0YXJnZXQ9XCJcIiBzdXBwb3J0ICh0aGFua3MgQ2hyaXMgTGFtYmFjaGVyKVxuICAgICAgdmFyIGh0bWwgPSAnPGlmcmFtZSBzcmM9XCJqYXZhc2NyaXB0OjBcIiBuYW1lPVwiJyArIHNlbGYuaWZyYW1lSWQgKyAnXCI+JztcbiAgICAgIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaHRtbCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgICBpZnJhbWUubmFtZSA9IHNlbGYuaWZyYW1lSWQ7XG4gICAgICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6MCc7XG4gICAgfVxuXG4gICAgaWZyYW1lLmlkID0gc2VsZi5pZnJhbWVJZDtcblxuICAgIHNlbGYuZm9ybS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgIHNlbGYuaWZyYW1lID0gaWZyYW1lO1xuICB9XG5cbiAgaW5pdElmcmFtZSgpO1xuXG4gIC8vIGVzY2FwZSBcXG4gdG8gcHJldmVudCBpdCBmcm9tIGJlaW5nIGNvbnZlcnRlZCBpbnRvIFxcclxcbiBieSBzb21lIFVBc1xuICAvLyBkb3VibGUgZXNjYXBpbmcgaXMgcmVxdWlyZWQgZm9yIGVzY2FwZWQgbmV3IGxpbmVzIGJlY2F1c2UgdW5lc2NhcGluZyBvZiBuZXcgbGluZXMgY2FuIGJlIGRvbmUgc2FmZWx5IG9uIHNlcnZlci1zaWRlXG4gIGRhdGEgPSBkYXRhLnJlcGxhY2UockVzY2FwZWROZXdsaW5lLCAnXFxcXFxcbicpO1xuICB0aGlzLmFyZWEudmFsdWUgPSBkYXRhLnJlcGxhY2Uock5ld2xpbmUsICdcXFxcbicpO1xuXG4gIHRyeSB7XG4gICAgdGhpcy5mb3JtLnN1Ym1pdCgpO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIGlmICh0aGlzLmlmcmFtZS5hdHRhY2hFdmVudCkge1xuICAgIHRoaXMuaWZyYW1lLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChzZWxmLmlmcmFtZS5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XG4gICAgICAgIGNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmlmcmFtZS5vbmxvYWQgPSBjb21wbGV0ZTtcbiAgfVxufTtcbiIsIi8qKlxuICogTW9kdWxlIHJlcXVpcmVtZW50cy5cbiAqL1xuXG52YXIgWE1MSHR0cFJlcXVlc3QgPSByZXF1aXJlKCd4bWxodHRwcmVxdWVzdC1zc2wnKTtcbnZhciBQb2xsaW5nID0gcmVxdWlyZSgnLi9wb2xsaW5nJyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgaW5oZXJpdCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1pbmhlcml0Jyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbmdpbmUuaW8tY2xpZW50OnBvbGxpbmcteGhyJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBYSFI7XG5tb2R1bGUuZXhwb3J0cy5SZXF1ZXN0ID0gUmVxdWVzdDtcblxuLyoqXG4gKiBFbXB0eSBmdW5jdGlvblxuICovXG5cbmZ1bmN0aW9uIGVtcHR5ICgpIHt9XG5cbi8qKlxuICogWEhSIFBvbGxpbmcgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gWEhSIChvcHRzKSB7XG4gIFBvbGxpbmcuY2FsbCh0aGlzLCBvcHRzKTtcbiAgdGhpcy5yZXF1ZXN0VGltZW91dCA9IG9wdHMucmVxdWVzdFRpbWVvdXQ7XG5cbiAgaWYgKGdsb2JhbC5sb2NhdGlvbikge1xuICAgIHZhciBpc1NTTCA9ICdodHRwczonID09PSBsb2NhdGlvbi5wcm90b2NvbDtcbiAgICB2YXIgcG9ydCA9IGxvY2F0aW9uLnBvcnQ7XG5cbiAgICAvLyBzb21lIHVzZXIgYWdlbnRzIGhhdmUgZW1wdHkgYGxvY2F0aW9uLnBvcnRgXG4gICAgaWYgKCFwb3J0KSB7XG4gICAgICBwb3J0ID0gaXNTU0wgPyA0NDMgOiA4MDtcbiAgICB9XG5cbiAgICB0aGlzLnhkID0gb3B0cy5ob3N0bmFtZSAhPT0gZ2xvYmFsLmxvY2F0aW9uLmhvc3RuYW1lIHx8XG4gICAgICBwb3J0ICE9PSBvcHRzLnBvcnQ7XG4gICAgdGhpcy54cyA9IG9wdHMuc2VjdXJlICE9PSBpc1NTTDtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmV4dHJhSGVhZGVycyA9IG9wdHMuZXh0cmFIZWFkZXJzO1xuICB9XG59XG5cbi8qKlxuICogSW5oZXJpdHMgZnJvbSBQb2xsaW5nLlxuICovXG5cbmluaGVyaXQoWEhSLCBQb2xsaW5nKTtcblxuLyoqXG4gKiBYSFIgc3VwcG9ydHMgYmluYXJ5XG4gKi9cblxuWEhSLnByb3RvdHlwZS5zdXBwb3J0c0JpbmFyeSA9IHRydWU7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHJlcXVlc3QuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuWEhSLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIG9wdHMudXJpID0gdGhpcy51cmkoKTtcbiAgb3B0cy54ZCA9IHRoaXMueGQ7XG4gIG9wdHMueHMgPSB0aGlzLnhzO1xuICBvcHRzLmFnZW50ID0gdGhpcy5hZ2VudCB8fCBmYWxzZTtcbiAgb3B0cy5zdXBwb3J0c0JpbmFyeSA9IHRoaXMuc3VwcG9ydHNCaW5hcnk7XG4gIG9wdHMuZW5hYmxlc1hEUiA9IHRoaXMuZW5hYmxlc1hEUjtcblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgb3B0cy5wZnggPSB0aGlzLnBmeDtcbiAgb3B0cy5rZXkgPSB0aGlzLmtleTtcbiAgb3B0cy5wYXNzcGhyYXNlID0gdGhpcy5wYXNzcGhyYXNlO1xuICBvcHRzLmNlcnQgPSB0aGlzLmNlcnQ7XG4gIG9wdHMuY2EgPSB0aGlzLmNhO1xuICBvcHRzLmNpcGhlcnMgPSB0aGlzLmNpcGhlcnM7XG4gIG9wdHMucmVqZWN0VW5hdXRob3JpemVkID0gdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQ7XG4gIG9wdHMucmVxdWVzdFRpbWVvdXQgPSB0aGlzLnJlcXVlc3RUaW1lb3V0O1xuXG4gIC8vIG90aGVyIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIG9wdHMuZXh0cmFIZWFkZXJzID0gdGhpcy5leHRyYUhlYWRlcnM7XG5cbiAgcmV0dXJuIG5ldyBSZXF1ZXN0KG9wdHMpO1xufTtcblxuLyoqXG4gKiBTZW5kcyBkYXRhLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhIHRvIHNlbmQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsZWQgdXBvbiBmbHVzaC5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblhIUi5wcm90b3R5cGUuZG9Xcml0ZSA9IGZ1bmN0aW9uIChkYXRhLCBmbikge1xuICB2YXIgaXNCaW5hcnkgPSB0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycgJiYgZGF0YSAhPT0gdW5kZWZpbmVkO1xuICB2YXIgcmVxID0gdGhpcy5yZXF1ZXN0KHsgbWV0aG9kOiAnUE9TVCcsIGRhdGE6IGRhdGEsIGlzQmluYXJ5OiBpc0JpbmFyeSB9KTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXEub24oJ3N1Y2Nlc3MnLCBmbik7XG4gIHJlcS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgc2VsZi5vbkVycm9yKCd4aHIgcG9zdCBlcnJvcicsIGVycik7XG4gIH0pO1xuICB0aGlzLnNlbmRYaHIgPSByZXE7XG59O1xuXG4vKipcbiAqIFN0YXJ0cyBhIHBvbGwgY3ljbGUuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuWEhSLnByb3RvdHlwZS5kb1BvbGwgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCd4aHIgcG9sbCcpO1xuICB2YXIgcmVxID0gdGhpcy5yZXF1ZXN0KCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmVxLm9uKCdkYXRhJywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBzZWxmLm9uRGF0YShkYXRhKTtcbiAgfSk7XG4gIHJlcS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgc2VsZi5vbkVycm9yKCd4aHIgcG9sbCBlcnJvcicsIGVycik7XG4gIH0pO1xuICB0aGlzLnBvbGxYaHIgPSByZXE7XG59O1xuXG4vKipcbiAqIFJlcXVlc3QgY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBSZXF1ZXN0IChvcHRzKSB7XG4gIHRoaXMubWV0aG9kID0gb3B0cy5tZXRob2QgfHwgJ0dFVCc7XG4gIHRoaXMudXJpID0gb3B0cy51cmk7XG4gIHRoaXMueGQgPSAhIW9wdHMueGQ7XG4gIHRoaXMueHMgPSAhIW9wdHMueHM7XG4gIHRoaXMuYXN5bmMgPSBmYWxzZSAhPT0gb3B0cy5hc3luYztcbiAgdGhpcy5kYXRhID0gdW5kZWZpbmVkICE9PSBvcHRzLmRhdGEgPyBvcHRzLmRhdGEgOiBudWxsO1xuICB0aGlzLmFnZW50ID0gb3B0cy5hZ2VudDtcbiAgdGhpcy5pc0JpbmFyeSA9IG9wdHMuaXNCaW5hcnk7XG4gIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSBvcHRzLnN1cHBvcnRzQmluYXJ5O1xuICB0aGlzLmVuYWJsZXNYRFIgPSBvcHRzLmVuYWJsZXNYRFI7XG4gIHRoaXMucmVxdWVzdFRpbWVvdXQgPSBvcHRzLnJlcXVlc3RUaW1lb3V0O1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLnBmeCA9IG9wdHMucGZ4O1xuICB0aGlzLmtleSA9IG9wdHMua2V5O1xuICB0aGlzLnBhc3NwaHJhc2UgPSBvcHRzLnBhc3NwaHJhc2U7XG4gIHRoaXMuY2VydCA9IG9wdHMuY2VydDtcbiAgdGhpcy5jYSA9IG9wdHMuY2E7XG4gIHRoaXMuY2lwaGVycyA9IG9wdHMuY2lwaGVycztcbiAgdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQgPSBvcHRzLnJlamVjdFVuYXV0aG9yaXplZDtcblxuICAvLyBvdGhlciBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLmV4dHJhSGVhZGVycyA9IG9wdHMuZXh0cmFIZWFkZXJzO1xuXG4gIHRoaXMuY3JlYXRlKCk7XG59XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFJlcXVlc3QucHJvdG90eXBlKTtcblxuLyoqXG4gKiBDcmVhdGVzIHRoZSBYSFIgb2JqZWN0IGFuZCBzZW5kcyB0aGUgcmVxdWVzdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBvcHRzID0geyBhZ2VudDogdGhpcy5hZ2VudCwgeGRvbWFpbjogdGhpcy54ZCwgeHNjaGVtZTogdGhpcy54cywgZW5hYmxlc1hEUjogdGhpcy5lbmFibGVzWERSIH07XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIG9wdHMucGZ4ID0gdGhpcy5wZng7XG4gIG9wdHMua2V5ID0gdGhpcy5rZXk7XG4gIG9wdHMucGFzc3BocmFzZSA9IHRoaXMucGFzc3BocmFzZTtcbiAgb3B0cy5jZXJ0ID0gdGhpcy5jZXJ0O1xuICBvcHRzLmNhID0gdGhpcy5jYTtcbiAgb3B0cy5jaXBoZXJzID0gdGhpcy5jaXBoZXJzO1xuICBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9IHRoaXMucmVqZWN0VW5hdXRob3JpemVkO1xuXG4gIHZhciB4aHIgPSB0aGlzLnhociA9IG5ldyBYTUxIdHRwUmVxdWVzdChvcHRzKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRyeSB7XG4gICAgZGVidWcoJ3hociBvcGVuICVzOiAlcycsIHRoaXMubWV0aG9kLCB0aGlzLnVyaSk7XG4gICAgeGhyLm9wZW4odGhpcy5tZXRob2QsIHRoaXMudXJpLCB0aGlzLmFzeW5jKTtcbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMuZXh0cmFIZWFkZXJzKSB7XG4gICAgICAgIHhoci5zZXREaXNhYmxlSGVhZGVyQ2hlY2sodHJ1ZSk7XG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5leHRyYUhlYWRlcnMpIHtcbiAgICAgICAgICBpZiAodGhpcy5leHRyYUhlYWRlcnMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGksIHRoaXMuZXh0cmFIZWFkZXJzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIGlmICh0aGlzLnN1cHBvcnRzQmluYXJ5KSB7XG4gICAgICAvLyBUaGlzIGhhcyB0byBiZSBkb25lIGFmdGVyIG9wZW4gYmVjYXVzZSBGaXJlZm94IGlzIHN0dXBpZFxuICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMzIxNjkwMy9nZXQtYmluYXJ5LWRhdGEtd2l0aC14bWxodHRwcmVxdWVzdC1pbi1hLWZpcmVmb3gtZXh0ZW5zaW9uXG4gICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICB9XG5cbiAgICBpZiAoJ1BPU1QnID09PSB0aGlzLm1ldGhvZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHRoaXMuaXNCaW5hcnkpIHtcbiAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LXR5cGUnLCAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04Jyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdBY2NlcHQnLCAnKi8qJyk7XG4gICAgfSBjYXRjaCAoZSkge31cblxuICAgIC8vIGllNiBjaGVja1xuICAgIGlmICgnd2l0aENyZWRlbnRpYWxzJyBpbiB4aHIpIHtcbiAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJlcXVlc3RUaW1lb3V0KSB7XG4gICAgICB4aHIudGltZW91dCA9IHRoaXMucmVxdWVzdFRpbWVvdXQ7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaGFzWERSKCkpIHtcbiAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYub25Mb2FkKCk7XG4gICAgICB9O1xuICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYub25FcnJvcih4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICg0ICE9PSB4aHIucmVhZHlTdGF0ZSkgcmV0dXJuO1xuICAgICAgICBpZiAoMjAwID09PSB4aHIuc3RhdHVzIHx8IDEyMjMgPT09IHhoci5zdGF0dXMpIHtcbiAgICAgICAgICBzZWxmLm9uTG9hZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgYGVycm9yYCBldmVudCBoYW5kbGVyIHRoYXQncyB1c2VyLXNldFxuICAgICAgICAgIC8vIGRvZXMgbm90IHRocm93IGluIHRoZSBzYW1lIHRpY2sgYW5kIGdldHMgY2F1Z2h0IGhlcmVcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNlbGYub25FcnJvcih4aHIuc3RhdHVzKTtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBkZWJ1ZygneGhyIGRhdGEgJXMnLCB0aGlzLmRhdGEpO1xuICAgIHhoci5zZW5kKHRoaXMuZGF0YSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBOZWVkIHRvIGRlZmVyIHNpbmNlIC5jcmVhdGUoKSBpcyBjYWxsZWQgZGlyZWN0bHkgZmhyb20gdGhlIGNvbnN0cnVjdG9yXG4gICAgLy8gYW5kIHRodXMgdGhlICdlcnJvcicgZXZlbnQgY2FuIG9ubHkgYmUgb25seSBib3VuZCAqYWZ0ZXIqIHRoaXMgZXhjZXB0aW9uXG4gICAgLy8gb2NjdXJzLiAgVGhlcmVmb3JlLCBhbHNvLCB3ZSBjYW5ub3QgdGhyb3cgaGVyZSBhdCBhbGwuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLm9uRXJyb3IoZSk7XG4gICAgfSwgMCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGdsb2JhbC5kb2N1bWVudCkge1xuICAgIHRoaXMuaW5kZXggPSBSZXF1ZXN0LnJlcXVlc3RzQ291bnQrKztcbiAgICBSZXF1ZXN0LnJlcXVlc3RzW3RoaXMuaW5kZXhdID0gdGhpcztcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzdWNjZXNzZnVsIHJlc3BvbnNlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uU3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0KCdzdWNjZXNzJyk7XG4gIHRoaXMuY2xlYW51cCgpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgaWYgd2UgaGF2ZSBkYXRhLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuZW1pdCgnZGF0YScsIGRhdGEpO1xuICB0aGlzLm9uU3VjY2VzcygpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBlcnJvci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgdGhpcy5jbGVhbnVwKHRydWUpO1xufTtcblxuLyoqXG4gKiBDbGVhbnMgdXAgaG91c2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uIChmcm9tRXJyb3IpIHtcbiAgaWYgKCd1bmRlZmluZWQnID09PSB0eXBlb2YgdGhpcy54aHIgfHwgbnVsbCA9PT0gdGhpcy54aHIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8geG1saHR0cHJlcXVlc3RcbiAgaWYgKHRoaXMuaGFzWERSKCkpIHtcbiAgICB0aGlzLnhoci5vbmxvYWQgPSB0aGlzLnhoci5vbmVycm9yID0gZW1wdHk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy54aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZW1wdHk7XG4gIH1cblxuICBpZiAoZnJvbUVycm9yKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMueGhyLmFib3J0KCk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuXG4gIGlmIChnbG9iYWwuZG9jdW1lbnQpIHtcbiAgICBkZWxldGUgUmVxdWVzdC5yZXF1ZXN0c1t0aGlzLmluZGV4XTtcbiAgfVxuXG4gIHRoaXMueGhyID0gbnVsbDtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gbG9hZC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5vbkxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBkYXRhO1xuICB0cnkge1xuICAgIHZhciBjb250ZW50VHlwZTtcbiAgICB0cnkge1xuICAgICAgY29udGVudFR5cGUgPSB0aGlzLnhoci5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1UeXBlJykuc3BsaXQoJzsnKVswXTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIGlmIChjb250ZW50VHlwZSA9PT0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpIHtcbiAgICAgIGRhdGEgPSB0aGlzLnhoci5yZXNwb25zZSB8fCB0aGlzLnhoci5yZXNwb25zZVRleHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghdGhpcy5zdXBwb3J0c0JpbmFyeSkge1xuICAgICAgICBkYXRhID0gdGhpcy54aHIucmVzcG9uc2VUZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkYXRhID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheSh0aGlzLnhoci5yZXNwb25zZSkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdmFyIHVpOEFyciA9IG5ldyBVaW50OEFycmF5KHRoaXMueGhyLnJlc3BvbnNlKTtcbiAgICAgICAgICB2YXIgZGF0YUFycmF5ID0gW107XG4gICAgICAgICAgZm9yICh2YXIgaWR4ID0gMCwgbGVuZ3RoID0gdWk4QXJyLmxlbmd0aDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgZGF0YUFycmF5LnB1c2godWk4QXJyW2lkeF0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRhdGEgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGRhdGFBcnJheSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aGlzLm9uRXJyb3IoZSk7XG4gIH1cbiAgaWYgKG51bGwgIT0gZGF0YSkge1xuICAgIHRoaXMub25EYXRhKGRhdGEpO1xuICB9XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGl0IGhhcyBYRG9tYWluUmVxdWVzdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5oYXNYRFIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGdsb2JhbC5YRG9tYWluUmVxdWVzdCAmJiAhdGhpcy54cyAmJiB0aGlzLmVuYWJsZXNYRFI7XG59O1xuXG4vKipcbiAqIEFib3J0cyB0aGUgcmVxdWVzdC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmNsZWFudXAoKTtcbn07XG5cbi8qKlxuICogQWJvcnRzIHBlbmRpbmcgcmVxdWVzdHMgd2hlbiB1bmxvYWRpbmcgdGhlIHdpbmRvdy4gVGhpcyBpcyBuZWVkZWQgdG8gcHJldmVudFxuICogbWVtb3J5IGxlYWtzIChlLmcuIHdoZW4gdXNpbmcgSUUpIGFuZCB0byBlbnN1cmUgdGhhdCBubyBzcHVyaW91cyBlcnJvciBpc1xuICogZW1pdHRlZC5cbiAqL1xuXG5SZXF1ZXN0LnJlcXVlc3RzQ291bnQgPSAwO1xuUmVxdWVzdC5yZXF1ZXN0cyA9IHt9O1xuXG5pZiAoZ2xvYmFsLmRvY3VtZW50KSB7XG4gIGlmIChnbG9iYWwuYXR0YWNoRXZlbnQpIHtcbiAgICBnbG9iYWwuYXR0YWNoRXZlbnQoJ29udW5sb2FkJywgdW5sb2FkSGFuZGxlcik7XG4gIH0gZWxzZSBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgdW5sb2FkSGFuZGxlciwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVubG9hZEhhbmRsZXIgKCkge1xuICBmb3IgKHZhciBpIGluIFJlcXVlc3QucmVxdWVzdHMpIHtcbiAgICBpZiAoUmVxdWVzdC5yZXF1ZXN0cy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgUmVxdWVzdC5yZXF1ZXN0c1tpXS5hYm9ydCgpO1xuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBUcmFuc3BvcnQgPSByZXF1aXJlKCcuLi90cmFuc3BvcnQnKTtcbnZhciBwYXJzZXFzID0gcmVxdWlyZSgncGFyc2VxcycpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcbnZhciBpbmhlcml0ID0gcmVxdWlyZSgnY29tcG9uZW50LWluaGVyaXQnKTtcbnZhciB5ZWFzdCA9IHJlcXVpcmUoJ3llYXN0Jyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbmdpbmUuaW8tY2xpZW50OnBvbGxpbmcnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvbGxpbmc7XG5cbi8qKlxuICogSXMgWEhSMiBzdXBwb3J0ZWQ/XG4gKi9cblxudmFyIGhhc1hIUjIgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgWE1MSHR0cFJlcXVlc3QgPSByZXF1aXJlKCd4bWxodHRwcmVxdWVzdC1zc2wnKTtcbiAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCh7IHhkb21haW46IGZhbHNlIH0pO1xuICByZXR1cm4gbnVsbCAhPSB4aHIucmVzcG9uc2VUeXBlO1xufSkoKTtcblxuLyoqXG4gKiBQb2xsaW5nIGludGVyZmFjZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gUG9sbGluZyAob3B0cykge1xuICB2YXIgZm9yY2VCYXNlNjQgPSAob3B0cyAmJiBvcHRzLmZvcmNlQmFzZTY0KTtcbiAgaWYgKCFoYXNYSFIyIHx8IGZvcmNlQmFzZTY0KSB7XG4gICAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuICB9XG4gIFRyYW5zcG9ydC5jYWxsKHRoaXMsIG9wdHMpO1xufVxuXG4vKipcbiAqIEluaGVyaXRzIGZyb20gVHJhbnNwb3J0LlxuICovXG5cbmluaGVyaXQoUG9sbGluZywgVHJhbnNwb3J0KTtcblxuLyoqXG4gKiBUcmFuc3BvcnQgbmFtZS5cbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5uYW1lID0gJ3BvbGxpbmcnO1xuXG4vKipcbiAqIE9wZW5zIHRoZSBzb2NrZXQgKHRyaWdnZXJzIHBvbGxpbmcpLiBXZSB3cml0ZSBhIFBJTkcgbWVzc2FnZSB0byBkZXRlcm1pbmVcbiAqIHdoZW4gdGhlIHRyYW5zcG9ydCBpcyBvcGVuLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLmRvT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5wb2xsKCk7XG59O1xuXG4vKipcbiAqIFBhdXNlcyBwb2xsaW5nLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIHVwb24gYnVmZmVycyBhcmUgZmx1c2hlZCBhbmQgdHJhbnNwb3J0IGlzIHBhdXNlZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAob25QYXVzZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy5yZWFkeVN0YXRlID0gJ3BhdXNpbmcnO1xuXG4gIGZ1bmN0aW9uIHBhdXNlICgpIHtcbiAgICBkZWJ1ZygncGF1c2VkJyk7XG4gICAgc2VsZi5yZWFkeVN0YXRlID0gJ3BhdXNlZCc7XG4gICAgb25QYXVzZSgpO1xuICB9XG5cbiAgaWYgKHRoaXMucG9sbGluZyB8fCAhdGhpcy53cml0YWJsZSkge1xuICAgIHZhciB0b3RhbCA9IDA7XG5cbiAgICBpZiAodGhpcy5wb2xsaW5nKSB7XG4gICAgICBkZWJ1Zygnd2UgYXJlIGN1cnJlbnRseSBwb2xsaW5nIC0gd2FpdGluZyB0byBwYXVzZScpO1xuICAgICAgdG90YWwrKztcbiAgICAgIHRoaXMub25jZSgncG9sbENvbXBsZXRlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBkZWJ1ZygncHJlLXBhdXNlIHBvbGxpbmcgY29tcGxldGUnKTtcbiAgICAgICAgLS10b3RhbCB8fCBwYXVzZSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLndyaXRhYmxlKSB7XG4gICAgICBkZWJ1Zygnd2UgYXJlIGN1cnJlbnRseSB3cml0aW5nIC0gd2FpdGluZyB0byBwYXVzZScpO1xuICAgICAgdG90YWwrKztcbiAgICAgIHRoaXMub25jZSgnZHJhaW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRlYnVnKCdwcmUtcGF1c2Ugd3JpdGluZyBjb21wbGV0ZScpO1xuICAgICAgICAtLXRvdGFsIHx8IHBhdXNlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcGF1c2UoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTdGFydHMgcG9sbGluZyBjeWNsZS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblBvbGxpbmcucHJvdG90eXBlLnBvbGwgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdwb2xsaW5nJyk7XG4gIHRoaXMucG9sbGluZyA9IHRydWU7XG4gIHRoaXMuZG9Qb2xsKCk7XG4gIHRoaXMuZW1pdCgncG9sbCcpO1xufTtcblxuLyoqXG4gKiBPdmVybG9hZHMgb25EYXRhIHRvIGRldGVjdCBwYXlsb2Fkcy5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGRlYnVnKCdwb2xsaW5nIGdvdCBkYXRhICVzJywgZGF0YSk7XG4gIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uIChwYWNrZXQsIGluZGV4LCB0b3RhbCkge1xuICAgIC8vIGlmIGl0cyB0aGUgZmlyc3QgbWVzc2FnZSB3ZSBjb25zaWRlciB0aGUgdHJhbnNwb3J0IG9wZW5cbiAgICBpZiAoJ29wZW5pbmcnID09PSBzZWxmLnJlYWR5U3RhdGUpIHtcbiAgICAgIHNlbGYub25PcGVuKCk7XG4gICAgfVxuXG4gICAgLy8gaWYgaXRzIGEgY2xvc2UgcGFja2V0LCB3ZSBjbG9zZSB0aGUgb25nb2luZyByZXF1ZXN0c1xuICAgIGlmICgnY2xvc2UnID09PSBwYWNrZXQudHlwZSkge1xuICAgICAgc2VsZi5vbkNsb3NlKCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gb3RoZXJ3aXNlIGJ5cGFzcyBvbkRhdGEgYW5kIGhhbmRsZSB0aGUgbWVzc2FnZVxuICAgIHNlbGYub25QYWNrZXQocGFja2V0KTtcbiAgfTtcblxuICAvLyBkZWNvZGUgcGF5bG9hZFxuICBwYXJzZXIuZGVjb2RlUGF5bG9hZChkYXRhLCB0aGlzLnNvY2tldC5iaW5hcnlUeXBlLCBjYWxsYmFjayk7XG5cbiAgLy8gaWYgYW4gZXZlbnQgZGlkIG5vdCB0cmlnZ2VyIGNsb3NpbmdcbiAgaWYgKCdjbG9zZWQnICE9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAvLyBpZiB3ZSBnb3QgZGF0YSB3ZSdyZSBub3QgcG9sbGluZ1xuICAgIHRoaXMucG9sbGluZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncG9sbENvbXBsZXRlJyk7XG5cbiAgICBpZiAoJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAgIHRoaXMucG9sbCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1ZygnaWdub3JpbmcgcG9sbCAtIHRyYW5zcG9ydCBzdGF0ZSBcIiVzXCInLCB0aGlzLnJlYWR5U3RhdGUpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBGb3IgcG9sbGluZywgc2VuZCBhIGNsb3NlIHBhY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5kb0Nsb3NlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gY2xvc2UgKCkge1xuICAgIGRlYnVnKCd3cml0aW5nIGNsb3NlIHBhY2tldCcpO1xuICAgIHNlbGYud3JpdGUoW3sgdHlwZTogJ2Nsb3NlJyB9XSk7XG4gIH1cblxuICBpZiAoJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICBkZWJ1ZygndHJhbnNwb3J0IG9wZW4gLSBjbG9zaW5nJyk7XG4gICAgY2xvc2UoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBpbiBjYXNlIHdlJ3JlIHRyeWluZyB0byBjbG9zZSB3aGlsZVxuICAgIC8vIGhhbmRzaGFraW5nIGlzIGluIHByb2dyZXNzIChHSC0xNjQpXG4gICAgZGVidWcoJ3RyYW5zcG9ydCBub3Qgb3BlbiAtIGRlZmVycmluZyBjbG9zZScpO1xuICAgIHRoaXMub25jZSgnb3BlbicsIGNsb3NlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBwYWNrZXRzIHBheWxvYWQuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gZGF0YSBwYWNrZXRzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBkcmFpbiBjYWxsYmFja1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAocGFja2V0cykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcbiAgdmFyIGNhbGxiYWNrZm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi53cml0YWJsZSA9IHRydWU7XG4gICAgc2VsZi5lbWl0KCdkcmFpbicpO1xuICB9O1xuXG4gIHBhcnNlci5lbmNvZGVQYXlsb2FkKHBhY2tldHMsIHRoaXMuc3VwcG9ydHNCaW5hcnksIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgc2VsZi5kb1dyaXRlKGRhdGEsIGNhbGxiYWNrZm4pO1xuICB9KTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIHVyaSBmb3IgY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS51cmkgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBxdWVyeSA9IHRoaXMucXVlcnkgfHwge307XG4gIHZhciBzY2hlbWEgPSB0aGlzLnNlY3VyZSA/ICdodHRwcycgOiAnaHR0cCc7XG4gIHZhciBwb3J0ID0gJyc7XG5cbiAgLy8gY2FjaGUgYnVzdGluZyBpcyBmb3JjZWRcbiAgaWYgKGZhbHNlICE9PSB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzKSB7XG4gICAgcXVlcnlbdGhpcy50aW1lc3RhbXBQYXJhbV0gPSB5ZWFzdCgpO1xuICB9XG5cbiAgaWYgKCF0aGlzLnN1cHBvcnRzQmluYXJ5ICYmICFxdWVyeS5zaWQpIHtcbiAgICBxdWVyeS5iNjQgPSAxO1xuICB9XG5cbiAgcXVlcnkgPSBwYXJzZXFzLmVuY29kZShxdWVyeSk7XG5cbiAgLy8gYXZvaWQgcG9ydCBpZiBkZWZhdWx0IGZvciBzY2hlbWFcbiAgaWYgKHRoaXMucG9ydCAmJiAoKCdodHRwcycgPT09IHNjaGVtYSAmJiBOdW1iZXIodGhpcy5wb3J0KSAhPT0gNDQzKSB8fFxuICAgICAoJ2h0dHAnID09PSBzY2hlbWEgJiYgTnVtYmVyKHRoaXMucG9ydCkgIT09IDgwKSkpIHtcbiAgICBwb3J0ID0gJzonICsgdGhpcy5wb3J0O1xuICB9XG5cbiAgLy8gcHJlcGVuZCA/IHRvIHF1ZXJ5XG4gIGlmIChxdWVyeS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9ICc/JyArIHF1ZXJ5O1xuICB9XG5cbiAgdmFyIGlwdjYgPSB0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSAhPT0gLTE7XG4gIHJldHVybiBzY2hlbWEgKyAnOi8vJyArIChpcHY2ID8gJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyA6IHRoaXMuaG9zdG5hbWUpICsgcG9ydCArIHRoaXMucGF0aCArIHF1ZXJ5O1xufTtcbiIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi4vdHJhbnNwb3J0Jyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xudmFyIHBhcnNlcXMgPSByZXF1aXJlKCdwYXJzZXFzJyk7XG52YXIgaW5oZXJpdCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1pbmhlcml0Jyk7XG52YXIgeWVhc3QgPSByZXF1aXJlKCd5ZWFzdCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZW5naW5lLmlvLWNsaWVudDp3ZWJzb2NrZXQnKTtcbnZhciBCcm93c2VyV2ViU29ja2V0ID0gZ2xvYmFsLldlYlNvY2tldCB8fCBnbG9iYWwuTW96V2ViU29ja2V0O1xudmFyIE5vZGVXZWJTb2NrZXQ7XG5pZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgdHJ5IHtcbiAgICBOb2RlV2ViU29ja2V0ID0gcmVxdWlyZSgnd3MnKTtcbiAgfSBjYXRjaCAoZSkgeyB9XG59XG5cbi8qKlxuICogR2V0IGVpdGhlciB0aGUgYFdlYlNvY2tldGAgb3IgYE1veldlYlNvY2tldGAgZ2xvYmFsc1xuICogaW4gdGhlIGJyb3dzZXIgb3IgdHJ5IHRvIHJlc29sdmUgV2ViU29ja2V0LWNvbXBhdGlibGVcbiAqIGludGVyZmFjZSBleHBvc2VkIGJ5IGB3c2AgZm9yIE5vZGUtbGlrZSBlbnZpcm9ubWVudC5cbiAqL1xuXG52YXIgV2ViU29ja2V0ID0gQnJvd3NlcldlYlNvY2tldDtcbmlmICghV2ViU29ja2V0ICYmIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gIFdlYlNvY2tldCA9IE5vZGVXZWJTb2NrZXQ7XG59XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBXUztcblxuLyoqXG4gKiBXZWJTb2NrZXQgdHJhbnNwb3J0IGNvbnN0cnVjdG9yLlxuICpcbiAqIEBhcGkge09iamVjdH0gY29ubmVjdGlvbiBvcHRpb25zXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFdTIChvcHRzKSB7XG4gIHZhciBmb3JjZUJhc2U2NCA9IChvcHRzICYmIG9wdHMuZm9yY2VCYXNlNjQpO1xuICBpZiAoZm9yY2VCYXNlNjQpIHtcbiAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cbiAgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSA9IG9wdHMucGVyTWVzc2FnZURlZmxhdGU7XG4gIHRoaXMudXNpbmdCcm93c2VyV2ViU29ja2V0ID0gQnJvd3NlcldlYlNvY2tldCAmJiAhb3B0cy5mb3JjZU5vZGU7XG4gIGlmICghdGhpcy51c2luZ0Jyb3dzZXJXZWJTb2NrZXQpIHtcbiAgICBXZWJTb2NrZXQgPSBOb2RlV2ViU29ja2V0O1xuICB9XG4gIFRyYW5zcG9ydC5jYWxsKHRoaXMsIG9wdHMpO1xufVxuXG4vKipcbiAqIEluaGVyaXRzIGZyb20gVHJhbnNwb3J0LlxuICovXG5cbmluaGVyaXQoV1MsIFRyYW5zcG9ydCk7XG5cbi8qKlxuICogVHJhbnNwb3J0IG5hbWUuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5XUy5wcm90b3R5cGUubmFtZSA9ICd3ZWJzb2NrZXQnO1xuXG4vKlxuICogV2ViU29ja2V0cyBzdXBwb3J0IGJpbmFyeVxuICovXG5cbldTLnByb3RvdHlwZS5zdXBwb3J0c0JpbmFyeSA9IHRydWU7XG5cbi8qKlxuICogT3BlbnMgc29ja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS5kb09wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5jaGVjaygpKSB7XG4gICAgLy8gbGV0IHByb2JlIHRpbWVvdXRcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgdXJpID0gdGhpcy51cmkoKTtcbiAgdmFyIHByb3RvY29scyA9IHZvaWQgKDApO1xuICB2YXIgb3B0cyA9IHtcbiAgICBhZ2VudDogdGhpcy5hZ2VudCxcbiAgICBwZXJNZXNzYWdlRGVmbGF0ZTogdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZVxuICB9O1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICBvcHRzLnBmeCA9IHRoaXMucGZ4O1xuICBvcHRzLmtleSA9IHRoaXMua2V5O1xuICBvcHRzLnBhc3NwaHJhc2UgPSB0aGlzLnBhc3NwaHJhc2U7XG4gIG9wdHMuY2VydCA9IHRoaXMuY2VydDtcbiAgb3B0cy5jYSA9IHRoaXMuY2E7XG4gIG9wdHMuY2lwaGVycyA9IHRoaXMuY2lwaGVycztcbiAgb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPSB0aGlzLnJlamVjdFVuYXV0aG9yaXplZDtcbiAgaWYgKHRoaXMuZXh0cmFIZWFkZXJzKSB7XG4gICAgb3B0cy5oZWFkZXJzID0gdGhpcy5leHRyYUhlYWRlcnM7XG4gIH1cbiAgaWYgKHRoaXMubG9jYWxBZGRyZXNzKSB7XG4gICAgb3B0cy5sb2NhbEFkZHJlc3MgPSB0aGlzLmxvY2FsQWRkcmVzcztcbiAgfVxuXG4gIHRyeSB7XG4gICAgdGhpcy53cyA9IHRoaXMudXNpbmdCcm93c2VyV2ViU29ja2V0ID8gbmV3IFdlYlNvY2tldCh1cmkpIDogbmV3IFdlYlNvY2tldCh1cmksIHByb3RvY29scywgb3B0cyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgfVxuXG4gIGlmICh0aGlzLndzLmJpbmFyeVR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLndzLnN1cHBvcnRzICYmIHRoaXMud3Muc3VwcG9ydHMuYmluYXJ5KSB7XG4gICAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IHRydWU7XG4gICAgdGhpcy53cy5iaW5hcnlUeXBlID0gJ25vZGVidWZmZXInO1xuICB9IGVsc2Uge1xuICAgIHRoaXMud3MuYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gIH1cblxuICB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKCk7XG59O1xuXG4vKipcbiAqIEFkZHMgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBzb2NrZXRcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0aGlzLndzLm9ub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLm9uT3BlbigpO1xuICB9O1xuICB0aGlzLndzLm9uY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5vbkNsb3NlKCk7XG4gIH07XG4gIHRoaXMud3Mub25tZXNzYWdlID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgc2VsZi5vbkRhdGEoZXYuZGF0YSk7XG4gIH07XG4gIHRoaXMud3Mub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgc2VsZi5vbkVycm9yKCd3ZWJzb2NrZXQgZXJyb3InLCBlKTtcbiAgfTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGRhdGEgdG8gc29ja2V0LlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IG9mIHBhY2tldHMuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAocGFja2V0cykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICAvLyBlbmNvZGVQYWNrZXQgZWZmaWNpZW50IGFzIGl0IHVzZXMgV1MgZnJhbWluZ1xuICAvLyBubyBuZWVkIGZvciBlbmNvZGVQYXlsb2FkXG4gIHZhciB0b3RhbCA9IHBhY2tldHMubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHRvdGFsOyBpIDwgbDsgaSsrKSB7XG4gICAgKGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgICAgIHBhcnNlci5lbmNvZGVQYWNrZXQocGFja2V0LCBzZWxmLnN1cHBvcnRzQmluYXJ5LCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAoIXNlbGYudXNpbmdCcm93c2VyV2ViU29ja2V0KSB7XG4gICAgICAgICAgLy8gYWx3YXlzIGNyZWF0ZSBhIG5ldyBvYmplY3QgKEdILTQzNylcbiAgICAgICAgICB2YXIgb3B0cyA9IHt9O1xuICAgICAgICAgIGlmIChwYWNrZXQub3B0aW9ucykge1xuICAgICAgICAgICAgb3B0cy5jb21wcmVzcyA9IHBhY2tldC5vcHRpb25zLmNvbXByZXNzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzZWxmLnBlck1lc3NhZ2VEZWZsYXRlKSB7XG4gICAgICAgICAgICB2YXIgbGVuID0gJ3N0cmluZycgPT09IHR5cGVvZiBkYXRhID8gZ2xvYmFsLkJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpIDogZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobGVuIDwgc2VsZi5wZXJNZXNzYWdlRGVmbGF0ZS50aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgb3B0cy5jb21wcmVzcyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNvbWV0aW1lcyB0aGUgd2Vic29ja2V0IGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkIGJ1dCB0aGUgYnJvd3NlciBkaWRuJ3RcbiAgICAgICAgLy8gaGF2ZSBhIGNoYW5jZSBvZiBpbmZvcm1pbmcgdXMgYWJvdXQgaXQgeWV0LCBpbiB0aGF0IGNhc2Ugc2VuZCB3aWxsXG4gICAgICAgIC8vIHRocm93IGFuIGVycm9yXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKHNlbGYudXNpbmdCcm93c2VyV2ViU29ja2V0KSB7XG4gICAgICAgICAgICAvLyBUeXBlRXJyb3IgaXMgdGhyb3duIHdoZW4gcGFzc2luZyB0aGUgc2Vjb25kIGFyZ3VtZW50IG9uIFNhZmFyaVxuICAgICAgICAgICAgc2VsZi53cy5zZW5kKGRhdGEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLndzLnNlbmQoZGF0YSwgb3B0cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZGVidWcoJ3dlYnNvY2tldCBjbG9zZWQgYmVmb3JlIG9uY2xvc2UgZXZlbnQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC0tdG90YWwgfHwgZG9uZSgpO1xuICAgICAgfSk7XG4gICAgfSkocGFja2V0c1tpXSk7XG4gIH1cblxuICBmdW5jdGlvbiBkb25lICgpIHtcbiAgICBzZWxmLmVtaXQoJ2ZsdXNoJyk7XG5cbiAgICAvLyBmYWtlIGRyYWluXG4gICAgLy8gZGVmZXIgdG8gbmV4dCB0aWNrIHRvIGFsbG93IFNvY2tldCB0byBjbGVhciB3cml0ZUJ1ZmZlclxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi53cml0YWJsZSA9IHRydWU7XG4gICAgICBzZWxmLmVtaXQoJ2RyYWluJyk7XG4gICAgfSwgMCk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gY2xvc2VcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUub25DbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgVHJhbnNwb3J0LnByb3RvdHlwZS5vbkNsb3NlLmNhbGwodGhpcyk7XG59O1xuXG4vKipcbiAqIENsb3NlcyBzb2NrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLmRvQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0eXBlb2YgdGhpcy53cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aGlzLndzLmNsb3NlKCk7XG4gIH1cbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIHVyaSBmb3IgY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUudXJpID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcXVlcnkgPSB0aGlzLnF1ZXJ5IHx8IHt9O1xuICB2YXIgc2NoZW1hID0gdGhpcy5zZWN1cmUgPyAnd3NzJyA6ICd3cyc7XG4gIHZhciBwb3J0ID0gJyc7XG5cbiAgLy8gYXZvaWQgcG9ydCBpZiBkZWZhdWx0IGZvciBzY2hlbWFcbiAgaWYgKHRoaXMucG9ydCAmJiAoKCd3c3MnID09PSBzY2hlbWEgJiYgTnVtYmVyKHRoaXMucG9ydCkgIT09IDQ0MykgfHxcbiAgICAoJ3dzJyA9PT0gc2NoZW1hICYmIE51bWJlcih0aGlzLnBvcnQpICE9PSA4MCkpKSB7XG4gICAgcG9ydCA9ICc6JyArIHRoaXMucG9ydDtcbiAgfVxuXG4gIC8vIGFwcGVuZCB0aW1lc3RhbXAgdG8gVVJJXG4gIGlmICh0aGlzLnRpbWVzdGFtcFJlcXVlc3RzKSB7XG4gICAgcXVlcnlbdGhpcy50aW1lc3RhbXBQYXJhbV0gPSB5ZWFzdCgpO1xuICB9XG5cbiAgLy8gY29tbXVuaWNhdGUgYmluYXJ5IHN1cHBvcnQgY2FwYWJpbGl0aWVzXG4gIGlmICghdGhpcy5zdXBwb3J0c0JpbmFyeSkge1xuICAgIHF1ZXJ5LmI2NCA9IDE7XG4gIH1cblxuICBxdWVyeSA9IHBhcnNlcXMuZW5jb2RlKHF1ZXJ5KTtcblxuICAvLyBwcmVwZW5kID8gdG8gcXVlcnlcbiAgaWYgKHF1ZXJ5Lmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gJz8nICsgcXVlcnk7XG4gIH1cblxuICB2YXIgaXB2NiA9IHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpICE9PSAtMTtcbiAgcmV0dXJuIHNjaGVtYSArICc6Ly8nICsgKGlwdjYgPyAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nIDogdGhpcy5ob3N0bmFtZSkgKyBwb3J0ICsgdGhpcy5wYXRoICsgcXVlcnk7XG59O1xuXG4vKipcbiAqIEZlYXR1cmUgZGV0ZWN0aW9uIGZvciBXZWJTb2NrZXQuXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn0gd2hldGhlciB0aGlzIHRyYW5zcG9ydCBpcyBhdmFpbGFibGUuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbldTLnByb3RvdHlwZS5jaGVjayA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICEhV2ViU29ja2V0ICYmICEoJ19faW5pdGlhbGl6ZScgaW4gV2ViU29ja2V0ICYmIHRoaXMubmFtZSA9PT0gV1MucHJvdG90eXBlLm5hbWUpO1xufTtcbiIsIi8vIGJyb3dzZXIgc2hpbSBmb3IgeG1saHR0cHJlcXVlc3QgbW9kdWxlXG5cbnZhciBoYXNDT1JTID0gcmVxdWlyZSgnaGFzLWNvcnMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0cykge1xuICB2YXIgeGRvbWFpbiA9IG9wdHMueGRvbWFpbjtcblxuICAvLyBzY2hlbWUgbXVzdCBiZSBzYW1lIHdoZW4gdXNpZ24gWERvbWFpblJlcXVlc3RcbiAgLy8gaHR0cDovL2Jsb2dzLm1zZG4uY29tL2IvaWVpbnRlcm5hbHMvYXJjaGl2ZS8yMDEwLzA1LzEzL3hkb21haW5yZXF1ZXN0LXJlc3RyaWN0aW9ucy1saW1pdGF0aW9ucy1hbmQtd29ya2Fyb3VuZHMuYXNweFxuICB2YXIgeHNjaGVtZSA9IG9wdHMueHNjaGVtZTtcblxuICAvLyBYRG9tYWluUmVxdWVzdCBoYXMgYSBmbG93IG9mIG5vdCBzZW5kaW5nIGNvb2tpZSwgdGhlcmVmb3JlIGl0IHNob3VsZCBiZSBkaXNhYmxlZCBhcyBhIGRlZmF1bHQuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9BdXRvbWF0dGljL2VuZ2luZS5pby1jbGllbnQvcHVsbC8yMTdcbiAgdmFyIGVuYWJsZXNYRFIgPSBvcHRzLmVuYWJsZXNYRFI7XG5cbiAgLy8gWE1MSHR0cFJlcXVlc3QgY2FuIGJlIGRpc2FibGVkIG9uIElFXG4gIHRyeSB7XG4gICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgWE1MSHR0cFJlcXVlc3QgJiYgKCF4ZG9tYWluIHx8IGhhc0NPUlMpKSB7XG4gICAgICByZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7IH1cblxuICAvLyBVc2UgWERvbWFpblJlcXVlc3QgZm9yIElFOCBpZiBlbmFibGVzWERSIGlzIHRydWVcbiAgLy8gYmVjYXVzZSBsb2FkaW5nIGJhciBrZWVwcyBmbGFzaGluZyB3aGVuIHVzaW5nIGpzb25wLXBvbGxpbmdcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3l1amlvc2FrYS9zb2NrZS5pby1pZTgtbG9hZGluZy1leGFtcGxlXG4gIHRyeSB7XG4gICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgWERvbWFpblJlcXVlc3QgJiYgIXhzY2hlbWUgJiYgZW5hYmxlc1hEUikge1xuICAgICAgcmV0dXJuIG5ldyBYRG9tYWluUmVxdWVzdCgpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkgeyB9XG5cbiAgaWYgKCF4ZG9tYWluKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBuZXcgZ2xvYmFsW1snQWN0aXZlJ10uY29uY2F0KCdPYmplY3QnKS5qb2luKCdYJyldKCdNaWNyb3NvZnQuWE1MSFRUUCcpO1xuICAgIH0gY2F0Y2ggKGUpIHsgfVxuICB9XG59O1xuIiwiXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGEsIGIpe1xuICB2YXIgZm4gPSBmdW5jdGlvbigpe307XG4gIGZuLnByb3RvdHlwZSA9IGIucHJvdG90eXBlO1xuICBhLnByb3RvdHlwZSA9IG5ldyBmbjtcbiAgYS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBhO1xufTsiLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcbnZhciBoYXNCaW5hcnkgPSByZXF1aXJlKCdoYXMtYmluYXJ5Jyk7XG52YXIgc2xpY2VCdWZmZXIgPSByZXF1aXJlKCdhcnJheWJ1ZmZlci5zbGljZScpO1xudmFyIGFmdGVyID0gcmVxdWlyZSgnYWZ0ZXInKTtcbnZhciB1dGY4ID0gcmVxdWlyZSgnd3RmLTgnKTtcblxudmFyIGJhc2U2NGVuY29kZXI7XG5pZiAoZ2xvYmFsICYmIGdsb2JhbC5BcnJheUJ1ZmZlcikge1xuICBiYXNlNjRlbmNvZGVyID0gcmVxdWlyZSgnYmFzZTY0LWFycmF5YnVmZmVyJyk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgd2UgYXJlIHJ1bm5pbmcgYW4gYW5kcm9pZCBicm93c2VyLiBUaGF0IHJlcXVpcmVzIHVzIHRvIHVzZVxuICogQXJyYXlCdWZmZXIgd2l0aCBwb2xsaW5nIHRyYW5zcG9ydHMuLi5cbiAqXG4gKiBodHRwOi8vZ2hpbmRhLm5ldC9qcGVnLWJsb2ItYWpheC1hbmRyb2lkL1xuICovXG5cbnZhciBpc0FuZHJvaWQgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvQW5kcm9pZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbi8qKlxuICogQ2hlY2sgaWYgd2UgYXJlIHJ1bm5pbmcgaW4gUGhhbnRvbUpTLlxuICogVXBsb2FkaW5nIGEgQmxvYiB3aXRoIFBoYW50b21KUyBkb2VzIG5vdCB3b3JrIGNvcnJlY3RseSwgYXMgcmVwb3J0ZWQgaGVyZTpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9hcml5YS9waGFudG9tanMvaXNzdWVzLzExMzk1XG4gKiBAdHlwZSBib29sZWFuXG4gKi9cbnZhciBpc1BoYW50b21KUyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9QaGFudG9tSlMvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4vKipcbiAqIFdoZW4gdHJ1ZSwgYXZvaWRzIHVzaW5nIEJsb2JzIHRvIGVuY29kZSBwYXlsb2Fkcy5cbiAqIEB0eXBlIGJvb2xlYW5cbiAqL1xudmFyIGRvbnRTZW5kQmxvYnMgPSBpc0FuZHJvaWQgfHwgaXNQaGFudG9tSlM7XG5cbi8qKlxuICogQ3VycmVudCBwcm90b2NvbCB2ZXJzaW9uLlxuICovXG5cbmV4cG9ydHMucHJvdG9jb2wgPSAzO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlcy5cbiAqL1xuXG52YXIgcGFja2V0cyA9IGV4cG9ydHMucGFja2V0cyA9IHtcbiAgICBvcGVuOiAgICAgMCAgICAvLyBub24td3NcbiAgLCBjbG9zZTogICAgMSAgICAvLyBub24td3NcbiAgLCBwaW5nOiAgICAgMlxuICAsIHBvbmc6ICAgICAzXG4gICwgbWVzc2FnZTogIDRcbiAgLCB1cGdyYWRlOiAgNVxuICAsIG5vb3A6ICAgICA2XG59O1xuXG52YXIgcGFja2V0c2xpc3QgPSBrZXlzKHBhY2tldHMpO1xuXG4vKipcbiAqIFByZW1hZGUgZXJyb3IgcGFja2V0LlxuICovXG5cbnZhciBlcnIgPSB7IHR5cGU6ICdlcnJvcicsIGRhdGE6ICdwYXJzZXIgZXJyb3InIH07XG5cbi8qKlxuICogQ3JlYXRlIGEgYmxvYiBhcGkgZXZlbiBmb3IgYmxvYiBidWlsZGVyIHdoZW4gdmVuZG9yIHByZWZpeGVzIGV4aXN0XG4gKi9cblxudmFyIEJsb2IgPSByZXF1aXJlKCdibG9iJyk7XG5cbi8qKlxuICogRW5jb2RlcyBhIHBhY2tldC5cbiAqXG4gKiAgICAgPHBhY2tldCB0eXBlIGlkPiBbIDxkYXRhPiBdXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgNWhlbGxvIHdvcmxkXG4gKiAgICAgM1xuICogICAgIDRcbiAqXG4gKiBCaW5hcnkgaXMgZW5jb2RlZCBpbiBhbiBpZGVudGljYWwgcHJpbmNpcGxlXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVQYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgdXRmOGVuY29kZSwgY2FsbGJhY2spIHtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIHN1cHBvcnRzQmluYXJ5KSB7XG4gICAgY2FsbGJhY2sgPSBzdXBwb3J0c0JpbmFyeTtcbiAgICBzdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIHV0ZjhlbmNvZGUpIHtcbiAgICBjYWxsYmFjayA9IHV0ZjhlbmNvZGU7XG4gICAgdXRmOGVuY29kZSA9IG51bGw7XG4gIH1cblxuICB2YXIgZGF0YSA9IChwYWNrZXQuZGF0YSA9PT0gdW5kZWZpbmVkKVxuICAgID8gdW5kZWZpbmVkXG4gICAgOiBwYWNrZXQuZGF0YS5idWZmZXIgfHwgcGFja2V0LmRhdGE7XG5cbiAgaWYgKGdsb2JhbC5BcnJheUJ1ZmZlciAmJiBkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZW5jb2RlQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spO1xuICB9IGVsc2UgaWYgKEJsb2IgJiYgZGF0YSBpbnN0YW5jZW9mIGdsb2JhbC5CbG9iKSB7XG4gICAgcmV0dXJuIGVuY29kZUJsb2IocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spO1xuICB9XG5cbiAgLy8gbWlnaHQgYmUgYW4gb2JqZWN0IHdpdGggeyBiYXNlNjQ6IHRydWUsIGRhdGE6IGRhdGFBc0Jhc2U2NFN0cmluZyB9XG4gIGlmIChkYXRhICYmIGRhdGEuYmFzZTY0KSB7XG4gICAgcmV0dXJuIGVuY29kZUJhc2U2NE9iamVjdChwYWNrZXQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8vIFNlbmRpbmcgZGF0YSBhcyBhIHV0Zi04IHN0cmluZ1xuICB2YXIgZW5jb2RlZCA9IHBhY2tldHNbcGFja2V0LnR5cGVdO1xuXG4gIC8vIGRhdGEgZnJhZ21lbnQgaXMgb3B0aW9uYWxcbiAgaWYgKHVuZGVmaW5lZCAhPT0gcGFja2V0LmRhdGEpIHtcbiAgICBlbmNvZGVkICs9IHV0ZjhlbmNvZGUgPyB1dGY4LmVuY29kZShTdHJpbmcocGFja2V0LmRhdGEpKSA6IFN0cmluZyhwYWNrZXQuZGF0YSk7XG4gIH1cblxuICByZXR1cm4gY2FsbGJhY2soJycgKyBlbmNvZGVkKTtcblxufTtcblxuZnVuY3Rpb24gZW5jb2RlQmFzZTY0T2JqZWN0KHBhY2tldCwgY2FsbGJhY2spIHtcbiAgLy8gcGFja2V0IGRhdGEgaXMgYW4gb2JqZWN0IHsgYmFzZTY0OiB0cnVlLCBkYXRhOiBkYXRhQXNCYXNlNjRTdHJpbmcgfVxuICB2YXIgbWVzc2FnZSA9ICdiJyArIGV4cG9ydHMucGFja2V0c1twYWNrZXQudHlwZV0gKyBwYWNrZXQuZGF0YS5kYXRhO1xuICByZXR1cm4gY2FsbGJhY2sobWVzc2FnZSk7XG59XG5cbi8qKlxuICogRW5jb2RlIHBhY2tldCBoZWxwZXJzIGZvciBiaW5hcnkgdHlwZXNcbiAqL1xuXG5mdW5jdGlvbiBlbmNvZGVBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICBpZiAoIXN1cHBvcnRzQmluYXJ5KSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0KHBhY2tldCwgY2FsbGJhY2spO1xuICB9XG5cbiAgdmFyIGRhdGEgPSBwYWNrZXQuZGF0YTtcbiAgdmFyIGNvbnRlbnRBcnJheSA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICB2YXIgcmVzdWx0QnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoMSArIGRhdGEuYnl0ZUxlbmd0aCk7XG5cbiAgcmVzdWx0QnVmZmVyWzBdID0gcGFja2V0c1twYWNrZXQudHlwZV07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29udGVudEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzdWx0QnVmZmVyW2krMV0gPSBjb250ZW50QXJyYXlbaV07XG4gIH1cblxuICByZXR1cm4gY2FsbGJhY2socmVzdWx0QnVmZmVyLmJ1ZmZlcik7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUJsb2JBc0FycmF5QnVmZmVyKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKSB7XG4gIGlmICghc3VwcG9ydHNCaW5hcnkpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQocGFja2V0LCBjYWxsYmFjayk7XG4gIH1cblxuICB2YXIgZnIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICBmci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICBwYWNrZXQuZGF0YSA9IGZyLnJlc3VsdDtcbiAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCB0cnVlLCBjYWxsYmFjayk7XG4gIH07XG4gIHJldHVybiBmci5yZWFkQXNBcnJheUJ1ZmZlcihwYWNrZXQuZGF0YSk7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUJsb2IocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcbiAgaWYgKCFzdXBwb3J0c0JpbmFyeSkge1xuICAgIHJldHVybiBleHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldChwYWNrZXQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGlmIChkb250U2VuZEJsb2JzKSB7XG4gICAgcmV0dXJuIGVuY29kZUJsb2JBc0FycmF5QnVmZmVyKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBuZXcgVWludDhBcnJheSgxKTtcbiAgbGVuZ3RoWzBdID0gcGFja2V0c1twYWNrZXQudHlwZV07XG4gIHZhciBibG9iID0gbmV3IEJsb2IoW2xlbmd0aC5idWZmZXIsIHBhY2tldC5kYXRhXSk7XG5cbiAgcmV0dXJuIGNhbGxiYWNrKGJsb2IpO1xufVxuXG4vKipcbiAqIEVuY29kZXMgYSBwYWNrZXQgd2l0aCBiaW5hcnkgZGF0YSBpbiBhIGJhc2U2NCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0LCBoYXMgYHR5cGVgIGFuZCBgZGF0YWBcbiAqIEByZXR1cm4ge1N0cmluZ30gYmFzZTY0IGVuY29kZWQgbWVzc2FnZVxuICovXG5cbmV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0ID0gZnVuY3Rpb24ocGFja2V0LCBjYWxsYmFjaykge1xuICB2YXIgbWVzc2FnZSA9ICdiJyArIGV4cG9ydHMucGFja2V0c1twYWNrZXQudHlwZV07XG4gIGlmIChCbG9iICYmIHBhY2tldC5kYXRhIGluc3RhbmNlb2YgZ2xvYmFsLkJsb2IpIHtcbiAgICB2YXIgZnIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgIGZyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGI2NCA9IGZyLnJlc3VsdC5zcGxpdCgnLCcpWzFdO1xuICAgICAgY2FsbGJhY2sobWVzc2FnZSArIGI2NCk7XG4gICAgfTtcbiAgICByZXR1cm4gZnIucmVhZEFzRGF0YVVSTChwYWNrZXQuZGF0YSk7XG4gIH1cblxuICB2YXIgYjY0ZGF0YTtcbiAgdHJ5IHtcbiAgICBiNjRkYXRhID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheShwYWNrZXQuZGF0YSkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gaVBob25lIFNhZmFyaSBkb2Vzbid0IGxldCB5b3UgYXBwbHkgd2l0aCB0eXBlZCBhcnJheXNcbiAgICB2YXIgdHlwZWQgPSBuZXcgVWludDhBcnJheShwYWNrZXQuZGF0YSk7XG4gICAgdmFyIGJhc2ljID0gbmV3IEFycmF5KHR5cGVkLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlZC5sZW5ndGg7IGkrKykge1xuICAgICAgYmFzaWNbaV0gPSB0eXBlZFtpXTtcbiAgICB9XG4gICAgYjY0ZGF0YSA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYmFzaWMpO1xuICB9XG4gIG1lc3NhZ2UgKz0gZ2xvYmFsLmJ0b2EoYjY0ZGF0YSk7XG4gIHJldHVybiBjYWxsYmFjayhtZXNzYWdlKTtcbn07XG5cbi8qKlxuICogRGVjb2RlcyBhIHBhY2tldC4gQ2hhbmdlcyBmb3JtYXQgdG8gQmxvYiBpZiByZXF1ZXN0ZWQuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSB3aXRoIGB0eXBlYCBhbmQgYGRhdGFgIChpZiBhbnkpXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmRlY29kZVBhY2tldCA9IGZ1bmN0aW9uIChkYXRhLCBiaW5hcnlUeXBlLCB1dGY4ZGVjb2RlKSB7XG4gIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZXJyO1xuICB9XG4gIC8vIFN0cmluZyBkYXRhXG4gIGlmICh0eXBlb2YgZGF0YSA9PSAnc3RyaW5nJykge1xuICAgIGlmIChkYXRhLmNoYXJBdCgwKSA9PSAnYicpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlY29kZUJhc2U2NFBhY2tldChkYXRhLnN1YnN0cigxKSwgYmluYXJ5VHlwZSk7XG4gICAgfVxuXG4gICAgaWYgKHV0ZjhkZWNvZGUpIHtcbiAgICAgIGRhdGEgPSB0cnlEZWNvZGUoZGF0YSk7XG4gICAgICBpZiAoZGF0YSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHR5cGUgPSBkYXRhLmNoYXJBdCgwKTtcblxuICAgIGlmIChOdW1iZXIodHlwZSkgIT0gdHlwZSB8fCAhcGFja2V0c2xpc3RbdHlwZV0pIHtcbiAgICAgIHJldHVybiBlcnI7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEubGVuZ3RoID4gMSkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogcGFja2V0c2xpc3RbdHlwZV0sIGRhdGE6IGRhdGEuc3Vic3RyaW5nKDEpIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IHBhY2tldHNsaXN0W3R5cGVdIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIGFzQXJyYXkgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgdmFyIHR5cGUgPSBhc0FycmF5WzBdO1xuICB2YXIgcmVzdCA9IHNsaWNlQnVmZmVyKGRhdGEsIDEpO1xuICBpZiAoQmxvYiAmJiBiaW5hcnlUeXBlID09PSAnYmxvYicpIHtcbiAgICByZXN0ID0gbmV3IEJsb2IoW3Jlc3RdKTtcbiAgfVxuICByZXR1cm4geyB0eXBlOiBwYWNrZXRzbGlzdFt0eXBlXSwgZGF0YTogcmVzdCB9O1xufTtcblxuZnVuY3Rpb24gdHJ5RGVjb2RlKGRhdGEpIHtcbiAgdHJ5IHtcbiAgICBkYXRhID0gdXRmOC5kZWNvZGUoZGF0YSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogRGVjb2RlcyBhIHBhY2tldCBlbmNvZGVkIGluIGEgYmFzZTY0IHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBiYXNlNjQgZW5jb2RlZCBtZXNzYWdlXG4gKiBAcmV0dXJuIHtPYmplY3R9IHdpdGggYHR5cGVgIGFuZCBgZGF0YWAgKGlmIGFueSlcbiAqL1xuXG5leHBvcnRzLmRlY29kZUJhc2U2NFBhY2tldCA9IGZ1bmN0aW9uKG1zZywgYmluYXJ5VHlwZSkge1xuICB2YXIgdHlwZSA9IHBhY2tldHNsaXN0W21zZy5jaGFyQXQoMCldO1xuICBpZiAoIWJhc2U2NGVuY29kZXIpIHtcbiAgICByZXR1cm4geyB0eXBlOiB0eXBlLCBkYXRhOiB7IGJhc2U2NDogdHJ1ZSwgZGF0YTogbXNnLnN1YnN0cigxKSB9IH07XG4gIH1cblxuICB2YXIgZGF0YSA9IGJhc2U2NGVuY29kZXIuZGVjb2RlKG1zZy5zdWJzdHIoMSkpO1xuXG4gIGlmIChiaW5hcnlUeXBlID09PSAnYmxvYicgJiYgQmxvYikge1xuICAgIGRhdGEgPSBuZXcgQmxvYihbZGF0YV0pO1xuICB9XG5cbiAgcmV0dXJuIHsgdHlwZTogdHlwZSwgZGF0YTogZGF0YSB9O1xufTtcblxuLyoqXG4gKiBFbmNvZGVzIG11bHRpcGxlIG1lc3NhZ2VzIChwYXlsb2FkKS5cbiAqXG4gKiAgICAgPGxlbmd0aD46ZGF0YVxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIDExOmhlbGxvIHdvcmxkMjpoaVxuICpcbiAqIElmIGFueSBjb250ZW50cyBhcmUgYmluYXJ5LCB0aGV5IHdpbGwgYmUgZW5jb2RlZCBhcyBiYXNlNjQgc3RyaW5ncy4gQmFzZTY0XG4gKiBlbmNvZGVkIHN0cmluZ3MgYXJlIG1hcmtlZCB3aXRoIGEgYiBiZWZvcmUgdGhlIGxlbmd0aCBzcGVjaWZpZXJcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBwYWNrZXRzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmVuY29kZVBheWxvYWQgPSBmdW5jdGlvbiAocGFja2V0cywgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygc3VwcG9ydHNCaW5hcnkgPT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gc3VwcG9ydHNCaW5hcnk7XG4gICAgc3VwcG9ydHNCaW5hcnkgPSBudWxsO1xuICB9XG5cbiAgdmFyIGlzQmluYXJ5ID0gaGFzQmluYXJ5KHBhY2tldHMpO1xuXG4gIGlmIChzdXBwb3J0c0JpbmFyeSAmJiBpc0JpbmFyeSkge1xuICAgIGlmIChCbG9iICYmICFkb250U2VuZEJsb2JzKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNCbG9iKHBhY2tldHMsIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNBcnJheUJ1ZmZlcihwYWNrZXRzLCBjYWxsYmFjayk7XG4gIH1cblxuICBpZiAoIXBhY2tldHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKCcwOicpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0TGVuZ3RoSGVhZGVyKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gbWVzc2FnZS5sZW5ndGggKyAnOicgKyBtZXNzYWdlO1xuICB9XG5cbiAgZnVuY3Rpb24gZW5jb2RlT25lKHBhY2tldCwgZG9uZUNhbGxiYWNrKSB7XG4gICAgZXhwb3J0cy5lbmNvZGVQYWNrZXQocGFja2V0LCAhaXNCaW5hcnkgPyBmYWxzZSA6IHN1cHBvcnRzQmluYXJ5LCB0cnVlLCBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICBkb25lQ2FsbGJhY2sobnVsbCwgc2V0TGVuZ3RoSGVhZGVyKG1lc3NhZ2UpKTtcbiAgICB9KTtcbiAgfVxuXG4gIG1hcChwYWNrZXRzLCBlbmNvZGVPbmUsIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICAgIHJldHVybiBjYWxsYmFjayhyZXN1bHRzLmpvaW4oJycpKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEFzeW5jIGFycmF5IG1hcCB1c2luZyBhZnRlclxuICovXG5cbmZ1bmN0aW9uIG1hcChhcnksIGVhY2gsIGRvbmUpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShhcnkubGVuZ3RoKTtcbiAgdmFyIG5leHQgPSBhZnRlcihhcnkubGVuZ3RoLCBkb25lKTtcblxuICB2YXIgZWFjaFdpdGhJbmRleCA9IGZ1bmN0aW9uKGksIGVsLCBjYikge1xuICAgIGVhY2goZWwsIGZ1bmN0aW9uKGVycm9yLCBtc2cpIHtcbiAgICAgIHJlc3VsdFtpXSA9IG1zZztcbiAgICAgIGNiKGVycm9yLCByZXN1bHQpO1xuICAgIH0pO1xuICB9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgZWFjaFdpdGhJbmRleChpLCBhcnlbaV0sIG5leHQpO1xuICB9XG59XG5cbi8qXG4gKiBEZWNvZGVzIGRhdGEgd2hlbiBhIHBheWxvYWQgaXMgbWF5YmUgZXhwZWN0ZWQuIFBvc3NpYmxlIGJpbmFyeSBjb250ZW50cyBhcmVcbiAqIGRlY29kZWQgZnJvbSB0aGVpciBiYXNlNjQgcmVwcmVzZW50YXRpb25cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YSwgY2FsbGJhY2sgbWV0aG9kXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuZGVjb2RlUGF5bG9hZCA9IGZ1bmN0aW9uIChkYXRhLCBiaW5hcnlUeXBlLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGRhdGEgIT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5kZWNvZGVQYXlsb2FkQXNCaW5hcnkoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBiaW5hcnlUeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBiaW5hcnlUeXBlO1xuICAgIGJpbmFyeVR5cGUgPSBudWxsO1xuICB9XG5cbiAgdmFyIHBhY2tldDtcbiAgaWYgKGRhdGEgPT0gJycpIHtcbiAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gIH1cblxuICB2YXIgbGVuZ3RoID0gJydcbiAgICAsIG4sIG1zZztcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGRhdGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGNociA9IGRhdGEuY2hhckF0KGkpO1xuXG4gICAgaWYgKCc6JyAhPSBjaHIpIHtcbiAgICAgIGxlbmd0aCArPSBjaHI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICgnJyA9PSBsZW5ndGggfHwgKGxlbmd0aCAhPSAobiA9IE51bWJlcihsZW5ndGgpKSkpIHtcbiAgICAgICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgICAgIH1cblxuICAgICAgbXNnID0gZGF0YS5zdWJzdHIoaSArIDEsIG4pO1xuXG4gICAgICBpZiAobGVuZ3RoICE9IG1zZy5sZW5ndGgpIHtcbiAgICAgICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1zZy5sZW5ndGgpIHtcbiAgICAgICAgcGFja2V0ID0gZXhwb3J0cy5kZWNvZGVQYWNrZXQobXNnLCBiaW5hcnlUeXBlLCB0cnVlKTtcblxuICAgICAgICBpZiAoZXJyLnR5cGUgPT0gcGFja2V0LnR5cGUgJiYgZXJyLmRhdGEgPT0gcGFja2V0LmRhdGEpIHtcbiAgICAgICAgICAvLyBwYXJzZXIgZXJyb3IgaW4gaW5kaXZpZHVhbCBwYWNrZXQgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmV0ID0gY2FsbGJhY2socGFja2V0LCBpICsgbiwgbCk7XG4gICAgICAgIGlmIChmYWxzZSA9PT0gcmV0KSByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGFkdmFuY2UgY3Vyc29yXG4gICAgICBpICs9IG47XG4gICAgICBsZW5ndGggPSAnJztcbiAgICB9XG4gIH1cblxuICBpZiAobGVuZ3RoICE9ICcnKSB7XG4gICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICB9XG5cbn07XG5cbi8qKlxuICogRW5jb2RlcyBtdWx0aXBsZSBtZXNzYWdlcyAocGF5bG9hZCkgYXMgYmluYXJ5LlxuICpcbiAqIDwxID0gYmluYXJ5LCAwID0gc3RyaW5nPjxudW1iZXIgZnJvbSAwLTk+PG51bWJlciBmcm9tIDAtOT5bLi4uXTxudW1iZXJcbiAqIDI1NT48ZGF0YT5cbiAqXG4gKiBFeGFtcGxlOlxuICogMSAzIDI1NSAxIDIgMywgaWYgdGhlIGJpbmFyeSBjb250ZW50cyBhcmUgaW50ZXJwcmV0ZWQgYXMgOCBiaXQgaW50ZWdlcnNcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBwYWNrZXRzXG4gKiBAcmV0dXJuIHtBcnJheUJ1ZmZlcn0gZW5jb2RlZCBwYXlsb2FkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmVuY29kZVBheWxvYWRBc0FycmF5QnVmZmVyID0gZnVuY3Rpb24ocGFja2V0cywgY2FsbGJhY2spIHtcbiAgaWYgKCFwYWNrZXRzLmxlbmd0aCkge1xuICAgIHJldHVybiBjYWxsYmFjayhuZXcgQXJyYXlCdWZmZXIoMCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZW5jb2RlT25lKHBhY2tldCwgZG9uZUNhbGxiYWNrKSB7XG4gICAgZXhwb3J0cy5lbmNvZGVQYWNrZXQocGFja2V0LCB0cnVlLCB0cnVlLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICByZXR1cm4gZG9uZUNhbGxiYWNrKG51bGwsIGRhdGEpO1xuICAgIH0pO1xuICB9XG5cbiAgbWFwKHBhY2tldHMsIGVuY29kZU9uZSwgZnVuY3Rpb24oZXJyLCBlbmNvZGVkUGFja2V0cykge1xuICAgIHZhciB0b3RhbExlbmd0aCA9IGVuY29kZWRQYWNrZXRzLnJlZHVjZShmdW5jdGlvbihhY2MsIHApIHtcbiAgICAgIHZhciBsZW47XG4gICAgICBpZiAodHlwZW9mIHAgPT09ICdzdHJpbmcnKXtcbiAgICAgICAgbGVuID0gcC5sZW5ndGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZW4gPSBwLmJ5dGVMZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjICsgbGVuLnRvU3RyaW5nKCkubGVuZ3RoICsgbGVuICsgMjsgLy8gc3RyaW5nL2JpbmFyeSBpZGVudGlmaWVyICsgc2VwYXJhdG9yID0gMlxuICAgIH0sIDApO1xuXG4gICAgdmFyIHJlc3VsdEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodG90YWxMZW5ndGgpO1xuXG4gICAgdmFyIGJ1ZmZlckluZGV4ID0gMDtcbiAgICBlbmNvZGVkUGFja2V0cy5mb3JFYWNoKGZ1bmN0aW9uKHApIHtcbiAgICAgIHZhciBpc1N0cmluZyA9IHR5cGVvZiBwID09PSAnc3RyaW5nJztcbiAgICAgIHZhciBhYiA9IHA7XG4gICAgICBpZiAoaXNTdHJpbmcpIHtcbiAgICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShwLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZpZXdbaV0gPSBwLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgYWIgPSB2aWV3LmJ1ZmZlcjtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzU3RyaW5nKSB7IC8vIG5vdCB0cnVlIGJpbmFyeVxuICAgICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IDA7XG4gICAgICB9IGVsc2UgeyAvLyB0cnVlIGJpbmFyeVxuICAgICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IDE7XG4gICAgICB9XG5cbiAgICAgIHZhciBsZW5TdHIgPSBhYi5ieXRlTGVuZ3RoLnRvU3RyaW5nKCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlblN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IHBhcnNlSW50KGxlblN0cltpXSk7XG4gICAgICB9XG4gICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IDI1NTtcblxuICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShhYik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSB2aWV3W2ldO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNhbGxiYWNrKHJlc3VsdEFycmF5LmJ1ZmZlcik7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBFbmNvZGUgYXMgQmxvYlxuICovXG5cbmV4cG9ydHMuZW5jb2RlUGF5bG9hZEFzQmxvYiA9IGZ1bmN0aW9uKHBhY2tldHMsIGNhbGxiYWNrKSB7XG4gIGZ1bmN0aW9uIGVuY29kZU9uZShwYWNrZXQsIGRvbmVDYWxsYmFjaykge1xuICAgIGV4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCwgdHJ1ZSwgdHJ1ZSwgZnVuY3Rpb24oZW5jb2RlZCkge1xuICAgICAgdmFyIGJpbmFyeUlkZW50aWZpZXIgPSBuZXcgVWludDhBcnJheSgxKTtcbiAgICAgIGJpbmFyeUlkZW50aWZpZXJbMF0gPSAxO1xuICAgICAgaWYgKHR5cGVvZiBlbmNvZGVkID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGVuY29kZWQubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmNvZGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmlld1tpXSA9IGVuY29kZWQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGVkID0gdmlldy5idWZmZXI7XG4gICAgICAgIGJpbmFyeUlkZW50aWZpZXJbMF0gPSAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGVuID0gKGVuY29kZWQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcilcbiAgICAgICAgPyBlbmNvZGVkLmJ5dGVMZW5ndGhcbiAgICAgICAgOiBlbmNvZGVkLnNpemU7XG5cbiAgICAgIHZhciBsZW5TdHIgPSBsZW4udG9TdHJpbmcoKTtcbiAgICAgIHZhciBsZW5ndGhBcnkgPSBuZXcgVWludDhBcnJheShsZW5TdHIubGVuZ3RoICsgMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlblN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZW5ndGhBcnlbaV0gPSBwYXJzZUludChsZW5TdHJbaV0pO1xuICAgICAgfVxuICAgICAgbGVuZ3RoQXJ5W2xlblN0ci5sZW5ndGhdID0gMjU1O1xuXG4gICAgICBpZiAoQmxvYikge1xuICAgICAgICB2YXIgYmxvYiA9IG5ldyBCbG9iKFtiaW5hcnlJZGVudGlmaWVyLmJ1ZmZlciwgbGVuZ3RoQXJ5LmJ1ZmZlciwgZW5jb2RlZF0pO1xuICAgICAgICBkb25lQ2FsbGJhY2sobnVsbCwgYmxvYik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBtYXAocGFja2V0cywgZW5jb2RlT25lLCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAgICByZXR1cm4gY2FsbGJhY2sobmV3IEJsb2IocmVzdWx0cykpO1xuICB9KTtcbn07XG5cbi8qXG4gKiBEZWNvZGVzIGRhdGEgd2hlbiBhIHBheWxvYWQgaXMgbWF5YmUgZXhwZWN0ZWQuIFN0cmluZ3MgYXJlIGRlY29kZWQgYnlcbiAqIGludGVycHJldGluZyBlYWNoIGJ5dGUgYXMgYSBrZXkgY29kZSBmb3IgZW50cmllcyBtYXJrZWQgdG8gc3RhcnQgd2l0aCAwLiBTZWVcbiAqIGRlc2NyaXB0aW9uIG9mIGVuY29kZVBheWxvYWRBc0JpbmFyeVxuICpcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGRhdGEsIGNhbGxiYWNrIG1ldGhvZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmRlY29kZVBheWxvYWRBc0JpbmFyeSA9IGZ1bmN0aW9uIChkYXRhLCBiaW5hcnlUeXBlLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGJpbmFyeVR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IGJpbmFyeVR5cGU7XG4gICAgYmluYXJ5VHlwZSA9IG51bGw7XG4gIH1cblxuICB2YXIgYnVmZmVyVGFpbCA9IGRhdGE7XG4gIHZhciBidWZmZXJzID0gW107XG5cbiAgdmFyIG51bWJlclRvb0xvbmcgPSBmYWxzZTtcbiAgd2hpbGUgKGJ1ZmZlclRhaWwuYnl0ZUxlbmd0aCA+IDApIHtcbiAgICB2YXIgdGFpbEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyVGFpbCk7XG4gICAgdmFyIGlzU3RyaW5nID0gdGFpbEFycmF5WzBdID09PSAwO1xuICAgIHZhciBtc2dMZW5ndGggPSAnJztcblxuICAgIGZvciAodmFyIGkgPSAxOyA7IGkrKykge1xuICAgICAgaWYgKHRhaWxBcnJheVtpXSA9PSAyNTUpIGJyZWFrO1xuXG4gICAgICBpZiAobXNnTGVuZ3RoLmxlbmd0aCA+IDMxMCkge1xuICAgICAgICBudW1iZXJUb29Mb25nID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIG1zZ0xlbmd0aCArPSB0YWlsQXJyYXlbaV07XG4gICAgfVxuXG4gICAgaWYobnVtYmVyVG9vTG9uZykgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG5cbiAgICBidWZmZXJUYWlsID0gc2xpY2VCdWZmZXIoYnVmZmVyVGFpbCwgMiArIG1zZ0xlbmd0aC5sZW5ndGgpO1xuICAgIG1zZ0xlbmd0aCA9IHBhcnNlSW50KG1zZ0xlbmd0aCk7XG5cbiAgICB2YXIgbXNnID0gc2xpY2VCdWZmZXIoYnVmZmVyVGFpbCwgMCwgbXNnTGVuZ3RoKTtcbiAgICBpZiAoaXNTdHJpbmcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG1zZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkobXNnKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIGlQaG9uZSBTYWZhcmkgZG9lc24ndCBsZXQgeW91IGFwcGx5IHRvIHR5cGVkIGFycmF5c1xuICAgICAgICB2YXIgdHlwZWQgPSBuZXcgVWludDhBcnJheShtc2cpO1xuICAgICAgICBtc2cgPSAnJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG1zZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHR5cGVkW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGJ1ZmZlcnMucHVzaChtc2cpO1xuICAgIGJ1ZmZlclRhaWwgPSBzbGljZUJ1ZmZlcihidWZmZXJUYWlsLCBtc2dMZW5ndGgpO1xuICB9XG5cbiAgdmFyIHRvdGFsID0gYnVmZmVycy5sZW5ndGg7XG4gIGJ1ZmZlcnMuZm9yRWFjaChmdW5jdGlvbihidWZmZXIsIGkpIHtcbiAgICBjYWxsYmFjayhleHBvcnRzLmRlY29kZVBhY2tldChidWZmZXIsIGJpbmFyeVR5cGUsIHRydWUpLCBpLCB0b3RhbCk7XG4gIH0pO1xufTtcbiIsIlxuLyoqXG4gKiBHZXRzIHRoZSBrZXlzIGZvciBhbiBvYmplY3QuXG4gKlxuICogQHJldHVybiB7QXJyYXl9IGtleXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyAob2JqKXtcbiAgdmFyIGFyciA9IFtdO1xuICB2YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmIChoYXMuY2FsbChvYmosIGkpKSB7XG4gICAgICBhcnIucHVzaChpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycjtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGFmdGVyXG5cbmZ1bmN0aW9uIGFmdGVyKGNvdW50LCBjYWxsYmFjaywgZXJyX2NiKSB7XG4gICAgdmFyIGJhaWwgPSBmYWxzZVxuICAgIGVycl9jYiA9IGVycl9jYiB8fCBub29wXG4gICAgcHJveHkuY291bnQgPSBjb3VudFxuXG4gICAgcmV0dXJuIChjb3VudCA9PT0gMCkgPyBjYWxsYmFjaygpIDogcHJveHlcblxuICAgIGZ1bmN0aW9uIHByb3h5KGVyciwgcmVzdWx0KSB7XG4gICAgICAgIGlmIChwcm94eS5jb3VudCA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FmdGVyIGNhbGxlZCB0b28gbWFueSB0aW1lcycpXG4gICAgICAgIH1cbiAgICAgICAgLS1wcm94eS5jb3VudFxuXG4gICAgICAgIC8vIGFmdGVyIGZpcnN0IGVycm9yLCByZXN0IGFyZSBwYXNzZWQgdG8gZXJyX2NiXG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGJhaWwgPSB0cnVlXG4gICAgICAgICAgICBjYWxsYmFjayhlcnIpXG4gICAgICAgICAgICAvLyBmdXR1cmUgZXJyb3IgY2FsbGJhY2tzIHdpbGwgZ28gdG8gZXJyb3IgaGFuZGxlclxuICAgICAgICAgICAgY2FsbGJhY2sgPSBlcnJfY2JcbiAgICAgICAgfSBlbHNlIGlmIChwcm94eS5jb3VudCA9PT0gMCAmJiAhYmFpbCkge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0KVxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBub29wKCkge31cbiIsIi8qKlxuICogQW4gYWJzdHJhY3Rpb24gZm9yIHNsaWNpbmcgYW4gYXJyYXlidWZmZXIgZXZlbiB3aGVuXG4gKiBBcnJheUJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgaXMgbm90IHN1cHBvcnRlZFxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcnJheWJ1ZmZlciwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBhcnJheWJ1ZmZlci5ieXRlTGVuZ3RoO1xuICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gIGVuZCA9IGVuZCB8fCBieXRlcztcblxuICBpZiAoYXJyYXlidWZmZXIuc2xpY2UpIHsgcmV0dXJuIGFycmF5YnVmZmVyLnNsaWNlKHN0YXJ0LCBlbmQpOyB9XG5cbiAgaWYgKHN0YXJ0IDwgMCkgeyBzdGFydCArPSBieXRlczsgfVxuICBpZiAoZW5kIDwgMCkgeyBlbmQgKz0gYnl0ZXM7IH1cbiAgaWYgKGVuZCA+IGJ5dGVzKSB7IGVuZCA9IGJ5dGVzOyB9XG5cbiAgaWYgKHN0YXJ0ID49IGJ5dGVzIHx8IHN0YXJ0ID49IGVuZCB8fCBieXRlcyA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gIH1cblxuICB2YXIgYWJ2ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpO1xuICB2YXIgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoZW5kIC0gc3RhcnQpO1xuICBmb3IgKHZhciBpID0gc3RhcnQsIGlpID0gMDsgaSA8IGVuZDsgaSsrLCBpaSsrKSB7XG4gICAgcmVzdWx0W2lpXSA9IGFidltpXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0LmJ1ZmZlcjtcbn07XG4iLCIvKlxuICogYmFzZTY0LWFycmF5YnVmZmVyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbmlrbGFzdmgvYmFzZTY0LWFycmF5YnVmZmVyXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEyIE5pa2xhcyB2b24gSGVydHplblxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICovXG4oZnVuY3Rpb24oKXtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIGNoYXJzID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCI7XG5cbiAgLy8gVXNlIGEgbG9va3VwIHRhYmxlIHRvIGZpbmQgdGhlIGluZGV4LlxuICB2YXIgbG9va3VwID0gbmV3IFVpbnQ4QXJyYXkoMjU2KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkrKykge1xuICAgIGxvb2t1cFtjaGFycy5jaGFyQ29kZUF0KGkpXSA9IGk7XG4gIH1cblxuICBleHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uKGFycmF5YnVmZmVyKSB7XG4gICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpLFxuICAgIGksIGxlbiA9IGJ5dGVzLmxlbmd0aCwgYmFzZTY0ID0gXCJcIjtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrPTMpIHtcbiAgICAgIGJhc2U2NCArPSBjaGFyc1tieXRlc1tpXSA+PiAyXTtcbiAgICAgIGJhc2U2NCArPSBjaGFyc1soKGJ5dGVzW2ldICYgMykgPDwgNCkgfCAoYnl0ZXNbaSArIDFdID4+IDQpXTtcbiAgICAgIGJhc2U2NCArPSBjaGFyc1soKGJ5dGVzW2kgKyAxXSAmIDE1KSA8PCAyKSB8IChieXRlc1tpICsgMl0gPj4gNildO1xuICAgICAgYmFzZTY0ICs9IGNoYXJzW2J5dGVzW2kgKyAyXSAmIDYzXTtcbiAgICB9XG5cbiAgICBpZiAoKGxlbiAlIDMpID09PSAyKSB7XG4gICAgICBiYXNlNjQgPSBiYXNlNjQuc3Vic3RyaW5nKDAsIGJhc2U2NC5sZW5ndGggLSAxKSArIFwiPVwiO1xuICAgIH0gZWxzZSBpZiAobGVuICUgMyA9PT0gMSkge1xuICAgICAgYmFzZTY0ID0gYmFzZTY0LnN1YnN0cmluZygwLCBiYXNlNjQubGVuZ3RoIC0gMikgKyBcIj09XCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJhc2U2NDtcbiAgfTtcblxuICBleHBvcnRzLmRlY29kZSA9ICBmdW5jdGlvbihiYXNlNjQpIHtcbiAgICB2YXIgYnVmZmVyTGVuZ3RoID0gYmFzZTY0Lmxlbmd0aCAqIDAuNzUsXG4gICAgbGVuID0gYmFzZTY0Lmxlbmd0aCwgaSwgcCA9IDAsXG4gICAgZW5jb2RlZDEsIGVuY29kZWQyLCBlbmNvZGVkMywgZW5jb2RlZDQ7XG5cbiAgICBpZiAoYmFzZTY0W2Jhc2U2NC5sZW5ndGggLSAxXSA9PT0gXCI9XCIpIHtcbiAgICAgIGJ1ZmZlckxlbmd0aC0tO1xuICAgICAgaWYgKGJhc2U2NFtiYXNlNjQubGVuZ3RoIC0gMl0gPT09IFwiPVwiKSB7XG4gICAgICAgIGJ1ZmZlckxlbmd0aC0tO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBhcnJheWJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihidWZmZXJMZW5ndGgpLFxuICAgIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSs9NCkge1xuICAgICAgZW5jb2RlZDEgPSBsb29rdXBbYmFzZTY0LmNoYXJDb2RlQXQoaSldO1xuICAgICAgZW5jb2RlZDIgPSBsb29rdXBbYmFzZTY0LmNoYXJDb2RlQXQoaSsxKV07XG4gICAgICBlbmNvZGVkMyA9IGxvb2t1cFtiYXNlNjQuY2hhckNvZGVBdChpKzIpXTtcbiAgICAgIGVuY29kZWQ0ID0gbG9va3VwW2Jhc2U2NC5jaGFyQ29kZUF0KGkrMyldO1xuXG4gICAgICBieXRlc1twKytdID0gKGVuY29kZWQxIDw8IDIpIHwgKGVuY29kZWQyID4+IDQpO1xuICAgICAgYnl0ZXNbcCsrXSA9ICgoZW5jb2RlZDIgJiAxNSkgPDwgNCkgfCAoZW5jb2RlZDMgPj4gMik7XG4gICAgICBieXRlc1twKytdID0gKChlbmNvZGVkMyAmIDMpIDw8IDYpIHwgKGVuY29kZWQ0ICYgNjMpO1xuICAgIH1cblxuICAgIHJldHVybiBhcnJheWJ1ZmZlcjtcbiAgfTtcbn0pKCk7XG4iLCIvKipcbiAqIENyZWF0ZSBhIGJsb2IgYnVpbGRlciBldmVuIHdoZW4gdmVuZG9yIHByZWZpeGVzIGV4aXN0XG4gKi9cblxudmFyIEJsb2JCdWlsZGVyID0gZ2xvYmFsLkJsb2JCdWlsZGVyXG4gIHx8IGdsb2JhbC5XZWJLaXRCbG9iQnVpbGRlclxuICB8fCBnbG9iYWwuTVNCbG9iQnVpbGRlclxuICB8fCBnbG9iYWwuTW96QmxvYkJ1aWxkZXI7XG5cbi8qKlxuICogQ2hlY2sgaWYgQmxvYiBjb25zdHJ1Y3RvciBpcyBzdXBwb3J0ZWRcbiAqL1xuXG52YXIgYmxvYlN1cHBvcnRlZCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYSA9IG5ldyBCbG9iKFsnaGknXSk7XG4gICAgcmV0dXJuIGEuc2l6ZSA9PT0gMjtcbiAgfSBjYXRjaChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59KSgpO1xuXG4vKipcbiAqIENoZWNrIGlmIEJsb2IgY29uc3RydWN0b3Igc3VwcG9ydHMgQXJyYXlCdWZmZXJWaWV3c1xuICogRmFpbHMgaW4gU2FmYXJpIDYsIHNvIHdlIG5lZWQgdG8gbWFwIHRvIEFycmF5QnVmZmVycyB0aGVyZS5cbiAqL1xuXG52YXIgYmxvYlN1cHBvcnRzQXJyYXlCdWZmZXJWaWV3ID0gYmxvYlN1cHBvcnRlZCAmJiAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgdmFyIGIgPSBuZXcgQmxvYihbbmV3IFVpbnQ4QXJyYXkoWzEsMl0pXSk7XG4gICAgcmV0dXJuIGIuc2l6ZSA9PT0gMjtcbiAgfSBjYXRjaChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59KSgpO1xuXG4vKipcbiAqIENoZWNrIGlmIEJsb2JCdWlsZGVyIGlzIHN1cHBvcnRlZFxuICovXG5cbnZhciBibG9iQnVpbGRlclN1cHBvcnRlZCA9IEJsb2JCdWlsZGVyXG4gICYmIEJsb2JCdWlsZGVyLnByb3RvdHlwZS5hcHBlbmRcbiAgJiYgQmxvYkJ1aWxkZXIucHJvdG90eXBlLmdldEJsb2I7XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgbWFwcyBBcnJheUJ1ZmZlclZpZXdzIHRvIEFycmF5QnVmZmVyc1xuICogVXNlZCBieSBCbG9iQnVpbGRlciBjb25zdHJ1Y3RvciBhbmQgb2xkIGJyb3dzZXJzIHRoYXQgZGlkbid0XG4gKiBzdXBwb3J0IGl0IGluIHRoZSBCbG9iIGNvbnN0cnVjdG9yLlxuICovXG5cbmZ1bmN0aW9uIG1hcEFycmF5QnVmZmVyVmlld3MoYXJ5KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNodW5rID0gYXJ5W2ldO1xuICAgIGlmIChjaHVuay5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgdmFyIGJ1ZiA9IGNodW5rLmJ1ZmZlcjtcblxuICAgICAgLy8gaWYgdGhpcyBpcyBhIHN1YmFycmF5LCBtYWtlIGEgY29weSBzbyB3ZSBvbmx5XG4gICAgICAvLyBpbmNsdWRlIHRoZSBzdWJhcnJheSByZWdpb24gZnJvbSB0aGUgdW5kZXJseWluZyBidWZmZXJcbiAgICAgIGlmIChjaHVuay5ieXRlTGVuZ3RoICE9PSBidWYuYnl0ZUxlbmd0aCkge1xuICAgICAgICB2YXIgY29weSA9IG5ldyBVaW50OEFycmF5KGNodW5rLmJ5dGVMZW5ndGgpO1xuICAgICAgICBjb3B5LnNldChuZXcgVWludDhBcnJheShidWYsIGNodW5rLmJ5dGVPZmZzZXQsIGNodW5rLmJ5dGVMZW5ndGgpKTtcbiAgICAgICAgYnVmID0gY29weS5idWZmZXI7XG4gICAgICB9XG5cbiAgICAgIGFyeVtpXSA9IGJ1ZjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gQmxvYkJ1aWxkZXJDb25zdHJ1Y3RvcihhcnksIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIGJiID0gbmV3IEJsb2JCdWlsZGVyKCk7XG4gIG1hcEFycmF5QnVmZmVyVmlld3MoYXJ5KTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyeS5sZW5ndGg7IGkrKykge1xuICAgIGJiLmFwcGVuZChhcnlbaV0pO1xuICB9XG5cbiAgcmV0dXJuIChvcHRpb25zLnR5cGUpID8gYmIuZ2V0QmxvYihvcHRpb25zLnR5cGUpIDogYmIuZ2V0QmxvYigpO1xufTtcblxuZnVuY3Rpb24gQmxvYkNvbnN0cnVjdG9yKGFyeSwgb3B0aW9ucykge1xuICBtYXBBcnJheUJ1ZmZlclZpZXdzKGFyeSk7XG4gIHJldHVybiBuZXcgQmxvYihhcnksIG9wdGlvbnMgfHwge30pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gIGlmIChibG9iU3VwcG9ydGVkKSB7XG4gICAgcmV0dXJuIGJsb2JTdXBwb3J0c0FycmF5QnVmZmVyVmlldyA/IGdsb2JhbC5CbG9iIDogQmxvYkNvbnN0cnVjdG9yO1xuICB9IGVsc2UgaWYgKGJsb2JCdWlsZGVyU3VwcG9ydGVkKSB7XG4gICAgcmV0dXJuIEJsb2JCdWlsZGVyQ29uc3RydWN0b3I7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufSkoKTtcbiIsIi8qISBodHRwczovL210aHMuYmUvd3RmOCB2MS4wLjAgYnkgQG1hdGhpYXMgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8vIERldGVjdCBmcmVlIHZhcmlhYmxlcyBgZXhwb3J0c2Bcblx0dmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cztcblxuXHQvLyBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYFxuXHR2YXIgZnJlZU1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmXG5cdFx0bW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMgJiYgbW9kdWxlO1xuXG5cdC8vIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgLCBmcm9tIE5vZGUuanMgb3IgQnJvd3NlcmlmaWVkIGNvZGUsXG5cdC8vIGFuZCB1c2UgaXQgYXMgYHJvb3RgXG5cdHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cdGlmIChmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCkge1xuXHRcdHJvb3QgPSBmcmVlR2xvYmFsO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0dmFyIHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5cblx0Ly8gVGFrZW4gZnJvbSBodHRwczovL210aHMuYmUvcHVueWNvZGVcblx0ZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0XHR2YXIgb3V0cHV0ID0gW107XG5cdFx0dmFyIGNvdW50ZXIgPSAwO1xuXHRcdHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuXHRcdHZhciB2YWx1ZTtcblx0XHR2YXIgZXh0cmE7XG5cdFx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdFx0Ly8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG5cdFx0XHRcdGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcblx0XHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG5cdFx0XHRcdFx0Ly8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0Ly8gVGFrZW4gZnJvbSBodHRwczovL210aHMuYmUvcHVueWNvZGVcblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0dmFyIGluZGV4ID0gLTE7XG5cdFx0dmFyIHZhbHVlO1xuXHRcdHZhciBvdXRwdXQgPSAnJztcblx0XHR3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBhcnJheVtpbmRleF07XG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdH1cblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0ZnVuY3Rpb24gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIHNoaWZ0KSB7XG5cdFx0cmV0dXJuIHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiBzaGlmdCkgJiAweDNGKSB8IDB4ODApO1xuXHR9XG5cblx0ZnVuY3Rpb24gZW5jb2RlQ29kZVBvaW50KGNvZGVQb2ludCkge1xuXHRcdGlmICgoY29kZVBvaW50ICYgMHhGRkZGRkY4MCkgPT0gMCkgeyAvLyAxLWJ5dGUgc2VxdWVuY2Vcblx0XHRcdHJldHVybiBzdHJpbmdGcm9tQ2hhckNvZGUoY29kZVBvaW50KTtcblx0XHR9XG5cdFx0dmFyIHN5bWJvbCA9ICcnO1xuXHRcdGlmICgoY29kZVBvaW50ICYgMHhGRkZGRjgwMCkgPT0gMCkgeyAvLyAyLWJ5dGUgc2VxdWVuY2Vcblx0XHRcdHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiA2KSAmIDB4MUYpIHwgMHhDMCk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKChjb2RlUG9pbnQgJiAweEZGRkYwMDAwKSA9PSAwKSB7IC8vIDMtYnl0ZSBzZXF1ZW5jZVxuXHRcdFx0c3ltYm9sID0gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IDEyKSAmIDB4MEYpIHwgMHhFMCk7XG5cdFx0XHRzeW1ib2wgKz0gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIDYpO1xuXHRcdH1cblx0XHRlbHNlIGlmICgoY29kZVBvaW50ICYgMHhGRkUwMDAwMCkgPT0gMCkgeyAvLyA0LWJ5dGUgc2VxdWVuY2Vcblx0XHRcdHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiAxOCkgJiAweDA3KSB8IDB4RjApO1xuXHRcdFx0c3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCAxMik7XG5cdFx0XHRzeW1ib2wgKz0gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIDYpO1xuXHRcdH1cblx0XHRzeW1ib2wgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKChjb2RlUG9pbnQgJiAweDNGKSB8IDB4ODApO1xuXHRcdHJldHVybiBzeW1ib2w7XG5cdH1cblxuXHRmdW5jdGlvbiB3dGY4ZW5jb2RlKHN0cmluZykge1xuXHRcdHZhciBjb2RlUG9pbnRzID0gdWNzMmRlY29kZShzdHJpbmcpO1xuXHRcdHZhciBsZW5ndGggPSBjb2RlUG9pbnRzLmxlbmd0aDtcblx0XHR2YXIgaW5kZXggPSAtMTtcblx0XHR2YXIgY29kZVBvaW50O1xuXHRcdHZhciBieXRlU3RyaW5nID0gJyc7XG5cdFx0d2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0XHRcdGNvZGVQb2ludCA9IGNvZGVQb2ludHNbaW5kZXhdO1xuXHRcdFx0Ynl0ZVN0cmluZyArPSBlbmNvZGVDb2RlUG9pbnQoY29kZVBvaW50KTtcblx0XHR9XG5cdFx0cmV0dXJuIGJ5dGVTdHJpbmc7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHRmdW5jdGlvbiByZWFkQ29udGludWF0aW9uQnl0ZSgpIHtcblx0XHRpZiAoYnl0ZUluZGV4ID49IGJ5dGVDb3VudCkge1xuXHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgYnl0ZSBpbmRleCcpO1xuXHRcdH1cblxuXHRcdHZhciBjb250aW51YXRpb25CeXRlID0gYnl0ZUFycmF5W2J5dGVJbmRleF0gJiAweEZGO1xuXHRcdGJ5dGVJbmRleCsrO1xuXG5cdFx0aWYgKChjb250aW51YXRpb25CeXRlICYgMHhDMCkgPT0gMHg4MCkge1xuXHRcdFx0cmV0dXJuIGNvbnRpbnVhdGlvbkJ5dGUgJiAweDNGO1xuXHRcdH1cblxuXHRcdC8vIElmIHdlIGVuZCB1cCBoZXJlLCBpdOKAmXMgbm90IGEgY29udGludWF0aW9uIGJ5dGUuXG5cdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGRlY29kZVN5bWJvbCgpIHtcblx0XHR2YXIgYnl0ZTE7XG5cdFx0dmFyIGJ5dGUyO1xuXHRcdHZhciBieXRlMztcblx0XHR2YXIgYnl0ZTQ7XG5cdFx0dmFyIGNvZGVQb2ludDtcblxuXHRcdGlmIChieXRlSW5kZXggPiBieXRlQ291bnQpIHtcblx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGJ5dGUgaW5kZXgnKTtcblx0XHR9XG5cblx0XHRpZiAoYnl0ZUluZGV4ID09IGJ5dGVDb3VudCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIFJlYWQgdGhlIGZpcnN0IGJ5dGUuXG5cdFx0Ynl0ZTEgPSBieXRlQXJyYXlbYnl0ZUluZGV4XSAmIDB4RkY7XG5cdFx0Ynl0ZUluZGV4Kys7XG5cblx0XHQvLyAxLWJ5dGUgc2VxdWVuY2UgKG5vIGNvbnRpbnVhdGlvbiBieXRlcylcblx0XHRpZiAoKGJ5dGUxICYgMHg4MCkgPT0gMCkge1xuXHRcdFx0cmV0dXJuIGJ5dGUxO1xuXHRcdH1cblxuXHRcdC8vIDItYnl0ZSBzZXF1ZW5jZVxuXHRcdGlmICgoYnl0ZTEgJiAweEUwKSA9PSAweEMwKSB7XG5cdFx0XHR2YXIgYnl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Y29kZVBvaW50ID0gKChieXRlMSAmIDB4MUYpIDw8IDYpIHwgYnl0ZTI7XG5cdFx0XHRpZiAoY29kZVBvaW50ID49IDB4ODApIHtcblx0XHRcdFx0cmV0dXJuIGNvZGVQb2ludDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gMy1ieXRlIHNlcXVlbmNlIChtYXkgaW5jbHVkZSB1bnBhaXJlZCBzdXJyb2dhdGVzKVxuXHRcdGlmICgoYnl0ZTEgJiAweEYwKSA9PSAweEUwKSB7XG5cdFx0XHRieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRieXRlMyA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgwRikgPDwgMTIpIHwgKGJ5dGUyIDw8IDYpIHwgYnl0ZTM7XG5cdFx0XHRpZiAoY29kZVBvaW50ID49IDB4MDgwMCkge1xuXHRcdFx0XHRyZXR1cm4gY29kZVBvaW50O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyA0LWJ5dGUgc2VxdWVuY2Vcblx0XHRpZiAoKGJ5dGUxICYgMHhGOCkgPT0gMHhGMCkge1xuXHRcdFx0Ynl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Ynl0ZTMgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Ynl0ZTQgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Y29kZVBvaW50ID0gKChieXRlMSAmIDB4MEYpIDw8IDB4MTIpIHwgKGJ5dGUyIDw8IDB4MEMpIHxcblx0XHRcdFx0KGJ5dGUzIDw8IDB4MDYpIHwgYnl0ZTQ7XG5cdFx0XHRpZiAoY29kZVBvaW50ID49IDB4MDEwMDAwICYmIGNvZGVQb2ludCA8PSAweDEwRkZGRikge1xuXHRcdFx0XHRyZXR1cm4gY29kZVBvaW50O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRocm93IEVycm9yKCdJbnZhbGlkIFdURi04IGRldGVjdGVkJyk7XG5cdH1cblxuXHR2YXIgYnl0ZUFycmF5O1xuXHR2YXIgYnl0ZUNvdW50O1xuXHR2YXIgYnl0ZUluZGV4O1xuXHRmdW5jdGlvbiB3dGY4ZGVjb2RlKGJ5dGVTdHJpbmcpIHtcblx0XHRieXRlQXJyYXkgPSB1Y3MyZGVjb2RlKGJ5dGVTdHJpbmcpO1xuXHRcdGJ5dGVDb3VudCA9IGJ5dGVBcnJheS5sZW5ndGg7XG5cdFx0Ynl0ZUluZGV4ID0gMDtcblx0XHR2YXIgY29kZVBvaW50cyA9IFtdO1xuXHRcdHZhciB0bXA7XG5cdFx0d2hpbGUgKCh0bXAgPSBkZWNvZGVTeW1ib2woKSkgIT09IGZhbHNlKSB7XG5cdFx0XHRjb2RlUG9pbnRzLnB1c2godG1wKTtcblx0XHR9XG5cdFx0cmV0dXJuIHVjczJlbmNvZGUoY29kZVBvaW50cyk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHR2YXIgd3RmOCA9IHtcblx0XHQndmVyc2lvbic6ICcxLjAuMCcsXG5cdFx0J2VuY29kZSc6IHd0ZjhlbmNvZGUsXG5cdFx0J2RlY29kZSc6IHd0ZjhkZWNvZGVcblx0fTtcblxuXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxuXHRpZiAoXG5cdFx0dHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiZcblx0XHRkZWZpbmUuYW1kXG5cdCkge1xuXHRcdGRlZmluZShmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB3dGY4O1xuXHRcdH0pO1xuXHR9XHRlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiAhZnJlZUV4cG9ydHMubm9kZVR5cGUpIHtcblx0XHRpZiAoZnJlZU1vZHVsZSkgeyAvLyBpbiBOb2RlLmpzIG9yIFJpbmdvSlMgdjAuOC4wK1xuXHRcdFx0ZnJlZU1vZHVsZS5leHBvcnRzID0gd3RmODtcblx0XHR9IGVsc2UgeyAvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0dmFyIG9iamVjdCA9IHt9O1xuXHRcdFx0dmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0Lmhhc093blByb3BlcnR5O1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIHd0ZjgpIHtcblx0XHRcdFx0aGFzT3duUHJvcGVydHkuY2FsbCh3dGY4LCBrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gd3RmOFtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7IC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcblx0XHRyb290Lnd0ZjggPSB3dGY4O1xuXHR9XG5cbn0odGhpcykpO1xuIiwiXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICpcbiAqIExvZ2ljIGJvcnJvd2VkIGZyb20gTW9kZXJuaXpyOlxuICpcbiAqICAgLSBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9mZWF0dXJlLWRldGVjdHMvY29ycy5qc1xuICovXG5cbnRyeSB7XG4gIG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICd3aXRoQ3JlZGVudGlhbHMnIGluIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xufSBjYXRjaCAoZXJyKSB7XG4gIC8vIGlmIFhNTEh0dHAgc3VwcG9ydCBpcyBkaXNhYmxlZCBpbiBJRSB0aGVuIGl0IHdpbGwgdGhyb3dcbiAgLy8gd2hlbiB0cnlpbmcgdG8gY3JlYXRlXG4gIG1vZHVsZS5leHBvcnRzID0gZmFsc2U7XG59XG4iLCIvKipcclxuICogSlNPTiBwYXJzZS5cclxuICpcclxuICogQHNlZSBCYXNlZCBvbiBqUXVlcnkjcGFyc2VKU09OIChNSVQpIGFuZCBKU09OMlxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG52YXIgcnZhbGlkY2hhcnMgPSAvXltcXF0sOnt9XFxzXSokLztcclxudmFyIHJ2YWxpZGVzY2FwZSA9IC9cXFxcKD86W1wiXFxcXFxcL2JmbnJ0XXx1WzAtOWEtZkEtRl17NH0pL2c7XHJcbnZhciBydmFsaWR0b2tlbnMgPSAvXCJbXlwiXFxcXFxcblxccl0qXCJ8dHJ1ZXxmYWxzZXxudWxsfC0/XFxkKyg/OlxcLlxcZCopPyg/OltlRV1bK1xcLV0/XFxkKyk/L2c7XHJcbnZhciBydmFsaWRicmFjZXMgPSAvKD86Xnw6fCwpKD86XFxzKlxcWykrL2c7XHJcbnZhciBydHJpbUxlZnQgPSAvXlxccysvO1xyXG52YXIgcnRyaW1SaWdodCA9IC9cXHMrJC87XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlanNvbihkYXRhKSB7XHJcbiAgaWYgKCdzdHJpbmcnICE9IHR5cGVvZiBkYXRhIHx8ICFkYXRhKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIGRhdGEgPSBkYXRhLnJlcGxhY2UocnRyaW1MZWZ0LCAnJykucmVwbGFjZShydHJpbVJpZ2h0LCAnJyk7XHJcblxyXG4gIC8vIEF0dGVtcHQgdG8gcGFyc2UgdXNpbmcgdGhlIG5hdGl2ZSBKU09OIHBhcnNlciBmaXJzdFxyXG4gIGlmIChnbG9iYWwuSlNPTiAmJiBKU09OLnBhcnNlKSB7XHJcbiAgICByZXR1cm4gSlNPTi5wYXJzZShkYXRhKTtcclxuICB9XHJcblxyXG4gIGlmIChydmFsaWRjaGFycy50ZXN0KGRhdGEucmVwbGFjZShydmFsaWRlc2NhcGUsICdAJylcclxuICAgICAgLnJlcGxhY2UocnZhbGlkdG9rZW5zLCAnXScpXHJcbiAgICAgIC5yZXBsYWNlKHJ2YWxpZGJyYWNlcywgJycpKSkge1xyXG4gICAgcmV0dXJuIChuZXcgRnVuY3Rpb24oJ3JldHVybiAnICsgZGF0YSkpKCk7XHJcbiAgfVxyXG59OyIsIi8qKlxyXG4gKiBDb21waWxlcyBhIHF1ZXJ5c3RyaW5nXHJcbiAqIFJldHVybnMgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvYmplY3RcclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9XHJcbiAqIEBhcGkgcHJpdmF0ZVxyXG4gKi9cclxuXHJcbmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gKG9iaikge1xyXG4gIHZhciBzdHIgPSAnJztcclxuXHJcbiAgZm9yICh2YXIgaSBpbiBvYmopIHtcclxuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcclxuICAgICAgaWYgKHN0ci5sZW5ndGgpIHN0ciArPSAnJic7XHJcbiAgICAgIHN0ciArPSBlbmNvZGVVUklDb21wb25lbnQoaSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQob2JqW2ldKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBzdHI7XHJcbn07XHJcblxyXG4vKipcclxuICogUGFyc2VzIGEgc2ltcGxlIHF1ZXJ5c3RyaW5nIGludG8gYW4gb2JqZWN0XHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBxc1xyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uKHFzKXtcclxuICB2YXIgcXJ5ID0ge307XHJcbiAgdmFyIHBhaXJzID0gcXMuc3BsaXQoJyYnKTtcclxuICBmb3IgKHZhciBpID0gMCwgbCA9IHBhaXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgdmFyIHBhaXIgPSBwYWlyc1tpXS5zcGxpdCgnPScpO1xyXG4gICAgcXJ5W2RlY29kZVVSSUNvbXBvbmVudChwYWlyWzBdKV0gPSBkZWNvZGVVUklDb21wb25lbnQocGFpclsxXSk7XHJcbiAgfVxyXG4gIHJldHVybiBxcnk7XHJcbn07XHJcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFscGhhYmV0ID0gJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6LV8nLnNwbGl0KCcnKVxuICAsIGxlbmd0aCA9IDY0XG4gICwgbWFwID0ge31cbiAgLCBzZWVkID0gMFxuICAsIGkgPSAwXG4gICwgcHJldjtcblxuLyoqXG4gKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBzcGVjaWZpZWQgbnVtYmVyLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBudW0gVGhlIG51bWJlciB0byBjb252ZXJ0LlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbnVtYmVyLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZW5jb2RlKG51bSkge1xuICB2YXIgZW5jb2RlZCA9ICcnO1xuXG4gIGRvIHtcbiAgICBlbmNvZGVkID0gYWxwaGFiZXRbbnVtICUgbGVuZ3RoXSArIGVuY29kZWQ7XG4gICAgbnVtID0gTWF0aC5mbG9vcihudW0gLyBsZW5ndGgpO1xuICB9IHdoaWxlIChudW0gPiAwKTtcblxuICByZXR1cm4gZW5jb2RlZDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGludGVnZXIgdmFsdWUgc3BlY2lmaWVkIGJ5IHRoZSBnaXZlbiBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgaW50ZWdlciB2YWx1ZSByZXByZXNlbnRlZCBieSB0aGUgc3RyaW5nLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZGVjb2RlKHN0cikge1xuICB2YXIgZGVjb2RlZCA9IDA7XG5cbiAgZm9yIChpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGRlY29kZWQgPSBkZWNvZGVkICogbGVuZ3RoICsgbWFwW3N0ci5jaGFyQXQoaSldO1xuICB9XG5cbiAgcmV0dXJuIGRlY29kZWQ7XG59XG5cbi8qKlxuICogWWVhc3Q6IEEgdGlueSBncm93aW5nIGlkIGdlbmVyYXRvci5cbiAqXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBBIHVuaXF1ZSBpZC5cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIHllYXN0KCkge1xuICB2YXIgbm93ID0gZW5jb2RlKCtuZXcgRGF0ZSgpKTtcblxuICBpZiAobm93ICE9PSBwcmV2KSByZXR1cm4gc2VlZCA9IDAsIHByZXYgPSBub3c7XG4gIHJldHVybiBub3cgKycuJysgZW5jb2RlKHNlZWQrKyk7XG59XG5cbi8vXG4vLyBNYXAgZWFjaCBjaGFyYWN0ZXIgdG8gaXRzIGluZGV4LlxuLy9cbmZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIG1hcFthbHBoYWJldFtpXV0gPSBpO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBgeWVhc3RgLCBgZW5jb2RlYCBhbmQgYGRlY29kZWAgZnVuY3Rpb25zLlxuLy9cbnllYXN0LmVuY29kZSA9IGVuY29kZTtcbnllYXN0LmRlY29kZSA9IGRlY29kZTtcbm1vZHVsZS5leHBvcnRzID0geWVhc3Q7XG4iLCJcbi8qXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzLlxuICovXG5cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gaGFzQmluYXJ5O1xuXG4vKipcbiAqIENoZWNrcyBmb3IgYmluYXJ5IGRhdGEuXG4gKlxuICogUmlnaHQgbm93IG9ubHkgQnVmZmVyIGFuZCBBcnJheUJ1ZmZlciBhcmUgc3VwcG9ydGVkLi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYW55dGhpbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gaGFzQmluYXJ5KGRhdGEpIHtcblxuICBmdW5jdGlvbiBfaGFzQmluYXJ5KG9iaikge1xuICAgIGlmICghb2JqKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAoIChnbG9iYWwuQnVmZmVyICYmIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIgJiYgZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlcihvYmopKSB8fFxuICAgICAgICAgKGdsb2JhbC5BcnJheUJ1ZmZlciAmJiBvYmogaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHxcbiAgICAgICAgIChnbG9iYWwuQmxvYiAmJiBvYmogaW5zdGFuY2VvZiBCbG9iKSB8fFxuICAgICAgICAgKGdsb2JhbC5GaWxlICYmIG9iaiBpbnN0YW5jZW9mIEZpbGUpXG4gICAgICAgICkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoX2hhc0JpbmFyeShvYmpbaV0pKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9iaiAmJiAnb2JqZWN0JyA9PSB0eXBlb2Ygb2JqKSB7XG4gICAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9BdXRvbWF0dGljL2hhcy1iaW5hcnkvcHVsbC80XG4gICAgICBpZiAob2JqLnRvSlNPTiAmJiAnZnVuY3Rpb24nID09IHR5cGVvZiBvYmoudG9KU09OKSB7XG4gICAgICAgIG9iaiA9IG9iai50b0pTT04oKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSAmJiBfaGFzQmluYXJ5KG9ialtrZXldKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIF9oYXNCaW5hcnkoZGF0YSk7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCJcbnZhciBpbmRleE9mID0gW10uaW5kZXhPZjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcnIsIG9iail7XG4gIGlmIChpbmRleE9mKSByZXR1cm4gYXJyLmluZGV4T2Yob2JqKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoYXJyW2ldID09PSBvYmopIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn07IiwiLyoqXHJcbiAqIFBhcnNlcyBhbiBVUklcclxuICpcclxuICogQGF1dGhvciBTdGV2ZW4gTGV2aXRoYW4gPHN0ZXZlbmxldml0aGFuLmNvbT4gKE1JVCBsaWNlbnNlKVxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG52YXIgcmUgPSAvXig/Oig/IVteOkBdKzpbXjpAXFwvXSpAKShodHRwfGh0dHBzfHdzfHdzcyk6XFwvXFwvKT8oKD86KChbXjpAXSopKD86OihbXjpAXSopKT8pP0ApPygoPzpbYS1mMC05XXswLDR9Oil7Miw3fVthLWYwLTldezAsNH18W146XFwvPyNdKikoPzo6KFxcZCopKT8pKCgoXFwvKD86W14/I10oPyFbXj8jXFwvXSpcXC5bXj8jXFwvLl0rKD86Wz8jXXwkKSkpKlxcLz8pPyhbXj8jXFwvXSopKSg/OlxcPyhbXiNdKikpPyg/OiMoLiopKT8pLztcclxuXHJcbnZhciBwYXJ0cyA9IFtcclxuICAgICdzb3VyY2UnLCAncHJvdG9jb2wnLCAnYXV0aG9yaXR5JywgJ3VzZXJJbmZvJywgJ3VzZXInLCAncGFzc3dvcmQnLCAnaG9zdCcsICdwb3J0JywgJ3JlbGF0aXZlJywgJ3BhdGgnLCAnZGlyZWN0b3J5JywgJ2ZpbGUnLCAncXVlcnknLCAnYW5jaG9yJ1xyXG5dO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZXVyaShzdHIpIHtcclxuICAgIHZhciBzcmMgPSBzdHIsXHJcbiAgICAgICAgYiA9IHN0ci5pbmRleE9mKCdbJyksXHJcbiAgICAgICAgZSA9IHN0ci5pbmRleE9mKCddJyk7XHJcblxyXG4gICAgaWYgKGIgIT0gLTEgJiYgZSAhPSAtMSkge1xyXG4gICAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgYikgKyBzdHIuc3Vic3RyaW5nKGIsIGUpLnJlcGxhY2UoLzovZywgJzsnKSArIHN0ci5zdWJzdHJpbmcoZSwgc3RyLmxlbmd0aCk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG0gPSByZS5leGVjKHN0ciB8fCAnJyksXHJcbiAgICAgICAgdXJpID0ge30sXHJcbiAgICAgICAgaSA9IDE0O1xyXG5cclxuICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICB1cmlbcGFydHNbaV1dID0gbVtpXSB8fCAnJztcclxuICAgIH1cclxuXHJcbiAgICBpZiAoYiAhPSAtMSAmJiBlICE9IC0xKSB7XHJcbiAgICAgICAgdXJpLnNvdXJjZSA9IHNyYztcclxuICAgICAgICB1cmkuaG9zdCA9IHVyaS5ob3N0LnN1YnN0cmluZygxLCB1cmkuaG9zdC5sZW5ndGggLSAxKS5yZXBsYWNlKC87L2csICc6Jyk7XHJcbiAgICAgICAgdXJpLmF1dGhvcml0eSA9IHVyaS5hdXRob3JpdHkucmVwbGFjZSgnWycsICcnKS5yZXBsYWNlKCddJywgJycpLnJlcGxhY2UoLzsvZywgJzonKTtcclxuICAgICAgICB1cmkuaXB2NnVyaSA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHVyaTtcclxufTtcclxuIiwiLypnbG9iYWwgQmxvYixGaWxlKi9cblxuLyoqXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzXG4gKi9cblxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG52YXIgaXNCdWYgPSByZXF1aXJlKCcuL2lzLWJ1ZmZlcicpO1xuXG4vKipcbiAqIFJlcGxhY2VzIGV2ZXJ5IEJ1ZmZlciB8IEFycmF5QnVmZmVyIGluIHBhY2tldCB3aXRoIGEgbnVtYmVyZWQgcGxhY2Vob2xkZXIuXG4gKiBBbnl0aGluZyB3aXRoIGJsb2JzIG9yIGZpbGVzIHNob3VsZCBiZSBmZWQgdGhyb3VnaCByZW1vdmVCbG9icyBiZWZvcmUgY29taW5nXG4gKiBoZXJlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQgLSBzb2NrZXQuaW8gZXZlbnQgcGFja2V0XG4gKiBAcmV0dXJuIHtPYmplY3R9IHdpdGggZGVjb25zdHJ1Y3RlZCBwYWNrZXQgYW5kIGxpc3Qgb2YgYnVmZmVyc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmRlY29uc3RydWN0UGFja2V0ID0gZnVuY3Rpb24ocGFja2V0KXtcbiAgdmFyIGJ1ZmZlcnMgPSBbXTtcbiAgdmFyIHBhY2tldERhdGEgPSBwYWNrZXQuZGF0YTtcblxuICBmdW5jdGlvbiBfZGVjb25zdHJ1Y3RQYWNrZXQoZGF0YSkge1xuICAgIGlmICghZGF0YSkgcmV0dXJuIGRhdGE7XG5cbiAgICBpZiAoaXNCdWYoZGF0YSkpIHtcbiAgICAgIHZhciBwbGFjZWhvbGRlciA9IHsgX3BsYWNlaG9sZGVyOiB0cnVlLCBudW06IGJ1ZmZlcnMubGVuZ3RoIH07XG4gICAgICBidWZmZXJzLnB1c2goZGF0YSk7XG4gICAgICByZXR1cm4gcGxhY2Vob2xkZXI7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KGRhdGEpKSB7XG4gICAgICB2YXIgbmV3RGF0YSA9IG5ldyBBcnJheShkYXRhLmxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbmV3RGF0YVtpXSA9IF9kZWNvbnN0cnVjdFBhY2tldChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdEYXRhO1xuICAgIH0gZWxzZSBpZiAoJ29iamVjdCcgPT0gdHlwZW9mIGRhdGEgJiYgIShkYXRhIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgIHZhciBuZXdEYXRhID0ge307XG4gICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgICBuZXdEYXRhW2tleV0gPSBfZGVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtrZXldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdEYXRhO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHZhciBwYWNrID0gcGFja2V0O1xuICBwYWNrLmRhdGEgPSBfZGVjb25zdHJ1Y3RQYWNrZXQocGFja2V0RGF0YSk7XG4gIHBhY2suYXR0YWNobWVudHMgPSBidWZmZXJzLmxlbmd0aDsgLy8gbnVtYmVyIG9mIGJpbmFyeSAnYXR0YWNobWVudHMnXG4gIHJldHVybiB7cGFja2V0OiBwYWNrLCBidWZmZXJzOiBidWZmZXJzfTtcbn07XG5cbi8qKlxuICogUmVjb25zdHJ1Y3RzIGEgYmluYXJ5IHBhY2tldCBmcm9tIGl0cyBwbGFjZWhvbGRlciBwYWNrZXQgYW5kIGJ1ZmZlcnNcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0IC0gZXZlbnQgcGFja2V0IHdpdGggcGxhY2Vob2xkZXJzXG4gKiBAcGFyYW0ge0FycmF5fSBidWZmZXJzIC0gYmluYXJ5IGJ1ZmZlcnMgdG8gcHV0IGluIHBsYWNlaG9sZGVyIHBvc2l0aW9uc1xuICogQHJldHVybiB7T2JqZWN0fSByZWNvbnN0cnVjdGVkIHBhY2tldFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnJlY29uc3RydWN0UGFja2V0ID0gZnVuY3Rpb24ocGFja2V0LCBidWZmZXJzKSB7XG4gIHZhciBjdXJQbGFjZUhvbGRlciA9IDA7XG5cbiAgZnVuY3Rpb24gX3JlY29uc3RydWN0UGFja2V0KGRhdGEpIHtcbiAgICBpZiAoZGF0YSAmJiBkYXRhLl9wbGFjZWhvbGRlcikge1xuICAgICAgdmFyIGJ1ZiA9IGJ1ZmZlcnNbZGF0YS5udW1dOyAvLyBhcHByb3ByaWF0ZSBidWZmZXIgKHNob3VsZCBiZSBuYXR1cmFsIG9yZGVyIGFueXdheSlcbiAgICAgIHJldHVybiBidWY7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KGRhdGEpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGF0YVtpXSA9IF9yZWNvbnN0cnVjdFBhY2tldChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0gZWxzZSBpZiAoZGF0YSAmJiAnb2JqZWN0JyA9PSB0eXBlb2YgZGF0YSkge1xuICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgICAgZGF0YVtrZXldID0gX3JlY29uc3RydWN0UGFja2V0KGRhdGFba2V5XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICBwYWNrZXQuZGF0YSA9IF9yZWNvbnN0cnVjdFBhY2tldChwYWNrZXQuZGF0YSk7XG4gIHBhY2tldC5hdHRhY2htZW50cyA9IHVuZGVmaW5lZDsgLy8gbm8gbG9uZ2VyIHVzZWZ1bFxuICByZXR1cm4gcGFja2V0O1xufTtcblxuLyoqXG4gKiBBc3luY2hyb25vdXNseSByZW1vdmVzIEJsb2JzIG9yIEZpbGVzIGZyb20gZGF0YSB2aWFcbiAqIEZpbGVSZWFkZXIncyByZWFkQXNBcnJheUJ1ZmZlciBtZXRob2QuIFVzZWQgYmVmb3JlIGVuY29kaW5nXG4gKiBkYXRhIGFzIG1zZ3BhY2suIENhbGxzIGNhbGxiYWNrIHdpdGggdGhlIGJsb2JsZXNzIGRhdGEuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLnJlbW92ZUJsb2JzID0gZnVuY3Rpb24oZGF0YSwgY2FsbGJhY2spIHtcbiAgZnVuY3Rpb24gX3JlbW92ZUJsb2JzKG9iaiwgY3VyS2V5LCBjb250YWluaW5nT2JqZWN0KSB7XG4gICAgaWYgKCFvYmopIHJldHVybiBvYmo7XG5cbiAgICAvLyBjb252ZXJ0IGFueSBibG9iXG4gICAgaWYgKChnbG9iYWwuQmxvYiAmJiBvYmogaW5zdGFuY2VvZiBCbG9iKSB8fFxuICAgICAgICAoZ2xvYmFsLkZpbGUgJiYgb2JqIGluc3RhbmNlb2YgRmlsZSkpIHtcbiAgICAgIHBlbmRpbmdCbG9icysrO1xuXG4gICAgICAvLyBhc3luYyBmaWxlcmVhZGVyXG4gICAgICB2YXIgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICBmaWxlUmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkgeyAvLyB0aGlzLnJlc3VsdCA9PSBhcnJheWJ1ZmZlclxuICAgICAgICBpZiAoY29udGFpbmluZ09iamVjdCkge1xuICAgICAgICAgIGNvbnRhaW5pbmdPYmplY3RbY3VyS2V5XSA9IHRoaXMucmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGJsb2JsZXNzRGF0YSA9IHRoaXMucmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgbm90aGluZyBwZW5kaW5nIGl0cyBjYWxsYmFjayB0aW1lXG4gICAgICAgIGlmKCEgLS1wZW5kaW5nQmxvYnMpIHtcbiAgICAgICAgICBjYWxsYmFjayhibG9ibGVzc0RhdGEpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmaWxlUmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKG9iaik7IC8vIGJsb2IgLT4gYXJyYXlidWZmZXJcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqKSkgeyAvLyBoYW5kbGUgYXJyYXlcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIF9yZW1vdmVCbG9icyhvYmpbaV0sIGksIG9iaik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvYmogJiYgJ29iamVjdCcgPT0gdHlwZW9mIG9iaiAmJiAhaXNCdWYob2JqKSkgeyAvLyBhbmQgb2JqZWN0XG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIF9yZW1vdmVCbG9icyhvYmpba2V5XSwga2V5LCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBwZW5kaW5nQmxvYnMgPSAwO1xuICB2YXIgYmxvYmxlc3NEYXRhID0gZGF0YTtcbiAgX3JlbW92ZUJsb2JzKGJsb2JsZXNzRGF0YSk7XG4gIGlmICghcGVuZGluZ0Jsb2JzKSB7XG4gICAgY2FsbGJhY2soYmxvYmxlc3NEYXRhKTtcbiAgfVxufTtcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tldC5pby1wYXJzZXInKTtcbnZhciBqc29uID0gcmVxdWlyZSgnanNvbjMnKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciBiaW5hcnkgPSByZXF1aXJlKCcuL2JpbmFyeScpO1xudmFyIGlzQnVmID0gcmVxdWlyZSgnLi9pcy1idWZmZXInKTtcblxuLyoqXG4gKiBQcm90b2NvbCB2ZXJzaW9uLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5wcm90b2NvbCA9IDQ7XG5cbi8qKlxuICogUGFja2V0IHR5cGVzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy50eXBlcyA9IFtcbiAgJ0NPTk5FQ1QnLFxuICAnRElTQ09OTkVDVCcsXG4gICdFVkVOVCcsXG4gICdBQ0snLFxuICAnRVJST1InLFxuICAnQklOQVJZX0VWRU5UJyxcbiAgJ0JJTkFSWV9BQ0snXG5dO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBjb25uZWN0YC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuQ09OTkVDVCA9IDA7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGRpc2Nvbm5lY3RgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5ESVNDT05ORUNUID0gMTtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgZXZlbnRgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5FVkVOVCA9IDI7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGFja2AuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkFDSyA9IDM7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGVycm9yYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuRVJST1IgPSA0O1xuXG4vKipcbiAqIFBhY2tldCB0eXBlICdiaW5hcnkgZXZlbnQnXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkJJTkFSWV9FVkVOVCA9IDU7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGJpbmFyeSBhY2tgLiBGb3IgYWNrcyB3aXRoIGJpbmFyeSBhcmd1bWVudHMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkJJTkFSWV9BQ0sgPSA2O1xuXG4vKipcbiAqIEVuY29kZXIgY29uc3RydWN0b3IuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkVuY29kZXIgPSBFbmNvZGVyO1xuXG4vKipcbiAqIERlY29kZXIgY29uc3RydWN0b3IuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkRlY29kZXIgPSBEZWNvZGVyO1xuXG4vKipcbiAqIEEgc29ja2V0LmlvIEVuY29kZXIgaW5zdGFuY2VcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEVuY29kZXIoKSB7fVxuXG4vKipcbiAqIEVuY29kZSBhIHBhY2tldCBhcyBhIHNpbmdsZSBzdHJpbmcgaWYgbm9uLWJpbmFyeSwgb3IgYXMgYVxuICogYnVmZmVyIHNlcXVlbmNlLCBkZXBlbmRpbmcgb24gcGFja2V0IHR5cGUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIHBhY2tldCBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gZnVuY3Rpb24gdG8gaGFuZGxlIGVuY29kaW5ncyAobGlrZWx5IGVuZ2luZS53cml0ZSlcbiAqIEByZXR1cm4gQ2FsbHMgY2FsbGJhY2sgd2l0aCBBcnJheSBvZiBlbmNvZGluZ3NcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW5jb2Rlci5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24ob2JqLCBjYWxsYmFjayl7XG4gIGRlYnVnKCdlbmNvZGluZyBwYWNrZXQgJWonLCBvYmopO1xuXG4gIGlmIChleHBvcnRzLkJJTkFSWV9FVkVOVCA9PSBvYmoudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT0gb2JqLnR5cGUpIHtcbiAgICBlbmNvZGVBc0JpbmFyeShvYmosIGNhbGxiYWNrKTtcbiAgfVxuICBlbHNlIHtcbiAgICB2YXIgZW5jb2RpbmcgPSBlbmNvZGVBc1N0cmluZyhvYmopO1xuICAgIGNhbGxiYWNrKFtlbmNvZGluZ10pO1xuICB9XG59O1xuXG4vKipcbiAqIEVuY29kZSBwYWNrZXQgYXMgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEByZXR1cm4ge1N0cmluZ30gZW5jb2RlZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZW5jb2RlQXNTdHJpbmcob2JqKSB7XG4gIHZhciBzdHIgPSAnJztcbiAgdmFyIG5zcCA9IGZhbHNlO1xuXG4gIC8vIGZpcnN0IGlzIHR5cGVcbiAgc3RyICs9IG9iai50eXBlO1xuXG4gIC8vIGF0dGFjaG1lbnRzIGlmIHdlIGhhdmUgdGhlbVxuICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT0gb2JqLnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09IG9iai50eXBlKSB7XG4gICAgc3RyICs9IG9iai5hdHRhY2htZW50cztcbiAgICBzdHIgKz0gJy0nO1xuICB9XG5cbiAgLy8gaWYgd2UgaGF2ZSBhIG5hbWVzcGFjZSBvdGhlciB0aGFuIGAvYFxuICAvLyB3ZSBhcHBlbmQgaXQgZm9sbG93ZWQgYnkgYSBjb21tYSBgLGBcbiAgaWYgKG9iai5uc3AgJiYgJy8nICE9IG9iai5uc3ApIHtcbiAgICBuc3AgPSB0cnVlO1xuICAgIHN0ciArPSBvYmoubnNwO1xuICB9XG5cbiAgLy8gaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgdGhlIGlkXG4gIGlmIChudWxsICE9IG9iai5pZCkge1xuICAgIGlmIChuc3ApIHtcbiAgICAgIHN0ciArPSAnLCc7XG4gICAgICBuc3AgPSBmYWxzZTtcbiAgICB9XG4gICAgc3RyICs9IG9iai5pZDtcbiAgfVxuXG4gIC8vIGpzb24gZGF0YVxuICBpZiAobnVsbCAhPSBvYmouZGF0YSkge1xuICAgIGlmIChuc3ApIHN0ciArPSAnLCc7XG4gICAgc3RyICs9IGpzb24uc3RyaW5naWZ5KG9iai5kYXRhKTtcbiAgfVxuXG4gIGRlYnVnKCdlbmNvZGVkICVqIGFzICVzJywgb2JqLCBzdHIpO1xuICByZXR1cm4gc3RyO1xufVxuXG4vKipcbiAqIEVuY29kZSBwYWNrZXQgYXMgJ2J1ZmZlciBzZXF1ZW5jZScgYnkgcmVtb3ZpbmcgYmxvYnMsIGFuZFxuICogZGVjb25zdHJ1Y3RpbmcgcGFja2V0IGludG8gb2JqZWN0IHdpdGggcGxhY2Vob2xkZXJzIGFuZFxuICogYSBsaXN0IG9mIGJ1ZmZlcnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQHJldHVybiB7QnVmZmVyfSBlbmNvZGVkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBlbmNvZGVBc0JpbmFyeShvYmosIGNhbGxiYWNrKSB7XG5cbiAgZnVuY3Rpb24gd3JpdGVFbmNvZGluZyhibG9ibGVzc0RhdGEpIHtcbiAgICB2YXIgZGVjb25zdHJ1Y3Rpb24gPSBiaW5hcnkuZGVjb25zdHJ1Y3RQYWNrZXQoYmxvYmxlc3NEYXRhKTtcbiAgICB2YXIgcGFjayA9IGVuY29kZUFzU3RyaW5nKGRlY29uc3RydWN0aW9uLnBhY2tldCk7XG4gICAgdmFyIGJ1ZmZlcnMgPSBkZWNvbnN0cnVjdGlvbi5idWZmZXJzO1xuXG4gICAgYnVmZmVycy51bnNoaWZ0KHBhY2spOyAvLyBhZGQgcGFja2V0IGluZm8gdG8gYmVnaW5uaW5nIG9mIGRhdGEgbGlzdFxuICAgIGNhbGxiYWNrKGJ1ZmZlcnMpOyAvLyB3cml0ZSBhbGwgdGhlIGJ1ZmZlcnNcbiAgfVxuXG4gIGJpbmFyeS5yZW1vdmVCbG9icyhvYmosIHdyaXRlRW5jb2RpbmcpO1xufVxuXG4vKipcbiAqIEEgc29ja2V0LmlvIERlY29kZXIgaW5zdGFuY2VcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IGRlY29kZXJcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gRGVjb2RlcigpIHtcbiAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbnVsbDtcbn1cblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgIHdpdGggRGVjb2Rlci5cbiAqL1xuXG5FbWl0dGVyKERlY29kZXIucHJvdG90eXBlKTtcblxuLyoqXG4gKiBEZWNvZGVzIGFuIGVjb2RlZCBwYWNrZXQgc3RyaW5nIGludG8gcGFja2V0IEpTT04uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG9iaiAtIGVuY29kZWQgcGFja2V0XG4gKiBAcmV0dXJuIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5EZWNvZGVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihvYmopIHtcbiAgdmFyIHBhY2tldDtcbiAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiBvYmopIHtcbiAgICBwYWNrZXQgPSBkZWNvZGVTdHJpbmcob2JqKTtcbiAgICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT0gcGFja2V0LnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09IHBhY2tldC50eXBlKSB7IC8vIGJpbmFyeSBwYWNrZXQncyBqc29uXG4gICAgICB0aGlzLnJlY29uc3RydWN0b3IgPSBuZXcgQmluYXJ5UmVjb25zdHJ1Y3RvcihwYWNrZXQpO1xuXG4gICAgICAvLyBubyBhdHRhY2htZW50cywgbGFiZWxlZCBiaW5hcnkgYnV0IG5vIGJpbmFyeSBkYXRhIHRvIGZvbGxvd1xuICAgICAgaWYgKHRoaXMucmVjb25zdHJ1Y3Rvci5yZWNvblBhY2suYXR0YWNobWVudHMgPT09IDApIHtcbiAgICAgICAgdGhpcy5lbWl0KCdkZWNvZGVkJywgcGFja2V0KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgeyAvLyBub24tYmluYXJ5IGZ1bGwgcGFja2V0XG4gICAgICB0aGlzLmVtaXQoJ2RlY29kZWQnLCBwYWNrZXQpO1xuICAgIH1cbiAgfVxuICBlbHNlIGlmIChpc0J1ZihvYmopIHx8IG9iai5iYXNlNjQpIHsgLy8gcmF3IGJpbmFyeSBkYXRhXG4gICAgaWYgKCF0aGlzLnJlY29uc3RydWN0b3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZ290IGJpbmFyeSBkYXRhIHdoZW4gbm90IHJlY29uc3RydWN0aW5nIGEgcGFja2V0Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhY2tldCA9IHRoaXMucmVjb25zdHJ1Y3Rvci50YWtlQmluYXJ5RGF0YShvYmopO1xuICAgICAgaWYgKHBhY2tldCkgeyAvLyByZWNlaXZlZCBmaW5hbCBidWZmZXJcbiAgICAgICAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbWl0KCdkZWNvZGVkJywgcGFja2V0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHR5cGU6ICcgKyBvYmopO1xuICB9XG59O1xuXG4vKipcbiAqIERlY29kZSBhIHBhY2tldCBTdHJpbmcgKEpTT04gZGF0YSlcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZGVjb2RlU3RyaW5nKHN0cikge1xuICB2YXIgcCA9IHt9O1xuICB2YXIgaSA9IDA7XG5cbiAgLy8gbG9vayB1cCB0eXBlXG4gIHAudHlwZSA9IE51bWJlcihzdHIuY2hhckF0KDApKTtcbiAgaWYgKG51bGwgPT0gZXhwb3J0cy50eXBlc1twLnR5cGVdKSByZXR1cm4gZXJyb3IoKTtcblxuICAvLyBsb29rIHVwIGF0dGFjaG1lbnRzIGlmIHR5cGUgYmluYXJ5XG4gIGlmIChleHBvcnRzLkJJTkFSWV9FVkVOVCA9PSBwLnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09IHAudHlwZSkge1xuICAgIHZhciBidWYgPSAnJztcbiAgICB3aGlsZSAoc3RyLmNoYXJBdCgrK2kpICE9ICctJykge1xuICAgICAgYnVmICs9IHN0ci5jaGFyQXQoaSk7XG4gICAgICBpZiAoaSA9PSBzdHIubGVuZ3RoKSBicmVhaztcbiAgICB9XG4gICAgaWYgKGJ1ZiAhPSBOdW1iZXIoYnVmKSB8fCBzdHIuY2hhckF0KGkpICE9ICctJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGF0dGFjaG1lbnRzJyk7XG4gICAgfVxuICAgIHAuYXR0YWNobWVudHMgPSBOdW1iZXIoYnVmKTtcbiAgfVxuXG4gIC8vIGxvb2sgdXAgbmFtZXNwYWNlIChpZiBhbnkpXG4gIGlmICgnLycgPT0gc3RyLmNoYXJBdChpICsgMSkpIHtcbiAgICBwLm5zcCA9ICcnO1xuICAgIHdoaWxlICgrK2kpIHtcbiAgICAgIHZhciBjID0gc3RyLmNoYXJBdChpKTtcbiAgICAgIGlmICgnLCcgPT0gYykgYnJlYWs7XG4gICAgICBwLm5zcCArPSBjO1xuICAgICAgaWYgKGkgPT0gc3RyLmxlbmd0aCkgYnJlYWs7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHAubnNwID0gJy8nO1xuICB9XG5cbiAgLy8gbG9vayB1cCBpZFxuICB2YXIgbmV4dCA9IHN0ci5jaGFyQXQoaSArIDEpO1xuICBpZiAoJycgIT09IG5leHQgJiYgTnVtYmVyKG5leHQpID09IG5leHQpIHtcbiAgICBwLmlkID0gJyc7XG4gICAgd2hpbGUgKCsraSkge1xuICAgICAgdmFyIGMgPSBzdHIuY2hhckF0KGkpO1xuICAgICAgaWYgKG51bGwgPT0gYyB8fCBOdW1iZXIoYykgIT0gYykge1xuICAgICAgICAtLWk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcC5pZCArPSBzdHIuY2hhckF0KGkpO1xuICAgICAgaWYgKGkgPT0gc3RyLmxlbmd0aCkgYnJlYWs7XG4gICAgfVxuICAgIHAuaWQgPSBOdW1iZXIocC5pZCk7XG4gIH1cblxuICAvLyBsb29rIHVwIGpzb24gZGF0YVxuICBpZiAoc3RyLmNoYXJBdCgrK2kpKSB7XG4gICAgcCA9IHRyeVBhcnNlKHAsIHN0ci5zdWJzdHIoaSkpO1xuICB9XG5cbiAgZGVidWcoJ2RlY29kZWQgJXMgYXMgJWonLCBzdHIsIHApO1xuICByZXR1cm4gcDtcbn1cblxuZnVuY3Rpb24gdHJ5UGFyc2UocCwgc3RyKSB7XG4gIHRyeSB7XG4gICAgcC5kYXRhID0ganNvbi5wYXJzZShzdHIpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiBlcnJvcigpO1xuICB9XG4gIHJldHVybiBwOyBcbn07XG5cbi8qKlxuICogRGVhbGxvY2F0ZXMgYSBwYXJzZXIncyByZXNvdXJjZXNcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRlY29kZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMucmVjb25zdHJ1Y3Rvcikge1xuICAgIHRoaXMucmVjb25zdHJ1Y3Rvci5maW5pc2hlZFJlY29uc3RydWN0aW9uKCk7XG4gIH1cbn07XG5cbi8qKlxuICogQSBtYW5hZ2VyIG9mIGEgYmluYXJ5IGV2ZW50J3MgJ2J1ZmZlciBzZXF1ZW5jZScuIFNob3VsZFxuICogYmUgY29uc3RydWN0ZWQgd2hlbmV2ZXIgYSBwYWNrZXQgb2YgdHlwZSBCSU5BUllfRVZFTlQgaXNcbiAqIGRlY29kZWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQHJldHVybiB7QmluYXJ5UmVjb25zdHJ1Y3Rvcn0gaW5pdGlhbGl6ZWQgcmVjb25zdHJ1Y3RvclxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gQmluYXJ5UmVjb25zdHJ1Y3RvcihwYWNrZXQpIHtcbiAgdGhpcy5yZWNvblBhY2sgPSBwYWNrZXQ7XG4gIHRoaXMuYnVmZmVycyA9IFtdO1xufVxuXG4vKipcbiAqIE1ldGhvZCB0byBiZSBjYWxsZWQgd2hlbiBiaW5hcnkgZGF0YSByZWNlaXZlZCBmcm9tIGNvbm5lY3Rpb25cbiAqIGFmdGVyIGEgQklOQVJZX0VWRU5UIHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlciB8IEFycmF5QnVmZmVyfSBiaW5EYXRhIC0gdGhlIHJhdyBiaW5hcnkgZGF0YSByZWNlaXZlZFxuICogQHJldHVybiB7bnVsbCB8IE9iamVjdH0gcmV0dXJucyBudWxsIGlmIG1vcmUgYmluYXJ5IGRhdGEgaXMgZXhwZWN0ZWQgb3JcbiAqICAgYSByZWNvbnN0cnVjdGVkIHBhY2tldCBvYmplY3QgaWYgYWxsIGJ1ZmZlcnMgaGF2ZSBiZWVuIHJlY2VpdmVkLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQmluYXJ5UmVjb25zdHJ1Y3Rvci5wcm90b3R5cGUudGFrZUJpbmFyeURhdGEgPSBmdW5jdGlvbihiaW5EYXRhKSB7XG4gIHRoaXMuYnVmZmVycy5wdXNoKGJpbkRhdGEpO1xuICBpZiAodGhpcy5idWZmZXJzLmxlbmd0aCA9PSB0aGlzLnJlY29uUGFjay5hdHRhY2htZW50cykgeyAvLyBkb25lIHdpdGggYnVmZmVyIGxpc3RcbiAgICB2YXIgcGFja2V0ID0gYmluYXJ5LnJlY29uc3RydWN0UGFja2V0KHRoaXMucmVjb25QYWNrLCB0aGlzLmJ1ZmZlcnMpO1xuICAgIHRoaXMuZmluaXNoZWRSZWNvbnN0cnVjdGlvbigpO1xuICAgIHJldHVybiBwYWNrZXQ7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIENsZWFucyB1cCBiaW5hcnkgcGFja2V0IHJlY29uc3RydWN0aW9uIHZhcmlhYmxlcy5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5CaW5hcnlSZWNvbnN0cnVjdG9yLnByb3RvdHlwZS5maW5pc2hlZFJlY29uc3RydWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucmVjb25QYWNrID0gbnVsbDtcbiAgdGhpcy5idWZmZXJzID0gW107XG59O1xuXG5mdW5jdGlvbiBlcnJvcihkYXRhKXtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBleHBvcnRzLkVSUk9SLFxuICAgIGRhdGE6ICdwYXJzZXIgZXJyb3InXG4gIH07XG59XG4iLCJcbm1vZHVsZS5leHBvcnRzID0gaXNCdWY7XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIG9iaiBpcyBhIGJ1ZmZlciBvciBhbiBhcnJheWJ1ZmZlci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpc0J1ZihvYmopIHtcbiAgcmV0dXJuIChnbG9iYWwuQnVmZmVyICYmIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIob2JqKSkgfHxcbiAgICAgICAgIChnbG9iYWwuQXJyYXlCdWZmZXIgJiYgb2JqIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpO1xufVxuIiwiXG4vKipcbiAqIEV4cG9zZSBgRW1pdHRlcmAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBFbWl0dGVyO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYEVtaXR0ZXJgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gRW1pdHRlcihvYmopIHtcbiAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XG59O1xuXG4vKipcbiAqIE1peGluIHRoZSBlbWl0dGVyIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbWl4aW4ob2JqKSB7XG4gIGZvciAodmFyIGtleSBpbiBFbWl0dGVyLnByb3RvdHlwZSkge1xuICAgIG9ialtrZXldID0gRW1pdHRlci5wcm90b3R5cGVba2V5XTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub24gPVxuRW1pdHRlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgKHRoaXMuX2NhbGxiYWNrc1tldmVudF0gPSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdIHx8IFtdKVxuICAgIC5wdXNoKGZuKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZHMgYW4gYGV2ZW50YCBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgaW52b2tlZCBhIHNpbmdsZVxuICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cbiAgZnVuY3Rpb24gb24oKSB7XG4gICAgc2VsZi5vZmYoZXZlbnQsIG9uKTtcbiAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgb24uZm4gPSBmbjtcbiAgdGhpcy5vbihldmVudCwgb24pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgYGV2ZW50YCBvciBhbGxcbiAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9mZiA9XG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcblxuICAvLyBhbGxcbiAgaWYgKDAgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc3BlY2lmaWMgZXZlbnRcbiAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1tldmVudF07XG4gIGlmICghY2FsbGJhY2tzKSByZXR1cm4gdGhpcztcblxuICAvLyByZW1vdmUgYWxsIGhhbmRsZXJzXG4gIGlmICgxID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzW2V2ZW50XTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHJlbW92ZSBzcGVjaWZpYyBoYW5kbGVyXG4gIHZhciBjYjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICBjYiA9IGNhbGxiYWNrc1tpXTtcbiAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xuICAgICAgY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRW1pdCBgZXZlbnRgIHdpdGggdGhlIGdpdmVuIGFyZ3MuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge01peGVkfSAuLi5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxuICAgICwgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XTtcblxuICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGNhbGxiYWNrc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0dXJuIGFycmF5IG9mIGNhbGxiYWNrcyBmb3IgYGV2ZW50YC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrc1tldmVudF0gfHwgW107XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoaXMgZW1pdHRlciBoYXMgYGV2ZW50YCBoYW5kbGVycy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgcmV0dXJuICEhIHRoaXMubGlzdGVuZXJzKGV2ZW50KS5sZW5ndGg7XG59O1xuIiwiXG4vKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kZWJ1ZycpO1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9ICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWVcbiAgICAgICAgICAgICAgICYmICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWUuc3RvcmFnZVxuICAgICAgICAgICAgICAgICAgPyBjaHJvbWUuc3RvcmFnZS5sb2NhbFxuICAgICAgICAgICAgICAgICAgOiBsb2NhbHN0b3JhZ2UoKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG4gICdsaWdodHNlYWdyZWVuJyxcbiAgJ2ZvcmVzdGdyZWVuJyxcbiAgJ2dvbGRlbnJvZCcsXG4gICdkb2RnZXJibHVlJyxcbiAgJ2RhcmtvcmNoaWQnLFxuICAnY3JpbXNvbidcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuICAvLyBpcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuICByZXR1cm4gKCdXZWJraXRBcHBlYXJhbmNlJyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUpIHx8XG4gICAgLy8gaXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuICAgICh3aW5kb3cuY29uc29sZSAmJiAoY29uc29sZS5maXJlYnVnIHx8IChjb25zb2xlLmV4Y2VwdGlvbiAmJiBjb25zb2xlLnRhYmxlKSkpIHx8XG4gICAgLy8gaXMgZmlyZWZveCA+PSB2MzE/XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG4gICAgKG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxKTtcbn1cblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcbn07XG5cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKCkge1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIHVzZUNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXG4gIGFyZ3NbMF0gPSAodXNlQ29sb3JzID8gJyVjJyA6ICcnKVxuICAgICsgdGhpcy5uYW1lc3BhY2VcbiAgICArICh1c2VDb2xvcnMgPyAnICVjJyA6ICcgJylcbiAgICArIGFyZ3NbMF1cbiAgICArICh1c2VDb2xvcnMgPyAnJWMgJyA6ICcgJylcbiAgICArICcrJyArIGV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuICBpZiAoIXVzZUNvbG9ycykgcmV0dXJuIGFyZ3M7XG5cbiAgdmFyIGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuICBhcmdzID0gW2FyZ3NbMF0sIGMsICdjb2xvcjogaW5oZXJpdCddLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzLCAxKSk7XG5cbiAgLy8gdGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcbiAgLy8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuICAvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RDID0gMDtcbiAgYXJnc1swXS5yZXBsYWNlKC8lW2EteiVdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgaWYgKCclJScgPT09IG1hdGNoKSByZXR1cm47XG4gICAgaW5kZXgrKztcbiAgICBpZiAoJyVjJyA9PT0gbWF0Y2gpIHtcbiAgICAgIC8vIHdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuICAgICAgLy8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcbiAgICAgIGxhc3RDID0gaW5kZXg7XG4gICAgfVxuICB9KTtcblxuICBhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG4gIHJldHVybiBhcmdzO1xufVxuXG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUubG9nKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5sb2dgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGxvZygpIHtcbiAgLy8gdGhpcyBoYWNrZXJ5IGlzIHJlcXVpcmVkIGZvciBJRTgvOSwgd2hlcmVcbiAgLy8gdGhlIGBjb25zb2xlLmxvZ2AgZnVuY3Rpb24gZG9lc24ndCBoYXZlICdhcHBseSdcbiAgcmV0dXJuICdvYmplY3QnID09PSB0eXBlb2YgY29uc29sZVxuICAgICYmIGNvbnNvbGUubG9nXG4gICAgJiYgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZS5sb2csIGNvbnNvbGUsIGFyZ3VtZW50cyk7XG59XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuICB0cnkge1xuICAgIGlmIChudWxsID09IG5hbWVzcGFjZXMpIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UuZGVidWcgPSBuYW1lc3BhY2VzO1xuICAgIH1cbiAgfSBjYXRjaChlKSB7fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvYWQoKSB7XG4gIHZhciByO1xuICB0cnkge1xuICAgIHIgPSBleHBvcnRzLnN0b3JhZ2UuZGVidWc7XG4gIH0gY2F0Y2goZSkge31cbiAgcmV0dXJuIHI7XG59XG5cbi8qKlxuICogRW5hYmxlIG5hbWVzcGFjZXMgbGlzdGVkIGluIGBsb2NhbFN0b3JhZ2UuZGVidWdgIGluaXRpYWxseS5cbiAqL1xuXG5leHBvcnRzLmVuYWJsZShsb2FkKCkpO1xuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpe1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICB9IGNhdGNoIChlKSB7fVxufVxuIiwiXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGRlYnVnO1xuZXhwb3J0cy5jb2VyY2UgPSBjb2VyY2U7XG5leHBvcnRzLmRpc2FibGUgPSBkaXNhYmxlO1xuZXhwb3J0cy5lbmFibGUgPSBlbmFibGU7XG5leHBvcnRzLmVuYWJsZWQgPSBlbmFibGVkO1xuZXhwb3J0cy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cbi8qKlxuICogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG4gKi9cblxuZXhwb3J0cy5uYW1lcyA9IFtdO1xuZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4vKipcbiAqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cbiAqXG4gKiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlcmNhc2VkIGxldHRlciwgaS5lLiBcIm5cIi5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMgPSB7fTtcblxuLyoqXG4gKiBQcmV2aW91c2x5IGFzc2lnbmVkIGNvbG9yLlxuICovXG5cbnZhciBwcmV2Q29sb3IgPSAwO1xuXG4vKipcbiAqIFByZXZpb3VzIGxvZyB0aW1lc3RhbXAuXG4gKi9cblxudmFyIHByZXZUaW1lO1xuXG4vKipcbiAqIFNlbGVjdCBhIGNvbG9yLlxuICpcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNlbGVjdENvbG9yKCkge1xuICByZXR1cm4gZXhwb3J0cy5jb2xvcnNbcHJldkNvbG9yKysgJSBleHBvcnRzLmNvbG9ycy5sZW5ndGhdO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZWJ1ZyhuYW1lc3BhY2UpIHtcblxuICAvLyBkZWZpbmUgdGhlIGBkaXNhYmxlZGAgdmVyc2lvblxuICBmdW5jdGlvbiBkaXNhYmxlZCgpIHtcbiAgfVxuICBkaXNhYmxlZC5lbmFibGVkID0gZmFsc2U7XG5cbiAgLy8gZGVmaW5lIHRoZSBgZW5hYmxlZGAgdmVyc2lvblxuICBmdW5jdGlvbiBlbmFibGVkKCkge1xuXG4gICAgdmFyIHNlbGYgPSBlbmFibGVkO1xuXG4gICAgLy8gc2V0IGBkaWZmYCB0aW1lc3RhbXBcbiAgICB2YXIgY3VyciA9ICtuZXcgRGF0ZSgpO1xuICAgIHZhciBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG4gICAgc2VsZi5kaWZmID0gbXM7XG4gICAgc2VsZi5wcmV2ID0gcHJldlRpbWU7XG4gICAgc2VsZi5jdXJyID0gY3VycjtcbiAgICBwcmV2VGltZSA9IGN1cnI7XG5cbiAgICAvLyBhZGQgdGhlIGBjb2xvcmAgaWYgbm90IHNldFxuICAgIGlmIChudWxsID09IHNlbGYudXNlQ29sb3JzKSBzZWxmLnVzZUNvbG9ycyA9IGV4cG9ydHMudXNlQ29sb3JzKCk7XG4gICAgaWYgKG51bGwgPT0gc2VsZi5jb2xvciAmJiBzZWxmLnVzZUNvbG9ycykgc2VsZi5jb2xvciA9IHNlbGVjdENvbG9yKCk7XG5cbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgICBhcmdzWzBdID0gZXhwb3J0cy5jb2VyY2UoYXJnc1swXSk7XG5cbiAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBhcmdzWzBdKSB7XG4gICAgICAvLyBhbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlb1xuICAgICAgYXJncyA9IFsnJW8nXS5jb25jYXQoYXJncyk7XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EteiVdKS9nLCBmdW5jdGlvbihtYXRjaCwgZm9ybWF0KSB7XG4gICAgICAvLyBpZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG4gICAgICBpZiAobWF0Y2ggPT09ICclJScpIHJldHVybiBtYXRjaDtcbiAgICAgIGluZGV4Kys7XG4gICAgICB2YXIgZm9ybWF0dGVyID0gZXhwb3J0cy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG4gICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGZvcm1hdHRlcikge1xuICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleF07XG4gICAgICAgIG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuICAgICAgICAvLyBub3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG4gICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgaW5kZXgtLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcblxuICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZXhwb3J0cy5mb3JtYXRBcmdzKSB7XG4gICAgICBhcmdzID0gZXhwb3J0cy5mb3JtYXRBcmdzLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIH1cbiAgICB2YXIgbG9nRm4gPSBlbmFibGVkLmxvZyB8fCBleHBvcnRzLmxvZyB8fCBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO1xuICAgIGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICB9XG4gIGVuYWJsZWQuZW5hYmxlZCA9IHRydWU7XG5cbiAgdmFyIGZuID0gZXhwb3J0cy5lbmFibGVkKG5hbWVzcGFjZSkgPyBlbmFibGVkIDogZGlzYWJsZWQ7XG5cbiAgZm4ubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuXG4gIHJldHVybiBmbjtcbn1cblxuLyoqXG4gKiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG4gKiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG4gIGV4cG9ydHMuc2F2ZShuYW1lc3BhY2VzKTtcblxuICB2YXIgc3BsaXQgPSAobmFtZXNwYWNlcyB8fCAnJykuc3BsaXQoL1tcXHMsXSsvKTtcbiAgdmFyIGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKCFzcGxpdFtpXSkgY29udGludWU7IC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG4gICAgbmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG4gICAgaWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuICAgICAgZXhwb3J0cy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgZXhwb3J0cy5lbmFibGUoJycpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG4gIHZhciBpLCBsZW47XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENvZXJjZSBgdmFsYC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWxcbiAqIEByZXR1cm4ge01peGVkfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG4gIHJldHVybiB2YWw7XG59XG4iLCIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHkgPSBkICogMzY1LjI1O1xuXG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKXtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgdmFsKSByZXR1cm4gcGFyc2UodmFsKTtcbiAgcmV0dXJuIG9wdGlvbnMubG9uZ1xuICAgID8gbG9uZyh2YWwpXG4gICAgOiBzaG9ydCh2YWwpO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9ICcnICsgc3RyO1xuICBpZiAoc3RyLmxlbmd0aCA+IDEwMDAwKSByZXR1cm47XG4gIHZhciBtYXRjaCA9IC9eKCg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoc3RyKTtcbiAgaWYgKCFtYXRjaCkgcmV0dXJuO1xuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZDtcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnaG91cic6XG4gICAgY2FzZSAnaHJzJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gbiAqIGg7XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtaW5zJzpcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtO1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogcztcbiAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICBjYXNlICdtc2Vjcyc6XG4gICAgY2FzZSAnbXNlYyc6XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIG47XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzaG9ydChtcykge1xuICBpZiAobXMgPj0gZCkgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcbiAgaWYgKG1zID49IGgpIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG4gIGlmIChtcyA+PSBtKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuICBpZiAobXMgPj0gcykgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvbmcobXMpIHtcbiAgcmV0dXJuIHBsdXJhbChtcywgZCwgJ2RheScpXG4gICAgfHwgcGx1cmFsKG1zLCBoLCAnaG91cicpXG4gICAgfHwgcGx1cmFsKG1zLCBtLCAnbWludXRlJylcbiAgICB8fCBwbHVyYWwobXMsIHMsICdzZWNvbmQnKVxuICAgIHx8IG1zICsgJyBtcyc7XG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBuLCBuYW1lKSB7XG4gIGlmIChtcyA8IG4pIHJldHVybjtcbiAgaWYgKG1zIDwgbiAqIDEuNSkgcmV0dXJuIE1hdGguZmxvb3IobXMgLyBuKSArICcgJyArIG5hbWU7XG4gIHJldHVybiBNYXRoLmNlaWwobXMgLyBuKSArICcgJyArIG5hbWUgKyAncyc7XG59XG4iLCIvKiEgSlNPTiB2My4zLjIgfCBodHRwOi8vYmVzdGllanMuZ2l0aHViLmlvL2pzb24zIHwgQ29weXJpZ2h0IDIwMTItMjAxNCwgS2l0IENhbWJyaWRnZSB8IGh0dHA6Ly9raXQubWl0LWxpY2Vuc2Uub3JnICovXG47KGZ1bmN0aW9uICgpIHtcbiAgLy8gRGV0ZWN0IHRoZSBgZGVmaW5lYCBmdW5jdGlvbiBleHBvc2VkIGJ5IGFzeW5jaHJvbm91cyBtb2R1bGUgbG9hZGVycy4gVGhlXG4gIC8vIHN0cmljdCBgZGVmaW5lYCBjaGVjayBpcyBuZWNlc3NhcnkgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBgci5qc2AuXG4gIHZhciBpc0xvYWRlciA9IHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kO1xuXG4gIC8vIEEgc2V0IG9mIHR5cGVzIHVzZWQgdG8gZGlzdGluZ3Vpc2ggb2JqZWN0cyBmcm9tIHByaW1pdGl2ZXMuXG4gIHZhciBvYmplY3RUeXBlcyA9IHtcbiAgICBcImZ1bmN0aW9uXCI6IHRydWUsXG4gICAgXCJvYmplY3RcIjogdHJ1ZVxuICB9O1xuXG4gIC8vIERldGVjdCB0aGUgYGV4cG9ydHNgIG9iamVjdCBleHBvc2VkIGJ5IENvbW1vbkpTIGltcGxlbWVudGF0aW9ucy5cbiAgdmFyIGZyZWVFeHBvcnRzID0gb2JqZWN0VHlwZXNbdHlwZW9mIGV4cG9ydHNdICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuICAvLyBVc2UgdGhlIGBnbG9iYWxgIG9iamVjdCBleHBvc2VkIGJ5IE5vZGUgKGluY2x1ZGluZyBCcm93c2VyaWZ5IHZpYVxuICAvLyBgaW5zZXJ0LW1vZHVsZS1nbG9iYWxzYCksIE5hcndoYWwsIGFuZCBSaW5nbyBhcyB0aGUgZGVmYXVsdCBjb250ZXh0LFxuICAvLyBhbmQgdGhlIGB3aW5kb3dgIG9iamVjdCBpbiBicm93c2Vycy4gUmhpbm8gZXhwb3J0cyBhIGBnbG9iYWxgIGZ1bmN0aW9uXG4gIC8vIGluc3RlYWQuXG4gIHZhciByb290ID0gb2JqZWN0VHlwZXNbdHlwZW9mIHdpbmRvd10gJiYgd2luZG93IHx8IHRoaXMsXG4gICAgICBmcmVlR2xvYmFsID0gZnJlZUV4cG9ydHMgJiYgb2JqZWN0VHlwZXNbdHlwZW9mIG1vZHVsZV0gJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgdHlwZW9mIGdsb2JhbCA9PSBcIm9iamVjdFwiICYmIGdsb2JhbDtcblxuICBpZiAoZnJlZUdsb2JhbCAmJiAoZnJlZUdsb2JhbFtcImdsb2JhbFwiXSA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsW1wid2luZG93XCJdID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWxbXCJzZWxmXCJdID09PSBmcmVlR2xvYmFsKSkge1xuICAgIHJvb3QgPSBmcmVlR2xvYmFsO1xuICB9XG5cbiAgLy8gUHVibGljOiBJbml0aWFsaXplcyBKU09OIDMgdXNpbmcgdGhlIGdpdmVuIGBjb250ZXh0YCBvYmplY3QsIGF0dGFjaGluZyB0aGVcbiAgLy8gYHN0cmluZ2lmeWAgYW5kIGBwYXJzZWAgZnVuY3Rpb25zIHRvIHRoZSBzcGVjaWZpZWQgYGV4cG9ydHNgIG9iamVjdC5cbiAgZnVuY3Rpb24gcnVuSW5Db250ZXh0KGNvbnRleHQsIGV4cG9ydHMpIHtcbiAgICBjb250ZXh0IHx8IChjb250ZXh0ID0gcm9vdFtcIk9iamVjdFwiXSgpKTtcbiAgICBleHBvcnRzIHx8IChleHBvcnRzID0gcm9vdFtcIk9iamVjdFwiXSgpKTtcblxuICAgIC8vIE5hdGl2ZSBjb25zdHJ1Y3RvciBhbGlhc2VzLlxuICAgIHZhciBOdW1iZXIgPSBjb250ZXh0W1wiTnVtYmVyXCJdIHx8IHJvb3RbXCJOdW1iZXJcIl0sXG4gICAgICAgIFN0cmluZyA9IGNvbnRleHRbXCJTdHJpbmdcIl0gfHwgcm9vdFtcIlN0cmluZ1wiXSxcbiAgICAgICAgT2JqZWN0ID0gY29udGV4dFtcIk9iamVjdFwiXSB8fCByb290W1wiT2JqZWN0XCJdLFxuICAgICAgICBEYXRlID0gY29udGV4dFtcIkRhdGVcIl0gfHwgcm9vdFtcIkRhdGVcIl0sXG4gICAgICAgIFN5bnRheEVycm9yID0gY29udGV4dFtcIlN5bnRheEVycm9yXCJdIHx8IHJvb3RbXCJTeW50YXhFcnJvclwiXSxcbiAgICAgICAgVHlwZUVycm9yID0gY29udGV4dFtcIlR5cGVFcnJvclwiXSB8fCByb290W1wiVHlwZUVycm9yXCJdLFxuICAgICAgICBNYXRoID0gY29udGV4dFtcIk1hdGhcIl0gfHwgcm9vdFtcIk1hdGhcIl0sXG4gICAgICAgIG5hdGl2ZUpTT04gPSBjb250ZXh0W1wiSlNPTlwiXSB8fCByb290W1wiSlNPTlwiXTtcblxuICAgIC8vIERlbGVnYXRlIHRvIHRoZSBuYXRpdmUgYHN0cmluZ2lmeWAgYW5kIGBwYXJzZWAgaW1wbGVtZW50YXRpb25zLlxuICAgIGlmICh0eXBlb2YgbmF0aXZlSlNPTiA9PSBcIm9iamVjdFwiICYmIG5hdGl2ZUpTT04pIHtcbiAgICAgIGV4cG9ydHMuc3RyaW5naWZ5ID0gbmF0aXZlSlNPTi5zdHJpbmdpZnk7XG4gICAgICBleHBvcnRzLnBhcnNlID0gbmF0aXZlSlNPTi5wYXJzZTtcbiAgICB9XG5cbiAgICAvLyBDb252ZW5pZW5jZSBhbGlhc2VzLlxuICAgIHZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGUsXG4gICAgICAgIGdldENsYXNzID0gb2JqZWN0UHJvdG8udG9TdHJpbmcsXG4gICAgICAgIGlzUHJvcGVydHksIGZvckVhY2gsIHVuZGVmO1xuXG4gICAgLy8gVGVzdCB0aGUgYERhdGUjZ2V0VVRDKmAgbWV0aG9kcy4gQmFzZWQgb24gd29yayBieSBAWWFmZmxlLlxuICAgIHZhciBpc0V4dGVuZGVkID0gbmV3IERhdGUoLTM1MDk4MjczMzQ1NzMyOTIpO1xuICAgIHRyeSB7XG4gICAgICAvLyBUaGUgYGdldFVUQ0Z1bGxZZWFyYCwgYE1vbnRoYCwgYW5kIGBEYXRlYCBtZXRob2RzIHJldHVybiBub25zZW5zaWNhbFxuICAgICAgLy8gcmVzdWx0cyBmb3IgY2VydGFpbiBkYXRlcyBpbiBPcGVyYSA+PSAxMC41My5cbiAgICAgIGlzRXh0ZW5kZWQgPSBpc0V4dGVuZGVkLmdldFVUQ0Z1bGxZZWFyKCkgPT0gLTEwOTI1MiAmJiBpc0V4dGVuZGVkLmdldFVUQ01vbnRoKCkgPT09IDAgJiYgaXNFeHRlbmRlZC5nZXRVVENEYXRlKCkgPT09IDEgJiZcbiAgICAgICAgLy8gU2FmYXJpIDwgMi4wLjIgc3RvcmVzIHRoZSBpbnRlcm5hbCBtaWxsaXNlY29uZCB0aW1lIHZhbHVlIGNvcnJlY3RseSxcbiAgICAgICAgLy8gYnV0IGNsaXBzIHRoZSB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGRhdGUgbWV0aG9kcyB0byB0aGUgcmFuZ2Ugb2ZcbiAgICAgICAgLy8gc2lnbmVkIDMyLWJpdCBpbnRlZ2VycyAoWy0yICoqIDMxLCAyICoqIDMxIC0gMV0pLlxuICAgICAgICBpc0V4dGVuZGVkLmdldFVUQ0hvdXJzKCkgPT0gMTAgJiYgaXNFeHRlbmRlZC5nZXRVVENNaW51dGVzKCkgPT0gMzcgJiYgaXNFeHRlbmRlZC5nZXRVVENTZWNvbmRzKCkgPT0gNiAmJiBpc0V4dGVuZGVkLmdldFVUQ01pbGxpc2Vjb25kcygpID09IDcwODtcbiAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG5cbiAgICAvLyBJbnRlcm5hbDogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBuYXRpdmUgYEpTT04uc3RyaW5naWZ5YCBhbmQgYHBhcnNlYFxuICAgIC8vIGltcGxlbWVudGF0aW9ucyBhcmUgc3BlYy1jb21wbGlhbnQuIEJhc2VkIG9uIHdvcmsgYnkgS2VuIFNueWRlci5cbiAgICBmdW5jdGlvbiBoYXMobmFtZSkge1xuICAgICAgaWYgKGhhc1tuYW1lXSAhPT0gdW5kZWYpIHtcbiAgICAgICAgLy8gUmV0dXJuIGNhY2hlZCBmZWF0dXJlIHRlc3QgcmVzdWx0LlxuICAgICAgICByZXR1cm4gaGFzW25hbWVdO1xuICAgICAgfVxuICAgICAgdmFyIGlzU3VwcG9ydGVkO1xuICAgICAgaWYgKG5hbWUgPT0gXCJidWctc3RyaW5nLWNoYXItaW5kZXhcIikge1xuICAgICAgICAvLyBJRSA8PSA3IGRvZXNuJ3Qgc3VwcG9ydCBhY2Nlc3Npbmcgc3RyaW5nIGNoYXJhY3RlcnMgdXNpbmcgc3F1YXJlXG4gICAgICAgIC8vIGJyYWNrZXQgbm90YXRpb24uIElFIDggb25seSBzdXBwb3J0cyB0aGlzIGZvciBwcmltaXRpdmVzLlxuICAgICAgICBpc1N1cHBvcnRlZCA9IFwiYVwiWzBdICE9IFwiYVwiO1xuICAgICAgfSBlbHNlIGlmIChuYW1lID09IFwianNvblwiKSB7XG4gICAgICAgIC8vIEluZGljYXRlcyB3aGV0aGVyIGJvdGggYEpTT04uc3RyaW5naWZ5YCBhbmQgYEpTT04ucGFyc2VgIGFyZVxuICAgICAgICAvLyBzdXBwb3J0ZWQuXG4gICAgICAgIGlzU3VwcG9ydGVkID0gaGFzKFwianNvbi1zdHJpbmdpZnlcIikgJiYgaGFzKFwianNvbi1wYXJzZVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB2YWx1ZSwgc2VyaWFsaXplZCA9ICd7XCJhXCI6WzEsdHJ1ZSxmYWxzZSxudWxsLFwiXFxcXHUwMDAwXFxcXGJcXFxcblxcXFxmXFxcXHJcXFxcdFwiXX0nO1xuICAgICAgICAvLyBUZXN0IGBKU09OLnN0cmluZ2lmeWAuXG4gICAgICAgIGlmIChuYW1lID09IFwianNvbi1zdHJpbmdpZnlcIikge1xuICAgICAgICAgIHZhciBzdHJpbmdpZnkgPSBleHBvcnRzLnN0cmluZ2lmeSwgc3RyaW5naWZ5U3VwcG9ydGVkID0gdHlwZW9mIHN0cmluZ2lmeSA9PSBcImZ1bmN0aW9uXCIgJiYgaXNFeHRlbmRlZDtcbiAgICAgICAgICBpZiAoc3RyaW5naWZ5U3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAvLyBBIHRlc3QgZnVuY3Rpb24gb2JqZWN0IHdpdGggYSBjdXN0b20gYHRvSlNPTmAgbWV0aG9kLlxuICAgICAgICAgICAgKHZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH0pLnRvSlNPTiA9IHZhbHVlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc3RyaW5naWZ5U3VwcG9ydGVkID1cbiAgICAgICAgICAgICAgICAvLyBGaXJlZm94IDMuMWIxIGFuZCBiMiBzZXJpYWxpemUgc3RyaW5nLCBudW1iZXIsIGFuZCBib29sZWFuXG4gICAgICAgICAgICAgICAgLy8gcHJpbWl0aXZlcyBhcyBvYmplY3QgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KDApID09PSBcIjBcIiAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCBiMiwgYW5kIEpTT04gMiBzZXJpYWxpemUgd3JhcHBlZCBwcmltaXRpdmVzIGFzIG9iamVjdFxuICAgICAgICAgICAgICAgIC8vIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgTnVtYmVyKCkpID09PSBcIjBcIiAmJlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgU3RyaW5nKCkpID09ICdcIlwiJyAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCAyIHRocm93IGFuIGVycm9yIGlmIHRoZSB2YWx1ZSBpcyBgbnVsbGAsIGB1bmRlZmluZWRgLCBvclxuICAgICAgICAgICAgICAgIC8vIGRvZXMgbm90IGRlZmluZSBhIGNhbm9uaWNhbCBKU09OIHJlcHJlc2VudGF0aW9uICh0aGlzIGFwcGxpZXMgdG9cbiAgICAgICAgICAgICAgICAvLyBvYmplY3RzIHdpdGggYHRvSlNPTmAgcHJvcGVydGllcyBhcyB3ZWxsLCAqdW5sZXNzKiB0aGV5IGFyZSBuZXN0ZWRcbiAgICAgICAgICAgICAgICAvLyB3aXRoaW4gYW4gb2JqZWN0IG9yIGFycmF5KS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoZ2V0Q2xhc3MpID09PSB1bmRlZiAmJlxuICAgICAgICAgICAgICAgIC8vIElFIDggc2VyaWFsaXplcyBgdW5kZWZpbmVkYCBhcyBgXCJ1bmRlZmluZWRcImAuIFNhZmFyaSA8PSA1LjEuNyBhbmRcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMyBwYXNzIHRoaXMgdGVzdC5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkodW5kZWYpID09PSB1bmRlZiAmJlxuICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA8PSA1LjEuNyBhbmQgRkYgMy4xYjMgdGhyb3cgYEVycm9yYHMgYW5kIGBUeXBlRXJyb3JgcyxcbiAgICAgICAgICAgICAgICAvLyByZXNwZWN0aXZlbHksIGlmIHRoZSB2YWx1ZSBpcyBvbWl0dGVkIGVudGlyZWx5LlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSgpID09PSB1bmRlZiAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCAyIHRocm93IGFuIGVycm9yIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSBudW1iZXIsXG4gICAgICAgICAgICAgICAgLy8gc3RyaW5nLCBhcnJheSwgb2JqZWN0LCBCb29sZWFuLCBvciBgbnVsbGAgbGl0ZXJhbC4gVGhpcyBhcHBsaWVzIHRvXG4gICAgICAgICAgICAgICAgLy8gb2JqZWN0cyB3aXRoIGN1c3RvbSBgdG9KU09OYCBtZXRob2RzIGFzIHdlbGwsIHVubGVzcyB0aGV5IGFyZSBuZXN0ZWRcbiAgICAgICAgICAgICAgICAvLyBpbnNpZGUgb2JqZWN0IG9yIGFycmF5IGxpdGVyYWxzLiBZVUkgMy4wLjBiMSBpZ25vcmVzIGN1c3RvbSBgdG9KU09OYFxuICAgICAgICAgICAgICAgIC8vIG1ldGhvZHMgZW50aXJlbHkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KHZhbHVlKSA9PT0gXCIxXCIgJiZcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoW3ZhbHVlXSkgPT0gXCJbMV1cIiAmJlxuICAgICAgICAgICAgICAgIC8vIFByb3RvdHlwZSA8PSAxLjYuMSBzZXJpYWxpemVzIGBbdW5kZWZpbmVkXWAgYXMgYFwiW11cImAgaW5zdGVhZCBvZlxuICAgICAgICAgICAgICAgIC8vIGBcIltudWxsXVwiYC5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoW3VuZGVmXSkgPT0gXCJbbnVsbF1cIiAmJlxuICAgICAgICAgICAgICAgIC8vIFlVSSAzLjAuMGIxIGZhaWxzIHRvIHNlcmlhbGl6ZSBgbnVsbGAgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG51bGwpID09IFwibnVsbFwiICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgaGFsdHMgc2VyaWFsaXphdGlvbiBpZiBhbiBhcnJheSBjb250YWlucyBhIGZ1bmN0aW9uOlxuICAgICAgICAgICAgICAgIC8vIGBbMSwgdHJ1ZSwgZ2V0Q2xhc3MsIDFdYCBzZXJpYWxpemVzIGFzIFwiWzEsdHJ1ZSxdLFwiLiBGRiAzLjFiM1xuICAgICAgICAgICAgICAgIC8vIGVsaWRlcyBub24tSlNPTiB2YWx1ZXMgZnJvbSBvYmplY3RzIGFuZCBhcnJheXMsIHVubGVzcyB0aGV5XG4gICAgICAgICAgICAgICAgLy8gZGVmaW5lIGN1c3RvbSBgdG9KU09OYCBtZXRob2RzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbdW5kZWYsIGdldENsYXNzLCBudWxsXSkgPT0gXCJbbnVsbCxudWxsLG51bGxdXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBTaW1wbGUgc2VyaWFsaXphdGlvbiB0ZXN0LiBGRiAzLjFiMSB1c2VzIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlc1xuICAgICAgICAgICAgICAgIC8vIHdoZXJlIGNoYXJhY3RlciBlc2NhcGUgY29kZXMgYXJlIGV4cGVjdGVkIChlLmcuLCBgXFxiYCA9PiBgXFx1MDAwOGApLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSh7IFwiYVwiOiBbdmFsdWUsIHRydWUsIGZhbHNlLCBudWxsLCBcIlxceDAwXFxiXFxuXFxmXFxyXFx0XCJdIH0pID09IHNlcmlhbGl6ZWQgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSBhbmQgYjIgaWdub3JlIHRoZSBgZmlsdGVyYCBhbmQgYHdpZHRoYCBhcmd1bWVudHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG51bGwsIHZhbHVlKSA9PT0gXCIxXCIgJiZcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoWzEsIDJdLCBudWxsLCAxKSA9PSBcIltcXG4gMSxcXG4gMlxcbl1cIiAmJlxuICAgICAgICAgICAgICAgIC8vIEpTT04gMiwgUHJvdG90eXBlIDw9IDEuNywgYW5kIG9sZGVyIFdlYktpdCBidWlsZHMgaW5jb3JyZWN0bHlcbiAgICAgICAgICAgICAgICAvLyBzZXJpYWxpemUgZXh0ZW5kZWQgeWVhcnMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKC04LjY0ZTE1KSkgPT0gJ1wiLTI3MTgyMS0wNC0yMFQwMDowMDowMC4wMDBaXCInICYmXG4gICAgICAgICAgICAgICAgLy8gVGhlIG1pbGxpc2Vjb25kcyBhcmUgb3B0aW9uYWwgaW4gRVMgNSwgYnV0IHJlcXVpcmVkIGluIDUuMS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoOC42NGUxNSkpID09ICdcIisyNzU3NjAtMDktMTNUMDA6MDA6MDAuMDAwWlwiJyAmJlxuICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggPD0gMTEuMCBpbmNvcnJlY3RseSBzZXJpYWxpemVzIHllYXJzIHByaW9yIHRvIDAgYXMgbmVnYXRpdmVcbiAgICAgICAgICAgICAgICAvLyBmb3VyLWRpZ2l0IHllYXJzIGluc3RlYWQgb2Ygc2l4LWRpZ2l0IHllYXJzLiBDcmVkaXRzOiBAWWFmZmxlLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtNjIxOTg3NTUyZTUpKSA9PSAnXCItMDAwMDAxLTAxLTAxVDAwOjAwOjAwLjAwMFpcIicgJiZcbiAgICAgICAgICAgICAgICAvLyBTYWZhcmkgPD0gNS4xLjUgYW5kIE9wZXJhID49IDEwLjUzIGluY29ycmVjdGx5IHNlcmlhbGl6ZSBtaWxsaXNlY29uZFxuICAgICAgICAgICAgICAgIC8vIHZhbHVlcyBsZXNzIHRoYW4gMTAwMC4gQ3JlZGl0czogQFlhZmZsZS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTEpKSA9PSAnXCIxOTY5LTEyLTMxVDIzOjU5OjU5Ljk5OVpcIic7XG4gICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgc3RyaW5naWZ5U3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzU3VwcG9ydGVkID0gc3RyaW5naWZ5U3VwcG9ydGVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRlc3QgYEpTT04ucGFyc2VgLlxuICAgICAgICBpZiAobmFtZSA9PSBcImpzb24tcGFyc2VcIikge1xuICAgICAgICAgIHZhciBwYXJzZSA9IGV4cG9ydHMucGFyc2U7XG4gICAgICAgICAgaWYgKHR5cGVvZiBwYXJzZSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCBiMiB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhIGJhcmUgbGl0ZXJhbCBpcyBwcm92aWRlZC5cbiAgICAgICAgICAgICAgLy8gQ29uZm9ybWluZyBpbXBsZW1lbnRhdGlvbnMgc2hvdWxkIGFsc28gY29lcmNlIHRoZSBpbml0aWFsIGFyZ3VtZW50IHRvXG4gICAgICAgICAgICAgIC8vIGEgc3RyaW5nIHByaW9yIHRvIHBhcnNpbmcuXG4gICAgICAgICAgICAgIGlmIChwYXJzZShcIjBcIikgPT09IDAgJiYgIXBhcnNlKGZhbHNlKSkge1xuICAgICAgICAgICAgICAgIC8vIFNpbXBsZSBwYXJzaW5nIHRlc3QuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZShzZXJpYWxpemVkKTtcbiAgICAgICAgICAgICAgICB2YXIgcGFyc2VTdXBwb3J0ZWQgPSB2YWx1ZVtcImFcIl0ubGVuZ3RoID09IDUgJiYgdmFsdWVbXCJhXCJdWzBdID09PSAxO1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS4yIGFuZCBGRiAzLjFiMSBhbGxvdyB1bmVzY2FwZWQgdGFicyBpbiBzdHJpbmdzLlxuICAgICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9ICFwYXJzZSgnXCJcXHRcIicpO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gRkYgNC4wIGFuZCA0LjAuMSBhbGxvdyBsZWFkaW5nIGArYCBzaWducyBhbmQgbGVhZGluZ1xuICAgICAgICAgICAgICAgICAgICAgIC8vIGRlY2ltYWwgcG9pbnRzLiBGRiA0LjAsIDQuMC4xLCBhbmQgSUUgOS0xMCBhbHNvIGFsbG93XG4gICAgICAgICAgICAgICAgICAgICAgLy8gY2VydGFpbiBvY3RhbCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IHBhcnNlKFwiMDFcIikgIT09IDE7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIEZGIDQuMCwgNC4wLjEsIGFuZCBSaGlubyAxLjdSMy1SNCBhbGxvdyB0cmFpbGluZyBkZWNpbWFsXG4gICAgICAgICAgICAgICAgICAgICAgLy8gcG9pbnRzLiBUaGVzZSBlbnZpcm9ubWVudHMsIGFsb25nIHdpdGggRkYgMy4xYjEgYW5kIDIsXG4gICAgICAgICAgICAgICAgICAgICAgLy8gYWxzbyBhbGxvdyB0cmFpbGluZyBjb21tYXMgaW4gSlNPTiBvYmplY3RzIGFuZCBhcnJheXMuXG4gICAgICAgICAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSBwYXJzZShcIjEuXCIpICE9PSAxO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaXNTdXBwb3J0ZWQgPSBwYXJzZVN1cHBvcnRlZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc1tuYW1lXSA9ICEhaXNTdXBwb3J0ZWQ7XG4gICAgfVxuXG4gICAgaWYgKCFoYXMoXCJqc29uXCIpKSB7XG4gICAgICAvLyBDb21tb24gYFtbQ2xhc3NdXWAgbmFtZSBhbGlhc2VzLlxuICAgICAgdmFyIGZ1bmN0aW9uQ2xhc3MgPSBcIltvYmplY3QgRnVuY3Rpb25dXCIsXG4gICAgICAgICAgZGF0ZUNsYXNzID0gXCJbb2JqZWN0IERhdGVdXCIsXG4gICAgICAgICAgbnVtYmVyQ2xhc3MgPSBcIltvYmplY3QgTnVtYmVyXVwiLFxuICAgICAgICAgIHN0cmluZ0NsYXNzID0gXCJbb2JqZWN0IFN0cmluZ11cIixcbiAgICAgICAgICBhcnJheUNsYXNzID0gXCJbb2JqZWN0IEFycmF5XVwiLFxuICAgICAgICAgIGJvb2xlYW5DbGFzcyA9IFwiW29iamVjdCBCb29sZWFuXVwiO1xuXG4gICAgICAvLyBEZXRlY3QgaW5jb21wbGV0ZSBzdXBwb3J0IGZvciBhY2Nlc3Npbmcgc3RyaW5nIGNoYXJhY3RlcnMgYnkgaW5kZXguXG4gICAgICB2YXIgY2hhckluZGV4QnVnZ3kgPSBoYXMoXCJidWctc3RyaW5nLWNoYXItaW5kZXhcIik7XG5cbiAgICAgIC8vIERlZmluZSBhZGRpdGlvbmFsIHV0aWxpdHkgbWV0aG9kcyBpZiB0aGUgYERhdGVgIG1ldGhvZHMgYXJlIGJ1Z2d5LlxuICAgICAgaWYgKCFpc0V4dGVuZGVkKSB7XG4gICAgICAgIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG4gICAgICAgIC8vIEEgbWFwcGluZyBiZXR3ZWVuIHRoZSBtb250aHMgb2YgdGhlIHllYXIgYW5kIHRoZSBudW1iZXIgb2YgZGF5cyBiZXR3ZWVuXG4gICAgICAgIC8vIEphbnVhcnkgMXN0IGFuZCB0aGUgZmlyc3Qgb2YgdGhlIHJlc3BlY3RpdmUgbW9udGguXG4gICAgICAgIHZhciBNb250aHMgPSBbMCwgMzEsIDU5LCA5MCwgMTIwLCAxNTEsIDE4MSwgMjEyLCAyNDMsIDI3MywgMzA0LCAzMzRdO1xuICAgICAgICAvLyBJbnRlcm5hbDogQ2FsY3VsYXRlcyB0aGUgbnVtYmVyIG9mIGRheXMgYmV0d2VlbiB0aGUgVW5peCBlcG9jaCBhbmQgdGhlXG4gICAgICAgIC8vIGZpcnN0IGRheSBvZiB0aGUgZ2l2ZW4gbW9udGguXG4gICAgICAgIHZhciBnZXREYXkgPSBmdW5jdGlvbiAoeWVhciwgbW9udGgpIHtcbiAgICAgICAgICByZXR1cm4gTW9udGhzW21vbnRoXSArIDM2NSAqICh5ZWFyIC0gMTk3MCkgKyBmbG9vcigoeWVhciAtIDE5NjkgKyAobW9udGggPSArKG1vbnRoID4gMSkpKSAvIDQpIC0gZmxvb3IoKHllYXIgLSAxOTAxICsgbW9udGgpIC8gMTAwKSArIGZsb29yKCh5ZWFyIC0gMTYwMSArIG1vbnRoKSAvIDQwMCk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIEludGVybmFsOiBEZXRlcm1pbmVzIGlmIGEgcHJvcGVydHkgaXMgYSBkaXJlY3QgcHJvcGVydHkgb2YgdGhlIGdpdmVuXG4gICAgICAvLyBvYmplY3QuIERlbGVnYXRlcyB0byB0aGUgbmF0aXZlIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIG1ldGhvZC5cbiAgICAgIGlmICghKGlzUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eSkpIHtcbiAgICAgICAgaXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgIHZhciBtZW1iZXJzID0ge30sIGNvbnN0cnVjdG9yO1xuICAgICAgICAgIGlmICgobWVtYmVycy5fX3Byb3RvX18gPSBudWxsLCBtZW1iZXJzLl9fcHJvdG9fXyA9IHtcbiAgICAgICAgICAgIC8vIFRoZSAqcHJvdG8qIHByb3BlcnR5IGNhbm5vdCBiZSBzZXQgbXVsdGlwbGUgdGltZXMgaW4gcmVjZW50XG4gICAgICAgICAgICAvLyB2ZXJzaW9ucyBvZiBGaXJlZm94IGFuZCBTZWFNb25rZXkuXG4gICAgICAgICAgICBcInRvU3RyaW5nXCI6IDFcbiAgICAgICAgICB9LCBtZW1iZXJzKS50b1N0cmluZyAhPSBnZXRDbGFzcykge1xuICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDIuMC4zIGRvZXNuJ3QgaW1wbGVtZW50IGBPYmplY3QjaGFzT3duUHJvcGVydHlgLCBidXRcbiAgICAgICAgICAgIC8vIHN1cHBvcnRzIHRoZSBtdXRhYmxlICpwcm90byogcHJvcGVydHkuXG4gICAgICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgIC8vIENhcHR1cmUgYW5kIGJyZWFrIHRoZSBvYmplY3QncyBwcm90b3R5cGUgY2hhaW4gKHNlZSBzZWN0aW9uIDguNi4yXG4gICAgICAgICAgICAgIC8vIG9mIHRoZSBFUyA1LjEgc3BlYykuIFRoZSBwYXJlbnRoZXNpemVkIGV4cHJlc3Npb24gcHJldmVudHMgYW5cbiAgICAgICAgICAgICAgLy8gdW5zYWZlIHRyYW5zZm9ybWF0aW9uIGJ5IHRoZSBDbG9zdXJlIENvbXBpbGVyLlxuICAgICAgICAgICAgICB2YXIgb3JpZ2luYWwgPSB0aGlzLl9fcHJvdG9fXywgcmVzdWx0ID0gcHJvcGVydHkgaW4gKHRoaXMuX19wcm90b19fID0gbnVsbCwgdGhpcyk7XG4gICAgICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHByb3RvdHlwZSBjaGFpbi5cbiAgICAgICAgICAgICAgdGhpcy5fX3Byb3RvX18gPSBvcmlnaW5hbDtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIENhcHR1cmUgYSByZWZlcmVuY2UgdG8gdGhlIHRvcC1sZXZlbCBgT2JqZWN0YCBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICAgIGNvbnN0cnVjdG9yID0gbWVtYmVycy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIC8vIFVzZSB0aGUgYGNvbnN0cnVjdG9yYCBwcm9wZXJ0eSB0byBzaW11bGF0ZSBgT2JqZWN0I2hhc093blByb3BlcnR5YCBpblxuICAgICAgICAgICAgLy8gb3RoZXIgZW52aXJvbm1lbnRzLlxuICAgICAgICAgICAgaXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gKHRoaXMuY29uc3RydWN0b3IgfHwgY29uc3RydWN0b3IpLnByb3RvdHlwZTtcbiAgICAgICAgICAgICAgcmV0dXJuIHByb3BlcnR5IGluIHRoaXMgJiYgIShwcm9wZXJ0eSBpbiBwYXJlbnQgJiYgdGhpc1twcm9wZXJ0eV0gPT09IHBhcmVudFtwcm9wZXJ0eV0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWVtYmVycyA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIGlzUHJvcGVydHkuY2FsbCh0aGlzLCBwcm9wZXJ0eSk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIEludGVybmFsOiBOb3JtYWxpemVzIHRoZSBgZm9yLi4uaW5gIGl0ZXJhdGlvbiBhbGdvcml0aG0gYWNyb3NzXG4gICAgICAvLyBlbnZpcm9ubWVudHMuIEVhY2ggZW51bWVyYXRlZCBrZXkgaXMgeWllbGRlZCB0byBhIGBjYWxsYmFja2AgZnVuY3Rpb24uXG4gICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHNpemUgPSAwLCBQcm9wZXJ0aWVzLCBtZW1iZXJzLCBwcm9wZXJ0eTtcblxuICAgICAgICAvLyBUZXN0cyBmb3IgYnVncyBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudCdzIGBmb3IuLi5pbmAgYWxnb3JpdGhtLiBUaGVcbiAgICAgICAgLy8gYHZhbHVlT2ZgIHByb3BlcnR5IGluaGVyaXRzIHRoZSBub24tZW51bWVyYWJsZSBmbGFnIGZyb21cbiAgICAgICAgLy8gYE9iamVjdC5wcm90b3R5cGVgIGluIG9sZGVyIHZlcnNpb25zIG9mIElFLCBOZXRzY2FwZSwgYW5kIE1vemlsbGEuXG4gICAgICAgIChQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMudmFsdWVPZiA9IDA7XG4gICAgICAgIH0pLnByb3RvdHlwZS52YWx1ZU9mID0gMDtcblxuICAgICAgICAvLyBJdGVyYXRlIG92ZXIgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGBQcm9wZXJ0aWVzYCBjbGFzcy5cbiAgICAgICAgbWVtYmVycyA9IG5ldyBQcm9wZXJ0aWVzKCk7XG4gICAgICAgIGZvciAocHJvcGVydHkgaW4gbWVtYmVycykge1xuICAgICAgICAgIC8vIElnbm9yZSBhbGwgcHJvcGVydGllcyBpbmhlcml0ZWQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuXG4gICAgICAgICAgaWYgKGlzUHJvcGVydHkuY2FsbChtZW1iZXJzLCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgIHNpemUrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgUHJvcGVydGllcyA9IG1lbWJlcnMgPSBudWxsO1xuXG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgaXRlcmF0aW9uIGFsZ29yaXRobS5cbiAgICAgICAgaWYgKCFzaXplKSB7XG4gICAgICAgICAgLy8gQSBsaXN0IG9mIG5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXMgaW5oZXJpdGVkIGZyb20gYE9iamVjdC5wcm90b3R5cGVgLlxuICAgICAgICAgIG1lbWJlcnMgPSBbXCJ2YWx1ZU9mXCIsIFwidG9TdHJpbmdcIiwgXCJ0b0xvY2FsZVN0cmluZ1wiLCBcInByb3BlcnR5SXNFbnVtZXJhYmxlXCIsIFwiaXNQcm90b3R5cGVPZlwiLCBcImhhc093blByb3BlcnR5XCIsIFwiY29uc3RydWN0b3JcIl07XG4gICAgICAgICAgLy8gSUUgPD0gOCwgTW96aWxsYSAxLjAsIGFuZCBOZXRzY2FwZSA2LjIgaWdub3JlIHNoYWRvd2VkIG5vbi1lbnVtZXJhYmxlXG4gICAgICAgICAgLy8gcHJvcGVydGllcy5cbiAgICAgICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5LCBsZW5ndGg7XG4gICAgICAgICAgICB2YXIgaGFzUHJvcGVydHkgPSAhaXNGdW5jdGlvbiAmJiB0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yICE9IFwiZnVuY3Rpb25cIiAmJiBvYmplY3RUeXBlc1t0eXBlb2Ygb2JqZWN0Lmhhc093blByb3BlcnR5XSAmJiBvYmplY3QuaGFzT3duUHJvcGVydHkgfHwgaXNQcm9wZXJ0eTtcbiAgICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgIC8vIEdlY2tvIDw9IDEuMCBlbnVtZXJhdGVzIHRoZSBgcHJvdG90eXBlYCBwcm9wZXJ0eSBvZiBmdW5jdGlvbnMgdW5kZXJcbiAgICAgICAgICAgICAgLy8gY2VydGFpbiBjb25kaXRpb25zOyBJRSBkb2VzIG5vdC5cbiAgICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiBoYXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNYW51YWxseSBpbnZva2UgdGhlIGNhbGxiYWNrIGZvciBlYWNoIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5LlxuICAgICAgICAgICAgZm9yIChsZW5ndGggPSBtZW1iZXJzLmxlbmd0aDsgcHJvcGVydHkgPSBtZW1iZXJzWy0tbGVuZ3RoXTsgaGFzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSAmJiBjYWxsYmFjayhwcm9wZXJ0eSkpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoc2l6ZSA9PSAyKSB7XG4gICAgICAgICAgLy8gU2FmYXJpIDw9IDIuMC40IGVudW1lcmF0ZXMgc2hhZG93ZWQgcHJvcGVydGllcyB0d2ljZS5cbiAgICAgICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIHNldCBvZiBpdGVyYXRlZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgdmFyIG1lbWJlcnMgPSB7fSwgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eTtcbiAgICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgIC8vIFN0b3JlIGVhY2ggcHJvcGVydHkgbmFtZSB0byBwcmV2ZW50IGRvdWJsZSBlbnVtZXJhdGlvbi4gVGhlXG4gICAgICAgICAgICAgIC8vIGBwcm90b3R5cGVgIHByb3BlcnR5IG9mIGZ1bmN0aW9ucyBpcyBub3QgZW51bWVyYXRlZCBkdWUgdG8gY3Jvc3MtXG4gICAgICAgICAgICAgIC8vIGVudmlyb25tZW50IGluY29uc2lzdGVuY2llcy5cbiAgICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiAhaXNQcm9wZXJ0eS5jYWxsKG1lbWJlcnMsIHByb3BlcnR5KSAmJiAobWVtYmVyc1twcm9wZXJ0eV0gPSAxKSAmJiBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE5vIGJ1Z3MgZGV0ZWN0ZWQ7IHVzZSB0aGUgc3RhbmRhcmQgYGZvci4uLmluYCBhbGdvcml0aG0uXG4gICAgICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eSwgaXNDb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgIGlmICghKGlzRnVuY3Rpb24gJiYgcHJvcGVydHkgPT0gXCJwcm90b3R5cGVcIikgJiYgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpICYmICEoaXNDb25zdHJ1Y3RvciA9IHByb3BlcnR5ID09PSBcImNvbnN0cnVjdG9yXCIpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNYW51YWxseSBpbnZva2UgdGhlIGNhbGxiYWNrIGZvciB0aGUgYGNvbnN0cnVjdG9yYCBwcm9wZXJ0eSBkdWUgdG9cbiAgICAgICAgICAgIC8vIGNyb3NzLWVudmlyb25tZW50IGluY29uc2lzdGVuY2llcy5cbiAgICAgICAgICAgIGlmIChpc0NvbnN0cnVjdG9yIHx8IGlzUHJvcGVydHkuY2FsbChvYmplY3QsIChwcm9wZXJ0eSA9IFwiY29uc3RydWN0b3JcIikpKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JFYWNoKG9iamVjdCwgY2FsbGJhY2spO1xuICAgICAgfTtcblxuICAgICAgLy8gUHVibGljOiBTZXJpYWxpemVzIGEgSmF2YVNjcmlwdCBgdmFsdWVgIGFzIGEgSlNPTiBzdHJpbmcuIFRoZSBvcHRpb25hbFxuICAgICAgLy8gYGZpbHRlcmAgYXJndW1lbnQgbWF5IHNwZWNpZnkgZWl0aGVyIGEgZnVuY3Rpb24gdGhhdCBhbHRlcnMgaG93IG9iamVjdCBhbmRcbiAgICAgIC8vIGFycmF5IG1lbWJlcnMgYXJlIHNlcmlhbGl6ZWQsIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MgYW5kIG51bWJlcnMgdGhhdFxuICAgICAgLy8gaW5kaWNhdGVzIHdoaWNoIHByb3BlcnRpZXMgc2hvdWxkIGJlIHNlcmlhbGl6ZWQuIFRoZSBvcHRpb25hbCBgd2lkdGhgXG4gICAgICAvLyBhcmd1bWVudCBtYXkgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIG51bWJlciB0aGF0IHNwZWNpZmllcyB0aGUgaW5kZW50YXRpb25cbiAgICAgIC8vIGxldmVsIG9mIHRoZSBvdXRwdXQuXG4gICAgICBpZiAoIWhhcyhcImpzb24tc3RyaW5naWZ5XCIpKSB7XG4gICAgICAgIC8vIEludGVybmFsOiBBIG1hcCBvZiBjb250cm9sIGNoYXJhY3RlcnMgYW5kIHRoZWlyIGVzY2FwZWQgZXF1aXZhbGVudHMuXG4gICAgICAgIHZhciBFc2NhcGVzID0ge1xuICAgICAgICAgIDkyOiBcIlxcXFxcXFxcXCIsXG4gICAgICAgICAgMzQ6ICdcXFxcXCInLFxuICAgICAgICAgIDg6IFwiXFxcXGJcIixcbiAgICAgICAgICAxMjogXCJcXFxcZlwiLFxuICAgICAgICAgIDEwOiBcIlxcXFxuXCIsXG4gICAgICAgICAgMTM6IFwiXFxcXHJcIixcbiAgICAgICAgICA5OiBcIlxcXFx0XCJcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogQ29udmVydHMgYHZhbHVlYCBpbnRvIGEgemVyby1wYWRkZWQgc3RyaW5nIHN1Y2ggdGhhdCBpdHNcbiAgICAgICAgLy8gbGVuZ3RoIGlzIGF0IGxlYXN0IGVxdWFsIHRvIGB3aWR0aGAuIFRoZSBgd2lkdGhgIG11c3QgYmUgPD0gNi5cbiAgICAgICAgdmFyIGxlYWRpbmdaZXJvZXMgPSBcIjAwMDAwMFwiO1xuICAgICAgICB2YXIgdG9QYWRkZWRTdHJpbmcgPSBmdW5jdGlvbiAod2lkdGgsIHZhbHVlKSB7XG4gICAgICAgICAgLy8gVGhlIGB8fCAwYCBleHByZXNzaW9uIGlzIG5lY2Vzc2FyeSB0byB3b3JrIGFyb3VuZCBhIGJ1ZyBpblxuICAgICAgICAgIC8vIE9wZXJhIDw9IDcuNTR1MiB3aGVyZSBgMCA9PSAtMGAsIGJ1dCBgU3RyaW5nKC0wKSAhPT0gXCIwXCJgLlxuICAgICAgICAgIHJldHVybiAobGVhZGluZ1plcm9lcyArICh2YWx1ZSB8fCAwKSkuc2xpY2UoLXdpZHRoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogRG91YmxlLXF1b3RlcyBhIHN0cmluZyBgdmFsdWVgLCByZXBsYWNpbmcgYWxsIEFTQ0lJIGNvbnRyb2xcbiAgICAgICAgLy8gY2hhcmFjdGVycyAoY2hhcmFjdGVycyB3aXRoIGNvZGUgdW5pdCB2YWx1ZXMgYmV0d2VlbiAwIGFuZCAzMSkgd2l0aFxuICAgICAgICAvLyB0aGVpciBlc2NhcGVkIGVxdWl2YWxlbnRzLiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZVxuICAgICAgICAvLyBgUXVvdGUodmFsdWUpYCBvcGVyYXRpb24gZGVmaW5lZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLlxuICAgICAgICB2YXIgdW5pY29kZVByZWZpeCA9IFwiXFxcXHUwMFwiO1xuICAgICAgICB2YXIgcXVvdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gJ1wiJywgaW5kZXggPSAwLCBsZW5ndGggPSB2YWx1ZS5sZW5ndGgsIHVzZUNoYXJJbmRleCA9ICFjaGFySW5kZXhCdWdneSB8fCBsZW5ndGggPiAxMDtcbiAgICAgICAgICB2YXIgc3ltYm9scyA9IHVzZUNoYXJJbmRleCAmJiAoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5zcGxpdChcIlwiKSA6IHZhbHVlKTtcbiAgICAgICAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIHZhciBjaGFyQ29kZSA9IHZhbHVlLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIGNoYXJhY3RlciBpcyBhIGNvbnRyb2wgY2hhcmFjdGVyLCBhcHBlbmQgaXRzIFVuaWNvZGUgb3JcbiAgICAgICAgICAgIC8vIHNob3J0aGFuZCBlc2NhcGUgc2VxdWVuY2U7IG90aGVyd2lzZSwgYXBwZW5kIHRoZSBjaGFyYWN0ZXIgYXMtaXMuXG4gICAgICAgICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgIGNhc2UgODogY2FzZSA5OiBjYXNlIDEwOiBjYXNlIDEyOiBjYXNlIDEzOiBjYXNlIDM0OiBjYXNlIDkyOlxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBFc2NhcGVzW2NoYXJDb2RlXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPCAzMikge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHVuaWNvZGVQcmVmaXggKyB0b1BhZGRlZFN0cmluZygyLCBjaGFyQ29kZS50b1N0cmluZygxNikpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB1c2VDaGFySW5kZXggPyBzeW1ib2xzW2luZGV4XSA6IHZhbHVlLmNoYXJBdChpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQgKyAnXCInO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBSZWN1cnNpdmVseSBzZXJpYWxpemVzIGFuIG9iamVjdC4gSW1wbGVtZW50cyB0aGVcbiAgICAgICAgLy8gYFN0cihrZXksIGhvbGRlcilgLCBgSk8odmFsdWUpYCwgYW5kIGBKQSh2YWx1ZSlgIG9wZXJhdGlvbnMuXG4gICAgICAgIHZhciBzZXJpYWxpemUgPSBmdW5jdGlvbiAocHJvcGVydHksIG9iamVjdCwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjaykge1xuICAgICAgICAgIHZhciB2YWx1ZSwgY2xhc3NOYW1lLCB5ZWFyLCBtb250aCwgZGF0ZSwgdGltZSwgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgcmVzdWx0cywgZWxlbWVudCwgaW5kZXgsIGxlbmd0aCwgcHJlZml4LCByZXN1bHQ7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIE5lY2Vzc2FyeSBmb3IgaG9zdCBvYmplY3Qgc3VwcG9ydC5cbiAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0W3Byb3BlcnR5XTtcbiAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICYmIHZhbHVlKSB7XG4gICAgICAgICAgICBjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gZGF0ZUNsYXNzICYmICFpc1Byb3BlcnR5LmNhbGwodmFsdWUsIFwidG9KU09OXCIpKSB7XG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA+IC0xIC8gMCAmJiB2YWx1ZSA8IDEgLyAwKSB7XG4gICAgICAgICAgICAgICAgLy8gRGF0ZXMgYXJlIHNlcmlhbGl6ZWQgYWNjb3JkaW5nIHRvIHRoZSBgRGF0ZSN0b0pTT05gIG1ldGhvZFxuICAgICAgICAgICAgICAgIC8vIHNwZWNpZmllZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS45LjUuNDQuIFNlZSBzZWN0aW9uIDE1LjkuMS4xNVxuICAgICAgICAgICAgICAgIC8vIGZvciB0aGUgSVNPIDg2MDEgZGF0ZSB0aW1lIHN0cmluZyBmb3JtYXQuXG4gICAgICAgICAgICAgICAgaWYgKGdldERheSkge1xuICAgICAgICAgICAgICAgICAgLy8gTWFudWFsbHkgY29tcHV0ZSB0aGUgeWVhciwgbW9udGgsIGRhdGUsIGhvdXJzLCBtaW51dGVzLFxuICAgICAgICAgICAgICAgICAgLy8gc2Vjb25kcywgYW5kIG1pbGxpc2Vjb25kcyBpZiB0aGUgYGdldFVUQypgIG1ldGhvZHMgYXJlXG4gICAgICAgICAgICAgICAgICAvLyBidWdneS4gQWRhcHRlZCBmcm9tIEBZYWZmbGUncyBgZGF0ZS1zaGltYCBwcm9qZWN0LlxuICAgICAgICAgICAgICAgICAgZGF0ZSA9IGZsb29yKHZhbHVlIC8gODY0ZTUpO1xuICAgICAgICAgICAgICAgICAgZm9yICh5ZWFyID0gZmxvb3IoZGF0ZSAvIDM2NS4yNDI1KSArIDE5NzAgLSAxOyBnZXREYXkoeWVhciArIDEsIDApIDw9IGRhdGU7IHllYXIrKyk7XG4gICAgICAgICAgICAgICAgICBmb3IgKG1vbnRoID0gZmxvb3IoKGRhdGUgLSBnZXREYXkoeWVhciwgMCkpIC8gMzAuNDIpOyBnZXREYXkoeWVhciwgbW9udGggKyAxKSA8PSBkYXRlOyBtb250aCsrKTtcbiAgICAgICAgICAgICAgICAgIGRhdGUgPSAxICsgZGF0ZSAtIGdldERheSh5ZWFyLCBtb250aCk7XG4gICAgICAgICAgICAgICAgICAvLyBUaGUgYHRpbWVgIHZhbHVlIHNwZWNpZmllcyB0aGUgdGltZSB3aXRoaW4gdGhlIGRheSAoc2VlIEVTXG4gICAgICAgICAgICAgICAgICAvLyA1LjEgc2VjdGlvbiAxNS45LjEuMikuIFRoZSBmb3JtdWxhIGAoQSAlIEIgKyBCKSAlIEJgIGlzIHVzZWRcbiAgICAgICAgICAgICAgICAgIC8vIHRvIGNvbXB1dGUgYEEgbW9kdWxvIEJgLCBhcyB0aGUgYCVgIG9wZXJhdG9yIGRvZXMgbm90XG4gICAgICAgICAgICAgICAgICAvLyBjb3JyZXNwb25kIHRvIHRoZSBgbW9kdWxvYCBvcGVyYXRpb24gZm9yIG5lZ2F0aXZlIG51bWJlcnMuXG4gICAgICAgICAgICAgICAgICB0aW1lID0gKHZhbHVlICUgODY0ZTUgKyA4NjRlNSkgJSA4NjRlNTtcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSBob3VycywgbWludXRlcywgc2Vjb25kcywgYW5kIG1pbGxpc2Vjb25kcyBhcmUgb2J0YWluZWQgYnlcbiAgICAgICAgICAgICAgICAgIC8vIGRlY29tcG9zaW5nIHRoZSB0aW1lIHdpdGhpbiB0aGUgZGF5LiBTZWUgc2VjdGlvbiAxNS45LjEuMTAuXG4gICAgICAgICAgICAgICAgICBob3VycyA9IGZsb29yKHRpbWUgLyAzNmU1KSAlIDI0O1xuICAgICAgICAgICAgICAgICAgbWludXRlcyA9IGZsb29yKHRpbWUgLyA2ZTQpICUgNjA7XG4gICAgICAgICAgICAgICAgICBzZWNvbmRzID0gZmxvb3IodGltZSAvIDFlMykgJSA2MDtcbiAgICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IHRpbWUgJSAxZTM7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHllYXIgPSB2YWx1ZS5nZXRVVENGdWxsWWVhcigpO1xuICAgICAgICAgICAgICAgICAgbW9udGggPSB2YWx1ZS5nZXRVVENNb250aCgpO1xuICAgICAgICAgICAgICAgICAgZGF0ZSA9IHZhbHVlLmdldFVUQ0RhdGUoKTtcbiAgICAgICAgICAgICAgICAgIGhvdXJzID0gdmFsdWUuZ2V0VVRDSG91cnMoKTtcbiAgICAgICAgICAgICAgICAgIG1pbnV0ZXMgPSB2YWx1ZS5nZXRVVENNaW51dGVzKCk7XG4gICAgICAgICAgICAgICAgICBzZWNvbmRzID0gdmFsdWUuZ2V0VVRDU2Vjb25kcygpO1xuICAgICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gdmFsdWUuZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFNlcmlhbGl6ZSBleHRlbmRlZCB5ZWFycyBjb3JyZWN0bHkuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSAoeWVhciA8PSAwIHx8IHllYXIgPj0gMWU0ID8gKHllYXIgPCAwID8gXCItXCIgOiBcIitcIikgKyB0b1BhZGRlZFN0cmluZyg2LCB5ZWFyIDwgMCA/IC15ZWFyIDogeWVhcikgOiB0b1BhZGRlZFN0cmluZyg0LCB5ZWFyKSkgK1xuICAgICAgICAgICAgICAgICAgXCItXCIgKyB0b1BhZGRlZFN0cmluZygyLCBtb250aCArIDEpICsgXCItXCIgKyB0b1BhZGRlZFN0cmluZygyLCBkYXRlKSArXG4gICAgICAgICAgICAgICAgICAvLyBNb250aHMsIGRhdGVzLCBob3VycywgbWludXRlcywgYW5kIHNlY29uZHMgc2hvdWxkIGhhdmUgdHdvXG4gICAgICAgICAgICAgICAgICAvLyBkaWdpdHM7IG1pbGxpc2Vjb25kcyBzaG91bGQgaGF2ZSB0aHJlZS5cbiAgICAgICAgICAgICAgICAgIFwiVFwiICsgdG9QYWRkZWRTdHJpbmcoMiwgaG91cnMpICsgXCI6XCIgKyB0b1BhZGRlZFN0cmluZygyLCBtaW51dGVzKSArIFwiOlwiICsgdG9QYWRkZWRTdHJpbmcoMiwgc2Vjb25kcykgK1xuICAgICAgICAgICAgICAgICAgLy8gTWlsbGlzZWNvbmRzIGFyZSBvcHRpb25hbCBpbiBFUyA1LjAsIGJ1dCByZXF1aXJlZCBpbiA1LjEuXG4gICAgICAgICAgICAgICAgICBcIi5cIiArIHRvUGFkZGVkU3RyaW5nKDMsIG1pbGxpc2Vjb25kcykgKyBcIlpcIjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlLnRvSlNPTiA9PSBcImZ1bmN0aW9uXCIgJiYgKChjbGFzc05hbWUgIT0gbnVtYmVyQ2xhc3MgJiYgY2xhc3NOYW1lICE9IHN0cmluZ0NsYXNzICYmIGNsYXNzTmFtZSAhPSBhcnJheUNsYXNzKSB8fCBpc1Byb3BlcnR5LmNhbGwodmFsdWUsIFwidG9KU09OXCIpKSkge1xuICAgICAgICAgICAgICAvLyBQcm90b3R5cGUgPD0gMS42LjEgYWRkcyBub24tc3RhbmRhcmQgYHRvSlNPTmAgbWV0aG9kcyB0byB0aGVcbiAgICAgICAgICAgICAgLy8gYE51bWJlcmAsIGBTdHJpbmdgLCBgRGF0ZWAsIGFuZCBgQXJyYXlgIHByb3RvdHlwZXMuIEpTT04gM1xuICAgICAgICAgICAgICAvLyBpZ25vcmVzIGFsbCBgdG9KU09OYCBtZXRob2RzIG9uIHRoZXNlIG9iamVjdHMgdW5sZXNzIHRoZXkgYXJlXG4gICAgICAgICAgICAgIC8vIGRlZmluZWQgZGlyZWN0bHkgb24gYW4gaW5zdGFuY2UuXG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9KU09OKHByb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAvLyBJZiBhIHJlcGxhY2VtZW50IGZ1bmN0aW9uIHdhcyBwcm92aWRlZCwgY2FsbCBpdCB0byBvYnRhaW4gdGhlIHZhbHVlXG4gICAgICAgICAgICAvLyBmb3Igc2VyaWFsaXphdGlvbi5cbiAgICAgICAgICAgIHZhbHVlID0gY2FsbGJhY2suY2FsbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKTtcbiAgICAgICAgICBpZiAoY2xhc3NOYW1lID09IGJvb2xlYW5DbGFzcykge1xuICAgICAgICAgICAgLy8gQm9vbGVhbnMgYXJlIHJlcHJlc2VudGVkIGxpdGVyYWxseS5cbiAgICAgICAgICAgIHJldHVybiBcIlwiICsgdmFsdWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gbnVtYmVyQ2xhc3MpIHtcbiAgICAgICAgICAgIC8vIEpTT04gbnVtYmVycyBtdXN0IGJlIGZpbml0ZS4gYEluZmluaXR5YCBhbmQgYE5hTmAgYXJlIHNlcmlhbGl6ZWQgYXNcbiAgICAgICAgICAgIC8vIGBcIm51bGxcImAuXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPiAtMSAvIDAgJiYgdmFsdWUgPCAxIC8gMCA/IFwiXCIgKyB2YWx1ZSA6IFwibnVsbFwiO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzKSB7XG4gICAgICAgICAgICAvLyBTdHJpbmdzIGFyZSBkb3VibGUtcXVvdGVkIGFuZCBlc2NhcGVkLlxuICAgICAgICAgICAgcmV0dXJuIHF1b3RlKFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBvYmplY3RzIGFuZCBhcnJheXMuXG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgY3ljbGljIHN0cnVjdHVyZXMuIFRoaXMgaXMgYSBsaW5lYXIgc2VhcmNoOyBwZXJmb3JtYW5jZVxuICAgICAgICAgICAgLy8gaXMgaW52ZXJzZWx5IHByb3BvcnRpb25hbCB0byB0aGUgbnVtYmVyIG9mIHVuaXF1ZSBuZXN0ZWQgb2JqZWN0cy5cbiAgICAgICAgICAgIGZvciAobGVuZ3RoID0gc3RhY2subGVuZ3RoOyBsZW5ndGgtLTspIHtcbiAgICAgICAgICAgICAgaWYgKHN0YWNrW2xlbmd0aF0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gQ3ljbGljIHN0cnVjdHVyZXMgY2Fubm90IGJlIHNlcmlhbGl6ZWQgYnkgYEpTT04uc3RyaW5naWZ5YC5cbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWRkIHRoZSBvYmplY3QgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgICAgICAgICAgc3RhY2sucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICAvLyBTYXZlIHRoZSBjdXJyZW50IGluZGVudGF0aW9uIGxldmVsIGFuZCBpbmRlbnQgb25lIGFkZGl0aW9uYWwgbGV2ZWwuXG4gICAgICAgICAgICBwcmVmaXggPSBpbmRlbnRhdGlvbjtcbiAgICAgICAgICAgIGluZGVudGF0aW9uICs9IHdoaXRlc3BhY2U7XG4gICAgICAgICAgICBpZiAoY2xhc3NOYW1lID09IGFycmF5Q2xhc3MpIHtcbiAgICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgc2VyaWFsaXplIGFycmF5IGVsZW1lbnRzLlxuICAgICAgICAgICAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gdmFsdWUubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBzZXJpYWxpemUoaW5kZXgsIHZhbHVlLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZWxlbWVudCA9PT0gdW5kZWYgPyBcIm51bGxcIiA6IGVsZW1lbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdHMubGVuZ3RoID8gKHdoaXRlc3BhY2UgPyBcIltcXG5cIiArIGluZGVudGF0aW9uICsgcmVzdWx0cy5qb2luKFwiLFxcblwiICsgaW5kZW50YXRpb24pICsgXCJcXG5cIiArIHByZWZpeCArIFwiXVwiIDogKFwiW1wiICsgcmVzdWx0cy5qb2luKFwiLFwiKSArIFwiXVwiKSkgOiBcIltdXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgb2JqZWN0IG1lbWJlcnMuIE1lbWJlcnMgYXJlIHNlbGVjdGVkIGZyb21cbiAgICAgICAgICAgICAgLy8gZWl0aGVyIGEgdXNlci1zcGVjaWZpZWQgbGlzdCBvZiBwcm9wZXJ0eSBuYW1lcywgb3IgdGhlIG9iamVjdFxuICAgICAgICAgICAgICAvLyBpdHNlbGYuXG4gICAgICAgICAgICAgIGZvckVhY2gocHJvcGVydGllcyB8fCB2YWx1ZSwgZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBzZXJpYWxpemUocHJvcGVydHksIHZhbHVlLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCAhPT0gdW5kZWYpIHtcbiAgICAgICAgICAgICAgICAgIC8vIEFjY29yZGluZyB0byBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zOiBcIklmIGBnYXBgIHt3aGl0ZXNwYWNlfVxuICAgICAgICAgICAgICAgICAgLy8gaXMgbm90IHRoZSBlbXB0eSBzdHJpbmcsIGxldCBgbWVtYmVyYCB7cXVvdGUocHJvcGVydHkpICsgXCI6XCJ9XG4gICAgICAgICAgICAgICAgICAvLyBiZSB0aGUgY29uY2F0ZW5hdGlvbiBvZiBgbWVtYmVyYCBhbmQgdGhlIGBzcGFjZWAgY2hhcmFjdGVyLlwiXG4gICAgICAgICAgICAgICAgICAvLyBUaGUgXCJgc3BhY2VgIGNoYXJhY3RlclwiIHJlZmVycyB0byB0aGUgbGl0ZXJhbCBzcGFjZVxuICAgICAgICAgICAgICAgICAgLy8gY2hhcmFjdGVyLCBub3QgdGhlIGBzcGFjZWAge3dpZHRofSBhcmd1bWVudCBwcm92aWRlZCB0b1xuICAgICAgICAgICAgICAgICAgLy8gYEpTT04uc3RyaW5naWZ5YC5cbiAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChxdW90ZShwcm9wZXJ0eSkgKyBcIjpcIiArICh3aGl0ZXNwYWNlID8gXCIgXCIgOiBcIlwiKSArIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdHMubGVuZ3RoID8gKHdoaXRlc3BhY2UgPyBcIntcXG5cIiArIGluZGVudGF0aW9uICsgcmVzdWx0cy5qb2luKFwiLFxcblwiICsgaW5kZW50YXRpb24pICsgXCJcXG5cIiArIHByZWZpeCArIFwifVwiIDogKFwie1wiICsgcmVzdWx0cy5qb2luKFwiLFwiKSArIFwifVwiKSkgOiBcInt9XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIG9iamVjdCBmcm9tIHRoZSB0cmF2ZXJzZWQgb2JqZWN0IHN0YWNrLlxuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBQdWJsaWM6IGBKU09OLnN0cmluZ2lmeWAuIFNlZSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLlxuICAgICAgICBleHBvcnRzLnN0cmluZ2lmeSA9IGZ1bmN0aW9uIChzb3VyY2UsIGZpbHRlciwgd2lkdGgpIHtcbiAgICAgICAgICB2YXIgd2hpdGVzcGFjZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIGNsYXNzTmFtZTtcbiAgICAgICAgICBpZiAob2JqZWN0VHlwZXNbdHlwZW9mIGZpbHRlcl0gJiYgZmlsdGVyKSB7XG4gICAgICAgICAgICBpZiAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwoZmlsdGVyKSkgPT0gZnVuY3Rpb25DbGFzcykge1xuICAgICAgICAgICAgICBjYWxsYmFjayA9IGZpbHRlcjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IGFycmF5Q2xhc3MpIHtcbiAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgcHJvcGVydHkgbmFtZXMgYXJyYXkgaW50byBhIG1ha2VzaGlmdCBzZXQuXG4gICAgICAgICAgICAgIHByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwLCBsZW5ndGggPSBmaWx0ZXIubGVuZ3RoLCB2YWx1ZTsgaW5kZXggPCBsZW5ndGg7IHZhbHVlID0gZmlsdGVyW2luZGV4KytdLCAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpKSwgY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzIHx8IGNsYXNzTmFtZSA9PSBudW1iZXJDbGFzcykgJiYgKHByb3BlcnRpZXNbdmFsdWVdID0gMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAod2lkdGgpIHtcbiAgICAgICAgICAgIGlmICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh3aWR0aCkpID09IG51bWJlckNsYXNzKSB7XG4gICAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIGB3aWR0aGAgdG8gYW4gaW50ZWdlciBhbmQgY3JlYXRlIGEgc3RyaW5nIGNvbnRhaW5pbmdcbiAgICAgICAgICAgICAgLy8gYHdpZHRoYCBudW1iZXIgb2Ygc3BhY2UgY2hhcmFjdGVycy5cbiAgICAgICAgICAgICAgaWYgKCh3aWR0aCAtPSB3aWR0aCAlIDEpID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAod2hpdGVzcGFjZSA9IFwiXCIsIHdpZHRoID4gMTAgJiYgKHdpZHRoID0gMTApOyB3aGl0ZXNwYWNlLmxlbmd0aCA8IHdpZHRoOyB3aGl0ZXNwYWNlICs9IFwiIFwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MpIHtcbiAgICAgICAgICAgICAgd2hpdGVzcGFjZSA9IHdpZHRoLmxlbmd0aCA8PSAxMCA/IHdpZHRoIDogd2lkdGguc2xpY2UoMCwgMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBPcGVyYSA8PSA3LjU0dTIgZGlzY2FyZHMgdGhlIHZhbHVlcyBhc3NvY2lhdGVkIHdpdGggZW1wdHkgc3RyaW5nIGtleXNcbiAgICAgICAgICAvLyAoYFwiXCJgKSBvbmx5IGlmIHRoZXkgYXJlIHVzZWQgZGlyZWN0bHkgd2l0aGluIGFuIG9iamVjdCBtZW1iZXIgbGlzdFxuICAgICAgICAgIC8vIChlLmcuLCBgIShcIlwiIGluIHsgXCJcIjogMX0pYCkuXG4gICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZShcIlwiLCAodmFsdWUgPSB7fSwgdmFsdWVbXCJcIl0gPSBzb3VyY2UsIHZhbHVlKSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIFwiXCIsIFtdKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gUHVibGljOiBQYXJzZXMgYSBKU09OIHNvdXJjZSBzdHJpbmcuXG4gICAgICBpZiAoIWhhcyhcImpzb24tcGFyc2VcIikpIHtcbiAgICAgICAgdmFyIGZyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IEEgbWFwIG9mIGVzY2FwZWQgY29udHJvbCBjaGFyYWN0ZXJzIGFuZCB0aGVpciB1bmVzY2FwZWRcbiAgICAgICAgLy8gZXF1aXZhbGVudHMuXG4gICAgICAgIHZhciBVbmVzY2FwZXMgPSB7XG4gICAgICAgICAgOTI6IFwiXFxcXFwiLFxuICAgICAgICAgIDM0OiAnXCInLFxuICAgICAgICAgIDQ3OiBcIi9cIixcbiAgICAgICAgICA5ODogXCJcXGJcIixcbiAgICAgICAgICAxMTY6IFwiXFx0XCIsXG4gICAgICAgICAgMTEwOiBcIlxcblwiLFxuICAgICAgICAgIDEwMjogXCJcXGZcIixcbiAgICAgICAgICAxMTQ6IFwiXFxyXCJcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogU3RvcmVzIHRoZSBwYXJzZXIgc3RhdGUuXG4gICAgICAgIHZhciBJbmRleCwgU291cmNlO1xuXG4gICAgICAgIC8vIEludGVybmFsOiBSZXNldHMgdGhlIHBhcnNlciBzdGF0ZSBhbmQgdGhyb3dzIGEgYFN5bnRheEVycm9yYC5cbiAgICAgICAgdmFyIGFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIEluZGV4ID0gU291cmNlID0gbnVsbDtcbiAgICAgICAgICB0aHJvdyBTeW50YXhFcnJvcigpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBSZXR1cm5zIHRoZSBuZXh0IHRva2VuLCBvciBgXCIkXCJgIGlmIHRoZSBwYXJzZXIgaGFzIHJlYWNoZWRcbiAgICAgICAgLy8gdGhlIGVuZCBvZiB0aGUgc291cmNlIHN0cmluZy4gQSB0b2tlbiBtYXkgYmUgYSBzdHJpbmcsIG51bWJlciwgYG51bGxgXG4gICAgICAgIC8vIGxpdGVyYWwsIG9yIEJvb2xlYW4gbGl0ZXJhbC5cbiAgICAgICAgdmFyIGxleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgc291cmNlID0gU291cmNlLCBsZW5ndGggPSBzb3VyY2UubGVuZ3RoLCB2YWx1ZSwgYmVnaW4sIHBvc2l0aW9uLCBpc1NpZ25lZCwgY2hhckNvZGU7XG4gICAgICAgICAgd2hpbGUgKEluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgY2FzZSA5OiBjYXNlIDEwOiBjYXNlIDEzOiBjYXNlIDMyOlxuICAgICAgICAgICAgICAgIC8vIFNraXAgd2hpdGVzcGFjZSB0b2tlbnMsIGluY2x1ZGluZyB0YWJzLCBjYXJyaWFnZSByZXR1cm5zLCBsaW5lXG4gICAgICAgICAgICAgICAgLy8gZmVlZHMsIGFuZCBzcGFjZSBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMTIzOiBjYXNlIDEyNTogY2FzZSA5MTogY2FzZSA5MzogY2FzZSA1ODogY2FzZSA0NDpcbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBhIHB1bmN0dWF0b3IgdG9rZW4gKGB7YCwgYH1gLCBgW2AsIGBdYCwgYDpgLCBvciBgLGApIGF0XG4gICAgICAgICAgICAgICAgLy8gdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBjaGFySW5kZXhCdWdneSA/IHNvdXJjZS5jaGFyQXQoSW5kZXgpIDogc291cmNlW0luZGV4XTtcbiAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgY2FzZSAzNDpcbiAgICAgICAgICAgICAgICAvLyBgXCJgIGRlbGltaXRzIGEgSlNPTiBzdHJpbmc7IGFkdmFuY2UgdG8gdGhlIG5leHQgY2hhcmFjdGVyIGFuZFxuICAgICAgICAgICAgICAgIC8vIGJlZ2luIHBhcnNpbmcgdGhlIHN0cmluZy4gU3RyaW5nIHRva2VucyBhcmUgcHJlZml4ZWQgd2l0aCB0aGVcbiAgICAgICAgICAgICAgICAvLyBzZW50aW5lbCBgQGAgY2hhcmFjdGVyIHRvIGRpc3Rpbmd1aXNoIHRoZW0gZnJvbSBwdW5jdHVhdG9ycyBhbmRcbiAgICAgICAgICAgICAgICAvLyBlbmQtb2Ytc3RyaW5nIHRva2Vucy5cbiAgICAgICAgICAgICAgICBmb3IgKHZhbHVlID0gXCJAXCIsIEluZGV4Kys7IEluZGV4IDwgbGVuZ3RoOykge1xuICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPCAzMikge1xuICAgICAgICAgICAgICAgICAgICAvLyBVbmVzY2FwZWQgQVNDSUkgY29udHJvbCBjaGFyYWN0ZXJzICh0aG9zZSB3aXRoIGEgY29kZSB1bml0XG4gICAgICAgICAgICAgICAgICAgIC8vIGxlc3MgdGhhbiB0aGUgc3BhY2UgY2hhcmFjdGVyKSBhcmUgbm90IHBlcm1pdHRlZC5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hhckNvZGUgPT0gOTIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSByZXZlcnNlIHNvbGlkdXMgKGBcXGApIG1hcmtzIHRoZSBiZWdpbm5pbmcgb2YgYW4gZXNjYXBlZFxuICAgICAgICAgICAgICAgICAgICAvLyBjb250cm9sIGNoYXJhY3RlciAoaW5jbHVkaW5nIGBcImAsIGBcXGAsIGFuZCBgL2ApIG9yIFVuaWNvZGVcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSA5MjogY2FzZSAzNDogY2FzZSA0NzogY2FzZSA5ODogY2FzZSAxMTY6IGNhc2UgMTEwOiBjYXNlIDEwMjogY2FzZSAxMTQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXZpdmUgZXNjYXBlZCBjb250cm9sIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBVbmVzY2FwZXNbY2hhckNvZGVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE3OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYFxcdWAgbWFya3MgdGhlIGJlZ2lubmluZyBvZiBhIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWR2YW5jZSB0byB0aGUgZmlyc3QgY2hhcmFjdGVyIGFuZCB2YWxpZGF0ZSB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvdXItZGlnaXQgY29kZSBwb2ludC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJlZ2luID0gKytJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAocG9zaXRpb24gPSBJbmRleCArIDQ7IEluZGV4IDwgcG9zaXRpb247IEluZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEEgdmFsaWQgc2VxdWVuY2UgY29tcHJpc2VzIGZvdXIgaGV4ZGlnaXRzIChjYXNlLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnNlbnNpdGl2ZSkgdGhhdCBmb3JtIGEgc2luZ2xlIGhleGFkZWNpbWFsIHZhbHVlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1NyB8fCBjaGFyQ29kZSA+PSA5NyAmJiBjaGFyQ29kZSA8PSAxMDIgfHwgY2hhckNvZGUgPj0gNjUgJiYgY2hhckNvZGUgPD0gNzApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW52YWxpZCBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXZpdmUgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gZnJvbUNoYXJDb2RlKFwiMHhcIiArIHNvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSAzNCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIEFuIHVuZXNjYXBlZCBkb3VibGUtcXVvdGUgY2hhcmFjdGVyIG1hcmtzIHRoZSBlbmQgb2YgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgLy8gc3RyaW5nLlxuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBiZWdpbiA9IEluZGV4O1xuICAgICAgICAgICAgICAgICAgICAvLyBPcHRpbWl6ZSBmb3IgdGhlIGNvbW1vbiBjYXNlIHdoZXJlIGEgc3RyaW5nIGlzIHZhbGlkLlxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY2hhckNvZGUgPj0gMzIgJiYgY2hhckNvZGUgIT0gOTIgJiYgY2hhckNvZGUgIT0gMzQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEFwcGVuZCB0aGUgc3RyaW5nIGFzLWlzLlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KSA9PSAzNCkge1xuICAgICAgICAgICAgICAgICAgLy8gQWR2YW5jZSB0byB0aGUgbmV4dCBjaGFyYWN0ZXIgYW5kIHJldHVybiB0aGUgcmV2aXZlZCBzdHJpbmcuXG4gICAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBVbnRlcm1pbmF0ZWQgc3RyaW5nLlxuICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgbnVtYmVycyBhbmQgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgYmVnaW4gPSBJbmRleDtcbiAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHBhc3QgdGhlIG5lZ2F0aXZlIHNpZ24sIGlmIG9uZSBpcyBzcGVjaWZpZWQuXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDQ1KSB7XG4gICAgICAgICAgICAgICAgICBpc1NpZ25lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBhbiBpbnRlZ2VyIG9yIGZsb2F0aW5nLXBvaW50IHZhbHVlLlxuICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nykge1xuICAgICAgICAgICAgICAgICAgLy8gTGVhZGluZyB6ZXJvZXMgYXJlIGludGVycHJldGVkIGFzIG9jdGFsIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDQ4ICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCArIDEpKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWwgb2N0YWwgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlzU2lnbmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgaW50ZWdlciBjb21wb25lbnQuXG4gICAgICAgICAgICAgICAgICBmb3IgKDsgSW5kZXggPCBsZW5ndGggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KTsgSW5kZXgrKyk7XG4gICAgICAgICAgICAgICAgICAvLyBGbG9hdHMgY2Fubm90IGNvbnRhaW4gYSBsZWFkaW5nIGRlY2ltYWwgcG9pbnQ7IGhvd2V2ZXIsIHRoaXNcbiAgICAgICAgICAgICAgICAgIC8vIGNhc2UgaXMgYWxyZWFkeSBhY2NvdW50ZWQgZm9yIGJ5IHRoZSBwYXJzZXIuXG4gICAgICAgICAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpID09IDQ2KSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gKytJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGRlY2ltYWwgY29tcG9uZW50LlxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgcG9zaXRpb24gPCBsZW5ndGggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KHBvc2l0aW9uKSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KTsgcG9zaXRpb24rKyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PSBJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWwgdHJhaWxpbmcgZGVjaW1hbC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIEluZGV4ID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvLyBQYXJzZSBleHBvbmVudHMuIFRoZSBgZWAgZGVub3RpbmcgdGhlIGV4cG9uZW50IGlzXG4gICAgICAgICAgICAgICAgICAvLyBjYXNlLWluc2Vuc2l0aXZlLlxuICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gMTAxIHx8IGNoYXJDb2RlID09IDY5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNraXAgcGFzdCB0aGUgc2lnbiBmb2xsb3dpbmcgdGhlIGV4cG9uZW50LCBpZiBvbmUgaXNcbiAgICAgICAgICAgICAgICAgICAgLy8gc3BlY2lmaWVkLlxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDMgfHwgY2hhckNvZGUgPT0gNDUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBleHBvbmVudGlhbCBjb21wb25lbnQuXG4gICAgICAgICAgICAgICAgICAgIGZvciAocG9zaXRpb24gPSBJbmRleDsgcG9zaXRpb24gPCBsZW5ndGggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KHBvc2l0aW9uKSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KTsgcG9zaXRpb24rKyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PSBJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWwgZW1wdHkgZXhwb25lbnQuXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBJbmRleCA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgLy8gQ29lcmNlIHRoZSBwYXJzZWQgdmFsdWUgdG8gYSBKYXZhU2NyaXB0IG51bWJlci5cbiAgICAgICAgICAgICAgICAgIHJldHVybiArc291cmNlLnNsaWNlKGJlZ2luLCBJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEEgbmVnYXRpdmUgc2lnbiBtYXkgb25seSBwcmVjZWRlIG51bWJlcnMuXG4gICAgICAgICAgICAgICAgaWYgKGlzU2lnbmVkKSB7XG4gICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBgdHJ1ZWAsIGBmYWxzZWAsIGFuZCBgbnVsbGAgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA0KSA9PSBcInRydWVcIikge1xuICAgICAgICAgICAgICAgICAgSW5kZXggKz0gNDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDUpID09IFwiZmFsc2VcIikge1xuICAgICAgICAgICAgICAgICAgSW5kZXggKz0gNTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA0KSA9PSBcIm51bGxcIikge1xuICAgICAgICAgICAgICAgICAgSW5kZXggKz0gNDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBVbnJlY29nbml6ZWQgdG9rZW4uXG4gICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUmV0dXJuIHRoZSBzZW50aW5lbCBgJGAgY2hhcmFjdGVyIGlmIHRoZSBwYXJzZXIgaGFzIHJlYWNoZWQgdGhlIGVuZFxuICAgICAgICAgIC8vIG9mIHRoZSBzb3VyY2Ugc3RyaW5nLlxuICAgICAgICAgIHJldHVybiBcIiRcIjtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUGFyc2VzIGEgSlNPTiBgdmFsdWVgIHRva2VuLlxuICAgICAgICB2YXIgZ2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdHMsIGhhc01lbWJlcnM7XG4gICAgICAgICAgaWYgKHZhbHVlID09IFwiJFwiKSB7XG4gICAgICAgICAgICAvLyBVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dC5cbiAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKChjaGFySW5kZXhCdWdneSA/IHZhbHVlLmNoYXJBdCgwKSA6IHZhbHVlWzBdKSA9PSBcIkBcIikge1xuICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHNlbnRpbmVsIGBAYCBjaGFyYWN0ZXIuXG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5zbGljZSgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFBhcnNlIG9iamVjdCBhbmQgYXJyYXkgbGl0ZXJhbHMuXG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJbXCIpIHtcbiAgICAgICAgICAgICAgLy8gUGFyc2VzIGEgSlNPTiBhcnJheSwgcmV0dXJuaW5nIGEgbmV3IEphdmFTY3JpcHQgYXJyYXkuXG4gICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgZm9yICg7OyBoYXNNZW1iZXJzIHx8IChoYXNNZW1iZXJzID0gdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgIC8vIEEgY2xvc2luZyBzcXVhcmUgYnJhY2tldCBtYXJrcyB0aGUgZW5kIG9mIHRoZSBhcnJheSBsaXRlcmFsLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIl1cIikge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBhcnJheSBsaXRlcmFsIGNvbnRhaW5zIGVsZW1lbnRzLCB0aGUgY3VycmVudCB0b2tlblxuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBiZSBhIGNvbW1hIHNlcGFyYXRpbmcgdGhlIHByZXZpb3VzIGVsZW1lbnQgZnJvbSB0aGVcbiAgICAgICAgICAgICAgICAvLyBuZXh0LlxuICAgICAgICAgICAgICAgIGlmIChoYXNNZW1iZXJzKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiXVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gVW5leHBlY3RlZCB0cmFpbGluZyBgLGAgaW4gYXJyYXkgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBBIGAsYCBtdXN0IHNlcGFyYXRlIGVhY2ggYXJyYXkgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRWxpc2lvbnMgYW5kIGxlYWRpbmcgY29tbWFzIGFyZSBub3QgcGVybWl0dGVkLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGdldCh2YWx1ZSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PSBcIntcIikge1xuICAgICAgICAgICAgICAvLyBQYXJzZXMgYSBKU09OIG9iamVjdCwgcmV0dXJuaW5nIGEgbmV3IEphdmFTY3JpcHQgb2JqZWN0LlxuICAgICAgICAgICAgICByZXN1bHRzID0ge307XG4gICAgICAgICAgICAgIGZvciAoOzsgaGFzTWVtYmVycyB8fCAoaGFzTWVtYmVycyA9IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAvLyBBIGNsb3NpbmcgY3VybHkgYnJhY2UgbWFya3MgdGhlIGVuZCBvZiB0aGUgb2JqZWN0IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwifVwiKSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIG9iamVjdCBsaXRlcmFsIGNvbnRhaW5zIG1lbWJlcnMsIHRoZSBjdXJyZW50IHRva2VuXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGEgY29tbWEgc2VwYXJhdG9yLlxuICAgICAgICAgICAgICAgIGlmIChoYXNNZW1iZXJzKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwifVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gVW5leHBlY3RlZCB0cmFpbGluZyBgLGAgaW4gb2JqZWN0IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBgLGAgbXVzdCBzZXBhcmF0ZSBlYWNoIG9iamVjdCBtZW1iZXIuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIExlYWRpbmcgY29tbWFzIGFyZSBub3QgcGVybWl0dGVkLCBvYmplY3QgcHJvcGVydHkgbmFtZXMgbXVzdCBiZVxuICAgICAgICAgICAgICAgIC8vIGRvdWJsZS1xdW90ZWQgc3RyaW5ncywgYW5kIGEgYDpgIG11c3Qgc2VwYXJhdGUgZWFjaCBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgIC8vIG5hbWUgYW5kIHZhbHVlLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIiB8fCB0eXBlb2YgdmFsdWUgIT0gXCJzdHJpbmdcIiB8fCAoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5jaGFyQXQoMCkgOiB2YWx1ZVswXSkgIT0gXCJAXCIgfHwgbGV4KCkgIT0gXCI6XCIpIHtcbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdHNbdmFsdWUuc2xpY2UoMSldID0gZ2V0KGxleCgpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgdG9rZW4gZW5jb3VudGVyZWQuXG4gICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFVwZGF0ZXMgYSB0cmF2ZXJzZWQgb2JqZWN0IG1lbWJlci5cbiAgICAgICAgdmFyIHVwZGF0ZSA9IGZ1bmN0aW9uIChzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjaykge1xuICAgICAgICAgIHZhciBlbGVtZW50ID0gd2Fsayhzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjayk7XG4gICAgICAgICAgaWYgKGVsZW1lbnQgPT09IHVuZGVmKSB7XG4gICAgICAgICAgICBkZWxldGUgc291cmNlW3Byb3BlcnR5XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc291cmNlW3Byb3BlcnR5XSA9IGVsZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBSZWN1cnNpdmVseSB0cmF2ZXJzZXMgYSBwYXJzZWQgSlNPTiBvYmplY3QsIGludm9raW5nIHRoZVxuICAgICAgICAvLyBgY2FsbGJhY2tgIGZ1bmN0aW9uIGZvciBlYWNoIHZhbHVlLiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZVxuICAgICAgICAvLyBgV2Fsayhob2xkZXIsIG5hbWUpYCBvcGVyYXRpb24gZGVmaW5lZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS4xMi4yLlxuICAgICAgICB2YXIgd2FsayA9IGZ1bmN0aW9uIChzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjaykge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHNvdXJjZVtwcm9wZXJ0eV0sIGxlbmd0aDtcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIGBmb3JFYWNoYCBjYW4ndCBiZSB1c2VkIHRvIHRyYXZlcnNlIGFuIGFycmF5IGluIE9wZXJhIDw9IDguNTRcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgaXRzIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIGltcGxlbWVudGF0aW9uIHJldHVybnMgYGZhbHNlYFxuICAgICAgICAgICAgLy8gZm9yIGFycmF5IGluZGljZXMgKGUuZy4sIGAhWzEsIDIsIDNdLmhhc093blByb3BlcnR5KFwiMFwiKWApLlxuICAgICAgICAgICAgaWYgKGdldENsYXNzLmNhbGwodmFsdWUpID09IGFycmF5Q2xhc3MpIHtcbiAgICAgICAgICAgICAgZm9yIChsZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGxlbmd0aC0tOykge1xuICAgICAgICAgICAgICAgIHVwZGF0ZSh2YWx1ZSwgbGVuZ3RoLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZvckVhY2godmFsdWUsIGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZSh2YWx1ZSwgcHJvcGVydHksIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHNvdXJjZSwgcHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBQdWJsaWM6IGBKU09OLnBhcnNlYC4gU2VlIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjIuXG4gICAgICAgIGV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiAoc291cmNlLCBjYWxsYmFjaykge1xuICAgICAgICAgIHZhciByZXN1bHQsIHZhbHVlO1xuICAgICAgICAgIEluZGV4ID0gMDtcbiAgICAgICAgICBTb3VyY2UgPSBcIlwiICsgc291cmNlO1xuICAgICAgICAgIHJlc3VsdCA9IGdldChsZXgoKSk7XG4gICAgICAgICAgLy8gSWYgYSBKU09OIHN0cmluZyBjb250YWlucyBtdWx0aXBsZSB0b2tlbnMsIGl0IGlzIGludmFsaWQuXG4gICAgICAgICAgaWYgKGxleCgpICE9IFwiJFwiKSB7XG4gICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZXNldCB0aGUgcGFyc2VyIHN0YXRlLlxuICAgICAgICAgIEluZGV4ID0gU291cmNlID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sgJiYgZ2V0Q2xhc3MuY2FsbChjYWxsYmFjaykgPT0gZnVuY3Rpb25DbGFzcyA/IHdhbGsoKHZhbHVlID0ge30sIHZhbHVlW1wiXCJdID0gcmVzdWx0LCB2YWx1ZSksIFwiXCIsIGNhbGxiYWNrKSA6IHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBleHBvcnRzW1wicnVuSW5Db250ZXh0XCJdID0gcnVuSW5Db250ZXh0O1xuICAgIHJldHVybiBleHBvcnRzO1xuICB9XG5cbiAgaWYgKGZyZWVFeHBvcnRzICYmICFpc0xvYWRlcikge1xuICAgIC8vIEV4cG9ydCBmb3IgQ29tbW9uSlMgZW52aXJvbm1lbnRzLlxuICAgIHJ1bkluQ29udGV4dChyb290LCBmcmVlRXhwb3J0cyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gRXhwb3J0IGZvciB3ZWIgYnJvd3NlcnMgYW5kIEphdmFTY3JpcHQgZW5naW5lcy5cbiAgICB2YXIgbmF0aXZlSlNPTiA9IHJvb3QuSlNPTixcbiAgICAgICAgcHJldmlvdXNKU09OID0gcm9vdFtcIkpTT04zXCJdLFxuICAgICAgICBpc1Jlc3RvcmVkID0gZmFsc2U7XG5cbiAgICB2YXIgSlNPTjMgPSBydW5JbkNvbnRleHQocm9vdCwgKHJvb3RbXCJKU09OM1wiXSA9IHtcbiAgICAgIC8vIFB1YmxpYzogUmVzdG9yZXMgdGhlIG9yaWdpbmFsIHZhbHVlIG9mIHRoZSBnbG9iYWwgYEpTT05gIG9iamVjdCBhbmRcbiAgICAgIC8vIHJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIGBKU09OM2Agb2JqZWN0LlxuICAgICAgXCJub0NvbmZsaWN0XCI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFpc1Jlc3RvcmVkKSB7XG4gICAgICAgICAgaXNSZXN0b3JlZCA9IHRydWU7XG4gICAgICAgICAgcm9vdC5KU09OID0gbmF0aXZlSlNPTjtcbiAgICAgICAgICByb290W1wiSlNPTjNcIl0gPSBwcmV2aW91c0pTT047XG4gICAgICAgICAgbmF0aXZlSlNPTiA9IHByZXZpb3VzSlNPTiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEpTT04zO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIHJvb3QuSlNPTiA9IHtcbiAgICAgIFwicGFyc2VcIjogSlNPTjMucGFyc2UsXG4gICAgICBcInN0cmluZ2lmeVwiOiBKU09OMy5zdHJpbmdpZnlcbiAgICB9O1xuICB9XG5cbiAgLy8gRXhwb3J0IGZvciBhc3luY2hyb25vdXMgbW9kdWxlIGxvYWRlcnMuXG4gIGlmIChpc0xvYWRlcikge1xuICAgIGRlZmluZShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gSlNPTjM7XG4gICAgfSk7XG4gIH1cbn0pLmNhbGwodGhpcyk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHRvQXJyYXlcblxuZnVuY3Rpb24gdG9BcnJheShsaXN0LCBpbmRleCkge1xuICAgIHZhciBhcnJheSA9IFtdXG5cbiAgICBpbmRleCA9IGluZGV4IHx8IDBcblxuICAgIGZvciAodmFyIGkgPSBpbmRleCB8fCAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJheVtpIC0gaW5kZXhdID0gbGlzdFtpXVxuICAgIH1cblxuICAgIHJldHVybiBhcnJheVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIHRoaXMgaXMgd2hhdCBpcyByZXR1cm5lZCBieSBuZXcgUmx0bSgpXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHNldHVwKSB7XG5cbiAgICAvLyB0aGVzZSBhcmUgYXZhaWxhYmxlIHJlYWx0aW1lIHByb3ZpZGVycyBhbmQgdGhlaXIgZGVmaW5pdGlvbnNcbiAgICBjb25zdCBzZXJ2aWNlcyA9IHtcbiAgICAgICAgYWJseTogcmVxdWlyZSgnLi9zZXJ2aWNlcy9hYmx5JyksXG4gICAgICAgIHB1Ym51YjogcmVxdWlyZSgnLi9zZXJ2aWNlcy9wdWJudWInKSxcbiAgICAgICAgc29ja2V0aW86IHJlcXVpcmUoJy4vc2VydmljZXMvc29ja2V0aW8nKVxuICAgIH07XG5cbiAgICAvLyByZXR1cm4gZXJyb3IgaWYgc2VydmljZSBpcyBub3Qgc2V0XG4gICAgbGV0IHNlcnZpY2UgPSBzZXJ2aWNlc1tzZXR1cC5zZXJ2aWNlXTtcblxuICAgIGlmKCFzZXR1cC5zZXJ2aWNlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3Qgc3VwcGx5IGEgc2VydmljZSBwcm9wZXJ0eS4nKTtcbiAgICB9XG5cbiAgICBpZighc2VydmljZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBzZXJ2aWNlIHlvdSBzdXBwbGllZCBpcyBpbnZhbGlkLicpO1xuICAgIH1cblxuICAgIC8vIGFkZCBjb25maWcgaWYgZG9lc24ndCBleGlzdFxuICAgIHNldHVwLmNvbmZpZyA9IHNldHVwLmNvbmZpZyB8fCB7fTtcblxuICAgIC8vIHNldCBhIGRlZmF1bHQgdXVpZCBpZiBpdCBoYXMgbm90IGJlZW4gc2V0IGZvciB0aGlzIHVzZXJcbiAgICBzZXR1cC5jb25maWcudXVpZCA9IHNldHVwLmNvbmZpZy51dWlkIHx8IG5ldyBEYXRlKCk7XG5cbiAgICAvLyBzZXQgdGhpcyB1dWlkIGlmIGl0IGlzIG5vdCBzZXRcbiAgICBzZXR1cC5jb25maWcuc3RhdGUgPSBzZXR1cC5jb25maWcuc3RhdGUgfHwge307XG5cbiAgICAvLyBpbW1lZGlhdGVseSBpbnZva2UgYW5kIHJldHVybiB0aGUgbWFpbiBmdW5jdGlvblxuICAgIHJldHVybiBuZXcgc2VydmljZShzZXR1cCk7XG5cbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gaW5jbHVkZSB0aGUgTm9kZUpTIGV2ZW50IGVtaXR0ZXJcbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuXG4vLyBpbmNsdWRlIHRoZSBBYmx5IGphdmFzY3JpcHQgc2RrXG5jb25zdCBBYmx5ID0gcmVxdWlyZSgnYWJseScpO1xuXG4vLyByZXByZXNlbnRzIGEgY29ubmVjdGlvbiB0byBhIHNpbmdsZSBjaGFubmVsXG5jbGFzcyBSb29tIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcihhYmx5LCBjaGFubmVsLCBzdGF0ZSkge1xuICAgICAgICAvLyBjYWxsIHRoZSBFdmVudEVtaXR0ZXIgY29uc3RydWN0b3JcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICAvLyBkZXRlcm1pbmUgdGhlIHVzZXIncyBzdGF0ZVxuICAgICAgICBzdGF0ZSA9IHN0YXRlIHx8IHt9O1xuXG4gICAgICAgIC8vIGFzc2lnbiB0aGUgY2hhbm5lbCBwYXJhbWV0ZXIgYXMgYSBwcm9wZXJ0eVxuICAgICAgICB0aGlzLmNoYW5uZWxOYW1lID0gY2hhbm5lbDtcbiAgICAgICAgdGhpcy5jaGFubmVsID0gYWJseS5jaGFubmVscy5nZXQoY2hhbm5lbCk7XG5cbiAgICAgICAgLy8gc2F2ZSBBYmx5IGluIHRoZSBpbnN0YW5jZSBvZiByb29tXG4gICAgICAgIHRoaXMuYWJseSA9IGFibHk7XG5cbiAgICAgICAgdGhpcy5pc1JlYWR5ID0gZmFsc2U7XG5cbiAgICAgICAgLy8gdXNlIHRoZSBBYmx5IGxpYnJhcnkgdG8gbGlzdGVuIGZvciBtZXNzYWdlc1xuICAgICAgICB0aGlzLmNoYW5uZWwub25jZSgnYXR0YWNoZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAvLyB0ZWxsIHRoZSB1c2VyIHRoYXQgZmlyc3QgY29ubmVjdGlvbiBtYWRlXG4gICAgICAgICAgICB0aGlzLm9uUmVhZHkoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5jaGFubmVsLnN1YnNjcmliZSgobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgLy8gZW1pdCB0aGUgbWVzc2FnZSBhcyBhbiBldmVudFxuICAgICAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgbWVzc2FnZS5pZCwgbWVzc2FnZS5kYXRhKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5jaGFubmVsLnByZXNlbmNlLnN1YnNjcmliZSgocHJlc2VuY2VFdmVudCkgPT4ge1xuICAgICAgICAgICAgaWYoKHByZXNlbmNlRXZlbnQuYWN0aW9uID09PSAnZW50ZXInKSB8fCAocHJlc2VuY2VFdmVudC5hY3Rpb24gPT09ICdzeW5jJykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2pvaW4nLFxuICAgICAgICAgICAgICAgICAgICBwcmVzZW5jZUV2ZW50LmNsaWVudElkLCBwcmVzZW5jZUV2ZW50LmRhdGEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzb21lb25lIGxlYXZlcyBjaGFubmVsXG4gICAgICAgICAgICBpZihwcmVzZW5jZUV2ZW50LmFjdGlvbiA9PT0gJ2xlYXZlJykge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnbGVhdmUnLCBwcmVzZW5jZUV2ZW50LmNsaWVudElkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdGltZW91dCBldmVudCBpcyBub3Qgc3VwcG9ydGVkIGluIEFibHlcbiAgICAgICAgICAgIC8vIHRoaXMuZW1pdCgnZGlzY29ubmVjdCcsIHByZXNlbmNlRXZlbnQudXVpZCk7XG5cbiAgICAgICAgICAgIC8vIHNvbWVvbmUncyBzdGF0ZSBpcyB1cGRhdGVkXG4gICAgICAgICAgICBpZihwcmVzZW5jZUV2ZW50LmFjdGlvbiA9PT0gJ3VwZGF0ZScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3N0YXRlJyxcbiAgICAgICAgICAgICAgICAgICAgcHJlc2VuY2VFdmVudC5jbGllbnRJZCwgcHJlc2VuY2VFdmVudC5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gZXhwbGljaXRseSBhdHRhY2ggdG8gdGhlIGNoYW5uZWwsIGFsdGhvdWdoIGl0IHdpbGwgaW1wbGljaWx0eSBiZSBhdHRhY2hlZCBieSBjYWxsaW5nIHN1YnNjcmliZSBhYm92ZVxuICAgICAgICB0aGlzLmNoYW5uZWwuYXR0YWNoKCk7XG5cbiAgICAgICAgLy8gZW50ZXIgdGhlIGNoYW5uZWwgcm9vbSBhdXRvbWF0aWNhbGx5IGFuZCBiZSBwcmVzZW50XG4gICAgICAgIHRoaXMuY2hhbm5lbC5wcmVzZW5jZS5lbnRlcigpO1xuICAgIH1cblxuICAgIG9uUmVhZHkoKSB7XG4gICAgICAgIC8vIHdhaXRpbmcgdG8gYmUgYXNzaWduZWQgYnkgdXNlclxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmVhZHkoZm4pIHtcbiAgICAgICAgdGhpcy5vblJlYWR5ID0gZm47XG4gICAgfVxuXG4gICAgbWVzc2FnZShkYXRhKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAvLyBwdWJsaXNoIHRoZSBnaXZlbiBkYXRhIG92ZXIgdGhlIEFibHkgY2hhbm5lbFxuICAgICAgICAgICAgdGhpcy5jaGFubmVsLnB1Ymxpc2gobnVsbCwgZGF0YSk7XG4gICAgICAgIH0sIChlcnIpID0+IHtcbiAgICAgICAgICAgIGlmKGVycikge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlJ3MgYSBwcm9ibGVtIHB1Ymxpc2hpbmcsIHJlamVjdFxuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGhlcmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAvLyBhc2sgQWJseSBmb3IgaW5mb3JtYXRpb24gYWJvdXQgbWVtYmVycyBwcmVzZW5jZSBvbiB0aGlzIGNoYW5uZWxcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbC5wcmVzZW5jZS5nZXQoKGVyciwgbWVtYmVycykgPT4ge1xuICAgICAgICAgICAgICAgIGlmKGVycikge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSdzIGEgcHJvYmxlbSB3aXRoIHRoZSBnZXQgcmVxdWVzdCwgcmVqZWN0XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYnVpbGQgYSB1c2VybGlzdCBpbiBybHRtLmpzIGZvcm1hdFxuICAgICAgICAgICAgICAgICAgICBsZXQgdXNlckxpc3QgPSB7fTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBmb3JtYXQgdGhlIHVzZXJMaXN0IGZvciBybHRtLmpzIHN0YW5kYXJkXG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaSBpbiBtZW1iZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VyTGlzdFttZW1iZXJzW2ldLmNsaWVudElkXSA9IG1lbWJlcnNbaV0uZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlc3BvbmQgd2l0aCBmb3JtYXR0ZWQgbGlzdFxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHVzZXJMaXN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc3RhdGUoc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBwcmVzZW5jZSBzdGF0ZVxuICAgICAgICAgICAgdGhpcy5jaGFubmVsLnByZXNlbmNlLnVwZGF0ZShzdGF0ZSwgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIGlmKGVycikge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSdzIGEgcHJvYmxlbSB3aXRoIHRoZSB1cGRhdGUgcmVxdWVzdCwgcmVqZWN0XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaGlzdG9yeSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIC8vIHJldHJpZXZlZCB0aGUgbWVzc2FnZSBoaXN0b3J5XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWwuaGlzdG9yeSh7IGNvdW50OiAxMDAgfSwgKGVyciwgcGFnZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmKGVycikge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSdzIGEgcHJvYmxlbSB3aXRoIHRoZSBoaXN0b3J5IHJlcXVlc3QsIHJlamVjdFxuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGUgb3VyIHJldHVybiBhcnJheVxuICAgICAgICAgICAgICAgICAgICBsZXQgZGF0YSA9IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGxvb3AgdGhyb3VnaCByZXNwb25zZSBhbmQgcHVzaCBkYXRhIHRvIGFycmF5XG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaSBpbiBwYWdlLml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV1aWQ6IHBhZ2UuaXRlbXNbaV0uY2xpZW50SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogcGFnZS5pdGVtc1tpXS5kYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlc3BvbmQgd2l0aCB0aGUgaGlzdG9yeSBkYXRhXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGxlYXZlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgLy8gdGVsbCBBYmx5IHRvIGNvbXBsZXRlIGxlYXZlIGFuZCBkZXRhY2ggZnJvbSB0aGlzIGNoYW5uZWxcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbC5kZXRhY2goKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIGlmKGVycikge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSdzIGEgcHJvYmxlbSBkZXRhY2hpbmcsIHJlamVjdFxuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLy8gZXhwb3J0IGEgZ2VuZXJpYyBmdW5jdGlvbiBleHBlY3RlZCBieSBybHRtLmpzXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHNldHVwKSB7XG4gICAgLy8gY29udmVuaWVuY2UgbWV0aG9kIHRvIGFzc2lnbiB0aGUgc2VydmljZSBzdHJpbmcgbmFtZSB0byBpdHNlbGZcbiAgICB0aGlzLnNlcnZpY2UgPSBzZXR1cC5zZXJ2aWNlO1xuXG4gICAgLy8gaW5pdGlhbGl6ZSBBYmx5IHdpdGggc3VwcGxpZWQgY29uZmlnIGluZm9ybWF0aW9uXG4gICAgbGV0IGFibHkgPSBuZXcgQWJseS5SZWFsdGltZShzZXR1cC5jb25maWcpO1xuXG4gICAgLy8gY2xpZW50SWQgbWF5IGJlIGFzc2lnbmVkIGZyb20gdGhlIHRva2VuIGlzc3VlZCB0byB0aGUgY2xpZW50IHNvXG4gICAgLy8gb25seSBhc3NpZ24gb25jZSB0aGUgY2xpZW50IGhhcyBjb25uZWN0ZWRcbiAgICBhYmx5LmNvbm5lY3Rpb24ub25jZSgnY29ubmVjdGVkJywgKCkgPT4ge1xuICAgICAgICBzZXR1cC5jb25maWcudXVpZCA9IGFibHkuYXV0aC5jbGllbnRJZDtcbiAgICB9KTtcblxuICAgIHRoaXMuYWJseSA9IGFibHk7XG5cbiAgICAvLyBleHBvc2UgdGhlIGpvaW4gbWV0aG9kIHRvIGNyZWF0ZSBuZXcgcm9vbSBjb25uZWN0aW9uc1xuICAgIHRoaXMuam9pbiA9IChjaGFubmVsLCBzdGF0ZSkgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IFJvb20odGhpcy5hYmx5LCBjaGFubmVsLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgLy8gcmV0dXJuIHRoZSBpbnN0YW5jZSBvZiB0aGlzIHNlcnZpY2VcbiAgICByZXR1cm4gdGhpcztcblxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyBpbmNsdWRlIHRoZSBOb2RlSlMgZXZlbnQgZW1pdHRlclxuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5cbi8vIGluY2x1ZGUgdGhlIFB1Yk51YiBqYXZhc2NyaXB0IHNkayB2NFxuY29uc3QgUHViTnViID0gcmVxdWlyZSgncHVibnViJyk7XG5sZXQgZ2xvYmFsUmVhZHkgPSBmYWxzZTtcblxuLy8gcmVwcmVzZW50cyBhIGNvbm5lY3Rpb24gdG8gYSBzaW5nbGUgY2hhbm5lbFxuY2xhc3MgUm9vbSBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJudWIsIGNoYW5uZWwsIHV1aWQsIHN0YXRlKSB7XG5cbiAgICAgICAgLy8gY2FsbCB0aGUgRXZlbnRFbWl0dGVyIGNvbnN0cnVjdG9yXG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgLy8gZGV0ZXJtaW5lIHRoZSB1c2VyJ3Mgc3RhdGUgXG4gICAgICAgIHN0YXRlID0gc3RhdGUgfHwge307XG5cbiAgICAgICAgLy8gc3RvcmUgdGhpcyB1c2VycyB1dWlkXG4gICAgICAgIHRoaXMudXVpZCA9IHV1aWQ7XG5cbiAgICAgICAgLy8gYXNzaWduIHRoZSBjaGFubmVsIHBhcmFtZXRlciBhcyBhIHByb3BlcnR5XG4gICAgICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWw7XG5cbiAgICAgICAgLy8gc2F2ZSBwdWJudWIgaW4gdGhlIGluc3RhbmNlIG9mIHJvb21cbiAgICAgICAgdGhpcy5wdWJudWIgPSBwdWJudWI7XG5cbiAgICAgICAgdGhpcy5pc1JlYWR5ID0gZmFsc2U7XG4gICAgICAgIFxuICAgICAgICAvLyB1c2UgdGhlIFB1Yk51YiBsaWJyYXJ5IHRvIGxpc3RlbiBmb3IgbWVzc2FnZXNcbiAgICAgICAgdGhpcy5wdWJudWIuYWRkTGlzdGVuZXIoe1xuXG4gICAgICAgICAgICBzdGF0dXM6IChzdGF0dXNFdmVudCkgPT4ge1xuXG4gICAgICAgICAgICAgICAgLy8gZGV0ZWN0IGlmIHRoaXMgaXMgYSBjb25uZWN0aW9uIGV2ZW50IG9uIHRoaXMgY2hhbm5lbFxuICAgICAgICAgICAgICAgIGlmIChzdGF0dXNFdmVudC5jYXRlZ29yeSA9PT0gXCJQTkNvbm5lY3RlZENhdGVnb3J5XCIgXG4gICAgICAgICAgICAgICAgICAgICYmICF0aGlzLmlzUmVhZHlcbiAgICAgICAgICAgICAgICAgICAgJiYgc3RhdHVzRXZlbnQuYWZmZWN0ZWRDaGFubmVscy5pbmRleE9mKGNoYW5uZWwpID4gLTEpIHtcblxuICAgICAgICAgICAgICAgICAgICBnbG9iYWxSZWFkeSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdGVsbCB0aGUgdXNlciB0aGF0IGZpcnN0IGNvbm5lY3Rpb24gbWFkZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uUmVhZHkoKTtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5wdWJudWIuYWRkTGlzdGVuZXIoe1xuICAgICAgICAgICAgbWVzc2FnZTogKG0pID0+IHtcblxuICAgICAgICAgICAgICAgIC8vIGlmIG1lc3NhZ2UgaXMgc2VudCB0byB0aGlzIHNwZWNpZmljIGNoYW5uZWxcbiAgICAgICAgICAgICAgICBpZihjaGFubmVsID09IG0uY2hhbm5lbCkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGVtaXQgdGhlIG1lc3NhZ2UgYXMgYW4gZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgbS5tZXNzYWdlLnV1aWQsIG0ubWVzc2FnZS5kYXRhKTsgICBcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcmVzZW5jZTogKHByZXNlbmNlRXZlbnQpID0+IHtcblxuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBjaGFubmVsIG1hdGNoZXMgdGhpcyBjaGFubmVsXG4gICAgICAgICAgICAgICAgaWYoY2hhbm5lbCA9PSBwcmVzZW5jZUV2ZW50LmNoYW5uZWwpIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBzb21lb25lIGpvaW5zIGNoYW5uZWxcbiAgICAgICAgICAgICAgICAgICAgaWYocHJlc2VuY2VFdmVudC5hY3Rpb24gPT0gXCJqb2luXCIpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdqb2luJywgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlc2VuY2VFdmVudC51dWlkLCBwcmVzZW5jZUV2ZW50LnN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvbWVvbmUgbGVhdmVzIGNoYW5uZWxcbiAgICAgICAgICAgICAgICAgICAgaWYocHJlc2VuY2VFdmVudC5hY3Rpb24gPT0gXCJsZWF2ZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2xlYXZlJywgcHJlc2VuY2VFdmVudC51dWlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvbWVvbmUgdGltZXNvdXRcbiAgICAgICAgICAgICAgICAgICAgaWYocHJlc2VuY2VFdmVudC5hY3Rpb24gPT0gXCJ0aW1lb3V0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZGlzY29ubmVjdCcsIHByZXNlbmNlRXZlbnQudXVpZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvbWVvbmUncyBzdGF0ZSBpcyB1cGRhdGVkXG4gICAgICAgICAgICAgICAgICAgIGlmKHByZXNlbmNlRXZlbnQuYWN0aW9uID09IFwic3RhdGUtY2hhbmdlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnc3RhdGUnLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVzZW5jZUV2ZW50LnV1aWQsIHByZXNlbmNlRXZlbnQuc3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyB0ZWxsIFB1Yk51YiB0byBzdWJzY3JpYmUgdG8gdGhlIHN1cHBsaWVkIGNoYW5uZWxcbiAgICAgICAgdGhpcy5wdWJudWIuc3Vic2NyaWJlKHsgXG4gICAgICAgICAgICBjaGFubmVsczogW2NoYW5uZWxdLFxuICAgICAgICAgICAgd2l0aFByZXNlbmNlOiB0cnVlLFxuICAgICAgICAgICAgc3RhdGU6IHN0YXRlXG4gICAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgLy8gcmVhZHkgaXMgYSBjYWxsYmFjayBhbmQgbm90IGFuIGV2ZW50IGJlY2F1c2UgcHVibnViIG1heSBiZSByZWFkeVxuICAgIC8vIGltbWVkaWF0ZWx5LCB3aGljaCBkb2Vzbid0IGFsbG93IHRpbWUgdG8gcmVnaXN0ZXIgYW4gZXZlbnQgaGFuZGxlclxuICAgIC8vIHRoaXMgY2FuIGJlIHNvbHZlZCB3aXRoIHNldFRpbWVvdXQoKCkgPT4ge30sIDEwKSB0byBsZXQgdGhlIFxuICAgIG9uUmVhZHkoKSB7XG5cbiAgICAgICAgLy8gd2FpdGluZyB0byBiZSBhc3NpZ25lZCBieSB1c2VyXG4gICAgICAgIHJldHVybjtcblxuICAgIH1cblxuICAgIHJlYWR5IChmbikge1xuICAgICAgICBcbiAgICAgICAgdGhpcy5vblJlYWR5ID0gZm47XG5cbiAgICAgICAgaWYoZ2xvYmFsUmVhZHkpIHtcbiAgICAgICAgICAgIHRoaXMub25SZWFkeSgpXG4gICAgICAgICAgICB0aGlzLmlzUmVhZHkgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBtZXNzYWdlIChkYXRhKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBwdWJsaXNoIHRoZSBnaXZlbiBkYXRhIG92ZXIgUHViTnViIGNoYW5uZWxcbiAgICAgICAgICB0aGlzLnB1Ym51Yi5wdWJsaXNoKHtcbiAgICAgICAgICAgICAgY2hhbm5lbDogdGhpcy5jaGFubmVsLFxuICAgICAgICAgICAgICBtZXNzYWdlOiB7XG4gICAgICAgICAgICAgICAgICB1dWlkOiB0aGlzLnV1aWQsXG4gICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCAoc3RhdHVzLCByZXNwb25zZSkgPT4ge1xuXG4gICAgICAgICAgICBpZihzdGF0dXMuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSdzIGEgcHJvYmxlbSBwdWJsaXNoaW5nLCByZWplY3RcbiAgICAgICAgICAgICAgICByZWplY3Qoc3RhdHVzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgfSk7XG5cbiAgICB9O1xuXG4gICAgaGVyZSgpIHtcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBcbiAgICAgICAgICAgIC8vIGFzayBQdWJOdWIgZm9yIGluZm9ybWF0aW9uIGFib3V0IGNvbm5lY3RlZCB1c2VycyBpbiB0aGlzIGNoYW5uZWxcbiAgICAgICAgICAgIHRoaXMucHVibnViLmhlcmVOb3coe1xuICAgICAgICAgICAgICAgIGNoYW5uZWxzOiBbdGhpcy5jaGFubmVsXSxcbiAgICAgICAgICAgICAgICBpbmNsdWRlVVVJRHM6IHRydWUsXG4gICAgICAgICAgICAgICAgaW5jbHVkZVN0YXRlOiB0cnVlXG4gICAgICAgICAgICB9LCAoc3RhdHVzLCByZXNwb25zZSkgPT4ge1xuXG4gICAgICAgICAgICAgICAgaWYoc3RhdHVzLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlJ3MgYSBwcm9ibGVtIHdpdGggdGhlIHJlcXVlc3QsIHJlamVjdFxuICAgICAgICAgICAgICAgICAgICByZWplY3Qoc3RhdHVzKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gYnVpbGQgYSB1c2VybGlzdCBpbiBybHRtLmpzIGZvcm1hdFxuICAgICAgICAgICAgICAgICAgICBsZXQgdXNlckxpc3QgPSB7fTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIGxpc3Qgb2Ygb2NjdXBhbnRzIGluIHRoaXMgY2hhbm5lbFxuICAgICAgICAgICAgICAgICAgICBsZXQgb2NjdXBhbnRzID0gcmVzcG9uc2UuY2hhbm5lbHNbdGhpcy5jaGFubmVsXS5vY2N1cGFudHM7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZm9ybWF0IHRoZSB1c2VyTGlzdCBmb3Igcmx0bS5qcyBzdGFuZGFyZFxuICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGkgaW4gb2NjdXBhbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VyTGlzdFtvY2N1cGFudHNbaV0udXVpZF0gPSBvY2N1cGFudHNbaV0uc3RhdGU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyByZXNwb25kIHdpdGggZm9ybWF0dGVkIGxpc3RcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh1c2VyTGlzdCk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgc3RhdGUoc3RhdGUpIHtcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyB1c2UgUHViTnViIHN0YXRlIGZ1bmN0aW9uIHRvIHVwZGF0ZSBzdGF0ZSBmb3IgY2hhbm5lbFxuICAgICAgICAgICAgdGhpcy5wdWJudWIuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgICAgICB1dWlkOiB0aGlzLnV1aWQsXG4gICAgICAgICAgICAgICAgY2hhbm5lbHM6IFt0aGlzLmNoYW5uZWxdXG4gICAgICAgICAgICB9LCAoc3RhdHVzLCByZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmKHN0YXR1cy5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSdzIGEgcHJvYmxlbSB3aXRoIHRoZSByZXF1ZXN0IGxvZyBpdFxuICAgICAgICAgICAgICAgICAgICByZWplY3Qoc3RhdHVzKTsgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9KTtcblxuICAgIH1cblxuICAgIGhpc3RvcnkoKSB7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXG4gICAgICAgICAgICAvLyByZXRyaWV2ZWQgdGhlIG1lc3NhZ2UgaGlzdG9yeSB3aXRoIFB1Yk51YlxuICAgICAgICAgICAgdGhpcy5wdWJudWIuaGlzdG9yeSh7XG4gICAgICAgICAgICAgICAgY2hhbm5lbDogdGhpcy5jaGFubmVsLFxuICAgICAgICAgICAgICAgIGNvdW50OiAxMDAgLy8gaG93IG1hbnkgaXRlbXMgdG8gZmV0Y2hcbiAgICAgICAgICAgIH0sIChzdGF0dXMsIHJlc3BvbnNlKSA9PiB7XG5cbiAgICAgICAgICAgICAgICBpZihzdGF0dXMuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUncyBhIHByb2JsZW0gd2l0aCB0aGUgcmVxdWVzdCBsb2cgaXRcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHN0YXR1cyk7ICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBvdXIgcmV0dXJuIGFycmF5XG4gICAgICAgICAgICAgICAgICAgIGxldCBkYXRhID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gbG9vcCB0aHJvdWdoIHJlc3BvbnNlIGFuZCBwdXNoIGRhdGEgdG8gYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBpIGluIHJlc3BvbnNlLm1lc3NhZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnB1c2gocmVzcG9uc2UubWVzc2FnZXNbaV0uZW50cnkpXG4gICAgICAgICAgICAgICAgICAgIH0gICBcblxuICAgICAgICAgICAgICAgICAgICAvLyByZXZlcnNlIHRoZSBhcnJheSBzbyBuZXdlc3QgYXJlIGZpcnN0XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhLnJldmVyc2UoKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyByZXNwb25kIHdpdGggdGhlIGhpc3RvcnkgZGF0YVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGRhdGEpO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9KTtcblxuICAgIH1cblxuICAgIGxlYXZlKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIHRlbGwgUHViTnViIHRvIG1hbnVhbGx5IHVuc3Vic2NyaWJlIGZyb20gdGhpcyBjaGFubmVsICAgICAgICBcbiAgICAgICAgICAgIHRoaXMucHVibnViLnVuc3Vic2NyaWJlKHtcbiAgICAgICAgICAgICAgICBjaGFubmVsczogW3RoaXMuY2hhbm5lbF0sXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuXG4gICAgICAgIH0pO1xuXG4gICAgfVxufVxuXG4vLyBleHBvcnQgYSBnZW5lcmljIGZ1bmN0aW9uIGV4cGVjdGVkIGJ5IHJsdG0uanNcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc2V0dXApIHtcblxuICAgIC8vIGNvbnZlbmllbmNlIG1ldGhvZCB0byBhc3NpZ24gdGhlIHNlcnZpY2Ugc3RyaW5nIG5hbWUgdG8gaXRzZWxmXG4gICAgdGhpcy5zZXJ2aWNlID0gc2V0dXAuc2VydmljZTtcblxuICAgIC8vIGluaXRpYWxpemUgUHViTnViIHdpdGggc3VwcGxpZWQgY29uZmlnIGluZm9ybWF0aW9uXG4gICAgdGhpcy5wdWJudWIgPSBuZXcgUHViTnViKHNldHVwLmNvbmZpZyk7XG5cbiAgICAvLyBleHBvc2UgdGhlIGpvaW4gbWV0aG9kIHRvIGNyZWF0ZSBuZXcgcm9vbSBjb25uZWN0aW9uc1xuICAgIHRoaXMuam9pbiA9IChjaGFubmVsLCBzdGF0ZSkgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IFJvb20odGhpcy5wdWJudWIsIGNoYW5uZWwsIHNldHVwLmNvbmZpZy51dWlkLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgLy8gcmV0dXJuIHRoZSBpbnN0YW5jZSBvZiB0aGlzIHNlcnZpY2VcbiAgICByZXR1cm4gdGhpcztcblxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyBpbmNsdWRlIE5vZGVKUyBldmVudCBlbWl0dGVyXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKTtcblxuLy8gaW5jbHVkZSB0aGUgU29ja2V0LmlvIHVzZXIgbGlicmFyeVxuY29uc3QgaW8gPSByZXF1aXJlKCdzb2NrZXQuaW8tY2xpZW50Jyk7XG5cbi8vIHJlcHJlc2VudHMgYSBjb25uZWN0aW9uIHRvIGEgc2luZ2xlIGNoYW5uZWxcbmNsYXNzIFJvb20gZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuXG4gICAgY29uc3RydWN0b3IoZW5kcG9pbnQsIGNoYW5uZWwsIHV1aWQsIHN0YXRlKSB7XG5cbiAgICAgICAgLy8gY2FsbCB0aGUgRXZlbnRFbWl0dGVyIGNvbnN0cnVjdG9yXG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgLy8gc3RvcmUgdGhpcyB1c2VycyB1dWlkXG4gICAgICAgIHRoaXMudXVpZCA9IHV1aWQ7XG5cbiAgICAgICAgLy8gYXNzaWduIHRoZSBjaGFubmVsIHBhcmFtZXRlciBhcyBhIHByb3BlcnR5XG4gICAgICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWw7XG5cbiAgICAgICAgdGhpcy5pc1JlYWR5ID0gZmFsc2U7XG5cbiAgICAgICAgLy8gY3JlYXRlIGEgY29ubmVjdGlvbiB0byB0aGUgc29ja2V0aW8gZW5kcG9pbnRcbiAgICAgICAgdGhpcy5zb2NrZXQgPSBpby5jb25uZWN0KGVuZHBvaW50LCB7bXVsdGlwbGV4OiB0cnVlfSk7XG5cbiAgICAgICAgLy8gc3Vic2NyaWJlIHRvIHRoZSBzb2NrZXQuaW8gY29ubmVjdGlvbiBldmVudFxuICAgICAgICB0aGlzLnNvY2tldC5vbignY29ubmVjdCcsICgpID0+IHtcblxuICAgICAgICAgICAgLy8gdGVsbCB0aGUgc2VydmVyIHRoYXQgd2Ugd2FudCB0byBqb2luIGEgY2hhbm5lbFxuICAgICAgICAgICAgdGhpcy5zb2NrZXQuZW1pdCgnY2hhbm5lbCcsIGNoYW5uZWwsIHRoaXMudXVpZCwgc3RhdGUpO1xuXG4gICAgICAgICAgICAvLyB0ZWxsIHRoZSB1c2VyIHRoZSBzZXJ2ZXIgaXMgcmVhZHlcbiAgICAgICAgICAgIHRoaXMub25SZWFkeSgpO1xuICAgICAgICAgICAgdGhpcy5pc1JlYWR5ID0gdHJ1ZTtcblxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBzZXJ2ZXIgc2F5cyBzb21lb25lIGhhcyBqb2luZWRcbiAgICAgICAgdGhpcy5zb2NrZXQub24oJ2pvaW4nLCAoY2hhbm5lbCwgdXVpZCwgc3RhdGUpID0+IHtcblxuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSBjaGFubmVsIGlzIHRoaXMgY2hhbm5lbFxuICAgICAgICAgICAgaWYodGhpcy5jaGFubmVsID09IGNoYW5uZWwpIHtcblxuICAgICAgICAgICAgICAgIC8vIGVtaXQgdGhlICdqb2luJyBldmVudCB0byB0aGUgdXNlclxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnam9pbicsIHV1aWQsIHN0YXRlKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHNlcnZlciBzYXlzIHNvbWVvbmUgaGFzIGxlZnRcbiAgICAgICAgdGhpcy5zb2NrZXQub24oJ2xlYXZlJywgKGNoYW5uZWwsIHV1aWQpID0+IHtcblxuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIGl0J3Mgb24gdGhpcyBjaGFubmVsXG4gICAgICAgICAgICBpZih0aGlzLmNoYW5uZWwgPT0gY2hhbm5lbCkge1xuXG4gICAgICAgICAgICAgICAgLy8gZW1pdCB0aGUgJ2xlYXZlJyBldmVudCB0byB0aGUgdXNlclxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnbGVhdmUnLCB1dWlkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9KTtcblxuXG4gICAgICAgIC8vIHNlcnZlciBzYXlzIHNvbWVvbmUgaGFzIGRpc2Nvbm5lY3RlZFxuICAgICAgICB0aGlzLnNvY2tldC5vbignZGlzY29ubmVjdCcsIChjaGFubmVsLCB1dWlkKSA9PiB7XG5cbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBpdCdzIG9uIHRoaXMgY2hhbm5lbFxuICAgICAgICAgICAgaWYodGhpcy5jaGFubmVsID09IGNoYW5uZWwpIHtcblxuICAgICAgICAgICAgICAgIC8vIGVtaXQgdGhlICdsZWF2ZScgZXZlbnQgdG8gdGhlIHVzZXJcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Rpc2Nvbm5lY3QnLCB1dWlkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBhIG1lc3NhZ2UgaXMgc2VudCBmcm9tIHRoZSBzcmV2ZXJcbiAgICAgICAgdGhpcy5zb2NrZXQub24oJ21lc3NhZ2UnLCAoY2hhbm5lbCwgdXVpZCwgZGF0YSkgPT4ge1xuXG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgaXQgaXMgb24gdGhpcyBjaGFubmVsXG4gICAgICAgICAgICBpZih0aGlzLmNoYW5uZWwgPT0gY2hhbm5lbCkge1xuXG4gICAgICAgICAgICAgICAgLy8gdGVsbCB0aGUgdXNlciBvZiB0aGUgbmV3IG1lc3NhZ2VcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCB1dWlkLCBkYXRhKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBhIHVzZXIgc2V0cyB0aGVpciBzdGF0ZVxuICAgICAgICB0aGlzLnNvY2tldC5vbignc3RhdGUnLCAoY2hhbm5lbCwgdXVpZCwgc3RhdGUpID0+IHtcblxuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIGl0IGlzIG9uIHRoaXMgY2hhbm5lbFxuICAgICAgICAgICAgaWYodGhpcy5jaGFubmVsID09IGNoYW5uZWwpIHtcblxuICAgICAgICAgICAgICAgIC8vIHRlbGwgdGhlIHVzZXIgb2YgdGhlIHNldCBzdGF0ZVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnc3RhdGUnLCB1dWlkLCBzdGF0ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG5cbiAgICB9XG4gICAgcmVhZHkoZm4pIHtcbiAgICAgICAgXG4gICAgICAgIHRoaXMub25SZWFkeSA9IGZuO1xuICAgICAgICBcbiAgICAgICAgaWYodGhpcy5pc1JlYWR5KSB7XG4gICAgICAgICAgICB0aGlzLm9uUmVhZHkoKTtcbiAgICAgICAgfVxuXG4gICAgfVxuICAgIG9uUmVhZHkoKSB7XG4gICAgICAgIC8vIHdhaXRpbmcgdG8gYmUgYXNzaWduZWQgYnkgdXNlclxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIG1lc3NhZ2UoZGF0YSkge1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cbiAgICAgICAgICAgIC8vIHB1Ymxpc2ggdGhlIGRhdGEgdG8gdGhlIHNvY2tldC5pbyBzZXJ2ZXJcbiAgICAgICAgICAgIHRoaXMuc29ja2V0LmVtaXQoJ3B1Ymxpc2gnLCB0aGlzLmNoYW5uZWwsIHRoaXMudXVpZCwgZGF0YSwgKCkgPT57XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSk7XG5cbiAgICB9XG4gICAgaGVyZSgpIHtcbiAgICAgICAgXG4gICAgICAgIC8vIGFzayBzb2NrZXQuaW8tc2VydmVyIGZvciBhIGxpc3Qgb2Ygb25saW5lIHVzZXJzXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuc29ja2V0LmVtaXQoJ3dob3NvbmxpbmUnLCB0aGlzLmNoYW5uZWwsIG51bGwsIGZ1bmN0aW9uKHVzZXJzKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBjYWxsYmFjayB3aXRoIGFuIG9iamVjdCBvZiB1c2Vyc1xuICAgICAgICAgICAgICAgIHJlc29sdmUodXNlcnMpO1xuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9KTtcblxuICAgIH1cbiAgICBzdGF0ZShzdGF0ZSkge1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblxuICAgICAgICAgICAgLy8gdGVsbCBzb2NrZXQuaW8tc2VydmVyIHRvIHVwZGF0ZSB0aGlzIHVzZXIncyBzdGF0ZVxuICAgICAgICAgICAgdGhpcy5zb2NrZXQuZW1pdCgnc2V0U3RhdGUnLCB0aGlzLmNoYW5uZWwsIHRoaXMudXVpZCwgc3RhdGUsICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9KTtcblxuICAgIH1cbiAgICBoaXN0b3J5KCkge1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gYXNrIHNvY2tldC5pby1zZXJ2ZXIgZm9yIHRoZSBoaXN0b3J5IG9mIG1lc3NhZ2VzIHB1Ymxpc2hlZFxuICAgICAgICAgICAgdGhpcy5zb2NrZXQuZW1pdCgnaGlzdG9yeScsIHRoaXMuY2hhbm5lbCwgKGRhdGEpID0+IHtcblxuICAgICAgICAgICAgICAgIC8vIGNhbGxiYWNrIHdpdGggYW4gYXJyYXkgb2YgbWVzc2FnZXNcbiAgICAgICAgICAgICAgICByZXNvbHZlKGRhdGEpO1xuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9KTtcblxuICAgIH1cbiAgICBsZWF2ZShjaGFubmVsKSB7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXG4gICAgICAgICAgICAvLyBtYW51YWxseSBkaXNjb25uZWN0IGZyb20gc29ja2V0LmlvLXNlcnZlclxuICAgICAgICAgICAgdGhpcy5zb2NrZXQuZW1pdCgnbGVhdmUnLCB0aGlzLnV1aWQsIGNoYW5uZWwsICgpID0+IHtcblxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSk7XG5cbiAgICB9XG4gICAgXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNldHVwKSB7XG5cbiAgICAvLyBjb252ZW5pZW5jZSBtZXRob2QgdG8gYXNzaWduIHRoZSBzZXJ2aWNlIHN0cmluZyBuYW1lIHRvIGl0c2VsZlxuICAgIHRoaXMuc2VydmljZSA9IHNldHVwLnNlcnZpY2U7XG5cbiAgICB0aGlzLmpvaW4gPSAoY2hhbm5lbCwgc3RhdGUpID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBSb29tKHNldHVwLmNvbmZpZy5lbmRwb2ludCwgY2hhbm5lbCwgc2V0dXAuY29uZmlnLnV1aWQsIHNldHVwLmNvbmZpZy5zdGF0ZSk7XG4gICAgfTtcblxuICAgIHJldHVybiB0aGlzO1xuXG59O1xuIl19
